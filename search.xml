<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STC52单片机简单控制直流电机正反转(已验证)</title>
      <link href="/2024/03/STC-STC52%E5%8D%95%E7%89%87%E6%9C%BA%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%B7%B2%E9%AA%8C%E8%AF%81/"/>
      <url>/2024/03/STC-STC52%E5%8D%95%E7%89%87%E6%9C%BA%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%B7%B2%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC52单片机简单控制直流电机正反转-已验证"><a href="#STC52单片机简单控制直流电机正反转-已验证" class="headerlink" title="STC52单片机简单控制直流电机正反转(已验证)"></a>STC52单片机简单控制直流电机正反转(已验证)</h1><h5 id="STC52单片机简单控制直流电机正反转-已验证-1"><a href="#STC52单片机简单控制直流电机正反转-已验证-1" class="headerlink" title="STC52单片机简单控制直流电机正反转(已验证)"></a>STC52单片机简单控制直流电机正反转(已验证)</h5><p>本实验源码来源于：坛友-书盲《STC单片机简单控制直流电机正反转》</p><p><a href="https://blog.csdn.net/XiaoCaiDaYong/article/details/82354311?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162238513616780366598380%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162238513616780366598380&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-9-82354311.nonecase&utm_term=51%E6%8E%A7%E5%88%B6%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC&spm=1018.2226.3001.4450">STC单片机简单控制直流电机正反转</a></p><ul><li>开发环境：Keil</li><li>STC型号STC89C52RC</li><li>源代码：</li></ul><p>开发环境：Keil</p><p>STC型号STC89C52RC</p><p><img src="https://img-blog.csdnimg.cn/20210530231048450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg4MDA4Mg==,size_16,color_FFFFFF,t_70" alt="*"></p><p>源代码：</p><p>main.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg51.h&gt;</span><br><span class="line"> </span><br><span class="line">sbit EN  = P1^0;  //    电机输入输出1,2</span><br><span class="line">sbit IN1 = P1^1;  //    输入1</span><br><span class="line">sbit IN2 = P1^2;  //    输入2</span><br><span class="line">sbit key1=P3^5;</span><br><span class="line">sbit key2=P3^4;</span><br><span class="line"> </span><br><span class="line">void delay();</span><br><span class="line"> </span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    EN=1;</span><br><span class="line">    IN1=0;</span><br><span class="line">    IN2=0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;     </span><br><span class="line">        if(key1==0)</span><br><span class="line">        &#123;</span><br><span class="line">            delay();</span><br><span class="line">            &#123;</span><br><span class="line">                if(key1==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    IN1=1;</span><br><span class="line">                    IN2=0;</span><br><span class="line">                &#125;</span><br><span class="line">                while(key1==0);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        if(key2==0)</span><br><span class="line">        &#123;</span><br><span class="line">            delay();</span><br><span class="line">            &#123;</span><br><span class="line">                if(key2==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    IN1=0;</span><br><span class="line">                    IN2=1;</span><br><span class="line">                &#125;</span><br><span class="line">                while(key2==0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void delay()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;100;j++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg51.h&gt;</p><p>sbit EN  &#x3D; P1^0;  &#x2F;&#x2F;    电机输入输出1,2<br>sbit IN1 &#x3D; P1^1;  &#x2F;&#x2F;    输入1<br>sbit IN2 &#x3D; P1^2;  &#x2F;&#x2F;    输入2<br>sbit key1&#x3D;P3^5;<br>sbit key2&#x3D;P3^4;</p><p>void delay();</p><p>void main()<br>{<br>    EN&#x3D;1;<br>    IN1&#x3D;0;<br>    IN2&#x3D;0;<br>    while(1)<br>    {<br>        if(key1&#x3D;&#x3D;0)<br>        {<br>            delay();<br>            {<br>                if(key1&#x3D;&#x3D;0)<br>                {<br>                    IN1&#x3D;1;<br>                    IN2&#x3D;0;<br>                }<br>                while(key1&#x3D;&#x3D;0);<br>            }</p><pre><code>    &#125;    if(key2==0)    &#123;        delay();        &#123;            if(key2==0)            &#123;                IN1=0;                IN2=1;            &#125;            while(key2==0);        &#125;    &#125;&#125;</code></pre><p>}</p><p>void delay()<br>{<br>    int i,j;<br>    for(i&#x3D;0;i&lt;10;i++)<br>    {<br>        for(j&#x3D;0;j&lt;100;j++);<br>    }<br>}&#96;</p><ul><li>Proteus仿真图：</li><li>程序源码和仿真文件下载地址： 百度网盘</li></ul><p><img src="https://img-blog.csdnimg.cn/20210530230415620.png#pic_center" alt="*"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1LR0egCSgEVZBkdeIBwiMaQ </span><br><span class="line">提取码：gkor</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1LR0egCSgEVZBkdeIBwiMaQ  提取码：gkor</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AT89C52利用定时器控制单个led灯闪烁</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-51%E5%8D%95%E7%89%87%E6%9C%BA%E5%88%A9%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AAled%E7%81%AF%E9%97%AA%E7%83%81/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-51%E5%8D%95%E7%89%87%E6%9C%BA%E5%88%A9%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%8D%95%E4%B8%AAled%E7%81%AF%E9%97%AA%E7%83%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="AT89C52利用定时器控制单个led灯闪烁"><a href="#AT89C52利用定时器控制单个led灯闪烁" class="headerlink" title="AT89C52利用定时器控制单个led灯闪烁"></a>AT89C52利用定时器控制单个led灯闪烁</h1><h3 id="AT89C52利用定时器控制单个led灯闪烁-1"><a href="#AT89C52利用定时器控制单个led灯闪烁-1" class="headerlink" title="AT89C52利用定时器控制单个led灯闪烁"></a>AT89C52利用定时器控制单个led灯闪烁</h3><h6 id="keil芯片选择AT89C52"><a href="#keil芯片选择AT89C52" class="headerlink" title="keil芯片选择AT89C52"></a>keil芯片选择AT89C52</h6><p><img src="https://img-blog.csdnimg.cn/20210322215041887.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210322215159540.png" alt="在这里插入图片描述"></p><ul><li>新建一个.c文件，将代码拷贝进去,然后保存。</li><li>然后将保存的.c文件加载到工程项目里面去。</li><li>设置好生产hex文件，就可以编译了。</li><li>main.c程序源码：</li></ul><p>新建一个.c文件，将代码拷贝进去,然后保存。</p><p>然后将保存的.c文件加载到工程项目里面去。</p><p>设置好生产hex文件，就可以编译了。</p><p><img src="https://img-blog.csdnimg.cn/2021032221553428.png" alt="在这里插入图片描述"></p><p>main.c程序源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define  uchar unsigned char</span><br><span class="line">#define  uint unsigned int</span><br><span class="line"></span><br><span class="line">sbit led = P0 ^ 0;</span><br><span class="line">uchar Cout = 0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">     TMOD = 0X00; //0000 0000 定时器0，工作方式0</span><br><span class="line">EA=1;</span><br><span class="line">    TH0 = (8192 - 5000) / 32; //5ms定时</span><br><span class="line">    TL0 = (8192 - 5000) % 32;</span><br><span class="line">    IE = 0X82; //1111 1101 T0中断允许位</span><br><span class="line">    TR0 = 1; //启动定时器</span><br><span class="line">    while (1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">void led_flash() interrupt 1 //T0中断号为1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = (8192 - 5000) / 32; //恢复初值</span><br><span class="line">    TL0 = (8192 - 5000) % 32;</span><br><span class="line">    if (++Cout == 100) //0.5秒开关一次，0.5S =5ms*100</span><br><span class="line">    &#123;</span><br><span class="line">        led = !led; //取反</span><br><span class="line">        Cout = 0;//恢复初始值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#define  uchar unsigned char<br>#define  uint unsigned int</p><p>sbit led &#x3D; P0 ^ 0;<br>uchar Cout &#x3D; 0;</p><p>void main()<br>{<br>     TMOD &#x3D; 0X00; &#x2F;&#x2F;0000 0000 定时器0，工作方式0<br>            EA&#x3D;1;<br>    TH0 &#x3D; (8192 - 5000) &#x2F; 32; &#x2F;&#x2F;5ms定时<br>    TL0 &#x3D; (8192 - 5000) % 32;<br>    IE &#x3D; 0X82; &#x2F;&#x2F;1111 1101 T0中断允许位<br>    TR0 &#x3D; 1; &#x2F;&#x2F;启动定时器<br>    while (1);</p><pre><code>&#125;</code></pre><p>void led_flash() interrupt 1 &#x2F;&#x2F;T0中断号为1<br>{<br>    TH0 &#x3D; (8192 - 5000) &#x2F; 32; &#x2F;&#x2F;恢复初值<br>    TL0 &#x3D; (8192 - 5000) % 32;<br>    if (++Cout &#x3D;&#x3D; 100) &#x2F;&#x2F;0.5秒开关一次，0.5S &#x3D;5ms*100<br>    {<br>        led &#x3D; !led; &#x2F;&#x2F;取反<br>        Cout &#x3D; 0;&#x2F;&#x2F;恢复初始值<br>    }<br>}&#96;</p><ul><li>proteus仿真</li><li>将编译输出的hex文件加载到proteus里面，进行仿真</li></ul><p>proteus仿真</p><p><img src="https://img-blog.csdnimg.cn/20210322215953188.png" alt="在这里插入图片描述"></p><p>将编译输出的hex文件加载到proteus里面，进行仿真</p><p><img src="https://img-blog.csdnimg.cn/20210322215619387.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用74HC138译码器实现数码管显示</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E5%88%A9%E7%94%A874HC138%E8%AF%91%E7%A0%81%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E5%88%A9%E7%94%A874HC138%E8%AF%91%E7%A0%81%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="利用74HC138译码器实现数码管显示"><a href="#利用74HC138译码器实现数码管显示" class="headerlink" title="利用74HC138译码器实现数码管显示"></a>利用74HC138译码器实现数码管显示</h1><h4 id="利用74HC138译码器实现数码管显示-1"><a href="#利用74HC138译码器实现数码管显示-1" class="headerlink" title="利用74HC138译码器实现数码管显示"></a>利用74HC138译码器实现数码管显示</h4><ul><li>74HC138真值表</li><li>仿真图</li><li>程序源码</li></ul><p>74HC138真值表</p><p><img src="https://img-blog.csdnimg.cn/20210622213016411.png" alt="在这里插入图片描述"></p><p>仿真图</p><p><img src="https://img-blog.csdnimg.cn/20210622213457781.gif#pic_center" alt="在这里插入图片描述"></p><p>程序源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;reg51.h&quot;</span><br><span class="line"></span><br><span class="line">typedef unsigned char u8;</span><br><span class="line">typedef unsigned int u16;</span><br><span class="line"></span><br><span class="line"> unsigned char code Seg_Tab[]  = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;</span><br><span class="line">  //共阴0-F段码，加code是存在rom里面</span><br><span class="line"></span><br><span class="line">void delay(u16 k);</span><br><span class="line">void Seg_display(unsigned int val);</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">Seg_display(9527);//显示内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Seg_display(unsigned int val)&#123;</span><br><span class="line"> unsigned char i,dia_data;</span><br><span class="line">for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">dia_data = val % 10;</span><br><span class="line">val =val/10 ;</span><br><span class="line">P0 = Seg_Tab[dia_data];</span><br><span class="line">P1 = i;</span><br><span class="line">delay(5);</span><br><span class="line">P0=0;//消隐作用</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时n毫秒</span><br><span class="line">void delay(unsigned int n)//@12MHz晶振</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int i=0,j=0;</span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">        for(j=0;j&lt;123;j++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “reg51.h”</p><p>typedef unsigned char u8;<br>typedef unsigned int u16;</p><p> unsigned char code Seg_Tab[]  &#x3D; {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};<br>                      &#x2F;&#x2F;共阴0-F段码，加code是存在rom里面</p><p>void delay(u16 k);<br>void Seg_display(unsigned int val);</p><p>void main(){<br>    while(1){<br>    Seg_display(9527);&#x2F;&#x2F;显示内容<br>    }</p><p>}</p><p>void Seg_display(unsigned int val){<br> unsigned char i,dia_data;<br>    for(i&#x3D;0;i&lt;4;i++){<br>    dia_data &#x3D; val % 10;<br>        val &#x3D;val&#x2F;10 ;<br>        P0 &#x3D; Seg_Tab[dia_data];<br>        P1 &#x3D; i;<br>delay(5);<br>        P0&#x3D;0;&#x2F;&#x2F;消隐作用<br>    }<br>}</p><p>&#x2F;&#x2F;延时n毫秒<br>void delay(unsigned int n)&#x2F;&#x2F;@12MHz晶振<br>{<br>    unsigned int i&#x3D;0,j&#x3D;0;<br>    for(i&#x3D;0;i&lt;n;i++)<br>        for(j&#x3D;0;j&lt;123;j++);<br>}&#96;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1gHqetaE8yc7v-0TPuQtoJw </span><br><span class="line">提取码：3zzm</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1gHqetaE8yc7v-0TPuQtoJw  提取码：3zzm</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标准库intrins.h中的循环指令在多种流水灯方式上的应用</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E6%A0%87%E5%87%86%E5%BA%93intrinsh%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4%E5%9C%A8%E5%A4%9A%E7%A7%8D%E6%B5%81%E6%B0%B4%E7%81%AF%E6%96%B9%E5%BC%8F%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E6%A0%87%E5%87%86%E5%BA%93intrinsh%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4%E5%9C%A8%E5%A4%9A%E7%A7%8D%E6%B5%81%E6%B0%B4%E7%81%AF%E6%96%B9%E5%BC%8F%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="标准库intrins-h中的循环指令在多种流水灯方式上的应用"><a href="#标准库intrins-h中的循环指令在多种流水灯方式上的应用" class="headerlink" title="标准库intrins.h中的循环指令在多种流水灯方式上的应用"></a>标准库intrins.h中的循环指令在多种流水灯方式上的应用</h1><h3 id="标准库intrins-h中的循环指令在多种流水灯方式上的应用-1"><a href="#标准库intrins-h中的循环指令在多种流水灯方式上的应用-1" class="headerlink" title="标准库intrins.h中的循环指令在多种流水灯方式上的应用"></a>标准库intrins.h中的循环指令在多种流水灯方式上的应用</h3><p>内部函数 描述： 　　crol 字符循环左移 　　cror 字符循环右移 　　irol 整数循环左移 　　iror 整数循环右移 　　lrol 长整数循环左移 　　lror 长整数循环右移 　　nop 空操作8051 NOP 指令 流水灯常用到的两个指令就是：<em>crol</em> 字符循环左移； 　　<em>cror</em> 字符循环右移；</p><p><code>_crol_ 字符循环左移； 　　_cror_ 字符循环右移；</code></p><p><img src="https://img-blog.csdnimg.cn/20210202104229131.png" alt="在这里插入图片描述"></p><p>用_crol_函数实现LED流水灯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">typedef unsigned int u16;</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line">#define led P2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">    while(i--)</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       led=0xfe;                //D1亮 ，其它灯不亮</span><br><span class="line">       delay(60000);</span><br><span class="line">       </span><br><span class="line">       led=_crol_(led,1);        //0xFD  D2亮,其它不亮 </span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_crol_(led,1);       //D3亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_crol_(led,1);       //D4亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_crol_(led,1);       //D5亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_crol_(led,1);       //D6亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_crol_(led,1);       //D7亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_crol_(led,1);       //D8亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       //让D7开始亮 一直到D1</span><br><span class="line"></span><br><span class="line">       led=_cror_(led,1);      //D7亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_cror_(led,1);      //D6亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_cror_(led,1);      //D5亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_cror_(led,1);      //D4亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_cror_(led,1);      //D3亮</span><br><span class="line">       delay(60000);</span><br><span class="line"></span><br><span class="line">       led=_cror_(led,1);      //D2亮</span><br><span class="line">       delay(60000);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “reg52.h”<br>#include “intrins.h”<br>typedef unsigned int u16;<br>typedef unsigned char u8;<br>#define led P2</p><p>void delay(u16 i)<br>{<br>    while(i–)<br>    {};<br>}</p><p>void main(void)<br>{</p><pre><code>    while(1)&#123;   led=0xfe;                //D1亮 ，其它灯不亮   delay(60000);      led=_crol_(led,1);        //0xFD  D2亮,其它不亮    delay(60000);   led=_crol_(led,1);       //D3亮   delay(60000);   led=_crol_(led,1);       //D4亮   delay(60000);   led=_crol_(led,1);       //D5亮   delay(60000);   led=_crol_(led,1);       //D6亮   delay(60000);   led=_crol_(led,1);       //D7亮   delay(60000);   led=_crol_(led,1);       //D8亮   delay(60000);   //让D7开始亮 一直到D1   led=_cror_(led,1);      //D7亮   delay(60000);   led=_cror_(led,1);      //D6亮   delay(60000);   led=_cror_(led,1);      //D5亮   delay(60000);   led=_cror_(led,1);      //D4亮   delay(60000);   led=_cror_(led,1);      //D3亮   delay(60000);   led=_cror_(led,1);      //D2亮   delay(60000);&#125;</code></pre><p>}&#96;</p><p>简洁一点的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">typedef unsigned int uint;</span><br><span class="line">typedef unsigned char uchar;</span><br><span class="line">#define led P2</span><br><span class="line">uchar temp;</span><br><span class="line"></span><br><span class="line">void delay(uint z)//延时函数</span><br><span class="line">&#123;</span><br><span class="line">uint x,y;</span><br><span class="line">for(x = z;x&gt;0;x--)</span><br><span class="line">for(y=114;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"> temp = 0xfe;</span><br><span class="line">led = temp;</span><br><span class="line"> delay(1000);</span><br><span class="line"></span><br><span class="line">        while(1)</span><br><span class="line">    &#123;</span><br><span class="line">       temp = _crol_(temp,1);        //temp变量自身左移移位</span><br><span class="line">led = temp;</span><br><span class="line">       delay(1000);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>typedef unsigned int uint;<br>typedef unsigned char uchar;<br>#define led P2<br>uchar temp;</p><p>void delay(uint z)&#x2F;&#x2F;延时函数<br>{<br>    uint x,y;<br>    for(x &#x3D; z;x&gt;0;x–)<br>        for(y&#x3D;114;y&gt;0;y–);<br>}</p><p>void main(void)<br>{<br>     temp &#x3D; 0xfe;<br>    led &#x3D; temp;<br>     delay(1000);</p><pre><code>    while(1)&#123;   temp = _crol_(temp,1);        //temp变量自身左移移位            led = temp;   delay(1000);&#125;</code></pre><p>}&#96;</p><p>用数组实现流水灯效果代码;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">uchar i;</span><br><span class="line">uchar  table[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;</span><br><span class="line"></span><br><span class="line">void delay(uint z)</span><br><span class="line">&#123;</span><br><span class="line">uint x,y;</span><br><span class="line">for(x=100;x&gt;0;x--)</span><br><span class="line">for(y=z;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">P2=table[i];</span><br><span class="line">delay(3000);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include&lt;reg52.h&gt;<br>#include&lt;intrins.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char<br>uchar i;<br>uchar  table[]&#x3D;{0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};</p><p>void delay(uint z)<br>{<br>    uint x,y;<br>    for(x&#x3D;100;x&gt;0;x–)<br>        for(y&#x3D;z;y&gt;0;y–);<br>}</p><p>void main()<br>{  </p><pre><code>while(1)&#123;    for(i=0;i&lt;8;i++)    &#123;        P2=table[i];        delay(3000);    &#125;      &#125;</code></pre><p>}&#96;</p><p>for循环实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">typedef unsigned int u16;</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line">#define led P2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay(u16 z)</span><br><span class="line">&#123;</span><br><span class="line">u16 x,y;</span><br><span class="line">for(x=100;x&gt;0;x--)</span><br><span class="line">for(y=z;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">u8 i;</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">u8 aa;</span><br><span class="line">aa=0xfe;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">P2=aa;</span><br><span class="line">delay(1000);</span><br><span class="line">aa=_crol_(aa,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aa=0x7f;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">P2=aa;</span><br><span class="line">delay(1000);</span><br><span class="line">aa=_cror_(aa,1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “reg52.h”<br>#include “intrins.h”<br>typedef unsigned int u16;<br>typedef unsigned char u8;<br>#define led P2</p><p>void delay(u16 z)<br>{<br>    u16 x,y;<br>    for(x&#x3D;100;x&gt;0;x–)<br>        for(y&#x3D;z;y&gt;0;y–);<br>}</p><p>void main(void)<br>{</p><pre><code>u8 i;while (1)&#123;    u8 aa;    aa=0xfe;    for(i=0;i&lt;8;i++)    &#123;        P2=aa;        delay(1000);        aa=_crol_(aa,1);    &#125;        aa=0x7f;    for(i=0;i&lt;8;i++)    &#123;        P2=aa;        delay(1000);        aa=_cror_(aa,1);    &#125;&#125;    </code></pre><p>}&#96;</p><p>左移指令效果：</p><p><img src="https://img-blog.csdnimg.cn/20210202144812855.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">typedef unsigned int uint;</span><br><span class="line">typedef unsigned char uchar;</span><br><span class="line">#define led P2</span><br><span class="line">uchar temp;</span><br><span class="line">uchar i;</span><br><span class="line">void delay(uint z)</span><br><span class="line">&#123;</span><br><span class="line">uint x,y;</span><br><span class="line">for(x = z;x&gt;0;x--)</span><br><span class="line">for(y=114;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"> temp = 0x01;</span><br><span class="line">led = temp;</span><br><span class="line"> delay(1000);</span><br><span class="line"></span><br><span class="line">  for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">    //   temp = _crol_(temp,1);        //全亮，逐一灭，亮。</span><br><span class="line">temp =temp&lt;&lt;1 ;</span><br><span class="line">led = temp;</span><br><span class="line">       delay(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">全亮，逐一灭，亮，反过来阶梯灭，亮</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>typedef unsigned int uint;<br>typedef unsigned char uchar;<br>#define led P2<br>uchar temp;<br>uchar i;<br>void delay(uint z)<br>{<br>    uint x,y;<br>    for(x &#x3D; z;x&gt;0;x–)<br>        for(y&#x3D;114;y&gt;0;y–);<br>}</p><p>void main(void)<br>{<br>     temp &#x3D; 0x01;<br>    led &#x3D; temp;<br>     delay(1000);</p><p>  for(i&#x3D;0;i&lt;8;i++){<br>    &#x2F;&#x2F;   temp &#x3D; <em>crol</em>(temp,1);        &#x2F;&#x2F;全亮，逐一灭，亮。<br>        temp &#x3D;temp&lt;&lt;1 ;<br>                led &#x3D; temp;<br>       delay(1000);<br>    }</p><p>}</p><p>全亮，逐一灭，亮，反过来阶梯灭，亮&#96;</p><p>#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; typedef unsigned int uint; typedef unsigned char uchar; #define led P2 uchar temp; uchar i; void delay(uint z) { uint x,y; for(x &#x3D; z;x&gt;0;x–) for(y&#x3D;114;y&gt;0;y–); }</p><p>void main(void) { temp &#x3D; 0x01; led &#x3D; temp; delay(1000);</p><p>for(i&#x3D;0;i&lt;8;i++){ &#x2F;&#x2F; temp &#x3D; crol(temp,1); &#x2F;&#x2F;全亮，逐一灭，亮。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp =temp&lt;&lt;1 ;</span><br><span class="line">led = temp;</span><br><span class="line">   delay(1000);</span><br><span class="line">&#125;</span><br><span class="line">temp = 0x80;</span><br></pre></td></tr></table></figure><p><code>temp =temp&lt;&lt;1 ;             led = temp;    delay(1000); &#125; temp = 0x80;</code></p><p>for(i&#x3D;0;i&lt;8;i++){ &#x2F;&#x2F; temp &#x3D; crol(temp,1); &#x2F;&#x2F;全亮，逐一灭，亮。 temp &#x3D;temp&gt;&gt;1 ; led &#x3D; temp;  delay(1000); } }</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LD3320语音识别模块+MP3-TF-16P模块实现语音交互功能</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-LD3320%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97MP3TF16P%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-LD3320%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97MP3TF16P%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E8%AF%AD%E9%9F%B3%E4%BA%A4%E4%BA%92%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="LD3320语音识别模块-MP3-TF-16P模块实现语音交互功能"><a href="#LD3320语音识别模块-MP3-TF-16P模块实现语音交互功能" class="headerlink" title="LD3320语音识别模块+MP3-TF-16P模块实现语音交互功能"></a>LD3320语音识别模块+MP3-TF-16P模块实现语音交互功能</h1><h3 id="LD3320语音识别模块-MP3-TF-16P模块实现语音交互功能-1"><a href="#LD3320语音识别模块-MP3-TF-16P模块实现语音交互功能-1" class="headerlink" title="LD3320语音识别模块+MP3-TF-16P模块实现语音交互功能"></a>LD3320语音识别模块+MP3-TF-16P模块实现语音交互功能</h3><h5 id="🔖利用LD3320语音识别模块可以实现非特定人声语音控制单片机io口动作，而加入MP3-TF-16P语音播放模块，可以让语音实现交互功能。"><a href="#🔖利用LD3320语音识别模块可以实现非特定人声语音控制单片机io口动作，而加入MP3-TF-16P语音播放模块，可以让语音实现交互功能。" class="headerlink" title="🔖利用LD3320语音识别模块可以实现非特定人声语音控制单片机io口动作，而加入MP3-TF-16P语音播放模块，可以让语音实现交互功能。"></a>🔖利用LD3320语音识别模块可以实现非特定人声语音控制单片机io口动作，而加入MP3-TF-16P语音播放模块，可以让语音实现交互功能。</h5><ul><li><p>📋原理就是利用两个模块进行串口收发数据，实现我们想要的功能。</p></li><li><p>MP3-TF-16P模块:</p></li><li><p>LD3320语音识别模块:</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200720230033702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg4MDA4Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200720230314395.png" alt="在这里插入图片描述"></p><ul><li>利用所给商家资料，进行进行个性化需求调整。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200720230751184.png" alt="在这里插入图片描述"></p><ul><li>man.c里面的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">/******************************************************</span><br><span class="line">**  工程名称：UNV-01语音识别模块驱动程序</span><br><span class="line">**CPU: STC11L08XE</span><br><span class="line">**晶振：22.1184MHZ</span><br><span class="line">**波特率：9600 bit/S</span><br><span class="line">**配套产品信息：UNV-LD3320+STC11语音识别开发板</span><br><span class="line">**  修改日期：2018.5.13</span><br><span class="line">**  说明：口令模式： 即每次识别时都需要说“小鹰”这个口令 ，才能够进行下一级的识别</span><br><span class="line">***************************/</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line">/************************************************************************************/</span><br><span class="line">//nAsrStatus 用来在main主程序中表示程序运行的状态，不是LD3320芯片内部的状态寄存器</span><br><span class="line">//LD_ASR_NONE:表示没有在作ASR识别</span><br><span class="line">//LD_ASR_RUNING：表示LD3320正在作ASR识别中</span><br><span class="line">//LD_ASR_FOUNDOK:表示一次识别流程结束后，有一个识别结果</span><br><span class="line">//LD_ASR_FOUNDZERO:表示一次识别流程结束后，没有识别结果</span><br><span class="line">//LD_ASR_ERROR:表示一次识别流程中LD3320芯片内部出现不正确的状态</span><br><span class="line">/***********************************************************************************/</span><br><span class="line">uint8 idata nAsrStatus=0;</span><br><span class="line">void MCU_init(); </span><br><span class="line">void ProcessInt0(); //识别处理函数</span><br><span class="line">void delay(unsigned long uldata);</span><br><span class="line">void User_handle(uint8 dat);//用户执行操作函数</span><br><span class="line">void Uart_SendCMD(int CMD ,int feedback , int dat);</span><br><span class="line">void Delay200ms();</span><br><span class="line">void Led_test(void);//单片机工作指示</span><br><span class="line">uint8_t G0_flag=DISABLE;//运行标志，ENABLE:运行。DISABLE:禁止运行</span><br><span class="line"></span><br><span class="line">sbit LED=P4^2;//信号指示灯</span><br><span class="line"></span><br><span class="line">//应用IO口定义 （模块标注 P2）</span><br><span class="line">sbit PA1=P1^0; //对应板上标号 P1.0</span><br><span class="line">sbit PA2=P1^1;  //对应板上标号 P1.1</span><br><span class="line">sbit PA3=P1^2;  //.....</span><br><span class="line">sbit PA4=P1^3;  //.....</span><br><span class="line">sbit PA5=P1^4;  //.....</span><br><span class="line">sbit PA6=P1^5;  //.....</span><br><span class="line">sbit PA7=P1^6;  //对应板上标号 P1.6</span><br><span class="line">sbit PA8=P1^7;  //对应板上标号 P1.7</span><br><span class="line">sbit PA9=P4^1;  //对应板上标号 P4.1</span><br><span class="line">sbit PA10=P4^7;  //对应板上标号 P2.7</span><br><span class="line">sbit PA11=P2^6;  //对应板上标号 P2.6</span><br><span class="line">sbit PA12=P2^5;  //对应板上标号 P2.5</span><br><span class="line">sbit PA13=P2^4;  //对应板上标号 P2.4</span><br><span class="line">sbit PA14=P2^3;  //对应板上标号 P2.3</span><br><span class="line">sbit PA15=P3^3;  //对应板上标号 P3.3</span><br><span class="line">sbit PA16=P3^4;  //对应板上标号 P3.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/***********************************************************</span><br><span class="line">* 名    称： void  main(void)</span><br><span class="line">* 功    能： 主函数程序入口</span><br><span class="line">* 入口参数：  </span><br><span class="line">* 出口参数：</span><br><span class="line">* 说    明：  </span><br><span class="line">* 调用方法： </span><br><span class="line">**********************************************************/ </span><br><span class="line">void  main(void)</span><br><span class="line">&#123;</span><br><span class="line">uint8 idata nAsrRes;</span><br><span class="line">uint8 i=0;</span><br><span class="line">Led_test();</span><br><span class="line">MCU_init();</span><br><span class="line">LD_Reset();</span><br><span class="line">UartIni(); /*串口初始化*/</span><br><span class="line">nAsrStatus = LD_ASR_NONE;//初始状态：没有在作ASR</span><br><span class="line"></span><br><span class="line">//复位所有io为低电平</span><br><span class="line">PA1 &amp;=0x00; </span><br><span class="line">PA2 &amp;=0x00; </span><br><span class="line">PA3 &amp;=0x00; </span><br><span class="line">PA4 &amp;=0x00; </span><br><span class="line">PA5 &amp;=0x00; </span><br><span class="line">PA6 &amp;=0x00; </span><br><span class="line">PA7 &amp;=0x00; </span><br><span class="line">PA8 &amp;=0x00; </span><br><span class="line">PA9 &amp;=0x00; </span><br><span class="line">PA10 &amp;=0x00; </span><br><span class="line">PA11 &amp;=0x00; </span><br><span class="line">PA12 &amp;=0x00; </span><br><span class="line">PA13 &amp;=0x00; </span><br><span class="line">PA14 &amp;=0x00; </span><br><span class="line">PA15 &amp;=0x00; </span><br><span class="line">PA16 &amp;=0x00; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">switch(nAsrStatus)</span><br><span class="line">&#123;</span><br><span class="line">case LD_ASR_RUNING:</span><br><span class="line">case LD_ASR_ERROR:</span><br><span class="line">break;</span><br><span class="line">case LD_ASR_NONE:</span><br><span class="line">&#123;</span><br><span class="line">nAsrStatus=LD_ASR_RUNING;</span><br><span class="line">if (RunASR()==0)/*启动一次ASR识别流程：ASR初始化，ASR添加关键词语，启动ASR运算*/</span><br><span class="line">&#123;</span><br><span class="line">nAsrStatus = LD_ASR_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case LD_ASR_FOUNDOK: /*一次ASR识别流程结束，去取ASR识别结果*/</span><br><span class="line">&#123;</span><br><span class="line">nAsrRes = LD_GetResult();/*获取结果*/</span><br><span class="line">User_handle(nAsrRes);//用户执行函数 </span><br><span class="line">nAsrStatus = LD_ASR_NONE;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case LD_ASR_FOUNDZERO:</span><br><span class="line">default:</span><br><span class="line">&#123;</span><br><span class="line">nAsrStatus = LD_ASR_NONE;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;// switch </span><br><span class="line">&#125;// while</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/***********************************************************</span><br><span class="line">* 名    称：  LED灯测试</span><br><span class="line">* 功    能： 单片机是否工作指示</span><br><span class="line">* 入口参数： 无 </span><br><span class="line">* 出口参数：无</span><br><span class="line">* 说    明：  </span><br><span class="line">**********************************************************/</span><br><span class="line">void Led_test(void)</span><br><span class="line">&#123;</span><br><span class="line">LED=~ LED;</span><br><span class="line">Delay200ms();;</span><br><span class="line">LED=~ LED;</span><br><span class="line">Delay200ms();;</span><br><span class="line">LED=~ LED;</span><br><span class="line">Delay200ms();;</span><br><span class="line">LED=~ LED;</span><br><span class="line">&#125;</span><br><span class="line">/***********************************************************</span><br><span class="line">* 名    称： void MCU_init()</span><br><span class="line">* 功    能： </span><br><span class="line">* 入口参数：  </span><br><span class="line">* 出口参数：</span><br><span class="line">* 说    明：  </span><br><span class="line">* 调用方法： </span><br><span class="line">**********************************************************/ </span><br><span class="line">void MCU_init()</span><br><span class="line">&#123;</span><br><span class="line">P0 = 0xff;</span><br><span class="line">P1 = 0xff;</span><br><span class="line">P2 = 0xff;</span><br><span class="line">P3 = 0xff;</span><br><span class="line">P4 = 0xff;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LD_MODE = 0;//设置MD管脚为低，并行模式读写</span><br><span class="line">IE0=1;</span><br><span class="line">EX0=1;</span><br><span class="line">EA=1;</span><br><span class="line">&#125;</span><br><span class="line">/***********************************************************</span><br><span class="line">* 名    称：延时函数</span><br><span class="line">* 功    能：</span><br><span class="line">* 入口参数：  </span><br><span class="line">* 出口参数：</span><br><span class="line">* 说    明：  </span><br><span class="line">* 调用方法： </span><br><span class="line">**********************************************************/ </span><br><span class="line">void Delay200us()//@22.1184MHz</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i, j;</span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">i = 5;</span><br><span class="line">j = 73;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">while (--j);</span><br><span class="line">&#125; while (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  delay(unsigned long uldata)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int j  =  0;</span><br><span class="line">unsigned int g  =  0;</span><br><span class="line">while(uldata--)</span><br><span class="line">Delay200us();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delay200ms()//@22.1184MHz</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i, j, k;</span><br><span class="line"></span><br><span class="line">i = 17;</span><br><span class="line">j = 208;</span><br><span class="line">k = 27;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">while (--k);</span><br><span class="line">&#125; while (--j);</span><br><span class="line">&#125; while (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***********************************************************</span><br><span class="line">* 名    称： 中断处理函数</span><br><span class="line">* 功    能：</span><br><span class="line">* 入口参数：  </span><br><span class="line">* 出口参数：</span><br><span class="line">* 说    明：  </span><br><span class="line">* 调用方法： </span><br><span class="line">**********************************************************/ </span><br><span class="line">void ExtInt0Handler(void) interrupt 0  </span><br><span class="line">&#123; </span><br><span class="line">ProcessInt0();</span><br><span class="line">&#125;</span><br><span class="line">/***********************************************************</span><br><span class="line">* 名    称：用户执行函数 </span><br><span class="line">* 功    能：识别成功后，执行动作可在此进行修改 </span><br><span class="line">* 入口参数： 无 </span><br><span class="line">* 出口参数：无</span><br><span class="line">* 说    明：  </span><br><span class="line">**********************************************************/</span><br><span class="line">void User_handle(uint8 dat)</span><br><span class="line">&#123;</span><br><span class="line">     //UARTSendByte(dat);//串口识别码（十六进制）</span><br><span class="line"> if(0==dat)  //判断是否识别一级口令</span><br><span class="line"> &#123;</span><br><span class="line">  G0_flag=ENABLE;</span><br><span class="line">LED = 0;</span><br><span class="line">delay(10);</span><br><span class="line">Uart_SendCMD(0x03 , 0, 0x01);  //播放第一首</span><br><span class="line">delay(10);</span><br><span class="line"> &#125;</span><br><span class="line"> else if(ENABLE==G0_flag)</span><br><span class="line"> &#123;</span><br><span class="line"> G0_flag=DISABLE;</span><br><span class="line">LED=1;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> switch(dat)   </span><br><span class="line">  &#123;</span><br><span class="line">  case CODE_KFBYZ:/*命令“开发板验证”*/</span><br><span class="line"> PA1 &amp;=0x01; </span><br><span class="line">                 delay(50);</span><br><span class="line">  Uart_SendCMD(0x03,0,0x02); //播放第17首</span><br><span class="line">               delay(50);</span><br><span class="line"> break;</span><br><span class="line">case CODE_DKJDQ:    /*命令“打开继电器”*/</span><br><span class="line"> PA2 &amp;=0x01; </span><br><span class="line">               delay(50);</span><br><span class="line"> Uart_SendCMD(0x03,0,0x03);  //播放第3首</span><br><span class="line">       Delay200ms();</span><br><span class="line"> break;</span><br><span class="line">case CODE_GBJDQ:   /*命令“关闭继电器”*/</span><br><span class="line">PA2 &amp;=0x00;</span><br><span class="line">                 delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x04); //播放第4首</span><br><span class="line">      delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_KD:   /*命令“开灯”*/</span><br><span class="line">PA3 &amp;=0x01;</span><br><span class="line">                 delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x08);  //播放第8首</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_GD:      /*命令“关灯”*/</span><br><span class="line">            PA3 &amp;=0x00; </span><br><span class="line">delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x07);//播放第7首</span><br><span class="line">          delay(50);</span><br><span class="line">break;</span><br><span class="line">          case CODE_DKFS:     /*命令“打开风扇”*/</span><br><span class="line">          PA4 &amp;=0x01; </span><br><span class="line">                 delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x05);//播放第5首</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">          case CODE_GBFS:     /*命令“关闭风扇”*/</span><br><span class="line">          PA4 &amp;=0x00; </span><br><span class="line">                delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x06);//播放第6首</span><br><span class="line">                delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_BB:     /*命令“拜拜”*/</span><br><span class="line">          PA5 &amp;=0x01; </span><br><span class="line">                delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x09);//播放第9首</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_BFYY:     /*命令“播放歌曲”*/</span><br><span class="line">          PA6 &amp;=0x01; </span><br><span class="line">                 delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x0a);//播放第9首</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_XYS:     /*命令“下一曲”*/</span><br><span class="line">          PA7 &amp;=0x01; </span><br><span class="line">                 delay(50);</span><br><span class="line">Uart_SendCMD(0x17,0,0x01);//循环播放01文件夹下的曲目</span><br><span class="line">               delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_PFZL:     /*命令“播放曲目”*/</span><br><span class="line">          PA8 &amp;=0x01; </span><br><span class="line">                 delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x0c);//播放平凡之路</span><br><span class="line">                delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_MZ:     /*命令“播放曲目”*/</span><br><span class="line">          PA9 &amp;=0x01; </span><br><span class="line">                delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x10);//播放芒种</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_SN:     /*命令“播放曲目”*/</span><br><span class="line">          PA9 &amp;=0x01; </span><br><span class="line">                delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x0d);//播放少年</span><br><span class="line">                delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_NDDA:     /*命令“播放曲目”*/</span><br><span class="line">          PA9 &amp;=0x01; </span><br><span class="line">               delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x0e);//播放你的答案</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_JL:     /*命令“播放曲目”*/</span><br><span class="line">          PA9 &amp;=0x01; </span><br><span class="line">                delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x0f);//播放惊雷</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">case CODE_QYS:     /*命令“播放曲目”*/</span><br><span class="line">          PA1 &amp;=0x01; </span><br><span class="line">                delay(50);</span><br><span class="line">Uart_SendCMD(0x03,0,0x11);//播放七月上</span><br><span class="line">                 delay(50);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;******************************************************<br>**  工程名称：UNV-01语音识别模块驱动程序<br>**CPU: STC11L08XE<br>**晶振：22.1184MHZ<br>**波特率：9600 bit&#x2F;S<br>**配套产品信息：UNV-LD3320+STC11语音识别开发板<br>**  修改日期：2018.5.13<br>**  说明：口令模式： 即每次识别时都需要说“小鹰”这个口令 ，才能够进行下一级的识别<br><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>#include “config.h”<br>&#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>&#x2F;&#x2F;nAsrStatus 用来在main主程序中表示程序运行的状态，不是LD3320芯片内部的状态寄存器<br>&#x2F;&#x2F;LD_ASR_NONE:表示没有在作ASR识别<br>&#x2F;&#x2F;LD_ASR_RUNING：表示LD3320正在作ASR识别中<br>&#x2F;&#x2F;LD_ASR_FOUNDOK:表示一次识别流程结束后，有一个识别结果<br>&#x2F;&#x2F;LD_ASR_FOUNDZERO:表示一次识别流程结束后，没有识别结果<br>&#x2F;&#x2F;LD_ASR_ERROR:表示一次识别流程中LD3320芯片内部出现不正确的状态<br>&#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>**************************&#x2F;<br>uint8 idata nAsrStatus&#x3D;0;<br>void MCU_init();<br>void ProcessInt0(); &#x2F;&#x2F;识别处理函数<br>void delay(unsigned long uldata);<br>void User_handle(uint8 dat);&#x2F;&#x2F;用户执行操作函数<br>void Uart_SendCMD(int CMD ,int feedback , int dat);<br>void Delay200ms();<br>void Led_test(void);&#x2F;&#x2F;单片机工作指示<br>uint8_t G0_flag&#x3D;DISABLE;&#x2F;&#x2F;运行标志，ENABLE:运行。DISABLE:禁止运行</p><p>sbit LED&#x3D;P4^2;&#x2F;&#x2F;信号指示灯</p><p>&#x2F;&#x2F;应用IO口定义 （模块标注 P2）<br>sbit PA1&#x3D;P1^0; &#x2F;&#x2F;对应板上标号 P1.0<br>sbit PA2&#x3D;P1^1;  &#x2F;&#x2F;对应板上标号 P1.1<br>sbit PA3&#x3D;P1^2;  &#x2F;&#x2F;…..<br>sbit PA4&#x3D;P1^3;  &#x2F;&#x2F;…..<br>sbit PA5&#x3D;P1^4;  &#x2F;&#x2F;…..<br>sbit PA6&#x3D;P1^5;  &#x2F;&#x2F;…..<br>sbit PA7&#x3D;P1^6;  &#x2F;&#x2F;对应板上标号 P1.6<br>sbit PA8&#x3D;P1^7;  &#x2F;&#x2F;对应板上标号 P1.7<br>sbit PA9&#x3D;P4^1;  &#x2F;&#x2F;对应板上标号 P4.1<br>sbit PA10&#x3D;P4^7;  &#x2F;&#x2F;对应板上标号 P2.7<br>sbit PA11&#x3D;P2^6;  &#x2F;&#x2F;对应板上标号 P2.6<br>sbit PA12&#x3D;P2^5;  &#x2F;&#x2F;对应板上标号 P2.5<br>sbit PA13&#x3D;P2^4;  &#x2F;&#x2F;对应板上标号 P2.4<br>sbit PA14&#x3D;P2^3;  &#x2F;&#x2F;对应板上标号 P2.3<br>sbit PA15&#x3D;P3^3;  &#x2F;&#x2F;对应板上标号 P3.3<br>sbit PA16&#x3D;P3^4;  &#x2F;&#x2F;对应板上标号 P3.4</p><p>&#x2F;***********************************************************</p><ul><li><p>名    称： void  main(void)</p></li><li><p>功    能： 主函数程序入口</p></li><li><p>入口参数：  </p></li><li><p>出口参数：</p></li><li><p>说    明：  </p></li><li><p>调用方法：<br>**********************************************************&#x2F;<br>void  main(void)<br>{<br>  uint8 idata nAsrRes;<br>  uint8 i&#x3D;0;<br>  Led_test();<br>  MCU_init();<br>  LD_Reset();<br>  UartIni(); &#x2F;<em>串口初始化</em>&#x2F;<br>  nAsrStatus &#x3D; LD_ASR_NONE;&#x2F;&#x2F;初始状态：没有在作ASR</p><p>  &#x2F;&#x2F;复位所有io为低电平</p></li></ul><p>PA1 &amp;&#x3D;0x00;<br>PA2 &amp;&#x3D;0x00;<br>PA3 &amp;&#x3D;0x00;<br>PA4 &amp;&#x3D;0x00;<br>PA5 &amp;&#x3D;0x00;<br>PA6 &amp;&#x3D;0x00;<br>PA7 &amp;&#x3D;0x00;<br>PA8 &amp;&#x3D;0x00;<br>PA9 &amp;&#x3D;0x00;<br>PA10 &amp;&#x3D;0x00;<br>PA11 &amp;&#x3D;0x00;<br>PA12 &amp;&#x3D;0x00;<br>PA13 &amp;&#x3D;0x00;<br>PA14 &amp;&#x3D;0x00;<br>PA15 &amp;&#x3D;0x00;<br>PA16 &amp;&#x3D;0x00; </p><pre><code>while(1)&#123;    switch(nAsrStatus)    &#123;        case LD_ASR_RUNING:        case LD_ASR_ERROR:            break;        case LD_ASR_NONE:        &#123;            nAsrStatus=LD_ASR_RUNING;            if (RunASR()==0)/*启动一次ASR识别流程：ASR初始化，ASR添加关键词语，启动ASR运算*/            &#123;                nAsrStatus = LD_ASR_ERROR;            &#125;            break;        &#125;        case LD_ASR_FOUNDOK: /*一次ASR识别流程结束，去取ASR识别结果*/        &#123;            nAsrRes = LD_GetResult();/*获取结果*/            User_handle(nAsrRes);//用户执行函数             nAsrStatus = LD_ASR_NONE;            break;        &#125;        case LD_ASR_FOUNDZERO:        default:        &#123;            nAsrStatus = LD_ASR_NONE;            break;        &#125;    &#125;// switch &#125;// while</code></pre><p>}<br>&#x2F;***********************************************************</p><ul><li><p>名    称：  LED灯测试</p></li><li><p>功    能： 单片机是否工作指示</p></li><li><p>入口参数： 无 </p></li><li><p>出口参数：无</p></li><li><p>说    明： <br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>void Led_test(void)<br>{<br>  LED&#x3D;~ LED;<br>  Delay200ms();;<br>  LED&#x3D;~ LED;<br>  Delay200ms();;<br>  LED&#x3D;~ LED;<br>  Delay200ms();;<br>  LED&#x3D;~ LED;<br>}<br>&#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*</p></li><li><p>名    称： void MCU_init()</p></li><li><p>功    能： </p></li><li><p>入口参数：  </p></li><li><p>出口参数：</p></li><li><p>说    明：  </p></li><li><p>调用方法：<br>**********************************************************&#x2F;<br>void MCU_init()<br>{<br>  P0 &#x3D; 0xff;<br>  P1 &#x3D; 0xff;<br>  P2 &#x3D; 0xff;<br>  P3 &#x3D; 0xff;<br>  P4 &#x3D; 0xff;</p><p>  LD_MODE &#x3D; 0;&#x2F;&#x2F;设置MD管脚为低，并行模式读写<br>  IE0&#x3D;1;<br>  EX0&#x3D;1;<br>  EA&#x3D;1;</p></li></ul><p>}<br>&#x2F;***********************************************************</p><ul><li>名    称：延时函数</li><li>功    能：</li><li>入口参数：  </li><li>出口参数：</li><li>说    明：  </li><li>调用方法：<br>**********************************************************&#x2F;<br>void Delay200us()&#x2F;&#x2F;@22.1184MHz<br>{<br>  unsigned char i, j;<br>  <em>nop</em>();<br>  <em>nop</em>();<br>  i &#x3D; 5;<br>  j &#x3D; 73;<br>  do<br>  {<br>  while (–j);<br>  } while (–i);<br>}</li></ul><p>void  delay(unsigned long uldata)<br>{<br>    unsigned int j  &#x3D;  0;<br>    unsigned int g  &#x3D;  0;<br>    while(uldata–)<br>    Delay200us();<br>}</p><p>void Delay200ms()&#x2F;&#x2F;@22.1184MHz<br>{<br>    unsigned char i, j, k;</p><pre><code>i = 17;j = 208;k = 27;do&#123;    do    &#123;        while (--k);    &#125; while (--j);&#125; while (--i);</code></pre><p>}</p><p>&#x2F;***********************************************************</p><ul><li>名    称： 中断处理函数</li><li>功    能：</li><li>入口参数：  </li><li>出口参数：</li><li>说    明：  </li><li>调用方法：<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>void ExtInt0Handler(void) interrupt 0<br>{ <br>  ProcessInt0();<br>}<br>&#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*</li><li>名    称：用户执行函数 </li><li>功    能：识别成功后，执行动作可在此进行修改 </li><li>入口参数： 无 </li><li>出口参数：无</li><li>说    明： <br>**********************************************************&#x2F;<br>void User_handle(uint8 dat)<br>{<br>   &#x2F;&#x2F;UARTSendByte(dat);&#x2F;&#x2F;串口识别码（十六进制）<br>   if(0&#x3D;&#x3D;dat)  &#x2F;&#x2F;判断是否识别一级口令<br>   {<br>    G0_flag&#x3D;ENABLE;<br>      LED &#x3D; 0;<br>      delay(10);<br>      Uart_SendCMD(0x03 , 0, 0x01);  &#x2F;&#x2F;播放第一首<br>  delay(10);<br>   }<br>   else if(ENABLE&#x3D;&#x3D;G0_flag)<br>   {<br>           G0_flag&#x3D;DISABLE;<br>          LED&#x3D;1;<br><br><br><br>           switch(dat)<br>        {<br>            case CODE_KFBYZ:&#x2F;<em>命令“开发板验证”</em>&#x2F;<br>                                               PA1 &amp;&#x3D;0x01;<br>                               delay(50);<br>                                                Uart_SendCMD(0x03,0,0x02); &#x2F;&#x2F;播放第17首<br>                                 delay(50);<br>                                               break;<br>              case CODE_DKJDQ:    &#x2F;<em>命令“打开继电器”</em>&#x2F;<br>                                               PA2 &amp;&#x3D;0x01;<br>                                 delay(50);<br>                                               Uart_SendCMD(0x03,0,0x03);  &#x2F;&#x2F;播放第3首<br>                                         Delay200ms();<br>                                               break;<br>              case CODE_GBJDQ:   &#x2F;<em>命令“关闭继电器”</em>&#x2F;<br>                                              PA2 &amp;&#x3D;0x00;<br>                               delay(50);<br>                                              Uart_SendCMD(0x03,0,0x04); &#x2F;&#x2F;播放第4首<br>                                        delay(50);<br>                                              break;<br>              case CODE_KD:   &#x2F;<em>命令“开灯”</em>&#x2F;<br>                                              PA3 &amp;&#x3D;0x01;<br>                                                   delay(50);<br>                                              Uart_SendCMD(0x03,0,0x08);  &#x2F;&#x2F;播放第8首<br>                                                   delay(50);<br>                                              break;<br>              case CODE_GD:      &#x2F;<em>命令“关灯”</em>&#x2F;<br>                                  PA3 &amp;&#x3D;0x00;<br>              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x07);&#x2F;&#x2F;播放第7首<br>    delay(50);<br>                                              break;<br>    case CODE_DKFS:     &#x2F;<em>命令“打开风扇”</em>&#x2F;<br>                                    PA4 &amp;&#x3D;0x01;<br>                                                   delay(50);<br>                                              Uart_SendCMD(0x03,0,0x05);&#x2F;&#x2F;播放第5首<br>                                                   delay(50);<br>                                              break;<br>    case CODE_GBFS:     &#x2F;<em>命令“关闭风扇”</em>&#x2F;<br>                                    PA4 &amp;&#x3D;0x00;<br>                              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x06);&#x2F;&#x2F;播放第6首<br>                                                  delay(50);<br>                                              break;<br>              case CODE_BB:     &#x2F;<em>命令“拜拜”</em>&#x2F;<br>                                    PA5 &amp;&#x3D;0x01; <br>                              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x09);&#x2F;&#x2F;播放第9首<br>                                                   delay(50);<br>                                              break;<br>              case CODE_BFYY:     &#x2F;<em>命令“播放歌曲”</em>&#x2F;<br>                                    PA6 &amp;&#x3D;0x01; <br>                               delay(50);<br>                                              Uart_SendCMD(0x03,0,0x0a);&#x2F;&#x2F;播放第9首<br>                                                   delay(50);<br>                                              break;<br>              case CODE_XYS:     &#x2F;<em>命令“下一曲”</em>&#x2F;<br>                                    PA7 &amp;&#x3D;0x01; <br>                               delay(50);<br>              Uart_SendCMD(0x17,0,0x01);&#x2F;&#x2F;循环播放01文件夹下的曲目<br>                                                 delay(50);<br>                                              break;<br>              case CODE_PFZL:     &#x2F;<em>命令“播放曲目”</em>&#x2F;<br>                                    PA8 &amp;&#x3D;0x01; <br>                               delay(50);<br>                                              Uart_SendCMD(0x03,0,0x0c);&#x2F;&#x2F;播放平凡之路<br>                                                  delay(50);<br>                                              break;<br>              case CODE_MZ:     &#x2F;<em>命令“播放曲目”</em>&#x2F;<br>                                    PA9 &amp;&#x3D;0x01; <br>                              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x10);&#x2F;&#x2F;播放芒种<br>                                                   delay(50);<br>                                              break;<br>              case CODE_SN:     &#x2F;<em>命令“播放曲目”</em>&#x2F;<br>                                    PA9 &amp;&#x3D;0x01; <br>                              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x0d);&#x2F;&#x2F;播放少年<br>                                                  delay(50);<br>                                              break;<br>              case CODE_NDDA:     &#x2F;<em>命令“播放曲目”</em>&#x2F;<br>                                    PA9 &amp;&#x3D;0x01; <br>                             delay(50);<br>                                              Uart_SendCMD(0x03,0,0x0e);&#x2F;&#x2F;播放你的答案<br>                                                   delay(50);<br>                                              break;<br>              case CODE_JL:     &#x2F;<em>命令“播放曲目”</em>&#x2F;<br>                                    PA9 &amp;&#x3D;0x01; <br>                              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x0f);&#x2F;&#x2F;播放惊雷<br>                                                   delay(50);<br>                                              break;<br>              case CODE_QYS:     &#x2F;<em>命令“播放曲目”</em>&#x2F;<br>                                    PA1 &amp;&#x3D;0x01; <br>                              delay(50);<br>                                              Uart_SendCMD(0x03,0,0x11);&#x2F;&#x2F;播放七月上<br>                                                   delay(50);<br>                                              break;<br>                      default:<br>                          break;<br>          }<br>      }<br>      else <br>      {<br><br>      }</li></ul><p>}&#96;</p><p>最主要的功能，实现串口之间数据收发的是usart.c文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;config.h&quot;</span><br><span class="line">#define FOSC 22118400L       //System frequency</span><br><span class="line">uint32_t baud=9600;           //UART baudrate</span><br><span class="line"></span><br><span class="line">static int Send_buf[10] = &#123;0&#125; ;</span><br><span class="line">/************************************************************************</span><br><span class="line">函 数 名： 串口初始化</span><br><span class="line">功能描述： STC10L08XE 单片机串口初始化函数</span><br><span class="line">返回函数： none</span><br><span class="line">其他说明： none</span><br><span class="line">**************************************************************************/</span><br><span class="line">void UartIni(void)</span><br><span class="line">&#123;</span><br><span class="line">    SCON = 0x50;              //8-bit variable UART</span><br><span class="line">    TMOD = 0x20;             //Set Timer1 as 8-bit auto reload mode</span><br><span class="line">    TH1 = TL1 = -(FOSC/12/32/baud); //Set auto-reload vaule</span><br><span class="line">    TR1 = 1;                //Timer1 start run</span><br><span class="line">    ES = 1;                 //Enable UART interrupt</span><br><span class="line">    EA = 1;                 //Open master interrupt switch</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 串口发送一字节数据</span><br><span class="line">入口参数：DAT:带发送的数据</span><br><span class="line">返 回 值： none</span><br><span class="line">其他说明：none</span><br><span class="line">**************************************************************************/</span><br><span class="line">void UARTSendByte(uint8_t DAT)</span><br><span class="line">&#123;</span><br><span class="line">ES  =  0;</span><br><span class="line">TI = 0;</span><br><span class="line">SBUF = DAT;</span><br><span class="line">while(TI==0);</span><br><span class="line">TI=0;</span><br><span class="line">ES = 1;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************************************************************************************</span><br><span class="line"> - 功能描述： 串口发送一帧数据</span><br><span class="line"> - 隶属模块： 内部 </span><br><span class="line"> - 参数说明： </span><br><span class="line"> - 返回说明： </span><br><span class="line"> - 注：无     </span><br><span class="line">*****************************************************************************************************/</span><br><span class="line">void SendCmd(int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0 ;</span><br><span class="line"></span><br><span class="line">    UARTSendByte(0x7E); //起始</span><br><span class="line"></span><br><span class="line">    for(i=0; i&lt;len; i++)//数据</span><br><span class="line">    &#123;</span><br><span class="line">UARTSendByte(Send_buf[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    UARTSendByte(0xEF) ;//结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************************************************</span><br><span class="line"> - 功能描述：求和校验</span><br><span class="line"> - 隶属模块：</span><br><span class="line"> - 参数说明：</span><br><span class="line"> - 返回说明：</span><br><span class="line"> - 注：      和校验的思路如下</span><br><span class="line">             发送的指令，去掉起始和结束。将中间的6个字节进行累加，最后取反码</span><br><span class="line">             接收端就将接收到的一帧数据，去掉起始和结束。将中间的数据累加，再加上接收到的校验</span><br><span class="line">             字节。刚好为0.这样就代表接收到的数据完全正确。</span><br><span class="line">********************************************************************************************/</span><br><span class="line">void DoSum( int *Str, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int xorsum = 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i=0; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xorsum  = xorsum + Str[i];</span><br><span class="line">    &#125;</span><br><span class="line">xorsum     = 0 -xorsum;</span><br><span class="line">*(Str+i)   = (int)(xorsum &gt;&gt;8);</span><br><span class="line">*(Str+i+1) = (int)(xorsum &amp; 0x00ff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/********************************************************************************************</span><br><span class="line"> - 功能描述： 串口向外发送命令[包括控制和查询]</span><br><span class="line"> - 隶属模块： 外部</span><br><span class="line"> - 参数说明： CMD:表示控制指令，请查阅指令表，还包括查询的相关指令</span><br><span class="line">              feedback:是否需要应答[0:不需要应答，1:需要应答]</span><br><span class="line">              data:传送的参数</span><br><span class="line"> - 返回说明：</span><br><span class="line"> - 注：       </span><br><span class="line">********************************************************************************************/</span><br><span class="line">void Uart_SendCMD(int CMD ,int feedback , int dat)</span><br><span class="line">&#123;</span><br><span class="line">    Send_buf[0] = 0xff;    //保留字节 </span><br><span class="line">    Send_buf[1] = 0x06;    //长度</span><br><span class="line">    Send_buf[2] = CMD;     //控制指令</span><br><span class="line">    Send_buf[3] = feedback;//是否需要反馈</span><br><span class="line">    Send_buf[4] = (int)(dat &gt;&gt; 8);//datah</span><br><span class="line">    Send_buf[5] = (int)(dat);     //datal</span><br><span class="line">    DoSum(&amp;Send_buf[0],6);        //校验</span><br><span class="line">    SendCmd(8);       //发送此帧数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"></span><br><span class="line">LDCChip.c:</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">/***************************飞音云电子****************************</span><br><span class="line">**  工程名称：YS-V0.7语音识别模块驱动程序</span><br><span class="line">**CPU: STC11L08XE</span><br><span class="line">**晶振：22.1184MHZ</span><br><span class="line">**波特率：9600 bit/S</span><br><span class="line">**配套产品信息：YS-V0.7语音识别开发板</span><br><span class="line">**                http://yuesheng001.taobao.com</span><br><span class="line">**  作者：zdings</span><br><span class="line">**  联系：751956552@qq.com</span><br><span class="line">**  修改日期：2013.9.13</span><br><span class="line">**  说明：口令模式： 即每次识别时都需要说“小杰”这个口令 ，才能够进行下一级的识别</span><br><span class="line">/***************************飞音云电子******************************/</span><br><span class="line">//#include &lt;REG51.H&gt;</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">extern void  delay(unsigned long uldata);</span><br><span class="line"></span><br><span class="line">uint8 idata ucRegVal;</span><br><span class="line">extern uint8 idata nAsrStatus;</span><br><span class="line"></span><br><span class="line">void ProcessInt0(void);</span><br><span class="line"></span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述：  复位LD模块</span><br><span class="line">入口参数： none</span><br><span class="line">返 回 值：  none</span><br><span class="line">其他说明： none</span><br><span class="line">**************************************************************************/</span><br><span class="line">void LD_Reset()</span><br><span class="line">&#123;</span><br><span class="line">RSTB=1;</span><br><span class="line">delay(1);</span><br><span class="line">RSTB=0;</span><br><span class="line">delay(1);</span><br><span class="line">RSTB=1;</span><br><span class="line"></span><br><span class="line">delay(1);</span><br><span class="line">CSB=0;</span><br><span class="line">delay(1);</span><br><span class="line">CSB=1;</span><br><span class="line">delay(1);</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： LD模块命令初始化</span><br><span class="line">入口参数： none</span><br><span class="line">返 回 值： none</span><br><span class="line">其他说明： 该函数为出厂配置，一般不需要修改；</span><br><span class="line"> 有兴趣的客户可对照开发手册根据需要自行修改。</span><br><span class="line">**************************************************************************/</span><br><span class="line">void LD_Init_Common()</span><br><span class="line">&#123;</span><br><span class="line">LD_ReadReg(0x06);  </span><br><span class="line">LD_WriteReg(0x17, 0x35); </span><br><span class="line">delay(10);</span><br><span class="line">LD_ReadReg(0x06);  </span><br><span class="line"></span><br><span class="line">LD_WriteReg(0x89, 0x03);  </span><br><span class="line">delay(5);</span><br><span class="line">LD_WriteReg(0xCF, 0x43);   </span><br><span class="line">delay(5);</span><br><span class="line">LD_WriteReg(0xCB, 0x02);</span><br><span class="line"></span><br><span class="line">/*PLL setting*/</span><br><span class="line">LD_WriteReg(0x11, LD_PLL_11);       </span><br><span class="line"></span><br><span class="line">LD_WriteReg(0x1E,0x00);</span><br><span class="line">LD_WriteReg(0x19, LD_PLL_ASR_19); </span><br><span class="line">LD_WriteReg(0x1B, LD_PLL_ASR_1B);</span><br><span class="line">  LD_WriteReg(0x1D, LD_PLL_ASR_1D);</span><br><span class="line">delay(10);</span><br><span class="line"></span><br><span class="line">    LD_WriteReg(0xCD, 0x04);</span><br><span class="line">//LD_WriteReg(0x17, 0x4c); </span><br><span class="line">delay(5);</span><br><span class="line">LD_WriteReg(0xB9, 0x00);</span><br><span class="line">LD_WriteReg(0xCF, 0x4F); </span><br><span class="line">LD_WriteReg(0x6F, 0xFF); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述：  LD模块 ASR功能初始化</span><br><span class="line">入口参数： none</span><br><span class="line">返 回 值：  none</span><br><span class="line">其他说明： 该函数为出厂配置，一般不需要修改；</span><br><span class="line"> 有兴趣的客户可对照开发手册根据需要自行修改。</span><br><span class="line">**************************************************************************/</span><br><span class="line">void LD_Init_ASR()</span><br><span class="line">&#123;</span><br><span class="line">LD_Init_Common();</span><br><span class="line">LD_WriteReg(0xBD, 0x00);</span><br><span class="line">LD_WriteReg(0x17, 0x48);</span><br><span class="line">delay( 10 );</span><br><span class="line">LD_WriteReg(0x3C, 0x80);    </span><br><span class="line">LD_WriteReg(0x3E, 0x07);</span><br><span class="line">LD_WriteReg(0x38, 0xff);    </span><br><span class="line">LD_WriteReg(0x3A, 0x07);</span><br><span class="line">  LD_WriteReg(0x40, 0);          </span><br><span class="line">LD_WriteReg(0x42, 8);</span><br><span class="line">LD_WriteReg(0x44, 0);    </span><br><span class="line">LD_WriteReg(0x46, 8); </span><br><span class="line">delay( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 中断处理函数</span><br><span class="line">入口参数： none</span><br><span class="line">返 回 值：  none</span><br><span class="line">其他说明：当LD模块接收到音频信号时，将进入该函数，</span><br><span class="line">判断识别是否有结果，如果没有从新配置寄</span><br><span class="line">            存器准备下一次的识别。</span><br><span class="line">**************************************************************************/</span><br><span class="line">void ProcessInt0(void)</span><br><span class="line">&#123;</span><br><span class="line">uint8 nAsrResCount=0;</span><br><span class="line"></span><br><span class="line">EX0=0;</span><br><span class="line">ucRegVal = LD_ReadReg(0x2B);</span><br><span class="line">LD_WriteReg(0x29,0) ;</span><br><span class="line">LD_WriteReg(0x02,0) ;</span><br><span class="line">if((ucRegVal &amp; 0x10) &amp;&amp;</span><br><span class="line">LD_ReadReg(0xb2)==0x21 &amp;&amp; </span><br><span class="line">LD_ReadReg(0xbf)==0x35)/*识别成功*/</span><br><span class="line">&#123;</span><br><span class="line">nAsrResCount = LD_ReadReg(0xba);</span><br><span class="line">if(nAsrResCount&gt;0 &amp;&amp; nAsrResCount&lt;=4) </span><br><span class="line">&#123;</span><br><span class="line">nAsrStatus=LD_ASR_FOUNDOK;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    &#123;</span><br><span class="line">nAsrStatus=LD_ASR_FOUNDZERO;</span><br><span class="line">&#125;</span><br><span class="line">&#125; /*没有识别结果*/</span><br><span class="line">else</span><br><span class="line">&#123; </span><br><span class="line">nAsrStatus=LD_ASR_FOUNDZERO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  LD_WriteReg(0x2b, 0);</span><br><span class="line">  LD_WriteReg(0x1C,0);/*写0:ADC不可用*/</span><br><span class="line"></span><br><span class="line">LD_WriteReg(0x29,0) ;</span><br><span class="line">LD_WriteReg(0x02,0) ;</span><br><span class="line">LD_WriteReg(0x2B,  0);</span><br><span class="line">LD_WriteReg(0xBA, 0);</span><br><span class="line">LD_WriteReg(0xBC,0);</span><br><span class="line">LD_WriteReg(0x08,1); /*清除FIFO_DATA*/</span><br><span class="line">LD_WriteReg(0x08,0);/*清除FIFO_DATA后 再次写0*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EX0=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 运行ASR识别流程</span><br><span class="line">入口参数：none</span><br><span class="line">返 回 值：  asrflag：1-&gt;启动成功， 0—&gt;启动失败</span><br><span class="line">其他说明：识别顺序如下:</span><br><span class="line">1、RunASR()函数实现了一次完整的ASR语音识别流程</span><br><span class="line">2、LD_AsrStart() 函数实现了ASR初始化</span><br><span class="line">3、LD_AsrAddFixed() 函数实现了添加关键词语到LD3320芯片中</span><br><span class="line">4、LD_AsrRun()函数启动了一次ASR语音识别流程</span><br><span class="line">任何一次ASR识别流程，都需要按照这个顺序，从初始化开始</span><br><span class="line">**************************************************************************/</span><br><span class="line">uint8 RunASR(void)</span><br><span class="line">&#123;</span><br><span class="line">uint8 i=0;</span><br><span class="line">uint8 asrflag=0;</span><br><span class="line">for (i=0; i&lt;5; i++)//防止由于硬件原因导致LD3320芯片工作不正常，所以一共尝试5次启动ASR识别流程</span><br><span class="line">&#123;</span><br><span class="line">LD_AsrStart();</span><br><span class="line">delay(50);</span><br><span class="line">if (LD_AsrAddFixed()==0)</span><br><span class="line">&#123;</span><br><span class="line">LD_Reset();//LD3320芯片内部出现不正常，立即重启LD3320芯片</span><br><span class="line">delay(50);//并从初始化开始重新ASR识别流程</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">delay(10);</span><br><span class="line">if (LD_AsrRun() == 0)</span><br><span class="line">&#123;</span><br><span class="line">LD_Reset();//LD3320芯片内部出现不正常，立即重启LD3320芯片</span><br><span class="line">delay(50);//并从初始化开始重新ASR识别流程</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">asrflag=1;</span><br><span class="line">break;//ASR流程启动成功，退出当前for循环。开始等待LD3320送出的中断信号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return asrflag;</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述：  检测LD模块是否空闲</span><br><span class="line">入口参数：none</span><br><span class="line">返 回 值： flag：1-&gt; 空闲</span><br><span class="line">其他说明：none</span><br><span class="line">**************************************************************************/</span><br><span class="line">uint8 LD_Check_ASRBusyFlag_b2()</span><br><span class="line">&#123;</span><br><span class="line">uint8 j;</span><br><span class="line">uint8 flag = 0;</span><br><span class="line">for (j=0; j&lt;10; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (LD_ReadReg(0xb2) == 0x21)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">delay(10);</span><br><span class="line">&#125;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 启动ASR</span><br><span class="line">入口参数：none</span><br><span class="line">返 回 值： none</span><br><span class="line">其他说明：none</span><br><span class="line">**************************************************************************/</span><br><span class="line">void LD_AsrStart()</span><br><span class="line">&#123;</span><br><span class="line">LD_Init_ASR();</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 运行ASR</span><br><span class="line">入口参数：none</span><br><span class="line">返 回 值： 1：启动成功</span><br><span class="line">其他说明：none</span><br><span class="line">**************************************************************************/</span><br><span class="line">uint8 LD_AsrRun()</span><br><span class="line">&#123;</span><br><span class="line">EX0=0;</span><br><span class="line">LD_WriteReg(0x35, MIC_VOL);</span><br><span class="line">LD_WriteReg(0x1C, 0x09);</span><br><span class="line">LD_WriteReg(0xBD, 0x20);</span><br><span class="line">LD_WriteReg(0x08, 0x01);</span><br><span class="line">delay( 10 );</span><br><span class="line">LD_WriteReg(0x08, 0x00);</span><br><span class="line">delay( 10 );</span><br><span class="line"></span><br><span class="line">if(LD_Check_ASRBusyFlag_b2() == 0)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//LD_WriteReg(0xB6, 0xa); //识别时间 1S</span><br><span class="line">//LD_WriteReg(0xB5, 0x1E); //背景音段时间 300ms</span><br><span class="line">//LD_WriteReg(0xB8, 10); //结束时间</span><br><span class="line"></span><br><span class="line">//LD_WriteReg(0x1C, 0x07); //配置双通道音频信号做为输入信号</span><br><span class="line">LD_WriteReg(0x1C, 0x0b); //配置麦克风做为输入信号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LD_WriteReg(0xB2, 0xff);</span><br><span class="line">delay( 10);</span><br><span class="line">LD_WriteReg(0x37, 0x06);</span><br><span class="line">delay( 10 );</span><br><span class="line">    LD_WriteReg(0x37, 0x06);</span><br><span class="line">delay( 5 );</span><br><span class="line">LD_WriteReg(0x29, 0x10);</span><br><span class="line"></span><br><span class="line">LD_WriteReg(0xBD, 0x00);</span><br><span class="line">EX0=1;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 向LD模块添加关键词</span><br><span class="line">入口参数： none</span><br><span class="line">返 回 值： flag：1-&gt;添加成功</span><br><span class="line">其他说明： 用户修改.</span><br><span class="line"> 1、根据如下格式添加拼音关键词，同时注意修改sRecog 和pCode 数组的长度</span><br><span class="line"> 和对应变了k的循环置。拼音串和识别码是一一对应的。</span><br><span class="line"> 2、开发者可以学习&quot;语音识别芯片LD3320高阶秘籍.pdf&quot;中</span><br><span class="line">           关于垃圾词语吸收错误的用法，来提供识别效果。</span><br><span class="line"> 3、”xiao jie “ 为口令，故在每次识别时，必须先发一级口令“小捷”</span><br><span class="line">**************************************************************************/</span><br><span class="line">uint8 LD_AsrAddFixed()</span><br><span class="line">&#123;</span><br><span class="line">uint8 k, flag;</span><br><span class="line">uint8 nAsrAddLength;</span><br><span class="line">#define DATE_A 18   /*数组二维数值*/</span><br><span class="line">#define DATE_B 20/*数组一维数值*/</span><br><span class="line">uint8 code sRecog[DATE_A][DATE_B] = &#123;</span><br><span class="line">&quot;xiao xin&quot;,\</span><br><span class="line">&quot;kai fa ban yan zheng&quot;,\</span><br><span class="line">&quot;da kai ji dian qi&quot;,\</span><br><span class="line">&quot;guan bi ji dian qi&quot;,\</span><br><span class="line">&quot;kai deng&quot;,\</span><br><span class="line">&quot;guan deng&quot;,\</span><br><span class="line">&quot;zai jian&quot;,\</span><br><span class="line">&quot;bo fang yin yue&quot;,\</span><br><span class="line">&quot;da kai feng shan&quot;,\</span><br><span class="line">                                    &quot;guan bi feng shan&quot;,\</span><br><span class="line">                                      &quot;bai bai&quot;,\</span><br><span class="line">                                     &quot;xia yi shou&quot;,\</span><br><span class="line">                                    &quot;ping fan zhi lu&quot;,\</span><br><span class="line"> &quot;mang zhong&quot;,\</span><br><span class="line"> &quot;shao nian&quot;,\</span><br><span class="line"> &quot;ni de da an&quot;,\</span><br><span class="line"> &quot;jing lei&quot;,\</span><br><span class="line">&quot;qi yue shang&quot;,\</span><br><span class="line">&#125;;  /*添加关键词，用户修改*/</span><br><span class="line">uint8 code pCode[DATE_A] = &#123;</span><br><span class="line">CODE_CMD,\   </span><br><span class="line">CODE_KFBYZ,\  </span><br><span class="line">CODE_DKJDQ,\  </span><br><span class="line">CODE_GBJDQ,\</span><br><span class="line">CODE_KD,\</span><br><span class="line">CODE_GD,\</span><br><span class="line">CODE_ZJ,\</span><br><span class="line">CODE_BFYY,\</span><br><span class="line">                          CODE_DKFS,\</span><br><span class="line">                          CODE_GBFS,\</span><br><span class="line">                          CODE_BB,\</span><br><span class="line">                          CODE_XYS,\</span><br><span class="line">                          CODE_PFZL,\</span><br><span class="line">                           CODE_MZ,\</span><br><span class="line">                            CODE_SN,\</span><br><span class="line">                            CODE_NDDA,\</span><br><span class="line">                           CODE_JL,\</span><br><span class="line">                          CODE_QYS,\</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line">/*添加识别码，用户修改*/</span><br><span class="line"> </span><br><span class="line">flag = 1;</span><br><span class="line">for (k=0; k&lt;DATE_A; k++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(LD_Check_ASRBusyFlag_b2() == 0)</span><br><span class="line">&#123;</span><br><span class="line">flag = 0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LD_WriteReg(0xc1, pCode[k] );</span><br><span class="line">LD_WriteReg(0xc3, 0 );</span><br><span class="line">LD_WriteReg(0x08, 0x04);</span><br><span class="line">delay(10);</span><br><span class="line">LD_WriteReg(0x08, 0x00);</span><br><span class="line">delay(10);</span><br><span class="line"></span><br><span class="line">for (nAsrAddLength=0; nAsrAddLength&lt;DATE_B; nAsrAddLength++)</span><br><span class="line">&#123;</span><br><span class="line">if (sRecog[k][nAsrAddLength] == 0)</span><br><span class="line">break;</span><br><span class="line">LD_WriteReg(0x5, sRecog[k][nAsrAddLength]);</span><br><span class="line">&#125;</span><br><span class="line">LD_WriteReg(0xb9, nAsrAddLength);</span><br><span class="line">LD_WriteReg(0xb2, 0xff);</span><br><span class="line">LD_WriteReg(0x37, 0x04);</span><br><span class="line">&#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">/************************************************************************</span><br><span class="line">功能描述： 获取识别结果</span><br><span class="line">入口参数：none</span><br><span class="line">返 回 值： LD_ReadReg(0xc5 )；  读取内部寄存器返回识别码。</span><br><span class="line">其他说明：none</span><br><span class="line">**************************************************************************/</span><br><span class="line">uint8 LD_GetResult()</span><br><span class="line">&#123;</span><br><span class="line">return LD_ReadReg(0xc5 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “config.h”<br>#define FOSC 22118400L       &#x2F;&#x2F;System frequency<br>uint32_t baud&#x3D;9600;           &#x2F;&#x2F;UART baudrate</p><p>static int Send_buf[10] &#x3D; {0} ;<br>&#x2F;************************************************************************<br>函 数 名： 串口初始化<br>功能描述： STC10L08XE 单片机串口初始化函数<br>返回函数： none<br>其他说明： none<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>void UartIni(void)<br>{<br>    SCON &#x3D; 0x50;              &#x2F;&#x2F;8-bit variable UART<br>    TMOD &#x3D; 0x20;             &#x2F;&#x2F;Set Timer1 as 8-bit auto reload mode<br>    TH1 &#x3D; TL1 &#x3D; -(FOSC&#x2F;12&#x2F;32&#x2F;baud); &#x2F;&#x2F;Set auto-reload vaule<br>    TR1 &#x3D; 1;                &#x2F;&#x2F;Timer1 start run<br>    ES &#x3D; 1;                 &#x2F;&#x2F;Enable UART interrupt<br>    EA &#x3D; 1;                 &#x2F;&#x2F;Open master interrupt switch<br>}<br>&#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>功能描述： 串口发送一字节数据<br>入口参数：DAT:带发送的数据<br>返 回 值： none<br>其他说明：none<br><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>void UARTSendByte(uint8_t DAT)<br>{<br>    ES  &#x3D;  0;<br>    TI &#x3D; 0;<br>    SBUF &#x3D; DAT;<br>    while(TI&#x3D;&#x3D;0);<br>    TI&#x3D;0;<br>    ES &#x3D; 1;<br>}<br>&#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*************************</p><ul><li><p>功能描述： 串口发送一帧数据</p></li><li><p>隶属模块： 内部 </p></li><li><p>参数说明： </p></li><li><p>返回说明： </p></li><li><p>注：无<br>*****************************************************************************************************&#x2F;<br>void SendCmd(int len)<br>{<br> int i &#x3D; 0 ;</p><p> UARTSendByte(0x7E); &#x2F;&#x2F;起始</p><p> for(i&#x3D;0; i&lt;len; i++)&#x2F;&#x2F;数据<br> {<br>     UARTSendByte(Send_buf[i]) ;<br> }<br> UARTSendByte(0xEF) ;&#x2F;&#x2F;结束</p></li></ul><p>}</p><p>&#x2F;********************************************************************************************</p><ul><li>功能描述：求和校验</li><li>隶属模块：</li><li>参数说明：</li><li>返回说明：</li><li>注：      和校验的思路如下<br>      发送的指令，去掉起始和结束。将中间的6个字节进行累加，最后取反码<br>      接收端就将接收到的一帧数据，去掉起始和结束。将中间的数据累加，再加上接收到的校验<br>      字节。刚好为0.这样就代表接收到的数据完全正确。</li></ul><p>********************************************************************************************&#x2F;<br>void DoSum( int *Str, int len)<br>{<br>    int xorsum &#x3D; 0;<br>    int i;</p><pre><code>for(i=0; i&lt;len; i++)&#123;    xorsum  = xorsum + Str[i];&#125;xorsum     = 0 -xorsum;*(Str+i)   = (int)(xorsum &gt;&gt;8);*(Str+i+1) = (int)(xorsum &amp; 0x00ff);</code></pre><p>}</p><p>&#x2F;********************************************************************************************</p><ul><li>功能描述： 串口向外发送命令[包括控制和查询]</li><li>隶属模块： 外部</li><li>参数说明： CMD:表示控制指令，请查阅指令表，还包括查询的相关指令<br>       feedback:是否需要应答[0:不需要应答，1:需要应答]<br>       data:传送的参数</li><li>返回说明：</li><li>注：<br>********************************************************************************************&#x2F;<br>void Uart_SendCMD(int CMD ,int feedback , int dat)<br>{<br> Send_buf[0] &#x3D; 0xff;    &#x2F;&#x2F;保留字节<br> Send_buf[1] &#x3D; 0x06;    &#x2F;&#x2F;长度<br> Send_buf[2] &#x3D; CMD;     &#x2F;&#x2F;控制指令<br> Send_buf[3] &#x3D; feedback;&#x2F;&#x2F;是否需要反馈<br> Send_buf[4] &#x3D; (int)(dat &gt;&gt; 8);&#x2F;&#x2F;datah<br> Send_buf[5] &#x3D; (int)(dat);     &#x2F;&#x2F;datal<br> DoSum(&amp;Send_buf[0],6);        &#x2F;&#x2F;校验<br> SendCmd(8);       &#x2F;&#x2F;发送此帧数据<br>}</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LDCChip.c:</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">/***************************飞音云电子****************************</span></span><br><span class="line"><span class="comment">**  工程名称：YS-V0.7语音识别模块驱动程序</span></span><br><span class="line"><span class="comment">**CPU: STC11L08XE</span></span><br><span class="line"><span class="comment">**晶振：22.1184MHZ</span></span><br><span class="line"><span class="comment">**波特率：9600 bit/S</span></span><br><span class="line"><span class="comment">**配套产品信息：YS-V0.7语音识别开发板</span></span><br><span class="line"><span class="comment">**                http://yuesheng001.taobao.com</span></span><br><span class="line"><span class="comment">**  作者：zdings</span></span><br><span class="line"><span class="comment">**  联系：751956552@qq.com</span></span><br><span class="line"><span class="comment">**  修改日期：2013.9.13</span></span><br><span class="line"><span class="comment">**  说明：口令模式： 即每次识别时都需要说“小杰”这个口令 ，才能够进行下一级的识别</span></span><br><span class="line"><span class="comment">/***************************飞音云电子******************************/</span></span><br><span class="line"><span class="comment">//#include &lt;REG51.H&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>  <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> uldata)</span>;</span><br><span class="line"></span><br><span class="line">uint8 idata ucRegVal;</span><br><span class="line"><span class="keyword">extern</span> uint8 idata nAsrStatus;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessInt0</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述：  复位LD模块</span></span><br><span class="line"><span class="comment">入口参数： none</span></span><br><span class="line"><span class="comment">返 回 值：  none</span></span><br><span class="line"><span class="comment">其他说明： none</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LD_Reset</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RSTB=<span class="number">1</span>;</span><br><span class="line">delay(<span class="number">1</span>);</span><br><span class="line">RSTB=<span class="number">0</span>;</span><br><span class="line">delay(<span class="number">1</span>);</span><br><span class="line">RSTB=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1</span>);</span><br><span class="line">CSB=<span class="number">0</span>;</span><br><span class="line">delay(<span class="number">1</span>);</span><br><span class="line">CSB=<span class="number">1</span>;</span><br><span class="line">delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： LD模块命令初始化</span></span><br><span class="line"><span class="comment">入口参数： none</span></span><br><span class="line"><span class="comment">返 回 值： none</span></span><br><span class="line"><span class="comment">其他说明： 该函数为出厂配置，一般不需要修改；</span></span><br><span class="line"><span class="comment"> 有兴趣的客户可对照开发手册根据需要自行修改。</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LD_Init_Common</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LD_ReadReg(<span class="number">0x06</span>);  </span><br><span class="line">LD_WriteReg(<span class="number">0x17</span>, <span class="number">0x35</span>); </span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line">LD_ReadReg(<span class="number">0x06</span>);  </span><br><span class="line"></span><br><span class="line">LD_WriteReg(<span class="number">0x89</span>, <span class="number">0x03</span>);  </span><br><span class="line">delay(<span class="number">5</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xCF</span>, <span class="number">0x43</span>);   </span><br><span class="line">delay(<span class="number">5</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xCB</span>, <span class="number">0x02</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*PLL setting*/</span></span><br><span class="line">LD_WriteReg(<span class="number">0x11</span>, LD_PLL_11);       </span><br><span class="line"></span><br><span class="line">LD_WriteReg(<span class="number">0x1E</span>,<span class="number">0x00</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x19</span>, LD_PLL_ASR_19); </span><br><span class="line">LD_WriteReg(<span class="number">0x1B</span>, LD_PLL_ASR_1B);</span><br><span class="line">  LD_WriteReg(<span class="number">0x1D</span>, LD_PLL_ASR_1D);</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    LD_WriteReg(<span class="number">0xCD</span>, <span class="number">0x04</span>);</span><br><span class="line"><span class="comment">//LD_WriteReg(0x17, 0x4c); </span></span><br><span class="line">delay(<span class="number">5</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xB9</span>, <span class="number">0x00</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xCF</span>, <span class="number">0x4F</span>); </span><br><span class="line">LD_WriteReg(<span class="number">0x6F</span>, <span class="number">0xFF</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述：  LD模块 ASR功能初始化</span></span><br><span class="line"><span class="comment">入口参数： none</span></span><br><span class="line"><span class="comment">返 回 值：  none</span></span><br><span class="line"><span class="comment">其他说明： 该函数为出厂配置，一般不需要修改；</span></span><br><span class="line"><span class="comment"> 有兴趣的客户可对照开发手册根据需要自行修改。</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LD_Init_ASR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LD_Init_Common();</span><br><span class="line">LD_WriteReg(<span class="number">0xBD</span>, <span class="number">0x00</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x17</span>, <span class="number">0x48</span>);</span><br><span class="line">delay( <span class="number">10</span> );</span><br><span class="line">LD_WriteReg(<span class="number">0x3C</span>, <span class="number">0x80</span>);    </span><br><span class="line">LD_WriteReg(<span class="number">0x3E</span>, <span class="number">0x07</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x38</span>, <span class="number">0xff</span>);    </span><br><span class="line">LD_WriteReg(<span class="number">0x3A</span>, <span class="number">0x07</span>);</span><br><span class="line">  LD_WriteReg(<span class="number">0x40</span>, <span class="number">0</span>);          </span><br><span class="line">LD_WriteReg(<span class="number">0x42</span>, <span class="number">8</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x44</span>, <span class="number">0</span>);    </span><br><span class="line">LD_WriteReg(<span class="number">0x46</span>, <span class="number">8</span>); </span><br><span class="line">delay( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： 中断处理函数</span></span><br><span class="line"><span class="comment">入口参数： none</span></span><br><span class="line"><span class="comment">返 回 值：  none</span></span><br><span class="line"><span class="comment">其他说明：当LD模块接收到音频信号时，将进入该函数，</span></span><br><span class="line"><span class="comment">判断识别是否有结果，如果没有从新配置寄</span></span><br><span class="line"><span class="comment">            存器准备下一次的识别。</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessInt0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">uint8 nAsrResCount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">EX0=<span class="number">0</span>;</span><br><span class="line">ucRegVal = LD_ReadReg(<span class="number">0x2B</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x29</span>,<span class="number">0</span>) ;</span><br><span class="line">LD_WriteReg(<span class="number">0x02</span>,<span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span>((ucRegVal &amp; <span class="number">0x10</span>) &amp;&amp;</span><br><span class="line">LD_ReadReg(<span class="number">0xb2</span>)==<span class="number">0x21</span> &amp;&amp; </span><br><span class="line">LD_ReadReg(<span class="number">0xbf</span>)==<span class="number">0x35</span>)<span class="comment">/*识别成功*/</span></span><br><span class="line">&#123;</span><br><span class="line">nAsrResCount = LD_ReadReg(<span class="number">0xba</span>);</span><br><span class="line"><span class="keyword">if</span>(nAsrResCount&gt;<span class="number">0</span> &amp;&amp; nAsrResCount&lt;=<span class="number">4</span>) </span><br><span class="line">&#123;</span><br><span class="line">nAsrStatus=LD_ASR_FOUNDOK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">nAsrStatus=LD_ASR_FOUNDZERO;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/*没有识别结果*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">nAsrStatus=LD_ASR_FOUNDZERO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  LD_WriteReg(<span class="number">0x2b</span>, <span class="number">0</span>);</span><br><span class="line">  LD_WriteReg(<span class="number">0x1C</span>,<span class="number">0</span>);<span class="comment">/*写0:ADC不可用*/</span></span><br><span class="line"></span><br><span class="line">LD_WriteReg(<span class="number">0x29</span>,<span class="number">0</span>) ;</span><br><span class="line">LD_WriteReg(<span class="number">0x02</span>,<span class="number">0</span>) ;</span><br><span class="line">LD_WriteReg(<span class="number">0x2B</span>,  <span class="number">0</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xBA</span>, <span class="number">0</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xBC</span>,<span class="number">0</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x08</span>,<span class="number">1</span>); <span class="comment">/*清除FIFO_DATA*/</span></span><br><span class="line">LD_WriteReg(<span class="number">0x08</span>,<span class="number">0</span>);<span class="comment">/*清除FIFO_DATA后 再次写0*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EX0=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： 运行ASR识别流程</span></span><br><span class="line"><span class="comment">入口参数：none</span></span><br><span class="line"><span class="comment">返 回 值：  asrflag：1-&gt;启动成功， 0—&gt;启动失败</span></span><br><span class="line"><span class="comment">其他说明：识别顺序如下:</span></span><br><span class="line"><span class="comment">1、RunASR()函数实现了一次完整的ASR语音识别流程</span></span><br><span class="line"><span class="comment">2、LD_AsrStart() 函数实现了ASR初始化</span></span><br><span class="line"><span class="comment">3、LD_AsrAddFixed() 函数实现了添加关键词语到LD3320芯片中</span></span><br><span class="line"><span class="comment">4、LD_AsrRun()函数启动了一次ASR语音识别流程</span></span><br><span class="line"><span class="comment">任何一次ASR识别流程，都需要按照这个顺序，从初始化开始</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line">uint8 <span class="title function_">RunASR</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">uint8 i=<span class="number">0</span>;</span><br><span class="line">uint8 asrflag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)<span class="comment">//防止由于硬件原因导致LD3320芯片工作不正常，所以一共尝试5次启动ASR识别流程</span></span><br><span class="line">&#123;</span><br><span class="line">LD_AsrStart();</span><br><span class="line">delay(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span> (LD_AsrAddFixed()==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LD_Reset();<span class="comment">//LD3320芯片内部出现不正常，立即重启LD3320芯片</span></span><br><span class="line">delay(<span class="number">50</span>);<span class="comment">//并从初始化开始重新ASR识别流程</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (LD_AsrRun() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LD_Reset();<span class="comment">//LD3320芯片内部出现不正常，立即重启LD3320芯片</span></span><br><span class="line">delay(<span class="number">50</span>);<span class="comment">//并从初始化开始重新ASR识别流程</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">asrflag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//ASR流程启动成功，退出当前for循环。开始等待LD3320送出的中断信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> asrflag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述：  检测LD模块是否空闲</span></span><br><span class="line"><span class="comment">入口参数：none</span></span><br><span class="line"><span class="comment">返 回 值： flag：1-&gt; 空闲</span></span><br><span class="line"><span class="comment">其他说明：none</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line">uint8 <span class="title function_">LD_Check_ASRBusyFlag_b2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">uint8 j;</span><br><span class="line">uint8 flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (LD_ReadReg(<span class="number">0xb2</span>) == <span class="number">0x21</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： 启动ASR</span></span><br><span class="line"><span class="comment">入口参数：none</span></span><br><span class="line"><span class="comment">返 回 值： none</span></span><br><span class="line"><span class="comment">其他说明：none</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LD_AsrStart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LD_Init_ASR();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： 运行ASR</span></span><br><span class="line"><span class="comment">入口参数：none</span></span><br><span class="line"><span class="comment">返 回 值： 1：启动成功</span></span><br><span class="line"><span class="comment">其他说明：none</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line">uint8 <span class="title function_">LD_AsrRun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">EX0=<span class="number">0</span>;</span><br><span class="line">LD_WriteReg(<span class="number">0x35</span>, MIC_VOL);</span><br><span class="line">LD_WriteReg(<span class="number">0x1C</span>, <span class="number">0x09</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0xBD</span>, <span class="number">0x20</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x08</span>, <span class="number">0x01</span>);</span><br><span class="line">delay( <span class="number">10</span> );</span><br><span class="line">LD_WriteReg(<span class="number">0x08</span>, <span class="number">0x00</span>);</span><br><span class="line">delay( <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LD_Check_ASRBusyFlag_b2() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LD_WriteReg(0xB6, 0xa); //识别时间 1S</span></span><br><span class="line"><span class="comment">//LD_WriteReg(0xB5, 0x1E); //背景音段时间 300ms</span></span><br><span class="line"><span class="comment">//LD_WriteReg(0xB8, 10); //结束时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LD_WriteReg(0x1C, 0x07); //配置双通道音频信号做为输入信号</span></span><br><span class="line">LD_WriteReg(<span class="number">0x1C</span>, <span class="number">0x0b</span>); <span class="comment">//配置麦克风做为输入信号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LD_WriteReg(<span class="number">0xB2</span>, <span class="number">0xff</span>);</span><br><span class="line">delay( <span class="number">10</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x37</span>, <span class="number">0x06</span>);</span><br><span class="line">delay( <span class="number">10</span> );</span><br><span class="line">    LD_WriteReg(<span class="number">0x37</span>, <span class="number">0x06</span>);</span><br><span class="line">delay( <span class="number">5</span> );</span><br><span class="line">LD_WriteReg(<span class="number">0x29</span>, <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">LD_WriteReg(<span class="number">0xBD</span>, <span class="number">0x00</span>);</span><br><span class="line">EX0=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： 向LD模块添加关键词</span></span><br><span class="line"><span class="comment">入口参数： none</span></span><br><span class="line"><span class="comment">返 回 值： flag：1-&gt;添加成功</span></span><br><span class="line"><span class="comment">其他说明： 用户修改.</span></span><br><span class="line"><span class="comment"> 1、根据如下格式添加拼音关键词，同时注意修改sRecog 和pCode 数组的长度</span></span><br><span class="line"><span class="comment"> 和对应变了k的循环置。拼音串和识别码是一一对应的。</span></span><br><span class="line"><span class="comment"> 2、开发者可以学习&quot;语音识别芯片LD3320高阶秘籍.pdf&quot;中</span></span><br><span class="line"><span class="comment">           关于垃圾词语吸收错误的用法，来提供识别效果。</span></span><br><span class="line"><span class="comment"> 3、”xiao jie “ 为口令，故在每次识别时，必须先发一级口令“小捷”</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line">uint8 <span class="title function_">LD_AsrAddFixed</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">uint8 k, flag;</span><br><span class="line">uint8 nAsrAddLength;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATE_A 18   <span class="comment">/*数组二维数值*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATE_B 20<span class="comment">/*数组一维数值*/</span></span></span><br><span class="line">uint8 code sRecog[DATE_A][DATE_B] = &#123;</span><br><span class="line"><span class="string">&quot;xiao xin&quot;</span>,\</span><br><span class="line"><span class="string">&quot;kai fa ban yan zheng&quot;</span>,\</span><br><span class="line"><span class="string">&quot;da kai ji dian qi&quot;</span>,\</span><br><span class="line"><span class="string">&quot;guan bi ji dian qi&quot;</span>,\</span><br><span class="line"><span class="string">&quot;kai deng&quot;</span>,\</span><br><span class="line"><span class="string">&quot;guan deng&quot;</span>,\</span><br><span class="line"><span class="string">&quot;zai jian&quot;</span>,\</span><br><span class="line"><span class="string">&quot;bo fang yin yue&quot;</span>,\</span><br><span class="line"><span class="string">&quot;da kai feng shan&quot;</span>,\</span><br><span class="line">                                    <span class="string">&quot;guan bi feng shan&quot;</span>,\</span><br><span class="line">                                      <span class="string">&quot;bai bai&quot;</span>,\</span><br><span class="line">                                     <span class="string">&quot;xia yi shou&quot;</span>,\</span><br><span class="line">                                    <span class="string">&quot;ping fan zhi lu&quot;</span>,\</span><br><span class="line"> <span class="string">&quot;mang zhong&quot;</span>,\</span><br><span class="line"> <span class="string">&quot;shao nian&quot;</span>,\</span><br><span class="line"> <span class="string">&quot;ni de da an&quot;</span>,\</span><br><span class="line"> <span class="string">&quot;jing lei&quot;</span>,\</span><br><span class="line"><span class="string">&quot;qi yue shang&quot;</span>,\</span><br><span class="line">&#125;;  <span class="comment">/*添加关键词，用户修改*/</span></span><br><span class="line">uint8 code pCode[DATE_A] = &#123;</span><br><span class="line">CODE_CMD,\   </span><br><span class="line">CODE_KFBYZ,\  </span><br><span class="line">CODE_DKJDQ,\  </span><br><span class="line">CODE_GBJDQ,\</span><br><span class="line">CODE_KD,\</span><br><span class="line">CODE_GD,\</span><br><span class="line">CODE_ZJ,\</span><br><span class="line">CODE_BFYY,\</span><br><span class="line">                          CODE_DKFS,\</span><br><span class="line">                          CODE_GBFS,\</span><br><span class="line">                          CODE_BB,\</span><br><span class="line">                          CODE_XYS,\</span><br><span class="line">                          CODE_PFZL,\</span><br><span class="line">                           CODE_MZ,\</span><br><span class="line">                            CODE_SN,\</span><br><span class="line">                            CODE_NDDA,\</span><br><span class="line">                           CODE_JL,\</span><br><span class="line">                          CODE_QYS,\</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">/*添加识别码，用户修改*/</span></span><br><span class="line"> </span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;DATE_A; k++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LD_Check_ASRBusyFlag_b2() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LD_WriteReg(<span class="number">0xc1</span>, pCode[k] );</span><br><span class="line">LD_WriteReg(<span class="number">0xc3</span>, <span class="number">0</span> );</span><br><span class="line">LD_WriteReg(<span class="number">0x08</span>, <span class="number">0x04</span>);</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x08</span>, <span class="number">0x00</span>);</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (nAsrAddLength=<span class="number">0</span>; nAsrAddLength&lt;DATE_B; nAsrAddLength++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sRecog[k][nAsrAddLength] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">LD_WriteReg(<span class="number">0x5</span>, sRecog[k][nAsrAddLength]);</span><br><span class="line">&#125;</span><br><span class="line">LD_WriteReg(<span class="number">0xb9</span>, nAsrAddLength);</span><br><span class="line">LD_WriteReg(<span class="number">0xb2</span>, <span class="number">0xff</span>);</span><br><span class="line">LD_WriteReg(<span class="number">0x37</span>, <span class="number">0x04</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">功能描述： 获取识别结果</span></span><br><span class="line"><span class="comment">入口参数：none</span></span><br><span class="line"><span class="comment">返 回 值： LD_ReadReg(0xc5 )；  读取内部寄存器返回识别码。</span></span><br><span class="line"><span class="comment">其他说明：none</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br><span class="line">uint8 <span class="title function_">LD_GetResult</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> LD_ReadReg(<span class="number">0xc5</span> );</span><br><span class="line">&#125;`</span><br><span class="line"></span><br><span class="line">LDChip.h:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#ifndef LD_CHIP_H<br>#define LD_CHIP_H</p><p>#define uint8 unsigned char<br>#define uint16 unsigned int<br>#define uint32 unsigned long</p><p>&#x2F;&#x2F;以下五个状态定义用来记录程序是在运行ASR识别过程中的哪个状态<br>#define LD_ASR_NONE0x00 &#x2F;*表示没有在作ASR识别*&#x2F;<br>#define LD_ASR_RUNING0x01&#x2F;*表示LD3320正在作ASR识别中*&#x2F;<br>#define LD_ASR_FOUNDOK0x10&#x2F;<em>表示一次识别流程结束后，有一个识别结果</em>&#x2F;<br>#define LD_ASR_FOUNDZERO 0x11&#x2F;<em>表示一次识别流程结束后，没有识别结果</em>&#x2F;<br>#define LD_ASR_ERROR 0x31&#x2F;<em>表示一次识别流程中LD3320芯片内部出现不正确的状态</em>&#x2F;</p><p>#define CLK_IN   22.1184&#x2F;* 用户注意修改输入的晶振时钟大小 <em>&#x2F;<br>#define LD_PLL_11(uint8)((CLK_IN&#x2F;2.0)-1)<br>#define LD_PLL_MP3_190x0f<br>#define LD_PLL_MP3_1B0x18<br>#define LD_PLL_MP3_1D   (uint8)(((90.0</em>((LD_PLL_11)+1))&#x2F;(CLK_IN))-1)</p><p>#define LD_PLL_ASR_19 (uint8)(CLK_IN*32.0&#x2F;(LD_PLL_11+1) - 0.51)<br>#define LD_PLL_ASR_1B 0x48<br>#define LD_PLL_ASR_1D 0x1f</p><p>&#x2F;&#x2F;函数声明<br>void LD_Reset();<br>void LD_Init_Common();<br>void LD_Init_ASR();<br>uint8 RunASR(void);<br>void LD_AsrStart();<br>uint8 LD_AsrRun();<br>uint8 LD_AsrAddFixed();<br>uint8 LD_GetResult();</p><p>&#x2F;&#x2F;识别码客户修改处<br>#define CODE_CMD  0x00   &#x2F;&#x2F;该命令码0x00用户不可进行修改。<br>#define CODE_KFBYZ  0x01  &#x2F;&#x2F;开发板验证<br>#defineCODE_DKJDQ   0x02  &#x2F;&#x2F;打开继电器<br>#defineCODE_GBJDQ  0x03  &#x2F;&#x2F;关闭继电器<br>#defineCODE_KD  0x04  &#x2F;&#x2F;开灯<br>#defineCODE_GD  0x05  &#x2F;&#x2F;关灯<br>#define CODE_ZJ  0x09  &#x2F;&#x2F;再见<br>#defineCODE_BFYY  0x06  &#x2F;&#x2F;播放歌曲<br>#define CODE_DKFS  0x07  &#x2F;&#x2F;打开风扇<br>#define CODE_GBFS  0x08  &#x2F;&#x2F;关闭风扇<br>#define CODE_BB  0x09  &#x2F;&#x2F;拜拜<br>#define CODE_XYS  0x10  &#x2F;&#x2F;循环播放01文件夹下的曲目<br>#define CODE_PFZL 0x0a &#x2F;&#x2F;平凡之路<br>#define CODE_SN 0x0b  &#x2F;&#x2F;曲目少年<br>#define CODE_NDDA 0x0c &#x2F;&#x2F;曲目你的答案<br>#define CODE_MZ 0x0e  &#x2F;&#x2F;曲目芒种<br>#define CODE_JL 0x0f &#x2F;&#x2F;曲目惊雷<br>#define CODE_QYS 0x11 &#x2F;&#x2F;曲目七月上</p><p>&#x2F;&#x2F;调节识别距离，数值越大越远，但误识别概率越大<br>#define MIC_VOL 0x42 &#x2F;&#x2F;咪头增益（灵敏度调节）范围：0X00-0X7f 越大越灵敏，<br>#endif</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`#ifndef LD_CHIP_H</span><br><span class="line">#define LD_CHIP_H</span><br><span class="line"></span><br><span class="line">#define uint8 unsigned char</span><br><span class="line">#define uint16 unsigned int</span><br><span class="line">#define uint32 unsigned long</span><br><span class="line"></span><br><span class="line">//以下五个状态定义用来记录程序是在运行ASR识别过程中的哪个状态</span><br><span class="line">#define LD_ASR_NONE0x00 /*表示没有在作ASR识别*/</span><br><span class="line">#define LD_ASR_RUNING0x01/*表示LD3320正在作ASR识别中*/</span><br><span class="line">#define LD_ASR_FOUNDOK0x10/*表示一次识别流程结束后，有一个识别结果*/</span><br><span class="line">#define LD_ASR_FOUNDZERO 0x11/*表示一次识别流程结束后，没有识别结果*/</span><br><span class="line">#define LD_ASR_ERROR 0x31/*表示一次识别流程中LD3320芯片内部出现不正确的状态*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define CLK_IN   22.1184/* 用户注意修改输入的晶振时钟大小 */</span><br><span class="line">#define LD_PLL_11(uint8)((CLK_IN/2.0)-1)</span><br><span class="line">#define LD_PLL_MP3_190x0f</span><br><span class="line">#define LD_PLL_MP3_1B0x18</span><br><span class="line">#define LD_PLL_MP3_1D   (uint8)(((90.0*((LD_PLL_11)+1))/(CLK_IN))-1)</span><br><span class="line"></span><br><span class="line">#define LD_PLL_ASR_19 (uint8)(CLK_IN*32.0/(LD_PLL_11+1) - 0.51)</span><br><span class="line">#define LD_PLL_ASR_1B 0x48</span><br><span class="line">#define LD_PLL_ASR_1D 0x1f</span><br><span class="line"></span><br><span class="line">//函数声明</span><br><span class="line">void LD_Reset();</span><br><span class="line">void LD_Init_Common();</span><br><span class="line">void LD_Init_ASR();</span><br><span class="line">uint8 RunASR(void);</span><br><span class="line">void LD_AsrStart();</span><br><span class="line">uint8 LD_AsrRun();</span><br><span class="line">uint8 LD_AsrAddFixed();</span><br><span class="line">uint8 LD_GetResult();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//识别码客户修改处 </span><br><span class="line">#define CODE_CMD  0x00   //该命令码0x00用户不可进行修改。</span><br><span class="line">#define CODE_KFBYZ  0x01  //开发板验证</span><br><span class="line">#defineCODE_DKJDQ   0x02  //打开继电器</span><br><span class="line">#defineCODE_GBJDQ  0x03  //关闭继电器</span><br><span class="line">#defineCODE_KD  0x04  //开灯</span><br><span class="line">#defineCODE_GD  0x05  //关灯</span><br><span class="line">#define CODE_ZJ  0x09  //再见</span><br><span class="line">#defineCODE_BFYY  0x06  //播放歌曲</span><br><span class="line">#define CODE_DKFS  0x07  //打开风扇</span><br><span class="line">#define CODE_GBFS  0x08  //关闭风扇</span><br><span class="line">#define CODE_BB  0x09  //拜拜</span><br><span class="line">#define CODE_XYS  0x10  //循环播放01文件夹下的曲目</span><br><span class="line">#define CODE_PFZL 0x0a //平凡之路</span><br><span class="line">#define CODE_SN 0x0b  //曲目少年</span><br><span class="line">#define CODE_NDDA 0x0c //曲目你的答案</span><br><span class="line">#define CODE_MZ 0x0e  //曲目芒种</span><br><span class="line">#define CODE_JL 0x0f //曲目惊雷</span><br><span class="line">#define CODE_QYS 0x11 //曲目七月上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//调节识别距离，数值越大越远，但误识别概率越大</span><br><span class="line">#define MIC_VOL 0x42 //咪头增益（灵敏度调节）范围：0X00-0X7f 越大越灵敏，</span><br><span class="line">#endif`</span><br><span class="line"></span><br><span class="line">- 📚百度资源链接：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>链接：<a href="https://pan.baidu.com/s/1NU_R5PitJGwI6C3svPpQwQ">https://pan.baidu.com/s/1NU_R5PitJGwI6C3svPpQwQ</a><br>提取码：kffj</p><pre><code>`链接：https://pan.baidu.com/s/1NU_R5PitJGwI6C3svPpQwQ 提取码：kffj`#### 📝总结##### 当前国内语音识别相关模块飞速发展，国内相关的语音识别模块，在识别率上很高，个人使用感觉，在识别率方面远超此模块，国内的语音模块大多是在抽象层进行进行开发。像机芯智能的语音模块，基于云平台编译。天问语音模块基于搭积木方式。海凌科需要批量才能定制。优劣各有。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>74HC595驱动2位数码管代码实现和注意事项</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-74HC595%E9%A9%B1%E5%8A%A82%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-74HC595%E9%A9%B1%E5%8A%A82%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="74HC595驱动2位数码管代码实现和注意事项"><a href="#74HC595驱动2位数码管代码实现和注意事项" class="headerlink" title="74HC595驱动2位数码管代码实现和注意事项"></a>74HC595驱动2位数码管代码实现和注意事项</h1><h4 id="74HC595驱动2位数码管"><a href="#74HC595驱动2位数码管" class="headerlink" title="74HC595驱动2位数码管"></a>74HC595驱动2位数码管</h4><p><img src="https://img-blog.csdnimg.cn/ecc4b2c0c1244c378c2c5f5f4800c4cf.png#pic_center" alt="在这里插入图片描述"></p><ul><li>📌相关篇《【Proteus仿真】51单片机+74HC595驱动数码管60秒倒计时》</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/130824754">【Proteus仿真】51单片机+74HC595驱动数码管60秒倒计时</a></p><ul><li>驱动芯片：74HC595,74LS595，</li><li>单片机：AT89C52，或者STC89C52都可以</li></ul><p><code>74HC595</code></p><p><code>74LS595</code></p><p><code>STC89C52</code></p><h4 id="📝实例代码"><a href="#📝实例代码" class="headerlink" title="📝实例代码"></a>📝实例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STC89C5xRC.H&gt;</span><br><span class="line">//#include&lt;reg52.h&gt;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line"></span><br><span class="line">sbit ST=P2^0;</span><br><span class="line">sbit SH=P2^2;</span><br><span class="line">sbit DS=P2^1;</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;  //对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">#define duanxuan P0</span><br><span class="line">#define keyboard P1</span><br><span class="line">u8 code smgduan[10]=// &#123;0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90&#125;;//共阳数码管段码</span><br><span class="line">&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;; //共阴数码管段码</span><br><span class="line">u8 duanZhi[]= &#123;0,0&#125;;//数码管显示位数的数值数组</span><br><span class="line">static u8 gewei, shiwei,num;</span><br><span class="line"></span><br><span class="line">void SendTo595(u8 byteData);</span><br><span class="line"></span><br><span class="line">void display();</span><br><span class="line">void delay(int s)</span><br><span class="line">&#123;</span><br><span class="line">    u16 i,j;</span><br><span class="line">    for(i=0; i&lt;s; i++)            //延时函数</span><br><span class="line">        for(j=114; j&gt;0; j--);</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    P2=0xff;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/***********************************************************</span><br><span class="line">*函数名：SendTo595</span><br><span class="line">*功能:串行发送8个比特（一个字节）的数据给595，再并行输出</span><br><span class="line">*参数：byteData</span><br><span class="line">************************************************************/</span><br><span class="line">void SendTo595(u8 byteData)</span><br><span class="line">&#123;</span><br><span class="line">    char i=0;</span><br><span class="line">//    P2=duanMa[n];</span><br><span class="line">    ST = 0;   //ST //先拉低，为后面的上升沿做准备</span><br><span class="line">    for(i; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //  SH = 0;//先拉低，</span><br><span class="line">//        if(byteData&amp;0x80)DS=1;</span><br><span class="line">//        else DS=0;</span><br><span class="line">        DS = (byteData&amp;0x80)?1:0;</span><br><span class="line">        byteData = byteData &lt;&lt;1;//该字节右移一位</span><br><span class="line">        SH = 1;//上升沿，让串行输入时钟变为高电平，并延时2个时钟周期</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SH = 0;        //上升沿，让串行输入时钟变为高电平，并延时2个时钟周期</span><br><span class="line">    &#125;</span><br><span class="line">/*位移寄存器数据准备完毕,转移到存储寄存器*/</span><br><span class="line">    ST =1;//上升沿，让存储寄存器时钟变为高电平，并延时2个时钟周期</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    ST = 0;</span><br><span class="line"></span><br><span class="line">    //    SH = 0; //变为低电平，为下次准备</span><br><span class="line">    //   byteData=byteData &lt;&lt;1;</span><br><span class="line">&#125;</span><br><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">    gewei = 97%10;</span><br><span class="line">    shiwei = 97/10;</span><br><span class="line">    duanZhi[0]=smgduan[shiwei];</span><br><span class="line">    duanZhi[1]=smgduan[gewei];</span><br><span class="line"></span><br><span class="line">    P26=0x01;</span><br><span class="line">    P25=0x00;//先让十位先显示</span><br><span class="line">    SendTo595(duanZhi[0]);//如果采用共阳就取反</span><br><span class="line">    delay(20);//该延时不能少，根据实际显示效果调整，已调好。</span><br><span class="line"></span><br><span class="line">    P25=0x01;</span><br><span class="line">    P26=0x00;//显示个位</span><br><span class="line">    SendTo595(duanZhi[1]); //送段码</span><br><span class="line">    delay(20);</span><br><span class="line">//消隐</span><br><span class="line">    P25=0x01;</span><br><span class="line">    P26=0x01;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;STC89C5xRC.H&gt;<br>&#x2F;&#x2F;#include&lt;reg52.h&gt;<br>#include “intrins.h”</p><p>sbit ST&#x3D;P2^0;<br>sbit SH&#x3D;P2^2;<br>sbit DS&#x3D;P2^1;</p><p>typedef unsigned int u16;  &#x2F;&#x2F;对数据类型进行声明定义<br>typedef unsigned char u8;</p><p>#define duanxuan P0<br>#define keyboard P1<br>u8 code smgduan[10]&#x3D;&#x2F;&#x2F; {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};&#x2F;&#x2F;共阳数码管段码<br>{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f}; &#x2F;&#x2F;共阴数码管段码<br>u8 duanZhi[]&#x3D; {0,0};&#x2F;&#x2F;数码管显示位数的数值数组<br>static u8 gewei, shiwei,num;</p><p>void SendTo595(u8 byteData);</p><p>void display();<br>void delay(int s)<br>{<br>    u16 i,j;<br>    for(i&#x3D;0; i&lt;s; i++)            &#x2F;&#x2F;延时函数<br>        for(j&#x3D;114; j&gt;0; j–);<br>}<br>void main()<br>{<br>    P2&#x3D;0xff;<br>    while(1)<br>    {<br>        display();<br>    }</p><p>}<br>&#x2F;***********************************************************<br>*函数名：SendTo595<br>*功能:串行发送8个比特（一个字节）的数据给595，再并行输出<br>*参数：byteData<br>************************************************************&#x2F;<br>void SendTo595(u8 byteData)<br>{<br>    char i&#x3D;0;<br>&#x2F;&#x2F;    P2&#x3D;duanMa[n];<br>    ST &#x3D; 0;   &#x2F;&#x2F;ST &#x2F;&#x2F;先拉低，为后面的上升沿做准备<br>    for(i; i&lt;8; i++)<br>    {<br>        &#x2F;&#x2F;  SH &#x3D; 0;&#x2F;&#x2F;先拉低，<br>&#x2F;&#x2F;        if(byteData&amp;0x80)DS&#x3D;1;<br>&#x2F;&#x2F;        else DS&#x3D;0;<br>        DS &#x3D; (byteData&amp;0x80)?1:0;<br>        byteData &#x3D; byteData &lt;&lt;1;&#x2F;&#x2F;该字节右移一位<br>        SH &#x3D; 1;&#x2F;&#x2F;上升沿，让串行输入时钟变为高电平，并延时2个时钟周期<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SH &#x3D; 0;        &#x2F;&#x2F;上升沿，让串行输入时钟变为高电平，并延时2个时钟周期<br>    }<br>        &#x2F;<em>位移寄存器数据准备完毕,转移到存储寄存器</em>&#x2F;<br>    ST &#x3D;1;&#x2F;&#x2F;上升沿，让存储寄存器时钟变为高电平，并延时2个时钟周期<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    ST &#x3D; 0;</p><pre><code>//    SH = 0; //变为低电平，为下次准备//   byteData=byteData &lt;&lt;1;</code></pre><p>}<br>void display()<br>{<br>    gewei &#x3D; 97%10;<br>    shiwei &#x3D; 97&#x2F;10;<br>    duanZhi[0]&#x3D;smgduan[shiwei];<br>    duanZhi[1]&#x3D;smgduan[gewei];</p><pre><code>P26=0x01;P25=0x00;//先让十位先显示SendTo595(duanZhi[0]);//如果采用共阳就取反delay(20);//该延时不能少，根据实际显示效果调整，已调好。P25=0x01;P26=0x00;//显示个位SendTo595(duanZhi[1]); //送段码delay(20);</code></pre><p>&#x2F;&#x2F;消隐<br>    P25&#x3D;0x01;<br>    P26&#x3D;0x01;</p><p>}&#96;</p><h4 id="在调试的过程中容易进入了一个误区，数码管闪屏现象，在函数SendTo595-在多位数码管显示的时候，注意调整，位与位切换显示的时间间隔。如果显示不正常，其实是由于间隔时间没有调整好，看到的视觉效果就是字符显示不全，需要在每个位发送完之后，添加一定的延时时间，数码管闪烁的另外一个原因是由于显示的函数放置的位置不合理导致的，应该靠近调用显示的地方，因为程序指令要执行一定的周期。"><a href="#在调试的过程中容易进入了一个误区，数码管闪屏现象，在函数SendTo595-在多位数码管显示的时候，注意调整，位与位切换显示的时间间隔。如果显示不正常，其实是由于间隔时间没有调整好，看到的视觉效果就是字符显示不全，需要在每个位发送完之后，添加一定的延时时间，数码管闪烁的另外一个原因是由于显示的函数放置的位置不合理导致的，应该靠近调用显示的地方，因为程序指令要执行一定的周期。" class="headerlink" title="在调试的过程中容易进入了一个误区，数码管闪屏现象，在函数SendTo595()在多位数码管显示的时候，注意调整，位与位切换显示的时间间隔。如果显示不正常，其实是由于间隔时间没有调整好，看到的视觉效果就是字符显示不全，需要在每个位发送完之后，添加一定的延时时间，数码管闪烁的另外一个原因是由于显示的函数放置的位置不合理导致的，应该靠近调用显示的地方，因为程序指令要执行一定的周期。"></a>在调试的过程中容易进入了一个误区，数码管闪屏现象，在函数SendTo595()在多位数码管显示的时候，注意调整，位与位切换显示的时间间隔。如果显示不正常，其实是由于间隔时间没有调整好，看到的视觉效果就是字符显示不全，需要在每个位发送完之后，添加一定的延时时间，数码管闪烁的另外一个原因是由于显示的函数放置的位置不合理导致的，应该靠近调用显示的地方，因为程序指令要执行一定的周期。</h4><p><code>SendTo595()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SendTo595(duanZhi[1]); //发送段码显示</span><br><span class="line"> delay(20);//对于多位数码管显示，该延时需要自行调整长短。</span><br></pre></td></tr></table></figure><p><code>SendTo595(duanZhi[1]); //发送段码显示  delay(20);//对于多位数码管显示，该延时需要自行调整长短。</code></p><h4 id="📑主要是学习74HC595，8位移位寄存器的原理和代码实现方法。"><a href="#📑主要是学习74HC595，8位移位寄存器的原理和代码实现方法。" class="headerlink" title="📑主要是学习74HC595，8位移位寄存器的原理和代码实现方法。"></a>📑主要是学习74HC595，8位移位寄存器的原理和代码实现方法。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************</span><br><span class="line">*函数名：SendTo595</span><br><span class="line">*功能:串行发送8个比特（一个字节）的数据给595，再并行输出</span><br><span class="line">*参数：byteData</span><br><span class="line">************************************************************/</span><br><span class="line">void SendTo595(u8 byteData)</span><br><span class="line">&#123;</span><br><span class="line">    char i=0;</span><br><span class="line">//    P2=duanMa[n];</span><br><span class="line">    ST = 0;   //ST //先拉低，为后面的上升沿做准备</span><br><span class="line">    for(i; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //  SH = 0;//先拉低，</span><br><span class="line">//        if(byteData&amp;0x80)DS=1;</span><br><span class="line">//        else DS=0;</span><br><span class="line">        DS = (byteData&amp;0x80)?1:0;</span><br><span class="line">        byteData = byteData &lt;&lt;1;//该字节右移一位</span><br><span class="line">        SH = 1;//上升沿，让串行输入时钟变为高电平，并延时2个时钟周期</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SH = 0;        //上升沿，让串行输入时钟变为高电平，并延时2个时钟周期</span><br><span class="line">    &#125;</span><br><span class="line">/*位移寄存器数据准备完毕,转移到存储寄存器*/</span><br><span class="line">    ST =1;//上升沿，让存储寄存器时钟变为高电平，并延时2个时钟周期</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    ST = 0;</span><br><span class="line"></span><br><span class="line">    //    SH = 0; //变为低电平，为下次准备</span><br><span class="line">    //   byteData=byteData &lt;&lt;1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;***********************************************************<br>*函数名：SendTo595<br>*功能:串行发送8个比特（一个字节）的数据给595，再并行输出<br>*参数：byteData<br>************************************************************&#x2F;<br>void SendTo595(u8 byteData)<br>{<br>    char i&#x3D;0;<br>&#x2F;&#x2F;    P2&#x3D;duanMa[n];<br>    ST &#x3D; 0;   &#x2F;&#x2F;ST &#x2F;&#x2F;先拉低，为后面的上升沿做准备<br>    for(i; i&lt;8; i++)<br>    {<br>        &#x2F;&#x2F;  SH &#x3D; 0;&#x2F;&#x2F;先拉低，<br>&#x2F;&#x2F;        if(byteData&amp;0x80)DS&#x3D;1;<br>&#x2F;&#x2F;        else DS&#x3D;0;<br>        DS &#x3D; (byteData&amp;0x80)?1:0;<br>        byteData &#x3D; byteData &lt;&lt;1;&#x2F;&#x2F;该字节右移一位<br>        SH &#x3D; 1;&#x2F;&#x2F;上升沿，让串行输入时钟变为高电平，并延时2个时钟周期<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SH &#x3D; 0;        &#x2F;&#x2F;上升沿，让串行输入时钟变为高电平，并延时2个时钟周期<br>    }<br>        &#x2F;<em>位移寄存器数据准备完毕,转移到存储寄存器</em>&#x2F;<br>    ST &#x3D;1;&#x2F;&#x2F;上升沿，让存储寄存器时钟变为高电平，并延时2个时钟周期<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    ST &#x3D; 0;</p><pre><code>//    SH = 0; //变为低电平，为下次准备//   byteData=byteData &lt;&lt;1;</code></pre><p>}&#96;</p><h4 id="📚仿真资源和程序代码"><a href="#📚仿真资源和程序代码" class="headerlink" title="📚仿真资源和程序代码"></a>📚仿真资源和程序代码</h4><ul><li>🔖99倒计时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1Z6r1Wc4d_TRoOMPcHTDkJg</span><br><span class="line">提取码: wyqg</span><br></pre></td></tr></table></figure><p><code>链接: https://pan.baidu.com/s/1Z6r1Wc4d_TRoOMPcHTDkJg 提取码: wyqg</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8个IO口检测64个按键，按键自锁控制方式</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-8%E4%B8%AAIO%E5%8F%A3%E6%A3%80%E6%B5%8B64%E4%B8%AA%E6%8C%89%E9%94%AE%E6%8C%89%E9%94%AE%E8%87%AA%E9%94%81%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-8%E4%B8%AAIO%E5%8F%A3%E6%A3%80%E6%B5%8B64%E4%B8%AA%E6%8C%89%E9%94%AE%E6%8C%89%E9%94%AE%E8%87%AA%E9%94%81%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="8个IO口检测64个按键，按键自锁控制方式"><a href="#8个IO口检测64个按键，按键自锁控制方式" class="headerlink" title="8个IO口检测64个按键，按键自锁控制方式"></a>8个IO口检测64个按键，按键自锁控制方式</h1><h3 id="8个IO口检测64个按键，按键自锁控制方式-1"><a href="#8个IO口检测64个按键，按键自锁控制方式-1" class="headerlink" title="8个IO口检测64个按键，按键自锁控制方式"></a>8个IO口检测64个按键，按键自锁控制方式</h3><p>相关篇《8个IO口检测64个按键，数码管显示(Proteus仿真)》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120162356">8个IO口检测64个按键，数码管显示(Proteus仿真)</a></p><p>《8个IO口检测64个按键，算法实现和心法要点讲解》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120243836">8个IO口检测64个按键，算法实现和心法要点讲解</a></p><p><img src="https://img-blog.csdnimg.cn/6518f4bfe2f14f2ba68e11f174a48110.gif#pic_center" alt="在这里插入图片描述"></p><p>本篇带来的控制模式与前面不同的是，采用自锁按键来控制显示内容的。</p><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/********************点动自锁版*************/</span><br><span class="line">include &quot;reg51.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">#define u8 unsigned char</span><br><span class="line">sbit P36 = P3 ^ 6;</span><br><span class="line">sbit P37 = P3 ^ 7;</span><br><span class="line">sbit STCP = P3 ^ 0;//定义74HC595移位寄存器</span><br><span class="line">sbit SHCP = P3 ^ 2;</span><br><span class="line">sbit DS = P3 ^ 1;</span><br><span class="line"></span><br><span class="line">u8 code table[16] = &#123;                //共阴数码管段码16进制</span><br><span class="line">    0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void delay() &#123;</span><br><span class="line">    u8 a,b;</span><br><span class="line">    for(b=19; b&gt;0; b--)</span><br><span class="line">        for(a=130; a&gt;0; a--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void txd595(u8 d) &#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        DS = d &amp; 0x80;</span><br><span class="line">        SHCP = 0;</span><br><span class="line">        d &lt;&lt;= 1;</span><br><span class="line">        SHCP = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    STCP=0;</span><br><span class="line">    _nop_();</span><br><span class="line">    STCP=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display(u8 d) &#123;</span><br><span class="line">    P37 = 0;</span><br><span class="line">    txd595(table[d%10]);</span><br><span class="line">    delay();</span><br><span class="line">    P37 = 1;</span><br><span class="line">    _nop_();</span><br><span class="line">    P36 = 0;</span><br><span class="line">    txd595(table[d/10]);</span><br><span class="line">    delay();</span><br><span class="line">    P36 = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 b0(u8 dat) &#123;                //取一个字节中有多少个二进制0 返回0~8</span><br><span class="line">    u8 i, j = 0;</span><br><span class="line">    for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        if (!(dat &amp; (1 &lt;&lt; i))) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 key_scan() &#123;                //无按键返回0 有按键返回1~64 (禁止多个按键同时按下,出错返回99)</span><br><span class="line">    u8 i, j, k, l, m;</span><br><span class="line">    P0 = 0xFF;</span><br><span class="line">    _nop_();</span><br><span class="line">    k = P0;</span><br><span class="line">    if (k != 0xFF) &#123;</span><br><span class="line">        if (b0(k) != 1) return 99;</span><br><span class="line">        for (i = 0; i &lt; 8; i++) &#123;//先扫描判断P0口自身有没有被触发拉低。</span><br><span class="line">            if (!(k &amp; (1 &lt;&lt; i))) &#123;//如果有触发</span><br><span class="line">                return 57 + i;//返回57+i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        j = ~(1 &lt;&lt; i);</span><br><span class="line">        P0 = j;</span><br><span class="line">        _nop_();</span><br><span class="line">        k= P0;</span><br><span class="line">        if (k != j) &#123;</span><br><span class="line">            if (k &amp; ~j || b0(k) != 2) return 99;</span><br><span class="line">            m = 0;</span><br><span class="line">            for (l = 0; l &lt; 8; l++) &#123;</span><br><span class="line">                if (i == l) continue;</span><br><span class="line">                m++;</span><br><span class="line">                if (!(k &amp; (1 &lt;&lt; l))) &#123;</span><br><span class="line">                    return i * 7 + m;//返回扫描行i乘以每行的数量7，m代表是i行的第m个数</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        display(key_scan());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*******<em><strong><strong><strong><strong><strong><strong>点动自锁版</strong></strong></strong></strong></strong></strong></em>&#x2F;<br>include “reg51.h”<br>#include “intrins.h”<br>#define u8 unsigned char<br>sbit P36 &#x3D; P3 ^ 6;<br>sbit P37 &#x3D; P3 ^ 7;<br>sbit STCP &#x3D; P3 ^ 0;&#x2F;&#x2F;定义74HC595移位寄存器<br>sbit SHCP &#x3D; P3 ^ 2;<br>sbit DS &#x3D; P3 ^ 1;</p><p>u8 code table[16] &#x3D; {                &#x2F;&#x2F;共阴数码管段码16进制<br>    0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71<br>};</p><p>void delay() {<br>    u8 a,b;<br>    for(b&#x3D;19; b&gt;0; b–)<br>        for(a&#x3D;130; a&gt;0; a–);<br>}</p><p>void txd595(u8 d) {<br>    u8 i;<br>    for (i &#x3D; 0; i &lt; 8; i++) {<br>        DS &#x3D; d &amp; 0x80;<br>        SHCP &#x3D; 0;<br>        d &lt;&lt;&#x3D; 1;<br>        SHCP &#x3D; 1;<br>    }<br>    STCP&#x3D;0;<br>    <em>nop</em>();<br>    STCP&#x3D;1;<br>}</p><p>void display(u8 d) {<br>    P37 &#x3D; 0;<br>    txd595(table[d%10]);<br>    delay();<br>    P37 &#x3D; 1;<br>    <em>nop</em>();<br>    P36 &#x3D; 0;<br>    txd595(table[d&#x2F;10]);<br>    delay();<br>    P36 &#x3D; 1;<br>}</p><p>u8 b0(u8 dat) {                &#x2F;&#x2F;取一个字节中有多少个二进制0 返回0~8<br>    u8 i, j &#x3D; 0;<br>    for (i &#x3D; 0; i &lt; 8; i++) {<br>        if (!(dat &amp; (1 &lt;&lt; i))) {<br>            j++;<br>        }<br>    }<br>    return j;<br>}</p><p>u8 key_scan() {                &#x2F;&#x2F;无按键返回0 有按键返回1~64 (禁止多个按键同时按下,出错返回99)<br>    u8 i, j, k, l, m;<br>    P0 &#x3D; 0xFF;<br>    <em>nop</em>();<br>    k &#x3D; P0;<br>    if (k !&#x3D; 0xFF) {<br>        if (b0(k) !&#x3D; 1) return 99;<br>        for (i &#x3D; 0; i &lt; 8; i++) {&#x2F;&#x2F;先扫描判断P0口自身有没有被触发拉低。<br>            if (!(k &amp; (1 &lt;&lt; i))) {&#x2F;&#x2F;如果有触发<br>                return 57 + i;&#x2F;&#x2F;返回57+i<br>            }<br>        }<br>    }</p><pre><code>for (i = 0; i &lt; 8; i++) &#123;    j = ~(1 &lt;&lt; i);    P0 = j;    _nop_();    k= P0;    if (k != j) &#123;        if (k &amp; ~j || b0(k) != 2) return 99;        m = 0;        for (l = 0; l &lt; 8; l++) &#123;            if (i == l) continue;            m++;            if (!(k &amp; (1 &lt;&lt; l))) &#123;                return i * 7 + m;//返回扫描行i乘以每行的数量7，m代表是i行的第m个数            &#125;        &#125;    &#125;&#125;return 0;</code></pre><p>}</p><p>void main() {<br>    while (1) {<br>        display(key_scan());<br>    }<br>}&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>uln2003和2803两个有刷直流电机控制方案</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-uln2003%E5%92%8C2803%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%88%B7%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-uln2003%E5%92%8C2803%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%88%B7%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="uln2003和2803两个有刷直流电机控制方案"><a href="#uln2003和2803两个有刷直流电机控制方案" class="headerlink" title="uln2003和2803两个有刷直流电机控制方案"></a>uln2003和2803两个有刷直流电机控制方案</h1><h4 id="uln2003控制两个有刷直流电机转动"><a href="#uln2003控制两个有刷直流电机转动" class="headerlink" title="uln2003控制两个有刷直流电机转动"></a>uln2003控制两个有刷直流电机转动</h4><p>*proteus仿真图</p><p><img src="https://img-blog.csdnimg.cn/20210620143940847.gif#pic_center" alt="在这里插入图片描述"></p><ul><li>仿真文件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1RDDLL5ezn7vzuTkWbxkDeA </span><br><span class="line">提取码：hxiw</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1RDDLL5ezn7vzuTkWbxkDeA  提取码：hxiw</code></p><ul><li>新方案</li></ul><p>2803+L9110</p><p><img src="https://img-blog.csdnimg.cn/2021062116523841.gif#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单粗暴的流水灯仿真和代码</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84%E6%B5%81%E6%B0%B4%E7%81%AF%E4%BB%BF%E7%9C%9F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E7%9A%84%E6%B5%81%E6%B0%B4%E7%81%AF%E4%BB%BF%E7%9C%9F%E5%92%8C%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="简单粗暴的流水灯仿真和代码"><a href="#简单粗暴的流水灯仿真和代码" class="headerlink" title="简单粗暴的流水灯仿真和代码"></a>简单粗暴的流水灯仿真和代码</h1><h5 id="简单粗暴的流水灯仿真和代码-1"><a href="#简单粗暴的流水灯仿真和代码-1" class="headerlink" title="简单粗暴的流水灯仿真和代码"></a>简单粗暴的流水灯仿真和代码</h5><ul><li>仿真演示</li><li>程序代码</li></ul><p>仿真演示</p><p><img src="https://img-blog.csdnimg.cn/20210625093124308.gif#pic_center" alt="在这里插入图片描述"></p><p>程序代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;// //crol和cror函数调用头文件 </span><br><span class="line">typedef unsigned int uint;</span><br><span class="line">typedef unsigned char uchar;</span><br><span class="line">#define led P2</span><br><span class="line">uchar temp;</span><br><span class="line">uchar i;</span><br><span class="line">void delay(uint z)</span><br><span class="line">&#123;</span><br><span class="line">uint x,y;</span><br><span class="line">for(x = z;x&gt;0;x--)</span><br><span class="line">for(y=114;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"> temp = 0x01;</span><br><span class="line">led = temp;</span><br><span class="line"> delay(1000);</span><br><span class="line"></span><br><span class="line">  for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">    //   temp = _crol_(temp,1);        //全亮，逐一灭，亮。</span><br><span class="line"></span><br><span class="line">temp =temp&lt;&lt;1 ;</span><br><span class="line">led = temp;</span><br><span class="line">       delay(1000);</span><br><span class="line">&#125;</span><br><span class="line">temp = 0x80;</span><br><span class="line">  for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">    //   temp = _crol_(temp,1);        //全亮，逐一灭，亮。</span><br><span class="line">temp =temp&gt;&gt;1 ;</span><br><span class="line">led = temp;</span><br><span class="line">       delay(1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;&#x2F;&#x2F; &#x2F;&#x2F;crol和cror函数调用头文件<br>typedef unsigned int uint;<br>typedef unsigned char uchar;<br>#define led P2<br>uchar temp;<br>uchar i;<br>void delay(uint z)<br>{<br>    uint x,y;<br>    for(x &#x3D; z;x&gt;0;x–)<br>        for(y&#x3D;114;y&gt;0;y–);<br>}</p><p>void main(void)<br>{<br>     temp &#x3D; 0x01;<br>    led &#x3D; temp;<br>     delay(1000);</p><p>  for(i&#x3D;0;i&lt;8;i++){<br>    &#x2F;&#x2F;   temp &#x3D; <em>crol</em>(temp,1);        &#x2F;&#x2F;全亮，逐一灭，亮。</p><pre><code>    temp =temp&lt;&lt;1 ;            led = temp;   delay(1000);&#125;temp = 0x80;</code></pre><p>  for(i&#x3D;0;i&lt;8;i++){<br>    &#x2F;&#x2F;   temp &#x3D; _crol_(temp,1);        &#x2F;&#x2F;全亮，逐一灭，亮。<br>        temp &#x3D;temp&gt;&gt;1 ;<br>                led &#x3D; temp;<br>       delay(1000);<br>    }<br>}&#96;</p><ul><li>通过_crol_和_cror_函数左移和右移程序代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;// //crol和cror函数调用头文件 </span><br><span class="line">typedef unsigned int uint;</span><br><span class="line">typedef unsigned char uchar;</span><br><span class="line">#define led P2</span><br><span class="line">uchar temp;</span><br><span class="line">uchar i;</span><br><span class="line">void delay(uint z)</span><br><span class="line">&#123;</span><br><span class="line">uint x,y;</span><br><span class="line">for(x = z;x&gt;0;x--)</span><br><span class="line">for(y=114;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"> temp = 0x01;</span><br><span class="line">led = temp;</span><br><span class="line"> delay(1000);</span><br><span class="line"></span><br><span class="line"> for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">   temp = _crol_(temp,1);        //全亮，逐一灭，亮。</span><br><span class="line"></span><br><span class="line">//temp =temp&lt;&lt;1 ;</span><br><span class="line">led = temp;</span><br><span class="line">       delay(1000);</span><br><span class="line">&#125;</span><br><span class="line">//temp = 0x80;</span><br><span class="line">  for(i=0;i&lt;8;i++)&#123;</span><br><span class="line">       temp = _cror_(temp,1);        //全亮，逐一灭，亮。</span><br><span class="line">//temp =temp&gt;&gt;1 ;</span><br><span class="line">led = temp;</span><br><span class="line">       delay(1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;&#x2F;&#x2F; &#x2F;&#x2F;crol和cror函数调用头文件<br>typedef unsigned int uint;<br>typedef unsigned char uchar;<br>#define led P2<br>uchar temp;<br>uchar i;<br>void delay(uint z)<br>{<br>    uint x,y;<br>    for(x &#x3D; z;x&gt;0;x–)<br>        for(y&#x3D;114;y&gt;0;y–);<br>}</p><p>void main(void)<br>{<br>     temp &#x3D; 0x01;<br>    led &#x3D; temp;<br>     delay(1000);</p><p> for(i&#x3D;0;i&lt;8;i++){<br>   temp &#x3D; <em>crol</em>(temp,1);        &#x2F;&#x2F;全亮，逐一灭，亮。</p><p>&#x2F;&#x2F;temp &#x3D;temp&lt;&lt;1 ;<br>                led &#x3D; temp;<br>       delay(1000);<br>    }<br>    &#x2F;&#x2F;temp &#x3D; 0x80;<br>  for(i&#x3D;0;i&lt;8;i++){<br>       temp &#x3D; _cror_(temp,1);        &#x2F;&#x2F;全亮，逐一灭，亮。<br>&#x2F;&#x2F;temp &#x3D;temp&gt;&gt;1 ;<br>                led &#x3D; temp;<br>       delay(1000);<br>}<br>}&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>经典按键扫描消抖算法实例仿真对比</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E7%BB%8F%E5%85%B8%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E6%B6%88%E6%8A%96%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B%E4%BB%BF%E7%9C%9F%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E7%BB%8F%E5%85%B8%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E6%B6%88%E6%8A%96%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B%E4%BB%BF%E7%9C%9F%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="经典按键扫描消抖算法实例仿真对比"><a href="#经典按键扫描消抖算法实例仿真对比" class="headerlink" title="经典按键扫描消抖算法实例仿真对比"></a>经典按键扫描消抖算法实例仿真对比</h1><h3 id="经典按键扫描消抖算法实例仿真对比-1"><a href="#经典按键扫描消抖算法实例仿真对比-1" class="headerlink" title="经典按键扫描消抖算法实例仿真对比"></a>经典按键扫描消抖算法实例仿真对比</h3><p>《经典按键扫描程序算法实现方式》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/118991832">经典按键扫描程序算法实现方式</a></p><ul><li>Proteus仿真效果对比</li></ul><p>这种算法摒弃了加延时的常规做法，</p><h4 id="算法实现代码"><a href="#算法实现代码" class="headerlink" title="算法实现代码"></a>算法实现代码</h4><p><img src="https://img-blog.csdnimg.cn/8db302959f714e4985bd642b38ffe775.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">sbit KeyValue=P3^7;</span><br><span class="line">unsigned char code segment[]= &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90&#125;;</span><br><span class="line">//定义共阳数码管显示0~9</span><br><span class="line">unsigned char Trg;</span><br><span class="line">unsigned char Cont;</span><br><span class="line">static char count=1;</span><br><span class="line">void KeyRead( void )</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char ReadData = KeyValue^0x01;   // </span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);   // 按键触发为1</span><br><span class="line">    Cont = ReadData;                     // 长按触发为1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">P3=0XFF;</span><br><span class="line">    P0=segment[0]; //开始运行显示0</span><br><span class="line">    while(1) &#123;</span><br><span class="line">KeyRead();</span><br><span class="line">        if(Trg==1) &#123;</span><br><span class="line">            P0=segment[count];</span><br><span class="line">            count++;</span><br><span class="line">            if(count&gt;=10) &#123;  //超过0~9，数码管显示回到0</span><br><span class="line">                count=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;REGX52.H&gt;<br>#include &lt;intrins.h&gt;<br>sbit KeyValue&#x3D;P3^7;<br>unsigned char code segment[]&#x3D; {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};<br>&#x2F;&#x2F;定义共阳数码管显示0~9<br>unsigned char Trg;<br>unsigned char Cont;<br>static char count&#x3D;1;<br>void KeyRead( void )<br>{<br>    unsigned char ReadData &#x3D; KeyValue^0x01;   &#x2F;&#x2F;<br>    Trg &#x3D; ReadData &amp; (ReadData ^ Cont);   &#x2F;&#x2F; 按键触发为1<br>    Cont &#x3D; ReadData;                     &#x2F;&#x2F; 长按触发为1</p><p>}</p><p>void main() {<br>        P3&#x3D;0XFF;<br>    P0&#x3D;segment[0]; &#x2F;&#x2F;开始运行显示0<br>    while(1) {<br>            KeyRead();<br>        if(Trg&#x3D;&#x3D;1) {<br>            P0&#x3D;segment[count];<br>            count++;<br>            if(count&gt;&#x3D;10) {  &#x2F;&#x2F;超过0~9，数码管显示回到0<br>                count&#x3D;0;<br>            }<br>        }<br>    }<br>}&#96;</p><h4 id="没有消抖处理代码"><a href="#没有消抖处理代码" class="headerlink" title="没有消抖处理代码"></a>没有消抖处理代码</h4><p><img src="https://img-blog.csdnimg.cn/d695806b02064360ac5a9b5f4fd12cea.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">sbit KeyValue=P3^7;</span><br><span class="line">unsigned char code segment[]= &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90&#125;;</span><br><span class="line">//定义数码管显示0~9</span><br><span class="line"></span><br><span class="line">unsigned char Trg;</span><br><span class="line">unsigned char Cont;</span><br><span class="line">    static char count=1;</span><br><span class="line">void main() &#123;</span><br><span class="line">P3=0XFF;</span><br><span class="line">    P0=segment[0]; //开始运行显示0</span><br><span class="line">    while(1) &#123;</span><br><span class="line"></span><br><span class="line">        if(KeyValue==0) &#123;</span><br><span class="line">            P0=segment[count];</span><br><span class="line">            count++;</span><br><span class="line">            if(count&gt;=10) &#123;  //超过0~9，数码管显示回到0</span><br><span class="line">                count=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;REGX52.H&gt;<br>#include &lt;intrins.h&gt;<br>sbit KeyValue&#x3D;P3^7;<br>unsigned char code segment[]&#x3D; {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};<br>&#x2F;&#x2F;定义数码管显示0~9</p><p>unsigned char Trg;<br>unsigned char Cont;<br>    static char count&#x3D;1;<br>void main() {<br>        P3&#x3D;0XFF;<br>    P0&#x3D;segment[0]; &#x2F;&#x2F;开始运行显示0<br>    while(1) {</p><pre><code>    if(KeyValue==0) &#123;        P0=segment[count];        count++;        if(count&gt;=10) &#123;  //超过0~9，数码管显示回到0            count=0;        &#125;    &#125;&#125;</code></pre><p>}&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>经典按键扫描程序算法实现方式</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E7%BB%8F%E5%85%B8%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E7%BB%8F%E5%85%B8%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="经典按键扫描程序算法实现方式"><a href="#经典按键扫描程序算法实现方式" class="headerlink" title="经典按键扫描程序算法实现方式"></a>经典按键扫描程序算法实现方式</h1><h3 id="经典按键扫描程序算法实现方式-1"><a href="#经典按键扫描程序算法实现方式-1" class="headerlink" title="经典按键扫描程序算法实现方式"></a>经典按键扫描程序算法实现方式</h3><ul><li>算法实现函数（来源于网络）</li></ul><p>相关篇目《经典按键扫描消抖算法实例仿真对比》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120219798">经典按键扫描消抖算法实例仿真对比</a></p><h4 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Trg;</span><br><span class="line">unsigned char Cont;</span><br><span class="line"></span><br><span class="line">void KeyRead( void )</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char ReadData = P1^0xff;   // 注解1</span><br><span class="line"></span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);   // 注解2</span><br><span class="line"></span><br><span class="line">    Cont = ReadData;                      // 注解3</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;unsigned char Trg;<br>unsigned char Cont;</p><p>void KeyRead( void )<br>{<br>    unsigned char ReadData &#x3D; P1^0xff;   &#x2F;&#x2F; 注解1</p><pre><code>Trg = ReadData &amp; (ReadData ^ Cont);   // 注解2Cont = ReadData;                      // 注解3</code></pre><p>}&#96;</p><p>Trg（triger） 代表的是触发，Cont（continue）代表的是连续按下。</p><p>注解1：读P1的端口数据，取反，然后送到ReadData 临时变量里面保存起来。</p><p>注解2：用来计算触发变量的。一个位与操作，一个异或操作，我想学过C语言都应该懂吧？Trg为全局变量，其它程序可以直接引用。</p><p>注解3：用来计算连续变量。</p><ul><li>上述实现算法不仅适用于端口以总线方式来读取判断，也同样适用于独立IO口信号的判断和处理，具体实现函数如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Trg;</span><br><span class="line">unsigned char Cont;</span><br><span class="line"></span><br><span class="line">void KeyRead( void )</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char ReadData = P10^0x01;   // 注解1</span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);   // 注解2</span><br><span class="line">    Cont = ReadData;                     // 注解3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&#96;unsigned char Trg;<br>unsigned char Cont;</p><p>void KeyRead( void )<br>{<br>    unsigned char ReadData &#x3D; P10^0x01;   &#x2F;&#x2F; 注解1<br>    Trg &#x3D; ReadData &amp; (ReadData ^ Cont);   &#x2F;&#x2F; 注解2<br>    Cont &#x3D; ReadData;                     &#x2F;&#x2F; 注解3<br>    }&#96;</p><h6 id="1-没有按键的时候"><a href="#1-没有按键的时候" class="headerlink" title="1. 没有按键的时候"></a>1. 没有按键的时候</h6><ul><li>没有按下时，IO口为高电平，就是P10为0x01，ReadData读端口并且和0x01进行取反，很显然，P10^0x01的值就是 0x00</li><li>Trg &#x3D; ReadData &amp; (ReadData ^ Cont); （初始状态下，Cont也是为0的）很简单的数学计算，因为ReadData为0，则它和任何数“相与”，结果也是为0</li><li>Cont &#x3D; ReadData; 保存Cont 其实就是等于ReadData为0；</li></ul><p>没有按下时，IO口为高电平，就是P10为0x01，ReadData读端口并且和0x01进行取反，很显然，P10^0x01的值就是 0x00</p><p><code>IO</code></p><p><code>0x01</code></p><p><code>P10^0x01</code></p><p><code>0x00</code></p><p>Trg &#x3D; ReadData &amp; (ReadData ^ Cont); （初始状态下，Cont也是为0的）很简单的数学计算，因为ReadData为0，则它和任何数“相与”，结果也是为0</p><p>Cont &#x3D; ReadData; 保存Cont 其实就是等于ReadData为0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadData ＝ 0;</span><br><span class="line">Trg ＝ 0;</span><br><span class="line">Cont ＝ 0;</span><br></pre></td></tr></table></figure><p><code>ReadData ＝ 0;     Trg ＝ 0;     Cont ＝ 0;</code></p><h6 id="2-第一次IO口按键按下的情况"><a href="#2-第一次IO口按键按下的情况" class="headerlink" title="2. 第一次IO口按键按下的情况"></a>2. 第一次IO口按键按下的情况</h6><p>端口数据为0xfe，ReadData读端口并且取反，很显然，就是 0x01 。</p><ul><li>Trg &#x3D; ReadData &amp; (ReadData ^ Cont); 因为这是第一次按下，所以Cont是上次的值，所以为0。那么这个式子的值也不难算，也就是 Trg &#x3D; 0x01 &amp; (0x01^0x00) &#x3D; 0x01</li><li>Cont &#x3D; ReadData &#x3D; 0x01；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadData ＝ 0x01;</span><br><span class="line">Trg ＝ 0x01;//Trg只会在这个时候对应位的值为1，其它时候都为0</span><br><span class="line">Cont ＝ 0x01;</span><br></pre></td></tr></table></figure><p><code>ReadData ＝ 0x01; Trg ＝ 0x01;//Trg只会在这个时候对应位的值为1，其它时候都为0 Cont ＝ 0x01;</code></p><h6 id="3-IO口按键按着不松（长按键）的情况"><a href="#3-IO口按键按着不松（长按键）的情况" class="headerlink" title="3. IO口按键按着不松（长按键）的情况"></a>3. IO口按键按着不松（长按键）的情况</h6><p>端口数据为0xfe，ReadData读端口并且取反是 0x01 。</p><ul><li>Trg &#x3D; ReadData &amp; (ReadData ^ Cont); 因为这是连续按下，所以Cont是上次的值，所以为0x01。那么这个式子就变成了 Trg &#x3D; 0x01 &amp; (0x01^0x01) &#x3D; 0x00</li><li>Cont &#x3D; ReadData &#x3D; 0x01；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadData ＝ 0x01;</span><br><span class="line">Trg ＝ 0x00;</span><br><span class="line">Cont ＝ 0x01;</span><br></pre></td></tr></table></figure><p><code>ReadData ＝ 0x01;     Trg ＝ 0x00;     Cont ＝ 0x01;</code></p><p>因为现在按键是长按着，所以MCU会每个一定时间（20ms左右）不断的执行这个函数，那么下次执行的时候情况会是怎么样的呢？</p><ul><li>ReadData ＝ 0x01；这个不会变，因为按键没有松开</li><li>Trg ＝ ReadData &amp; (ReadData ^ Cont) ＝ 0x01 &amp; (0x01 ^ 0x01) &#x3D; 0 ，只要按键没有松开，这个Trg值永远为 0</li><li>Cont ＝ 0x01；只要按键没有松开，这个值永远是0x01</li></ul><h6 id="4-按键松开的情况"><a href="#4-按键松开的情况" class="headerlink" title="4. 按键松开的情况"></a>4. 按键松开的情况</h6><p>端口数据为0xff，ReadData读端口并且取反是 0x00 。</p><ul><li>Trg &#x3D; ReadData &amp; (ReadData ^ Cont) &#x3D; 0x00 &amp; (0x00^0x01) &#x3D; 0x00;</li><li>Cont &#x3D; ReadData &#x3D; 0x00；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReadData ＝ 0x00;</span><br><span class="line">Trg ＝ 0x00;</span><br><span class="line">Cont ＝ 0x00;</span><br></pre></td></tr></table></figure><p><code>ReadData ＝ 0x00;     Trg ＝ 0x00;     Cont ＝ 0x00;</code></p><p>.&gt; 回到了初始状态，也就是没有按键按下的状态</p><h6 id="应用一：一次触发的按键处理"><a href="#应用一：一次触发的按键处理" class="headerlink" title="应用一：一次触发的按键处理"></a>应用一：一次触发的按键处理</h6><ul><li>假设PB0为蜂鸣器按键，按一下，蜂鸣器beep的响一声。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define KEY_BEEP 0x01</span><br><span class="line">void KeyProc(void)</span><br><span class="line">&#123;</span><br><span class="line">       if (Trg &amp; KEY_BEEP) // 如果按下的是KEY_BEEP</span><br><span class="line">    &#123;</span><br><span class="line">         Beep();            // 执行蜂鸣器处理函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define KEY_BEEP 0x01 void KeyProc(void) &#123;        if (Trg &amp; KEY_BEEP) // 如果按下的是KEY_BEEP     &#123;          Beep();            // 执行蜂鸣器处理函数     &#125; &#125;</code></p><h6 id="应用2：长按键的处理"><a href="#应用2：长按键的处理" class="headerlink" title="应用2：长按键的处理"></a>应用2：长按键的处理</h6><ul><li>项目中经常会遇到一些要求，例如：一个按键如果短按一下执行功能A，如果长按2秒不放的话会执行功能B，又或者是要求3秒按着不放，计数连加什么什么的功能.</li></ul><p>为了只是说明原理，PB1是模式按键，短按则切换模式，PB1就是加，如果长按的话则连加.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define KEY_MODE 0x01    // 模式按键</span><br><span class="line">#define KEY_PLUS 0x02     // 加</span><br><span class="line">void KeyProc(void)</span><br><span class="line">&#123;</span><br><span class="line">       if (Trg &amp; KEY_MODE) // 如果按下的是KEY_MODE，而且你常按这按键也没有用，</span><br><span class="line">    &#123;                    //它是不会执行第二次的哦 ， 必须先松开再按下</span><br><span class="line">         Mode++;         // 执行+1</span><br><span class="line">                         // (执行的其他代码)</span><br><span class="line">    &#125;</span><br><span class="line">    if (Cont ^ KEY_PLUS) // 如果按键保持被按着不放</span><br><span class="line">    &#123;</span><br><span class="line">         cnt_plus++;       // 计时，这里最好放置定时器，启动，开始计数</span><br><span class="line">         if (cnt_plus &gt; 100) // 20ms*100 = 2S 如果时间到</span><br><span class="line">         &#123;</span><br><span class="line">              Func();      // 你需要的执行的程序</span><br><span class="line">         &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define KEY_MODE 0x01    // 模式按键 #define KEY_PLUS 0x02     // 加 void KeyProc(void) &#123;        if (Trg &amp; KEY_MODE) // 如果按下的是KEY_MODE，而且你常按这按键也没有用，     &#123;                    //它是不会执行第二次的哦 ， 必须先松开再按下          Mode++;         // 执行+1                          // (执行的其他代码)     &#125;     if (Cont ^ KEY_PLUS) // 如果按键保持被按着不放     &#123;          cnt_plus++;       // 计时，这里最好放置定时器，启动，开始计数          if (cnt_plus &gt; 100) // 20ms*100 = 2S 如果时间到          &#123;               Func();      // 你需要的执行的程序          &#125;               &#125; &#125;</code></p><h6 id="Trg-表示的就是触发的意思，也就是跳变，只要有按键按下（电平从1到0的跳变），那么Trg在对应按键的位上面会置1，我们用了按键Trg的值为0x01，类似，如果我们按键按下的话，Trg-的值就应该为-0x01-，最关键的地方，Trg-的值每次按下只会出现一次，然后立刻被清除，完全不需要人工去干预。所以按键功能处理程序不会重复执行，省下了一大堆的条件判断，Cont代表的是长按键，如果按键按着不放，那么Cont的值就为-0x01，相对应，按键长按不放，那么Cont的值为0x01，同样很好理解。"><a href="#Trg-表示的就是触发的意思，也就是跳变，只要有按键按下（电平从1到0的跳变），那么Trg在对应按键的位上面会置1，我们用了按键Trg的值为0x01，类似，如果我们按键按下的话，Trg-的值就应该为-0x01-，最关键的地方，Trg-的值每次按下只会出现一次，然后立刻被清除，完全不需要人工去干预。所以按键功能处理程序不会重复执行，省下了一大堆的条件判断，Cont代表的是长按键，如果按键按着不放，那么Cont的值就为-0x01，相对应，按键长按不放，那么Cont的值为0x01，同样很好理解。" class="headerlink" title="Trg 表示的就是触发的意思，也就是跳变，只要有按键按下（电平从1到0的跳变），那么Trg在对应按键的位上面会置1，我们用了按键Trg的值为0x01，类似，如果我们按键按下的话，Trg 的值就应该为 0x01 ，最关键的地方，Trg 的值每次按下只会出现一次，然后立刻被清除，完全不需要人工去干预。所以按键功能处理程序不会重复执行，省下了一大堆的条件判断，Cont代表的是长按键，如果按键按着不放，那么Cont的值就为 0x01，相对应，按键长按不放，那么Cont的值为0x01，同样很好理解。"></a>Trg 表示的就是触发的意思，也就是跳变，只要有按键按下（电平从1到0的跳变），那么Trg在对应按键的位上面会置1，我们用了按键Trg的值为0x01，类似，如果我们按键按下的话，Trg 的值就应该为 0x01 ，最关键的地方，Trg 的值每次按下只会出现一次，然后立刻被清除，完全不需要人工去干预。所以按键功能处理程序不会重复执行，省下了一大堆的条件判断，Cont代表的是长按键，如果按键按着不放，那么Cont的值就为 0x01，相对应，按键长按不放，那么Cont的值为0x01，同样很好理解。</h6><p><code>Trg</code></p><p><code>1</code></p><p><code>Trg</code></p><p><code>0x01</code></p><p><code>Trg</code></p><p><code>0x01</code></p><p><code>Trg</code></p><p><code>Cont</code></p><p><code>Cont</code></p><p><code>0x01</code></p><p><code>Cont</code></p><p><code>0x01</code></p><ul><li>原文：<a href="https://link.csdn.net/?target=http://blog.ednchina.com/zp2009/983530/message.aspx">https://link.csdn.net/?target=http%3A%2F%2Fblog.ednchina.com%2Fzp2009%2F983530%2Fmessage.aspx</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过CD4019设计的电子时钟</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E9%80%9A%E8%BF%87CD4019%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%94%B5%E5%AD%90%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-%E9%80%9A%E8%BF%87CD4019%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%94%B5%E5%AD%90%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="通过CD4019设计的电子时钟"><a href="#通过CD4019设计的电子时钟" class="headerlink" title="通过CD4019设计的电子时钟"></a>通过CD4019设计的电子时钟</h1><h3 id="通过CD4019设计的电子时钟-1"><a href="#通过CD4019设计的电子时钟-1" class="headerlink" title="通过CD4019设计的电子时钟"></a>通过CD4019设计的电子时钟</h3><ul><li>proteus仿真演示</li><li>仿真资料</li></ul><p><img src="https://img-blog.csdnimg.cn/20210628110408665.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1KeIPO_5zGpbFW10cA5jGCw </span><br><span class="line">提取码：t151</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1KeIPO_5zGpbFW10cA5jGCw  提取码：t151</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8个IO口检测64个按键，算法实现和心法要点讲解</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-8%E4%B8%AAIO%E5%8F%A3%E6%A3%80%E6%B5%8B64%E4%B8%AA%E6%8C%89%E9%94%AE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BF%83%E6%B3%95%E8%A6%81%E7%82%B9%E8%AE%B2%E8%A7%A3/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-8%E4%B8%AAIO%E5%8F%A3%E6%A3%80%E6%B5%8B64%E4%B8%AA%E6%8C%89%E9%94%AE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BF%83%E6%B3%95%E8%A6%81%E7%82%B9%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="8个IO口检测64个按键，算法实现和心法要点讲解"><a href="#8个IO口检测64个按键，算法实现和心法要点讲解" class="headerlink" title="8个IO口检测64个按键，算法实现和心法要点讲解"></a>8个IO口检测64个按键，算法实现和心法要点讲解</h1><h3 id="8个IO口检测64个按键，算法实现和心法要点讲解-1"><a href="#8个IO口检测64个按键，算法实现和心法要点讲解-1" class="headerlink" title="8个IO口检测64个按键，算法实现和心法要点讲解"></a>8个IO口检测64个按键，算法实现和心法要点讲解</h3><p><img src="https://img-blog.csdnimg.cn/b06936679fd94a8198ae7fd9722cbde1.gif#pic_center" alt="在这里插入图片描述"></p><p>在此篇基础上《8个IO口检测64个按键，数码管显示(Proteus仿真)》进行了算法实现原理讲解和注意要领。</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120162356">8个IO口检测64个按键，数码管显示(Proteus仿真)</a></p><p>番外篇《8个IO口检测64个按键，按键自锁控制方式》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120337930">8个IO口检测64个按键，按键自锁控制方式</a></p><p><img src="https://img-blog.csdnimg.cn/f8623c241ce94d13b34b61cbb78d87d2.png" alt="在这里插入图片描述"></p><p>扫描原理想通了很简单，就是通过一个IO拉低，其检测这一组其他7个IO口状态，如果检测到有被拉低了，说明就有按键按下了，因为检测到拉低的IO口，是被被用来检测的IO口拉低的。相当于我用一个接GND的探针去碰一个高电平的IO口，肯定是会拉低的。电路原理的话，利用二极管单向导通特性，在检查过程中，如果IO口被拉低，只能构成一个回路。</p><ul><li>知道了按键扫描原理然后去实现的过程并不是很艰难，我觉得最困难的是调试过程遇到的各种问题。掌握其原理并不那么复杂，在写完之后，代码并不是很顺利按照自己的思路去运行的，也许就是一个项目的学习过程。一个DIY创意可能很简单，真正让其按照自己的想法运行还是有很多细节点要打通的。</li><li>小bug折腾的时间比整个写代码的花费的经历和时间多得多，想想一个稳定好用的产品都需要几个版本的迭代。</li></ul><h4 id="总结要领"><a href="#总结要领" class="headerlink" title="总结要领"></a>总结要领</h4><ul><li>最难的地方是，控制56-64最后一排的数码管显示，因为，这个你是对P0总线端口自身的扫描，最容易出问题的地方，也是卡在这个地方最长时间。一定要了解其单片机运行和按键扫描原理。在没有延时或打断的情况下，按键动作的时间一定是快不过单片机运行的速度。所以在处理最后一排按键时，需要特别注意，显示时要比其他行扫描处理的时间留长一点，不然就很容易跳数，按下的按键，和显示的数值不是你想要的结果，下面我会将经验一一写下来。</li></ul><h5 id="在处理最后一排按键，我有想过两个办法来处理逻辑判断问题："><a href="#在处理最后一排按键，我有想过两个办法来处理逻辑判断问题：" class="headerlink" title="在处理最后一排按键，我有想过两个办法来处理逻辑判断问题："></a>在处理最后一排按键，我有想过两个办法来处理逻辑判断问题：</h5><ul><li>利用复合逻辑来写，很直观，但是代码阅读和可执行性看起来相对很臃肿一样，写的时候很爽，单片机处理逻辑，运行的时间会多一些。</li></ul><p>最先想到的第一种办法，写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(P0==0x7f||P0==0xbf||P0==0xdf||P0==0xef||P0==0xf7||P0==0xfb||P0==0xfd||P0==0xfe)</span><br></pre></td></tr></table></figure><p><code>if(P0==0x7f||P0==0xbf||P0==0xdf||P0==0xef||P0==0xf7||P0==0xfb||P0==0xfd||P0==0xfe)</code></p><p>第二种办法，通过二分查找的方式：（为什么可以采用二分查找算法来快速筛查对象，是有讲究的）：二分查找的条件就是注意事项，定义的数组必须是有序序列才行。最优方法看不懂不要紧，直接搜算法拿来用就行！写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int Search(uchar arr[], int len, int flag)</span><br><span class="line">&#123;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    while (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if (arr[mid] &gt; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (arr[mid] &lt; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return arr[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int Search(uchar arr[], int len, int flag) &#123;     int right = len - 1;     int left = 0;     while (left &lt;= right)     &#123;         int mid = (right + left) / 2;         if (arr[mid] &gt; flag)         &#123;             right = mid - 1;         &#125;         else if (arr[mid] &lt; flag)         &#123;             left = mid + 1;         &#125;         else         &#123;             return arr[mid];         &#125;     &#125;     return 0; &#125;</code></p><p>第三种遍历方法，就不需要参照二分查找算法那样考虑什么注意事项了，随便写一个简单的遍历程序即可，执行效率虽然慢一点，起码实现起来简单，代码可敲性强，比起二分查找算法写起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uchar libian(uchar a[], int value, int n)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">  for (i = 0; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if (value == a[i])</span><br><span class="line">    &#123;</span><br><span class="line">      return a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uchar libian(uchar a[], int value, int n) &#123;     int i;   for (i = 0; i &lt; n; i++)   &#123;     if (value == a[i])     &#123;       return a[i];     &#125;   &#125;   return 0; &#125;</code></p><ul><li>0-64个按键，需要考虑消抖的只有最后一排56-64的8个按键的响应。为什么这么说呢?这是因为按键从设计原理和实现来看的。0-56的按键不管你怎么长按还是短按，单片机给你的响应数值都是一样的不会变，但是在处理56-64这8个按键时，是做了特殊处理，连接的是GND，如果敲代码没注意的话，就很容易造成跳数字，单片机扫描是通过按照规定先给指定的IO口拉点，再去检测其他7个IO的电平状态，所以在处理第56-64按键时，如果你操作的按键按下时，单片机扫描按键的速度已经从你按下那一到弹起前已经超过了你的速度，那么会造成，单片机读取到错误的响应数据，处理方式如下：</li></ul><p><code>0-64</code></p><p><code>56-64</code></p><p><code>0-56</code></p><p><code>56-64</code></p><p><code>GND</code></p><p><code>IO</code></p><p><code>IO</code></p><p><code>56-64</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/****************自身端口读取*********************/</span><br><span class="line">P0=0xff;//扫描第8行</span><br><span class="line">//    delay(5);</span><br><span class="line">tmp=P0;</span><br><span class="line">    if (Search(arr, 8, tmp))</span><br><span class="line">    &#123;</span><br><span class="line">        //将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(Search(arr, 8, tmp))</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xfe:</span><br><span class="line">            keynum=57;</span><br><span class="line">            break;//第1行第1个按键按下</span><br><span class="line">        case 0xfd:</span><br><span class="line">            keynum=58;</span><br><span class="line">            break;//第1行第2个按键按下</span><br><span class="line">        case 0xfb:</span><br><span class="line">            keynum=59;</span><br><span class="line">            break;//第1行第3个按键按下</span><br><span class="line">        case 0xf7:</span><br><span class="line">            keynum=60;</span><br><span class="line">            break;//第1行第4个按键按下</span><br><span class="line">        case 0xef:</span><br><span class="line">            keynum=61;</span><br><span class="line">            break;//第1行第5个按键按下</span><br><span class="line">        case 0xdf:</span><br><span class="line">            keynum=62;</span><br><span class="line">            break;//第1行第6个按键按下</span><br><span class="line">        case 0xbf:</span><br><span class="line">            keynum=63;</span><br><span class="line">            break;//第1行第7个按键按下</span><br><span class="line">        case 0x7f:</span><br><span class="line">            keynum=64;</span><br><span class="line">            break;//第1行第8个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">display();//这里必须单独处理P0的IO检测和显示，否则容易跳数</span><br><span class="line">delay(80);//阻塞按键扫描，防止数码管跳变，其他行扫描不需要此处的延时。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>/****************自身端口读取*********************/         P0=0xff;//扫描第8行 //    delay(5);         tmp=P0;     if (Search(arr, 8, tmp))     &#123;         //将检测到的P0状态值赋值给临时变量         switch(Search(arr, 8, tmp))         &#123;   //临时变量对逐个IO口进行查询         case 0xfe:             keynum=57;             break;//第1行第1个按键按下         case 0xfd:             keynum=58;             break;//第1行第2个按键按下         case 0xfb:             keynum=59;             break;//第1行第3个按键按下         case 0xf7:             keynum=60;             break;//第1行第4个按键按下         case 0xef:             keynum=61;             break;//第1行第5个按键按下         case 0xdf:             keynum=62;             break;//第1行第6个按键按下         case 0xbf:             keynum=63;             break;//第1行第7个按键按下         case 0x7f:             keynum=64;             break;//第1行第8个按键按下         &#125;             display();//这里必须单独处理P0的IO检测和显示，否则容易跳数             delay(80);//阻塞按键扫描，防止数码管跳变，其他行扫描不需要此处的延时。     &#125;</code></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">//共阴极数码管0~9</span><br><span class="line">uchar code table[]= &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;//0-9共阴数码管</span><br><span class="line">uchar code arr[] = &#123;0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe&#125;;</span><br><span class="line"></span><br><span class="line">uchar duanZhi[]= &#123;0,0&#125;;//保存每段数码管显示位数的数值</span><br><span class="line">sbit P36=P3^6;//数码管时能端</span><br><span class="line">sbit P37=P3^7;</span><br><span class="line">sbit ST=P3^0;//定义74HC595移位寄存器</span><br><span class="line">sbit SH=P3^2;</span><br><span class="line">sbit DS=P3^1;</span><br><span class="line">sbit P33=P3^3;</span><br><span class="line">sbit P34=P3^4;</span><br><span class="line">sbit P35=P3^5;</span><br><span class="line"></span><br><span class="line">uchar shi,ge;//数码管个位和十位显示</span><br><span class="line">uchar tmp;//暂存P0的值</span><br><span class="line">static uchar keynum=0;//按键值</span><br><span class="line">unsigned char Trg;</span><br><span class="line">unsigned char Cont;</span><br><span class="line">static char count=1;</span><br><span class="line">//毫秒级延时</span><br><span class="line">void delay(uint z)</span><br><span class="line">&#123;</span><br><span class="line">    uint x,y;</span><br><span class="line">    for(x=z; x&gt;&gt;0; x--)</span><br><span class="line">        for(y=110; y&gt;&gt;0; y--);</span><br><span class="line">&#125;</span><br><span class="line">void SendTo595(uchar byteData);</span><br><span class="line">int Search(uchar arr[], int len, int flag)</span><br><span class="line">&#123;</span><br><span class="line">    int right = len - 1;</span><br><span class="line">    int left = 0;</span><br><span class="line">    while (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if (arr[mid] &gt; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (arr[mid] &lt; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return arr[mid];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*----------------------------------------------------------------------------------</span><br><span class="line">                                显示</span><br><span class="line"></span><br><span class="line">void display2()</span><br><span class="line">&#123;</span><br><span class="line">    ge = keynum%10;</span><br><span class="line">    shi = keynum/10;</span><br><span class="line">    duanZhi[0]=table[ge];</span><br><span class="line">    duanZhi[1]=table[shi];</span><br><span class="line">    P34=0x00;</span><br><span class="line">    SendTo595(duanZhi[0]); //</span><br><span class="line">    delay(5);</span><br><span class="line">    P34=0x01;//消隐</span><br><span class="line"></span><br><span class="line">    P33=0x00;</span><br><span class="line">    SendTo595(duanZhi[1]);//</span><br><span class="line">    delay(5);</span><br><span class="line">    P33=0x01;//消隐</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------*/</span><br><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">    ge = keynum%10;</span><br><span class="line">    shi = keynum/10;</span><br><span class="line">    duanZhi[0]=table[ge];</span><br><span class="line">    duanZhi[1]=table[shi];</span><br><span class="line">    //显示个位</span><br><span class="line">    P37=0;</span><br><span class="line">    SendTo595(duanZhi[0]); //</span><br><span class="line">    delay(2);</span><br><span class="line">    P37=1;//消隐</span><br><span class="line">    //显示十位</span><br><span class="line">    P36=0;</span><br><span class="line">    SendTo595(duanZhi[1]);//</span><br><span class="line">    delay(2);</span><br><span class="line">    P36=1;//消隐</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/***********************************************************</span><br><span class="line">*函数名：SendTo595</span><br><span class="line">*功能:串行发送8个比特（一个字节）的数据给595，再并行输出</span><br><span class="line">*参数：byteData</span><br><span class="line">************************************************************/</span><br><span class="line">void SendTo595(uchar byteData)</span><br><span class="line">&#123;</span><br><span class="line">    uchar i=0;</span><br><span class="line">    ST = 0;   //ST //先拉低，为后面的上升沿做准备</span><br><span class="line">    for(i; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SH = 0;//先拉低，</span><br><span class="line">        if(byteData&amp;0x80)DS=1;</span><br><span class="line">        else DS=0;</span><br><span class="line">//        DS = (byteData&amp;0x80)?1:0;</span><br><span class="line">        byteData = byteData &lt;&lt;1;//该字节右移一位</span><br><span class="line"></span><br><span class="line">        SH = 1;//上升沿，让串行输入时钟变为高电平，并延时2个时钟周期</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SH = 0;        //上升沿，让串行输入时钟变为高电平，并延时2个时钟周期</span><br><span class="line">    &#125;</span><br><span class="line">    /*位移寄存器数据准备完毕,转移到存储寄存器*/</span><br><span class="line">    ST =1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    ST = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void key_scan()</span><br><span class="line">&#123;</span><br><span class="line">//    P0=0xff;</span><br><span class="line">//    delay(6);</span><br><span class="line">    </span><br><span class="line">    /********************第1行扫描**************************/</span><br><span class="line"></span><br><span class="line">    P0=0x7F;//扫描第1行0111 1111</span><br><span class="line">    delay(5);</span><br><span class="line">    if (!Search(arr, 8, tmp))//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0x7e:</span><br><span class="line">            keynum=50;</span><br><span class="line">            break;//第1行第1个按键按下</span><br><span class="line">        case 0x7d:</span><br><span class="line">            keynum=51;</span><br><span class="line">            break;//第1行第2个按键按下</span><br><span class="line">        case 0x7b:</span><br><span class="line">            keynum=52;</span><br><span class="line">            break;//第1行第3个按键按下</span><br><span class="line">        case 0x77:</span><br><span class="line">            keynum=53;</span><br><span class="line">            break;//第1行第4个按键按下</span><br><span class="line">        case 0x6f:</span><br><span class="line">            keynum=54;</span><br><span class="line">            break;//第1行第5个按键按下</span><br><span class="line">        case 0x5f:</span><br><span class="line">            keynum=55;</span><br><span class="line">            break;//第1行第6个按键按下</span><br><span class="line">        case 0x3f:</span><br><span class="line">            keynum=56;</span><br><span class="line">            break;//第1行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /********************第2行扫描**************************/</span><br><span class="line">    P0=0xbf;//扫描第2行</span><br><span class="line">    delay(5);</span><br><span class="line">    if(P0!=0xbf)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xbe:</span><br><span class="line">            keynum=43;</span><br><span class="line">            break;//第2行第1个按键按下</span><br><span class="line">        case 0xbd:</span><br><span class="line">            keynum=44;</span><br><span class="line">            break;//第2行第2个按键按下</span><br><span class="line">        case 0xbb:</span><br><span class="line">            keynum=45;</span><br><span class="line">            break;//第2行第3个按键按下</span><br><span class="line">        case 0xb7:</span><br><span class="line">            keynum=46;</span><br><span class="line">            break;//第2行第4个按键按下</span><br><span class="line">        case 0xaf:</span><br><span class="line">            keynum=47;</span><br><span class="line">            break;//第2行第5个按键按下</span><br><span class="line">        case 0x9f:</span><br><span class="line">            keynum=48;</span><br><span class="line">            break;//第2行第6个按键按下</span><br><span class="line">        case 0x3f:</span><br><span class="line">            keynum=49;</span><br><span class="line">            break;//第2行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /********************第3行扫描**************************/</span><br><span class="line"></span><br><span class="line">    P0=0xdf;//扫描第3行</span><br><span class="line">    delay(5);</span><br><span class="line">     if(P0!=0xdf)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xde:</span><br><span class="line">            keynum=36;</span><br><span class="line">            break;//第3行第1个按键按下</span><br><span class="line">        case 0xdd:</span><br><span class="line">            keynum=37;</span><br><span class="line">            break;//第3行第2个按键按下</span><br><span class="line">        case 0xdb:</span><br><span class="line">            keynum=38;</span><br><span class="line">            break;//第3行第3个按键按下</span><br><span class="line">        case 0xd7:</span><br><span class="line">            keynum=39;</span><br><span class="line">            break;//第3行第4个按键按下</span><br><span class="line">        case 0xcf:</span><br><span class="line">            keynum=40;</span><br><span class="line">            break;//第3行第5个按键按下</span><br><span class="line">        case 0x9f:</span><br><span class="line">            keynum=41;</span><br><span class="line">            break;//第3行第6个按键按下</span><br><span class="line">        case 0x5f:</span><br><span class="line">            keynum=42;</span><br><span class="line">            break;//第3行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /********************第4行扫描**************************/</span><br><span class="line"></span><br><span class="line">    P0=0xef;//扫描第4行</span><br><span class="line">    delay(5);</span><br><span class="line">    if(P0!=0xef)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xee:</span><br><span class="line">            keynum=29;</span><br><span class="line">            break;//第4行第1个按键按下</span><br><span class="line">        case 0xed:</span><br><span class="line">            keynum=30;</span><br><span class="line">            break;//第4行第2个按键按下</span><br><span class="line">        case 0xeb:</span><br><span class="line">            keynum=31;</span><br><span class="line">            break;//第4行第3个按键按下</span><br><span class="line">        case 0xe7:</span><br><span class="line">            keynum=32;</span><br><span class="line">            break;//第3行第4个按键按下</span><br><span class="line">        case 0xcf:</span><br><span class="line">            keynum=33;</span><br><span class="line">            break;//第4行第5个按键按下</span><br><span class="line">        case 0xaf:</span><br><span class="line">            keynum=34;</span><br><span class="line">            break;//第4行第6个按键按下</span><br><span class="line">        case 0x6f:</span><br><span class="line">            keynum=35;</span><br><span class="line">            break;//第4行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /********************第5行扫描**************************/</span><br><span class="line"></span><br><span class="line">    P0=0xf7;//扫描第5行</span><br><span class="line">    delay(5);</span><br><span class="line">    if(P0!=0xf7)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xf6:</span><br><span class="line">            keynum=22;</span><br><span class="line">            break;//第5行第1个按键按下</span><br><span class="line">        case 0xf5:</span><br><span class="line">            keynum=23;</span><br><span class="line">            break;//第5行第2个按键按下</span><br><span class="line">        case 0xf3:</span><br><span class="line">            keynum=24;</span><br><span class="line">            break;//第5行第3个按键按下</span><br><span class="line">        case 0xe7:</span><br><span class="line">            keynum=25;</span><br><span class="line">            break;//第5行第4个按键按下</span><br><span class="line">        case 0xd7:</span><br><span class="line">            keynum=26;</span><br><span class="line">            break;//第5行第5个按键按下</span><br><span class="line">        case 0xb7:</span><br><span class="line">            keynum=27;</span><br><span class="line">            break;//第5行第6个按键按下</span><br><span class="line">        case 0x77:</span><br><span class="line">            keynum=28;</span><br><span class="line">            break;//第5行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /********************第6行扫描**************************/</span><br><span class="line"></span><br><span class="line">    P0=0xfb;//扫描第6行</span><br><span class="line">    delay(5);</span><br><span class="line">    if(P0!=0xfb)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xfa:</span><br><span class="line">            keynum=15;</span><br><span class="line">            break;//第6行第1个按键按下</span><br><span class="line">        case 0xf9:</span><br><span class="line">            keynum=16;</span><br><span class="line">            break;//第6行第2个按键按下</span><br><span class="line">        case 0xf3:</span><br><span class="line">            keynum=17;</span><br><span class="line">            break;//第6行第3个按键按下</span><br><span class="line">        case 0xeb:</span><br><span class="line">            keynum=18;</span><br><span class="line">            break;//第6行第4个按键按下</span><br><span class="line">        case 0xdb:</span><br><span class="line">            keynum=19;</span><br><span class="line">            break;//第6行第5个按键按下</span><br><span class="line">        case 0xbb:</span><br><span class="line">            keynum=20;</span><br><span class="line">            break;//第6行第6个按键按下</span><br><span class="line">        case 0x7b:</span><br><span class="line">            keynum=21;</span><br><span class="line">            break;//第6行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /********************第7行扫描**************************/</span><br><span class="line">    P0=0xfd;//扫描第7行</span><br><span class="line">    delay(5);</span><br><span class="line">    if(P0!=0xfd)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xfc:</span><br><span class="line">            keynum=8;</span><br><span class="line">            break;//第7行第1个按键按下</span><br><span class="line">        case 0xf9:</span><br><span class="line">            keynum=9;</span><br><span class="line">            break;//第7行第2个按键按下</span><br><span class="line">        case 0xf5:</span><br><span class="line">            keynum=10;</span><br><span class="line">            break;//第7行第3个按键按下</span><br><span class="line">        case 0xed:</span><br><span class="line">            keynum=11;</span><br><span class="line">            break;//第7行第4个按键按下</span><br><span class="line">        case 0xdd:</span><br><span class="line">            keynum=12;</span><br><span class="line">            break;//第7行第5个按键按下</span><br><span class="line">        case 0xbd:</span><br><span class="line">            keynum=13;</span><br><span class="line">            break;//第7行第6个按键按下</span><br><span class="line">        case 0x7d:</span><br><span class="line">            keynum=14;</span><br><span class="line">            break;//第7行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /********************第8行扫描**************************/</span><br><span class="line"></span><br><span class="line">    P0=0xfe;//扫描第8行</span><br><span class="line">    delay(5);</span><br><span class="line">    if(P0!=0xfe)//有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=P0;//将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(tmp)</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xfc:</span><br><span class="line">            keynum=1;</span><br><span class="line">            break;//第8行第1个按键按下</span><br><span class="line">        case 0xfa:</span><br><span class="line">            keynum=2;</span><br><span class="line">            break;//第8行第2个按键按下</span><br><span class="line">        case 0xf6:</span><br><span class="line">            keynum=3;</span><br><span class="line">            break;//第8行第3个按键按下</span><br><span class="line">        case 0xee:</span><br><span class="line">            keynum=4;</span><br><span class="line">            break;//第8行第4个按键按下</span><br><span class="line">        case 0xde:</span><br><span class="line">            keynum=5;</span><br><span class="line">            break;//第8行第5个按键按下</span><br><span class="line">        case 0xbe:</span><br><span class="line">            keynum=6;</span><br><span class="line">            break;//第8行第6个按键按下</span><br><span class="line">        case 0x7e:</span><br><span class="line">            keynum=7;</span><br><span class="line">            break;//第8行第7个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/****************自身端口读取*********************/</span><br><span class="line">P0=0xff;//扫描第8行</span><br><span class="line">//    delay(5);</span><br><span class="line">tmp=P0;</span><br><span class="line">    if (Search(arr, 8, tmp))</span><br><span class="line">    &#123;</span><br><span class="line">        //将检测到的P0状态值赋值给临时变量</span><br><span class="line">        switch(Search(arr, 8, tmp))</span><br><span class="line">        &#123;   //临时变量对逐个IO口进行查询</span><br><span class="line">        case 0xfe:</span><br><span class="line">            keynum=57;</span><br><span class="line">            break;//第1行第1个按键按下</span><br><span class="line">        case 0xfd:</span><br><span class="line">            keynum=58;</span><br><span class="line">            break;//第1行第2个按键按下</span><br><span class="line">        case 0xfb:</span><br><span class="line">            keynum=59;</span><br><span class="line">            break;//第1行第3个按键按下</span><br><span class="line">        case 0xf7:</span><br><span class="line">            keynum=60;</span><br><span class="line">            break;//第1行第4个按键按下</span><br><span class="line">        case 0xef:</span><br><span class="line">            keynum=61;</span><br><span class="line">            break;//第1行第5个按键按下</span><br><span class="line">        case 0xdf:</span><br><span class="line">            keynum=62;</span><br><span class="line">            break;//第1行第6个按键按下</span><br><span class="line">        case 0xbf:</span><br><span class="line">            keynum=63;</span><br><span class="line">            break;//第1行第7个按键按下</span><br><span class="line">        case 0x7f:</span><br><span class="line">            keynum=64;</span><br><span class="line">            break;//第1行第8个按键按下</span><br><span class="line">        &#125;</span><br><span class="line">display();//这里必须单独处理P0的IO检测和显示，否则容易跳数</span><br><span class="line">delay(80);//阻塞按键扫描，防止数码管跳变，其他行扫描不需要此处的延时。</span><br><span class="line">    &#125;</span><br><span class="line">   display();//这里的显示是保存上一次的显示值 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    keynum=0;</span><br><span class="line">    P0=0xff;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        key_scan();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include&lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>&#x2F;&#x2F;共阴极数码管0~9<br>uchar code table[]&#x3D; {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F;0-9共阴数码管<br>uchar code arr[] &#x3D; {0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe};</p><p>uchar duanZhi[]&#x3D; {0,0};&#x2F;&#x2F;保存每段数码管显示位数的数值<br>sbit P36&#x3D;P3^6;&#x2F;&#x2F;数码管时能端<br>sbit P37&#x3D;P3^7;<br>sbit ST&#x3D;P3^0;&#x2F;&#x2F;定义74HC595移位寄存器<br>sbit SH&#x3D;P3^2;<br>sbit DS&#x3D;P3^1;<br>sbit P33&#x3D;P3^3;<br>sbit P34&#x3D;P3^4;<br>sbit P35&#x3D;P3^5;</p><p>uchar shi,ge;&#x2F;&#x2F;数码管个位和十位显示<br>uchar tmp;&#x2F;&#x2F;暂存P0的值<br>static uchar keynum&#x3D;0;&#x2F;&#x2F;按键值<br>unsigned char Trg;<br>unsigned char Cont;<br>static char count&#x3D;1;<br>&#x2F;&#x2F;毫秒级延时<br>void delay(uint z)<br>{<br>    uint x,y;<br>    for(x&#x3D;z; x&gt;&gt;0; x–)<br>        for(y&#x3D;110; y&gt;&gt;0; y–);<br>}<br>void SendTo595(uchar byteData);<br>int Search(uchar arr[], int len, int flag)<br>{<br>    int right &#x3D; len - 1;<br>    int left &#x3D; 0;<br>    while (left &lt;&#x3D; right)<br>    {<br>        int mid &#x3D; (right + left) &#x2F; 2;<br>        if (arr[mid] &gt; flag)<br>        {<br>            right &#x3D; mid - 1;<br>        }<br>        else if (arr[mid] &lt; flag)<br>        {<br>            left &#x3D; mid + 1;<br>        }<br>        else<br>        {<br>            return arr[mid];<br>        }<br>    }<br>    return 0;<br>}<br>&#x2F;*———————————————————————————-<br>                                显示</p><p>void display2()<br>{<br>    ge &#x3D; keynum%10;<br>    shi &#x3D; keynum&#x2F;10;<br>    duanZhi[0]&#x3D;table[ge];<br>    duanZhi[1]&#x3D;table[shi];<br>    P34&#x3D;0x00;<br>    SendTo595(duanZhi[0]); &#x2F;&#x2F;<br>    delay(5);<br>    P34&#x3D;0x01;&#x2F;&#x2F;消隐</p><pre><code>P33=0x00;SendTo595(duanZhi[1]);//delay(5);P33=0x01;//消隐</code></pre><p>}<br>———————————————————————————-*&#x2F;<br>void display()<br>{<br>    ge &#x3D; keynum%10;<br>    shi &#x3D; keynum&#x2F;10;<br>    duanZhi[0]&#x3D;table[ge];<br>    duanZhi[1]&#x3D;table[shi];<br>    &#x2F;&#x2F;显示个位<br>    P37&#x3D;0;<br>    SendTo595(duanZhi[0]); &#x2F;&#x2F;<br>    delay(2);<br>    P37&#x3D;1;&#x2F;&#x2F;消隐<br>    &#x2F;&#x2F;显示十位<br>    P36&#x3D;0;<br>    SendTo595(duanZhi[1]);&#x2F;&#x2F;<br>    delay(2);<br>    P36&#x3D;1;&#x2F;&#x2F;消隐</p><p>}<br>&#x2F;***********************************************************<br>*函数名：SendTo595<br>*功能:串行发送8个比特（一个字节）的数据给595，再并行输出<br>*参数：byteData<br>************************************************************&#x2F;<br>void SendTo595(uchar byteData)<br>{<br>    uchar i&#x3D;0;<br>    ST &#x3D; 0;   &#x2F;&#x2F;ST &#x2F;&#x2F;先拉低，为后面的上升沿做准备<br>    for(i; i&lt;8; i++)<br>    {<br>        SH &#x3D; 0;&#x2F;&#x2F;先拉低，<br>        if(byteData&amp;0x80)DS&#x3D;1;<br>        else DS&#x3D;0;<br>&#x2F;&#x2F;        DS &#x3D; (byteData&amp;0x80)?1:0;<br>        byteData &#x3D; byteData &lt;&lt;1;&#x2F;&#x2F;该字节右移一位</p><pre><code>    SH = 1;//上升沿，让串行输入时钟变为高电平，并延时2个时钟周期    _nop_();    _nop_();    SH = 0;        //上升沿，让串行输入时钟变为高电平，并延时2个时钟周期&#125;/*位移寄存器数据准备完毕,转移到存储寄存器*/ST =1;_nop_();_nop_();ST = 0;</code></pre><p>}</p><p>void key_scan()<br>{<br>&#x2F;&#x2F;    P0&#x3D;0xff;<br>&#x2F;&#x2F;    delay(6);</p><pre><code>/********************第1行扫描**************************/P0=0x7F;//扫描第1行0111 1111delay(5);if (!Search(arr, 8, tmp))//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0x7e:        keynum=50;        break;//第1行第1个按键按下    case 0x7d:        keynum=51;        break;//第1行第2个按键按下    case 0x7b:        keynum=52;        break;//第1行第3个按键按下    case 0x77:        keynum=53;        break;//第1行第4个按键按下    case 0x6f:        keynum=54;        break;//第1行第5个按键按下    case 0x5f:        keynum=55;        break;//第1行第6个按键按下    case 0x3f:        keynum=56;        break;//第1行第7个按键按下    &#125;&#125;/********************第2行扫描**************************/P0=0xbf;//扫描第2行delay(5);if(P0!=0xbf)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xbe:        keynum=43;        break;//第2行第1个按键按下    case 0xbd:        keynum=44;        break;//第2行第2个按键按下    case 0xbb:        keynum=45;        break;//第2行第3个按键按下    case 0xb7:        keynum=46;        break;//第2行第4个按键按下    case 0xaf:        keynum=47;        break;//第2行第5个按键按下    case 0x9f:        keynum=48;        break;//第2行第6个按键按下    case 0x3f:        keynum=49;        break;//第2行第7个按键按下    &#125;&#125;/********************第3行扫描**************************/P0=0xdf;//扫描第3行delay(5); if(P0!=0xdf)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xde:        keynum=36;        break;//第3行第1个按键按下    case 0xdd:        keynum=37;        break;//第3行第2个按键按下    case 0xdb:        keynum=38;        break;//第3行第3个按键按下    case 0xd7:        keynum=39;        break;//第3行第4个按键按下    case 0xcf:        keynum=40;        break;//第3行第5个按键按下    case 0x9f:        keynum=41;        break;//第3行第6个按键按下    case 0x5f:        keynum=42;        break;//第3行第7个按键按下    &#125;&#125;/********************第4行扫描**************************/P0=0xef;//扫描第4行delay(5);if(P0!=0xef)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xee:        keynum=29;        break;//第4行第1个按键按下    case 0xed:        keynum=30;        break;//第4行第2个按键按下    case 0xeb:        keynum=31;        break;//第4行第3个按键按下    case 0xe7:        keynum=32;        break;//第3行第4个按键按下    case 0xcf:        keynum=33;        break;//第4行第5个按键按下    case 0xaf:        keynum=34;        break;//第4行第6个按键按下    case 0x6f:        keynum=35;        break;//第4行第7个按键按下    &#125;&#125;/********************第5行扫描**************************/P0=0xf7;//扫描第5行delay(5);if(P0!=0xf7)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xf6:        keynum=22;        break;//第5行第1个按键按下    case 0xf5:        keynum=23;        break;//第5行第2个按键按下    case 0xf3:        keynum=24;        break;//第5行第3个按键按下    case 0xe7:        keynum=25;        break;//第5行第4个按键按下    case 0xd7:        keynum=26;        break;//第5行第5个按键按下    case 0xb7:        keynum=27;        break;//第5行第6个按键按下    case 0x77:        keynum=28;        break;//第5行第7个按键按下    &#125;&#125;/********************第6行扫描**************************/P0=0xfb;//扫描第6行delay(5);if(P0!=0xfb)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xfa:        keynum=15;        break;//第6行第1个按键按下    case 0xf9:        keynum=16;        break;//第6行第2个按键按下    case 0xf3:        keynum=17;        break;//第6行第3个按键按下    case 0xeb:        keynum=18;        break;//第6行第4个按键按下    case 0xdb:        keynum=19;        break;//第6行第5个按键按下    case 0xbb:        keynum=20;        break;//第6行第6个按键按下    case 0x7b:        keynum=21;        break;//第6行第7个按键按下    &#125;&#125;/********************第7行扫描**************************/P0=0xfd;//扫描第7行delay(5);if(P0!=0xfd)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xfc:        keynum=8;        break;//第7行第1个按键按下    case 0xf9:        keynum=9;        break;//第7行第2个按键按下    case 0xf5:        keynum=10;        break;//第7行第3个按键按下    case 0xed:        keynum=11;        break;//第7行第4个按键按下    case 0xdd:        keynum=12;        break;//第7行第5个按键按下    case 0xbd:        keynum=13;        break;//第7行第6个按键按下    case 0x7d:        keynum=14;        break;//第7行第7个按键按下    &#125;&#125;/********************第8行扫描**************************/P0=0xfe;//扫描第8行delay(5);if(P0!=0xfe)//有按键按下&#123;    tmp=P0;//将检测到的P0状态值赋值给临时变量    switch(tmp)    &#123;   //临时变量对逐个IO口进行查询    case 0xfc:        keynum=1;        break;//第8行第1个按键按下    case 0xfa:        keynum=2;        break;//第8行第2个按键按下    case 0xf6:        keynum=3;        break;//第8行第3个按键按下    case 0xee:        keynum=4;        break;//第8行第4个按键按下    case 0xde:        keynum=5;        break;//第8行第5个按键按下    case 0xbe:        keynum=6;        break;//第8行第6个按键按下    case 0x7e:        keynum=7;        break;//第8行第7个按键按下    &#125;&#125;</code></pre><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong>自身端口读取</strong></strong></strong></strong></strong></strong></strong></strong>*****&#x2F;<br>        P0&#x3D;0xff;&#x2F;&#x2F;扫描第8行<br>&#x2F;&#x2F;    delay(5);<br>        tmp&#x3D;P0;<br>    if (Search(arr, 8, tmp))<br>    {<br>        &#x2F;&#x2F;将检测到的P0状态值赋值给临时变量<br>        switch(Search(arr, 8, tmp))<br>        {   &#x2F;&#x2F;临时变量对逐个IO口进行查询<br>        case 0xfe:<br>            keynum&#x3D;57;<br>            break;&#x2F;&#x2F;第1行第1个按键按下<br>        case 0xfd:<br>            keynum&#x3D;58;<br>            break;&#x2F;&#x2F;第1行第2个按键按下<br>        case 0xfb:<br>            keynum&#x3D;59;<br>            break;&#x2F;&#x2F;第1行第3个按键按下<br>        case 0xf7:<br>            keynum&#x3D;60;<br>            break;&#x2F;&#x2F;第1行第4个按键按下<br>        case 0xef:<br>            keynum&#x3D;61;<br>            break;&#x2F;&#x2F;第1行第5个按键按下<br>        case 0xdf:<br>            keynum&#x3D;62;<br>            break;&#x2F;&#x2F;第1行第6个按键按下<br>        case 0xbf:<br>            keynum&#x3D;63;<br>            break;&#x2F;&#x2F;第1行第7个按键按下<br>        case 0x7f:<br>            keynum&#x3D;64;<br>            break;&#x2F;&#x2F;第1行第8个按键按下<br>        }<br>            display();&#x2F;&#x2F;这里必须单独处理P0的IO检测和显示，否则容易跳数<br>            delay(80);&#x2F;&#x2F;阻塞按键扫描，防止数码管跳变，其他行扫描不需要此处的延时。<br>    }<br>   display();&#x2F;&#x2F;这里的显示是保存上一次的显示值 </p><p>}<br>void main()<br>{<br>    keynum&#x3D;0;<br>    P0&#x3D;0xff;<br>    while(1)<br>    {<br>        key_scan();</p><pre><code>&#125;</code></pre><p>}&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E4%B8%89%E6%9E%81%E7%AE%A1%E7%BB%84%E6%88%90%E7%9A%84H%E6%A1%A5%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%8F%AF%E6%8E%A7/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E4%B8%89%E6%9E%81%E7%AE%A1%E7%BB%84%E6%88%90%E7%9A%84H%E6%A1%A5%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%8F%AF%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控"><a href="#【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控" class="headerlink" title="【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控"></a>【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控</h1><h3 id="【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控-1"><a href="#【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控-1" class="headerlink" title="【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控"></a>【Proteus仿真】三极管组成的H桥驱动直流电机正反转可控</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/0da52aa9618f45b6aa29983a6705f781.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">三极管组成的H桥驱动直流电机正反转可控</span><br><span class="line">*/</span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">sbit K1   = P3^0;//正转</span><br><span class="line">sbit K2   = P3^1;//反转</span><br><span class="line">sbit K3   = P3^2;//停止</span><br><span class="line"></span><br><span class="line">sbit LED1 = P0^0;//指示灯</span><br><span class="line">sbit LED2 = P0^1;</span><br><span class="line">sbit LED3 = P0^2;</span><br><span class="line"></span><br><span class="line">sbit MA   = P1^0;//电机控制引脚</span><br><span class="line">sbit MB   = P1^1;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">LED1 = 1;</span><br><span class="line">LED2 = 1;</span><br><span class="line">LED3 = 0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> if(K1 == 0)</span><br><span class="line">&#123;</span><br><span class="line"> while(K1 == 0);</span><br><span class="line">LED1 = 0;</span><br><span class="line">LED2 = 1;</span><br><span class="line">LED3 = 1;</span><br><span class="line">MA   = 0;</span><br><span class="line">MB   = 1;</span><br><span class="line">&#125;</span><br><span class="line">if(K2 == 0)</span><br><span class="line">&#123;</span><br><span class="line"> while(K1 == 0);</span><br><span class="line">LED1 = 1;</span><br><span class="line">LED2 = 0;</span><br><span class="line">LED3 = 1;</span><br><span class="line">MA   = 1;</span><br><span class="line">MB   = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(K3 == 0)</span><br><span class="line">&#123;</span><br><span class="line"> while(K1 == 0);</span><br><span class="line">LED1 = 1;</span><br><span class="line">LED2 = 1;</span><br><span class="line">LED3 = 0;</span><br><span class="line">MA   = 0;</span><br><span class="line">MB   = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*<br>三极管组成的H桥驱动直流电机正反转可控<br>*&#x2F;<br>#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char<br>sbit K1   &#x3D; P3^0;&#x2F;&#x2F;正转<br>sbit K2   &#x3D; P3^1;&#x2F;&#x2F;反转<br>sbit K3   &#x3D; P3^2;&#x2F;&#x2F;停止</p><p>sbit LED1 &#x3D; P0^0;&#x2F;&#x2F;指示灯<br>sbit LED2 &#x3D; P0^1;<br>sbit LED3 &#x3D; P0^2;</p><p>sbit MA   &#x3D; P1^0;&#x2F;&#x2F;电机控制引脚<br>sbit MB   &#x3D; P1^1;</p><p>void main(void)<br>{<br>    LED1 &#x3D; 1;<br>    LED2 &#x3D; 1;<br>    LED3 &#x3D; 0;<br>    while(1)<br>    {<br>     if(K1 &#x3D;&#x3D; 0)<br>        {<br>         while(K1 &#x3D;&#x3D; 0);<br>            LED1 &#x3D; 0;<br>            LED2 &#x3D; 1;<br>            LED3 &#x3D; 1;<br>            MA   &#x3D; 0;<br>            MB   &#x3D; 1;<br>        }<br>        if(K2 &#x3D;&#x3D; 0)<br>        {<br>         while(K1 &#x3D;&#x3D; 0);<br>            LED1 &#x3D; 1;<br>            LED2 &#x3D; 0;<br>            LED3 &#x3D; 1;<br>            MA   &#x3D; 1;<br>            MB   &#x3D; 0;<br>        }<br>        if(K3 &#x3D;&#x3D; 0)<br>        {<br>         while(K1 &#x3D;&#x3D; 0);<br>            LED1 &#x3D; 1;<br>            LED2 &#x3D; 1;<br>            LED3 &#x3D; 0;<br>            MA   &#x3D; 0;<br>            MB   &#x3D; 0;<br>        }<br>    }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1aAQ4BJ0AV-MzecxzrpC8YQ </span><br><span class="line">提取码：bmd8</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1aAQ4BJ0AV-MzecxzrpC8YQ  提取码：bmd8</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯单片机定时器与中断秒表实验+Proteus仿真</title>
      <link href="/2024/03/Proteus-%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%A7%92%E8%A1%A8%E5%AE%9E%E9%AA%8CProteus%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/03/Proteus-%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%A7%92%E8%A1%A8%E5%AE%9E%E9%AA%8CProteus%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="蓝桥杯单片机定时器与中断秒表实验-Proteus仿真"><a href="#蓝桥杯单片机定时器与中断秒表实验-Proteus仿真" class="headerlink" title="蓝桥杯单片机定时器与中断秒表实验+Proteus仿真"></a>蓝桥杯单片机定时器与中断秒表实验+Proteus仿真</h1><h3 id="蓝桥杯单片机定时器与中断秒表实验"><a href="#蓝桥杯单片机定时器与中断秒表实验" class="headerlink" title="蓝桥杯单片机定时器与中断秒表实验"></a>蓝桥杯单片机定时器与中断秒表实验</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/62276bbc5bb64afda7599984a2e2ac9a.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="秒表实验"><a href="#秒表实验" class="headerlink" title="秒表实验"></a>秒表实验</h4><p>实验目标：在CT107D单片机综合训练平台上，利用定时器T0、数码管模块和2个独立按键(J5的2-3短接)，设计一个秒表，具有清零、暂停、启动功能。</p><h5 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h5><ol><li>显示格式为: 分-秒- 0.05秒(即50ms)，例：08-26-18表示: 8分 26秒900毫秒。</li><li>独立按键S4为:暂停|启动；独立按键S5为:清零 ，按键均为按下有效。</li></ol><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line"></span><br><span class="line">sbit S4 = P3^3;</span><br><span class="line">sbit S5 = P3^2;/*独立按键*/</span><br><span class="line"></span><br><span class="line">unsigned char t_m = 0;/*分*/</span><br><span class="line">unsigned char t_s = 0;/*秒*/</span><br><span class="line">unsigned char t_005s = 0;/*50毫秒*/</span><br><span class="line"></span><br><span class="line">unsigned char code SMG_NoDot[18] = </span><br><span class="line">    &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,</span><br><span class="line">     0x80,0x90,0x88,0x80,0xc6,0xc0,0x86,0x8e,</span><br><span class="line">     0xbf,0x7f&#125;;/*共阳数码管真值*/</span><br><span class="line"></span><br><span class="line">void SelectHC573(unsigned char channel)/*74HC573锁存器*/</span><br><span class="line">&#123;</span><br><span class="line">switch(channel)</span><br><span class="line">&#123;</span><br><span class="line">case 4:</span><br><span class="line">P2 = (P2 &amp; 0x1f) | 0x80;</span><br><span class="line">break;</span><br><span class="line">case 5:</span><br><span class="line">P2 = (P2 &amp; 0x1f) | 0xa0;</span><br><span class="line">break;</span><br><span class="line">case 6:</span><br><span class="line">P2 = (P2 &amp; 0x1f) | 0xc0;</span><br><span class="line">break;</span><br><span class="line">case 7:</span><br><span class="line">P2 = (P2 &amp; 0x1f) | 0xe0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DelaySMG(unsigned int t)/*数码管延时函数*/</span><br><span class="line">&#123;</span><br><span class="line">while(t--);</span><br><span class="line">&#125;</span><br><span class="line">void DisplaySMG_Bit(unsigned char value, unsigned char pos)/*数码管显示函数*/</span><br><span class="line">&#123;</span><br><span class="line">P0 = 0x00;</span><br><span class="line">SelectHC573(6);</span><br><span class="line">P0 = 0x01 &lt;&lt; pos;</span><br><span class="line">P2=0x00;//消隐</span><br><span class="line">SelectHC573(7);</span><br><span class="line">P0 = value;</span><br><span class="line">P2=0x00;//消隐</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void DisplayTime()/*设置数码管显示内容*/</span><br><span class="line">&#123;</span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[t_005s%10],7);</span><br><span class="line">DelaySMG(500);</span><br><span class="line"></span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[t_005s/10],6);</span><br><span class="line">DelaySMG(500);</span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[16],5);</span><br><span class="line">DelaySMG(500);</span><br><span class="line"></span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[t_s%10],4);</span><br><span class="line">DelaySMG(500);</span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[t_s/10],3);</span><br><span class="line">DelaySMG(500);</span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[16],2);</span><br><span class="line">DelaySMG(500);</span><br><span class="line"></span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[t_m%10],1);</span><br><span class="line">DelaySMG(500);</span><br><span class="line">DisplaySMG_Bit(SMG_NoDot[t_m/10],0);</span><br><span class="line">DelaySMG(500);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//=============定时器相关函数========================</span><br><span class="line">void InitTimer0() /*定时器0初始化*/</span><br><span class="line">&#123;</span><br><span class="line">TMOD = 0x01;</span><br><span class="line">TH0 = (65535 - 50000) / 256;</span><br><span class="line">TL0 = (65535 - 50000) % 256;</span><br><span class="line">ET0 = 1;</span><br><span class="line">EA = 1;</span><br><span class="line">TR0 = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定时器中断服务函数</span><br><span class="line">void ServiceTimer0() interrupt 1 //默认中断优先级 1</span><br><span class="line">&#123;</span><br><span class="line">TH0 = (65535 - 50000) / 256;</span><br><span class="line">TL0 = (65535 - 50000) % 256;</span><br><span class="line"></span><br><span class="line">t_005s++;</span><br><span class="line">if(t_005s == 20)</span><br><span class="line">&#123;</span><br><span class="line">t_s++;</span><br><span class="line">t_005s = 0;</span><br><span class="line">if(t_s == 60)</span><br><span class="line">&#123;</span><br><span class="line">t_m++;</span><br><span class="line">t_s = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(t_m == 99)</span><br><span class="line">&#123;</span><br><span class="line">t_m = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//==================按键相关函数=================================</span><br><span class="line">void DelayK(unsigned char t) /*按键延时函数*/</span><br><span class="line">&#123;</span><br><span class="line">while(t--);</span><br><span class="line">&#125;</span><br><span class="line">void ScanKeys() /*按键读值并设置按键功能*/</span><br><span class="line">&#123;</span><br><span class="line">if(S4 == 0)//秒表启动与暂停</span><br><span class="line">&#123;</span><br><span class="line">DelayK(100);</span><br><span class="line">if(S4 == 0)</span><br><span class="line">&#123;</span><br><span class="line">TR0 = ~TR0;</span><br><span class="line">while(S4 == 0)</span><br><span class="line">&#123;</span><br><span class="line">DisplayTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(S5 == 0)//秒表清零</span><br><span class="line">&#123;</span><br><span class="line">DelayK(100);</span><br><span class="line">if(S5 == 0)</span><br><span class="line">&#123;</span><br><span class="line">t_005s = 0;</span><br><span class="line">t_s = 0;</span><br><span class="line">t_m = 0;</span><br><span class="line">while(S5 == 0)</span><br><span class="line">&#123;</span><br><span class="line">DisplayTime();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//==================函数=================================</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">InitTimer0();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">DisplayTime();</span><br><span class="line">ScanKeys();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “reg52.h”</p><p>sbit S4 &#x3D; P3^3;<br>sbit S5 &#x3D; P3^2;&#x2F;<em>独立按键</em>&#x2F;</p><p>unsigned char t_m &#x3D; 0;&#x2F;<em>分</em>&#x2F;<br>unsigned char t_s &#x3D; 0;&#x2F;<em>秒</em>&#x2F;<br>unsigned char t_005s &#x3D; 0;&#x2F;<em>50毫秒</em>&#x2F;</p><p>unsigned char code SMG_NoDot[18] &#x3D;<br>    {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,<br>     0x80,0x90,0x88,0x80,0xc6,0xc0,0x86,0x8e,<br>     0xbf,0x7f};&#x2F;<em>共阳数码管真值</em>&#x2F;</p><p>void SelectHC573(unsigned char channel)&#x2F;<em>74HC573锁存器</em>&#x2F;<br>{<br>    switch(channel)<br>    {<br>        case 4:<br>            P2 &#x3D; (P2 &amp; 0x1f) | 0x80;<br>        break;<br>        case 5:<br>            P2 &#x3D; (P2 &amp; 0x1f) | 0xa0;<br>        break;<br>        case 6:<br>            P2 &#x3D; (P2 &amp; 0x1f) | 0xc0;<br>        break;<br>        case 7:<br>            P2 &#x3D; (P2 &amp; 0x1f) | 0xe0;<br>        break;<br>    }<br>}<br>void DelaySMG(unsigned int t)&#x2F;<em>数码管延时函数</em>&#x2F;<br>{<br>    while(t–);<br>}<br>void DisplaySMG_Bit(unsigned char value, unsigned char pos)&#x2F;<em>数码管显示函数</em>&#x2F;<br>{<br>    P0 &#x3D; 0x00;<br>    SelectHC573(6);<br>    P0 &#x3D; 0x01 &lt;&lt; pos;<br>    P2&#x3D;0x00;&#x2F;&#x2F;消隐<br>    SelectHC573(7);<br>    P0 &#x3D; value;<br>    P2&#x3D;0x00;&#x2F;&#x2F;消隐<br>}</p><p>void DisplayTime()&#x2F;<em>设置数码管显示内容</em>&#x2F;<br>{<br>    DisplaySMG_Bit(SMG_NoDot[t_005s%10],7);<br>    DelaySMG(500);</p><pre><code>DisplaySMG_Bit(SMG_NoDot[t_005s/10],6);DelaySMG(500);DisplaySMG_Bit(SMG_NoDot[16],5);DelaySMG(500);DisplaySMG_Bit(SMG_NoDot[t_s%10],4);DelaySMG(500);DisplaySMG_Bit(SMG_NoDot[t_s/10],3);DelaySMG(500);DisplaySMG_Bit(SMG_NoDot[16],2);DelaySMG(500);DisplaySMG_Bit(SMG_NoDot[t_m%10],1);DelaySMG(500);DisplaySMG_Bit(SMG_NoDot[t_m/10],0);DelaySMG(500);</code></pre><p>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;定时器相关函数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void InitTimer0() &#x2F;<em>定时器0初始化</em>&#x2F;<br>{<br>    TMOD &#x3D; 0x01;<br>    TH0 &#x3D; (65535 - 50000) &#x2F; 256;<br>    TL0 &#x3D; (65535 - 50000) % 256;<br>    ET0 &#x3D; 1;<br>    EA &#x3D; 1;<br>    TR0 &#x3D; 1;<br>}</p><p>&#x2F;&#x2F;定时器中断服务函数<br>void ServiceTimer0() interrupt 1 &#x2F;&#x2F;默认中断优先级 1<br>{<br>    TH0 &#x3D; (65535 - 50000) &#x2F; 256;<br>    TL0 &#x3D; (65535 - 50000) % 256;</p><pre><code>t_005s++;if(t_005s == 20)&#123;    t_s++;    t_005s = 0;    if(t_s == 60)    &#123;        t_m++;        t_s = 0;    &#125;    if(t_m == 99)    &#123;        t_m = 0;    &#125;&#125;</code></pre><p>}<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;按键相关函数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void DelayK(unsigned char t) &#x2F;<em>按键延时函数</em>&#x2F;<br>{<br>    while(t–);<br>}<br>void ScanKeys() &#x2F;<em>按键读值并设置按键功能</em>&#x2F;<br>{<br>    if(S4 &#x3D;&#x3D; 0)&#x2F;&#x2F;秒表启动与暂停<br>    {<br>        DelayK(100);<br>        if(S4 &#x3D;&#x3D; 0)<br>        {<br>            TR0 &#x3D; ~TR0;<br>            while(S4 &#x3D;&#x3D; 0)<br>            {<br>                DisplayTime();<br>            }<br>        }<br>    }</p><pre><code>if(S5 == 0)//秒表清零&#123;    DelayK(100);    if(S5 == 0)    &#123;        t_005s = 0;        t_s = 0;        t_m = 0;        while(S5 == 0)        &#123;            DisplayTime();        &#125;    &#125;&#125;</code></pre><p>}<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;函数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void main()<br>{<br>    InitTimer0();<br>    while(1)<br>    {<br>        DisplayTime();<br>        ScanKeys();<br>    }<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1hLA69iEetIyEYXpdJ3-7lQ </span><br><span class="line">提取码：4jc7</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1hLA69iEetIyEYXpdJ3-7lQ  提取码：4jc7</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Internal Exception: access violation in module ‘SPICEINP.DLL‘ [000007F9].解决办法</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-Internal-Exception-access-violation-in-module-SPICEINPDLL-000007F9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-Internal-Exception-access-violation-in-module-SPICEINPDLL-000007F9%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Internal-Exception-access-violation-in-module-‘SPICEINP-DLL‘-000007F9-解决办法"><a href="#Internal-Exception-access-violation-in-module-‘SPICEINP-DLL‘-000007F9-解决办法" class="headerlink" title="Internal Exception: access violation in module ‘SPICEINP.DLL‘ [000007F9].解决办法"></a>Internal Exception: access violation in module ‘SPICEINP.DLL‘ [000007F9].解决办法</h1><h3 id="Proteus仿真报“Internal-Exception-access-violation-in-module-‘SPICEINP-DLL’-000007F9-”解决办法"><a href="#Proteus仿真报“Internal-Exception-access-violation-in-module-‘SPICEINP-DLL’-000007F9-”解决办法" class="headerlink" title="Proteus仿真报“Internal Exception: access violation in module ‘SPICEINP.DLL’ [000007F9].”解决办法"></a>Proteus仿真报“Internal Exception: access violation in module ‘SPICEINP.DLL’ [000007F9].”解决办法</h3><ul><li>Proteus错误截图</li></ul><p><img src="https://img-blog.csdnimg.cn/ee104009199e4005a6acc2b07e8a1161.png" alt="在这里插入图片描述"></p><p>我不敢保证，能解决所有人的，关于这个错误的通用解决办法。但是这个是我自己实测有效，反复测试了bug的可重复性实验做过验证。</p><h3 id="此错误信息是在运行一个Proteus仿真步进电机控制程序的时候报错。"><a href="#此错误信息是在运行一个Proteus仿真步进电机控制程序的时候报错。" class="headerlink" title="此错误信息是在运行一个Proteus仿真步进电机控制程序的时候报错。"></a>此错误信息是在运行一个Proteus仿真步进电机控制程序的时候报错。</h3><ul><li>我在网上也搜索了很久，有人说重新建Proteus工程，重新添加器件可以解决此错误，按照这个线索，我确定应该还是某个器件不兼容导致的，于是我尝试删除电路中连接的器件，进行逐个筛查，果然，在我删除仿真电路中的步进电机以后，在点击运行仿真就不再报错了，问题就锁定在了步进电机器件上，于是，我删掉这个步进电机，重新取器件库搜索添加，结果放置上去，运行仿真，结果依旧是报错，我还是重新连接线路，也无果，双击步进电机属性发型属性里面的电压值是12V默认值，二系统仿真默认是5V供电电压，于是我去配置系统里面添加12V的电源电压，添加了12V电压之后，运行店楼仿真，果然不再报错，问题解决。</li><li>查看电机属性，可以看到驱动电压值是12V。</li><li>首先，在步进电机供电属性设置标签12V</li><li>去添加12V电压配置到系统当中去。</li><li>新建12电压值的电压。</li></ul><p><img src="https://img-blog.csdnimg.cn/2e9a45b7073744b6bbcc3c95ec8cdecf.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/ba33fcb8dd4744a3afb9ffc407455e75.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/cd4099f8f52c4310bbe3ec5070e5749b.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e3b1e3fd775640faa27489c62f1ae387.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC89C52RC+ LCD1602+PCF8574转IIC接口屏幕驱动显示+Proteus仿真</title>
      <link href="/2024/03/Proteus-STC89C52RC-LCD1602PCF8574%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BAProteus%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/03/Proteus-STC89C52RC-LCD1602PCF8574%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BAProteus%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC89C52RC-LCD1602-PCF8574转IIC接口屏幕驱动显示-Proteus仿真"><a href="#STC89C52RC-LCD1602-PCF8574转IIC接口屏幕驱动显示-Proteus仿真" class="headerlink" title="STC89C52RC+ LCD1602+PCF8574转IIC接口屏幕驱动显示+Proteus仿真"></a>STC89C52RC+ LCD1602+PCF8574转IIC接口屏幕驱动显示+Proteus仿真</h1><h3 id="STC89C52RC-LCD1602-PCF8574转IIC接口屏幕驱动显示-Proteus仿真-1"><a href="#STC89C52RC-LCD1602-PCF8574转IIC接口屏幕驱动显示-Proteus仿真-1" class="headerlink" title="STC89C52RC+ LCD1602+PCF8574转IIC接口屏幕驱动显示+Proteus仿真"></a>STC89C52RC+ LCD1602+PCF8574转IIC接口屏幕驱动显示+Proteus仿真</h3><ul><li>硬件实物驱动显示</li></ul><p><img src="https://img-blog.csdnimg.cn/fb8f84298f6d4c86b58cfb41befde03f.jpg#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/42c63f7574a5450db6586c53cbb27444.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/c235fd7e6dad44e3a1d25dd2e8a4d9bb.jpg#pic_center" alt="在这里插入图片描述"></p><ul><li>Proteus动态仿真显示</li></ul><p><img src="https://img-blog.csdnimg.cn/3ce6b01acdf74804a2b3c4e062ee042f.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="Proteus器件选择注意事项"><a href="#Proteus器件选择注意事项" class="headerlink" title="Proteus器件选择注意事项"></a>Proteus器件选择注意事项</h4><ul><li>在选择PCF8574，器件的时候，选择不要带A的的，不然仿真的时候不会显示。</li></ul><p><code>PCF8574</code></p><p><img src="https://img-blog.csdnimg.cn/f043eccdd9b2493a9e01223968ea4a88.png" alt="在这里插入图片描述"></p><h4 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//#define   L1                0x80            // 第一行写入地址</span><br><span class="line">//#define   L2                0xc0            // 第二行写入地址</span><br><span class="line"></span><br><span class="line">sbit SCL = P1^0;</span><br><span class="line">sbit SDA = P1^1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ADDR = 0x4E;    // PCF8574  T  模块的地址码</span><br><span class="line">//char ADDR = 0x7e;    // PCF8574   AT  模块的地址码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//***************************** 延时毫秒函数***********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay1(int y)   //</span><br><span class="line">&#123;</span><br><span class="line">    while(y--)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char a,b,c;</span><br><span class="line">        for(c=1; c&gt;0; c--)</span><br><span class="line">            for(b=142; b&gt;0; b--)</span><br><span class="line">                for(a=2; a&gt;0; a--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** IIC 串口开始 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IIC_start(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SDA=0;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//********************************** IIC 串口写1个字节 ******************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IIC_writeByte(char temp)</span><br><span class="line">&#123;</span><br><span class="line">    char i;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SDA=(bit)(temp &amp; 0x80) ;   // 根据规定1602的数据最高位必须为  1</span><br><span class="line">        temp &lt;&lt;=1;</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SCL=1;</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SCL=0;</span><br><span class="line">    &#125;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SDA=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    while(SDA);</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** 1602写命令 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_command(char comm)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp;</span><br><span class="line">    IIC_start();          // 串口开始</span><br><span class="line">    IIC_writeByte(ADDR);  // 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</span><br><span class="line"></span><br><span class="line">    tmp = comm &amp; 0xF0;    // 与0xf0 应该是取第四位的意思吧</span><br><span class="line">    tmp |= 0x0C;         //保留高4位为指令的高四位，低四位为   RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);  //从串口送出</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB;        //Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">    tmp = (comm &amp; 0x0F) &lt;&lt; 4 ;  //将指令的低四位 送到高位置保存</span><br><span class="line">    tmp |= 0x0C;        //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB; // Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//******************************** 1602写数据 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_data(char data1)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp;</span><br><span class="line">    IIC_start();</span><br><span class="line">    IIC_writeByte(ADDR);   // 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</span><br><span class="line"></span><br><span class="line">    tmp = data1 &amp; 0xF0;</span><br><span class="line">    tmp |= 0x0D; //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB; //Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">    tmp = (data1 &amp; 0x0F) &lt;&lt; 4 ;</span><br><span class="line">    tmp |= 0x0D; //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB ; // Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** 1602初始化 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Init_Lcd(void)</span><br><span class="line">&#123;</span><br><span class="line">    LCD_write_command(0x33); //将8位总线转为4位总线</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x32); //</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x28); // 4位数据线，显示2行，5*7点阵字符  ！如果是0x38  则为8位数据线，显示2行，5*7点阵字符</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x0C); // 开显示，关闭光标，不闪烁</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x06); // 设定输入方式，增量不位移</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x01); // 清屏</span><br><span class="line">    delay1(50) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//*************************************** 在指定位置显示字符串 *************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Write_LCD(int x, int y, char *str)</span><br><span class="line">&#123;</span><br><span class="line">    char addr;</span><br><span class="line">    if( x &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x &gt; 15)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 15;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        y = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = 0x80 + 0x40 * y + x;   // Move cursor  移动光标</span><br><span class="line">    LCD_write_command(addr);</span><br><span class="line">    while (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_write_data(*str++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------------------------------- 显示字符串的函数 ----------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_word(unsigned char *s) //显示字符串的函数</span><br><span class="line">&#123;</span><br><span class="line">    while(*s&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_write_data(*s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//********************************* 指定位置显示一个字符*******************************************</span><br><span class="line">/*</span><br><span class="line">void Print_Char (unsigned char line,unsigned char num,unsigned char date)</span><br><span class="line">&#123;</span><br><span class="line">                LCD_write_command(line+num);</span><br><span class="line">                LCD_write_data(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//按指定位置显示一个字符(针对1602液晶)-用在温度显示</span><br><span class="line">void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)</span><br><span class="line">&#123;</span><br><span class="line">    Y &amp;= 0x1;</span><br><span class="line">    X &amp;= 0xF;                 //限制X不能大于15，Y不能大于1</span><br><span class="line">    if (Y) X |= 0x40;        //当要显示第二行时地址码+0x40;</span><br><span class="line">    X |= 0x80;               // 算出指令码</span><br><span class="line">    LCD_write_command(X);    //这里不检测忙信号，发送地址码</span><br><span class="line">    LCD_write_data(DData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    Init_Lcd();</span><br><span class="line">Write_LCD(3, 1, &quot;STC89C52RC&quot;);//在第一行第一个位置显示字符串</span><br><span class="line">    DisplayOneChar(0,0,&#x27;P&#x27;);//在指定位置显示一个字符</span><br><span class="line">    DisplayOneChar(1,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(2,0,&#x27;r&#x27;);</span><br><span class="line">    DisplayOneChar(3,0,&#x27;s&#x27;);</span><br><span class="line">    DisplayOneChar(4,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(5,0,&#x27;v&#x27;);</span><br><span class="line">    DisplayOneChar(6,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(7,0,&#x27;r&#x27;);</span><br><span class="line">    DisplayOneChar(8,0,&#x27;a&#x27;);</span><br><span class="line">    DisplayOneChar(9,0,&#x27;n&#x27;);</span><br><span class="line">    DisplayOneChar(10,0,&#x27;c&#x27;);</span><br><span class="line">    DisplayOneChar(11,0,&#x27;e&#x27;);</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include “intrins.h”<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>&#x2F;&#x2F;#define   L1                0x80            &#x2F;&#x2F; 第一行写入地址<br>&#x2F;&#x2F;#define   L2                0xc0            &#x2F;&#x2F; 第二行写入地址</p><p>sbit SCL &#x3D; P1^0;<br>sbit SDA &#x3D; P1^1;</p><p>char ADDR &#x3D; 0x4E;    &#x2F;&#x2F; PCF8574  T  模块的地址码<br>&#x2F;&#x2F;char ADDR &#x3D; 0x7e;    &#x2F;&#x2F; PCF8574   AT  模块的地址码</p><p>&#x2F;&#x2F;***************************** 延时毫秒函数***********************************************</p><p>void delay1(int y)   &#x2F;&#x2F;<br>{<br>    while(y–)<br>    {<br>        unsigned char a,b,c;<br>        for(c&#x3D;1; c&gt;0; c–)<br>            for(b&#x3D;142; b&gt;0; b–)<br>                for(a&#x3D;2; a&gt;0; a–);<br>    }<br>}</p><p>&#x2F;&#x2F;******************************** IIC 串口开始 ********************************************</p><p>void IIC_start(void)<br>{<br>    SDA&#x3D;1;<br>    <em>nop</em>();<br>    SCL&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SDA&#x3D;0;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SCL&#x3D;0;<br>}</p><p>&#x2F;&#x2F;********************************** IIC 串口写1个字节 ******************************************</p><p>void IIC_writeByte(char temp)<br>{<br>    char i;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>        SDA&#x3D;(bit)(temp &amp; 0x80) ;   &#x2F;&#x2F; 根据规定1602的数据最高位必须为  1<br>        temp &lt;&lt;&#x3D;1;<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SCL&#x3D;1;<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SCL&#x3D;0;<br>    }<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SDA&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SCL&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    while(SDA);<br>    <em>nop</em>();<br>    SCL&#x3D;0;<br>}</p><p>&#x2F;&#x2F;******************************** 1602写命令 ********************************************</p><p>void LCD_write_command(char comm)<br>{<br>    char tmp;<br>    IIC_start();          &#x2F;&#x2F; 串口开始<br>    IIC_writeByte(ADDR);  &#x2F;&#x2F; 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</p><pre><code>tmp = comm &amp; 0xF0;    // 与0xf0 应该是取第四位的意思吧tmp |= 0x0C;         //保留高4位为指令的高四位，低四位为   RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);  //从串口送出delay1(20);tmp &amp;= 0xFB;        //Make EN = 0IIC_writeByte(tmp);tmp = (comm &amp; 0x0F) &lt;&lt; 4 ;  //将指令的低四位 送到高位置保存tmp |= 0x0C;        //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB; // Make EN = 0IIC_writeByte(tmp);</code></pre><p>}<br>&#x2F;&#x2F;******************************** 1602写数据 ********************************************</p><p>void LCD_write_data(char data1)<br>{<br>    char tmp;<br>    IIC_start();<br>    IIC_writeByte(ADDR);   &#x2F;&#x2F; 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</p><pre><code>tmp = data1 &amp; 0xF0;tmp |= 0x0D; //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB; //Make EN = 0IIC_writeByte(tmp);tmp = (data1 &amp; 0x0F) &lt;&lt; 4 ;tmp |= 0x0D; //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB ; // Make EN = 0IIC_writeByte(tmp);</code></pre><p>}</p><p>&#x2F;&#x2F;******************************** 1602初始化 ********************************************</p><p>void Init_Lcd(void)<br>{<br>    LCD_write_command(0x33); &#x2F;&#x2F;将8位总线转为4位总线<br>    delay1(50) ;<br>    LCD_write_command(0x32); &#x2F;&#x2F;<br>    delay1(50) ;<br>    LCD_write_command(0x28); &#x2F;&#x2F; 4位数据线，显示2行，5<em>7点阵字符  ！如果是0x38  则为8位数据线，显示2行，5</em>7点阵字符<br>    delay1(50) ;<br>    LCD_write_command(0x0C); &#x2F;&#x2F; 开显示，关闭光标，不闪烁<br>    delay1(50) ;<br>    LCD_write_command(0x06); &#x2F;&#x2F; 设定输入方式，增量不位移<br>    delay1(50) ;<br>    LCD_write_command(0x01); &#x2F;&#x2F; 清屏<br>    delay1(50) ;<br>}</p><p>&#x2F;&#x2F;*************************************** 在指定位置显示字符串 *************************************</p><p>void Write_LCD(int x, int y, char *str)<br>{<br>    char addr;<br>    if( x &lt; 0)<br>    {<br>        x &#x3D; 0;<br>    }<br>    if(x &gt; 15)<br>    {<br>        x &#x3D; 15;<br>    }<br>    if(y&lt;0)<br>    {<br>        y &#x3D; 0;<br>    }<br>    if(y &gt; 1)<br>    {<br>        y &#x3D; 1;<br>    }</p><pre><code>addr = 0x80 + 0x40 * y + x;   // Move cursor  移动光标LCD_write_command(addr);while (*str)&#123;    LCD_write_data(*str++);&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;——————————————– 显示字符串的函数 —————————————————-</p><p>void LCD_write_word(unsigned char *s) &#x2F;&#x2F;显示字符串的函数<br>{<br>    while(*s&gt;0)<br>    {<br>        LCD_write_data(*s);<br>        s++;<br>    }<br>}</p><p>&#x2F;&#x2F;********************************* 指定位置显示一个字符*******************************************<br>&#x2F;*<br>void Print_Char (unsigned char line,unsigned char num,unsigned char date)<br>{<br>                LCD_write_command(line+num);<br>                LCD_write_data(date);<br>}</p><p>*&#x2F;</p><p>&#x2F;&#x2F;按指定位置显示一个字符(针对1602液晶)-用在温度显示<br>void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)<br>{<br>    Y &amp;&#x3D; 0x1;<br>    X &amp;&#x3D; 0xF;                 &#x2F;&#x2F;限制X不能大于15，Y不能大于1<br>    if (Y) X |&#x3D; 0x40;        &#x2F;&#x2F;当要显示第二行时地址码+0x40;<br>    X |&#x3D; 0x80;               &#x2F;&#x2F; 算出指令码<br>    LCD_write_command(X);    &#x2F;&#x2F;这里不检测忙信号，发送地址码<br>    LCD_write_data(DData);<br>}</p><p>void main() {<br>    Init_Lcd();<br>    Write_LCD(3, 1, “STC89C52RC”);&#x2F;&#x2F;在第一行第一个位置显示字符串<br>    DisplayOneChar(0,0,’P’);&#x2F;&#x2F;在指定位置显示一个字符<br>    DisplayOneChar(1,0,’e’);<br>    DisplayOneChar(2,0,’r’);<br>    DisplayOneChar(3,0,’s’);<br>    DisplayOneChar(4,0,’e’);<br>    DisplayOneChar(5,0,’v’);<br>    DisplayOneChar(6,0,’e’);<br>    DisplayOneChar(7,0,’r’);<br>    DisplayOneChar(8,0,’a’);<br>    DisplayOneChar(9,0,’n’);<br>    DisplayOneChar(10,0,’c’);<br>    DisplayOneChar(11,0,’e’);<br>                while(1);<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1Pn_Et54aGQn-vP_9Up8-gg </span><br><span class="line">提取码：us98</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1Pn_Et54aGQn-vP_9Up8-gg  提取码：us98</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC89C52RC+ LCD1602转IIC接口屏幕驱动显示</title>
      <link href="/2024/03/STC-51%E5%8D%95%E7%89%87%E6%9C%BALCD1602%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/STC-51%E5%8D%95%E7%89%87%E6%9C%BALCD1602%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC89C52RC-LCD1602转IIC接口屏幕驱动显示"><a href="#STC89C52RC-LCD1602转IIC接口屏幕驱动显示" class="headerlink" title="STC89C52RC+ LCD1602转IIC接口屏幕驱动显示"></a>STC89C52RC+ LCD1602转IIC接口屏幕驱动显示</h1><h3 id="STC89C52RC-LCD1602转IIC接口屏幕驱动显示-1"><a href="#STC89C52RC-LCD1602转IIC接口屏幕驱动显示-1" class="headerlink" title="STC89C52RC+ LCD1602转IIC接口屏幕驱动显示"></a>STC89C52RC+ LCD1602转IIC接口屏幕驱动显示</h3><ul><li>液晶屏资料</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1Gkcpa_sG0M12yK2233GYfQ </span><br><span class="line">提取码：7cz7</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1Gkcpa_sG0M12yK2233GYfQ  提取码：7cz7</code></p><p><img src="https://img-blog.csdnimg.cn/64874702b15b434085b31e06563ca95b.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/d15fc15b74af44e3a42a35d653303a60.jpg" alt="在这里插入图片描述"></p><ul><li>LCD1602转IIC转接板驱动显示正面</li><li>显示效果</li></ul><p><img src="https://img-blog.csdnimg.cn/a77e0cc1911f4211b477ebf463d451c6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b8817f9b3fcb4084aa9b28c92ae89265.png" alt="在这里插入图片描述"></p><ul><li>LCD1602转IIC转接板驱动模块反面</li></ul><p><img src="https://img-blog.csdnimg.cn/80fe86cb100741028b4a47d5cb8eb9c7.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2dff11700d02468d96424dc7b8d359e4.png" alt="在这里插入图片描述"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>LCD1602转IIC接口芯片采用的驱动芯片型号不一样，其地址不相同。</li></ul><p>看清楚背面转接板上面芯片型号，我的是带T的PCF8574T</p><p><code>PCF8574T</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ADDR = 0x4E;    // PCF8574T  模块的地址码</span><br><span class="line">//char ADDR = 0x7e;    // PCF8574AT  模块的地址码</span><br></pre></td></tr></table></figure><p><code>char ADDR = 0x4E;    // PCF8574T  模块的地址码 //char ADDR = 0x7e;    // PCF8574AT  模块的地址码</code></p><h4 id="接线方式"><a href="#接线方式" class="headerlink" title="接线方式"></a>接线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STC15W408AS----- LCD1602</span><br><span class="line">P1.0--------SCL</span><br><span class="line">P1.1--------SDA</span><br><span class="line">VCC--------VCC(如果是3.3V供电需要把亮度调至到最大，如果是5V供电不需要调至到最亮)，即可看清显示内容</span><br><span class="line">GND------GND</span><br></pre></td></tr></table></figure><p><code>STC15W408AS----- LCD1602 P1.0--------SCL P1.1--------SDA VCC--------VCC(如果是3.3V供电需要把亮度调至到最大，如果是5V供电不需要调至到最亮)，即可看清显示内容 GND------GND</code></p><h4 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h4><p>驱动代码和驱动STC15W408AS相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//#define   L1                0x80            // 第一行写入地址</span><br><span class="line">//#define   L2                0xc0            // 第二行写入地址</span><br><span class="line"></span><br><span class="line">sbit SCL = P1^0;</span><br><span class="line">sbit SDA = P1^1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ADDR = 0x4E;    // PCF8574  T  模块的地址码</span><br><span class="line">//char ADDR = 0x7e;    // PCF8574   AT  模块的地址码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//***************************** 延时毫秒函数***********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay1(int y)   //</span><br><span class="line">&#123;</span><br><span class="line">    while(y--)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char a,b,c;</span><br><span class="line">        for(c=1; c&gt;0; c--)</span><br><span class="line">            for(b=142; b&gt;0; b--)</span><br><span class="line">                for(a=2; a&gt;0; a--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** IIC 串口开始 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IIC_start(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SDA=0;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//********************************** IIC 串口写1个字节 ******************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IIC_writeByte(char temp)</span><br><span class="line">&#123;</span><br><span class="line">    char i;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SDA=(bit)(temp &amp; 0x80) ;   // 根据规定1602的数据最高位必须为  1</span><br><span class="line">        temp &lt;&lt;=1;</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SCL=1;</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SCL=0;</span><br><span class="line">    &#125;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SDA=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    while(SDA);</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** 1602写命令 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_command(char comm)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp;</span><br><span class="line">    IIC_start();          // 串口开始</span><br><span class="line">    IIC_writeByte(ADDR);  // 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</span><br><span class="line"></span><br><span class="line">    tmp = comm &amp; 0xF0;    // 与0xf0 应该是取第四位的意思吧</span><br><span class="line">    tmp |= 0x0C;         //保留高4位为指令的高四位，低四位为   RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);  //从串口送出</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB;        //Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">    tmp = (comm &amp; 0x0F) &lt;&lt; 4 ;  //将指令的低四位 送到高位置保存</span><br><span class="line">    tmp |= 0x0C;        //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB; // Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//******************************** 1602写数据 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_data(char data1)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp;</span><br><span class="line">    IIC_start();</span><br><span class="line">    IIC_writeByte(ADDR);   // 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</span><br><span class="line"></span><br><span class="line">    tmp = data1 &amp; 0xF0;</span><br><span class="line">    tmp |= 0x0D; //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB; //Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">    tmp = (data1 &amp; 0x0F) &lt;&lt; 4 ;</span><br><span class="line">    tmp |= 0x0D; //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB ; // Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** 1602初始化 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Init_Lcd(void)</span><br><span class="line">&#123;</span><br><span class="line">    LCD_write_command(0x33); //将8位总线转为4位总线</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x32); //</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x28); // 4位数据线，显示2行，5*7点阵字符  ！如果是0x38  则为8位数据线，显示2行，5*7点阵字符</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x0C); // 开显示，关闭光标，不闪烁</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x06); // 设定输入方式，增量不位移</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x01); // 清屏</span><br><span class="line">    delay1(50) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//*************************************** 在指定位置显示字符串 *************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Write_LCD(int x, int y, char *str)</span><br><span class="line">&#123;</span><br><span class="line">    char addr;</span><br><span class="line">    if( x &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x &gt; 15)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 15;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        y = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = 0x80 + 0x40 * y + x;   // Move cursor  移动光标</span><br><span class="line">    LCD_write_command(addr);</span><br><span class="line">    while (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_write_data(*str++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------------------------------- 显示字符串的函数 ----------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_word(unsigned char *s) //显示字符串的函数</span><br><span class="line">&#123;</span><br><span class="line">    while(*s&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_write_data(*s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//********************************* 指定位置显示一个字符*******************************************</span><br><span class="line">/*</span><br><span class="line">void Print_Char (unsigned char line,unsigned char num,unsigned char date)</span><br><span class="line">&#123;</span><br><span class="line">                LCD_write_command(line+num);</span><br><span class="line">                LCD_write_data(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//按指定位置显示一个字符(针对1602液晶)-用在温度显示</span><br><span class="line">void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)</span><br><span class="line">&#123;</span><br><span class="line">    Y &amp;= 0x1;</span><br><span class="line">    X &amp;= 0xF;                 //限制X不能大于15，Y不能大于1</span><br><span class="line">    if (Y) X |= 0x40;        //当要显示第二行时地址码+0x40;</span><br><span class="line">    X |= 0x80;               // 算出指令码</span><br><span class="line">    LCD_write_command(X);    //这里不检测忙信号，发送地址码</span><br><span class="line">    LCD_write_data(DData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    Init_Lcd();</span><br><span class="line">Write_LCD(0, 1, &quot;Hell0 World!&quot;);//在第一行第一个位置显示字符串</span><br><span class="line">    DisplayOneChar(0,0,&#x27;P&#x27;);//在指定位置显示一个字符</span><br><span class="line">    DisplayOneChar(1,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(2,0,&#x27;r&#x27;);</span><br><span class="line">    DisplayOneChar(3,0,&#x27;s&#x27;);</span><br><span class="line">    DisplayOneChar(4,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(5,0,&#x27;v&#x27;);</span><br><span class="line">    DisplayOneChar(6,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(7,0,&#x27;r&#x27;);</span><br><span class="line">    DisplayOneChar(8,0,&#x27;a&#x27;);</span><br><span class="line">    DisplayOneChar(9,0,&#x27;n&#x27;);</span><br><span class="line">    DisplayOneChar(10,0,&#x27;c&#x27;);</span><br><span class="line">    DisplayOneChar(11,0,&#x27;e&#x27;);</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include “intrins.h”<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>&#x2F;&#x2F;#define   L1                0x80            &#x2F;&#x2F; 第一行写入地址<br>&#x2F;&#x2F;#define   L2                0xc0            &#x2F;&#x2F; 第二行写入地址</p><p>sbit SCL &#x3D; P1^0;<br>sbit SDA &#x3D; P1^1;</p><p>char ADDR &#x3D; 0x4E;    &#x2F;&#x2F; PCF8574  T  模块的地址码<br>&#x2F;&#x2F;char ADDR &#x3D; 0x7e;    &#x2F;&#x2F; PCF8574   AT  模块的地址码</p><p>&#x2F;&#x2F;***************************** 延时毫秒函数***********************************************</p><p>void delay1(int y)   &#x2F;&#x2F;<br>{<br>    while(y–)<br>    {<br>        unsigned char a,b,c;<br>        for(c&#x3D;1; c&gt;0; c–)<br>            for(b&#x3D;142; b&gt;0; b–)<br>                for(a&#x3D;2; a&gt;0; a–);<br>    }<br>}</p><p>&#x2F;&#x2F;******************************** IIC 串口开始 ********************************************</p><p>void IIC_start(void)<br>{<br>    SDA&#x3D;1;<br>    <em>nop</em>();<br>    SCL&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SDA&#x3D;0;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SCL&#x3D;0;<br>}</p><p>&#x2F;&#x2F;********************************** IIC 串口写1个字节 ******************************************</p><p>void IIC_writeByte(char temp)<br>{<br>    char i;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>        SDA&#x3D;(bit)(temp &amp; 0x80) ;   &#x2F;&#x2F; 根据规定1602的数据最高位必须为  1<br>        temp &lt;&lt;&#x3D;1;<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SCL&#x3D;1;<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SCL&#x3D;0;<br>    }<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SDA&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SCL&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    while(SDA);<br>    <em>nop</em>();<br>    SCL&#x3D;0;<br>}</p><p>&#x2F;&#x2F;******************************** 1602写命令 ********************************************</p><p>void LCD_write_command(char comm)<br>{<br>    char tmp;<br>    IIC_start();          &#x2F;&#x2F; 串口开始<br>    IIC_writeByte(ADDR);  &#x2F;&#x2F; 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</p><pre><code>tmp = comm &amp; 0xF0;    // 与0xf0 应该是取第四位的意思吧tmp |= 0x0C;         //保留高4位为指令的高四位，低四位为   RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);  //从串口送出delay1(20);tmp &amp;= 0xFB;        //Make EN = 0IIC_writeByte(tmp);tmp = (comm &amp; 0x0F) &lt;&lt; 4 ;  //将指令的低四位 送到高位置保存tmp |= 0x0C;        //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB; // Make EN = 0IIC_writeByte(tmp);</code></pre><p>}<br>&#x2F;&#x2F;******************************** 1602写数据 ********************************************</p><p>void LCD_write_data(char data1)<br>{<br>    char tmp;<br>    IIC_start();<br>    IIC_writeByte(ADDR);   &#x2F;&#x2F; 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</p><pre><code>tmp = data1 &amp; 0xF0;tmp |= 0x0D; //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB; //Make EN = 0IIC_writeByte(tmp);tmp = (data1 &amp; 0x0F) &lt;&lt; 4 ;tmp |= 0x0D; //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB ; // Make EN = 0IIC_writeByte(tmp);</code></pre><p>}</p><p>&#x2F;&#x2F;******************************** 1602初始化 ********************************************</p><p>void Init_Lcd(void)<br>{<br>    LCD_write_command(0x33); &#x2F;&#x2F;将8位总线转为4位总线<br>    delay1(50) ;<br>    LCD_write_command(0x32); &#x2F;&#x2F;<br>    delay1(50) ;<br>    LCD_write_command(0x28); &#x2F;&#x2F; 4位数据线，显示2行，5<em>7点阵字符  ！如果是0x38  则为8位数据线，显示2行，5</em>7点阵字符<br>    delay1(50) ;<br>    LCD_write_command(0x0C); &#x2F;&#x2F; 开显示，关闭光标，不闪烁<br>    delay1(50) ;<br>    LCD_write_command(0x06); &#x2F;&#x2F; 设定输入方式，增量不位移<br>    delay1(50) ;<br>    LCD_write_command(0x01); &#x2F;&#x2F; 清屏<br>    delay1(50) ;<br>}</p><p>&#x2F;&#x2F;*************************************** 在指定位置显示字符串 *************************************</p><p>void Write_LCD(int x, int y, char *str)<br>{<br>    char addr;<br>    if( x &lt; 0)<br>    {<br>        x &#x3D; 0;<br>    }<br>    if(x &gt; 15)<br>    {<br>        x &#x3D; 15;<br>    }<br>    if(y&lt;0)<br>    {<br>        y &#x3D; 0;<br>    }<br>    if(y &gt; 1)<br>    {<br>        y &#x3D; 1;<br>    }</p><pre><code>addr = 0x80 + 0x40 * y + x;   // Move cursor  移动光标LCD_write_command(addr);while (*str)&#123;    LCD_write_data(*str++);&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;——————————————– 显示字符串的函数 —————————————————-</p><p>void LCD_write_word(unsigned char *s) &#x2F;&#x2F;显示字符串的函数<br>{<br>    while(*s&gt;0)<br>    {<br>        LCD_write_data(*s);<br>        s++;<br>    }<br>}</p><p>&#x2F;&#x2F;********************************* 指定位置显示一个字符*******************************************<br>&#x2F;*<br>void Print_Char (unsigned char line,unsigned char num,unsigned char date)<br>{<br>                LCD_write_command(line+num);<br>                LCD_write_data(date);<br>}</p><p>*&#x2F;</p><p>&#x2F;&#x2F;按指定位置显示一个字符(针对1602液晶)-用在温度显示<br>void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)<br>{<br>    Y &amp;&#x3D; 0x1;<br>    X &amp;&#x3D; 0xF;                 &#x2F;&#x2F;限制X不能大于15，Y不能大于1<br>    if (Y) X |&#x3D; 0x40;        &#x2F;&#x2F;当要显示第二行时地址码+0x40;<br>    X |&#x3D; 0x80;               &#x2F;&#x2F; 算出指令码<br>    LCD_write_command(X);    &#x2F;&#x2F;这里不检测忙信号，发送地址码<br>    LCD_write_data(DData);<br>}</p><p>void main() {<br>    Init_Lcd();<br>    Write_LCD(0, 1, “Hell0 World!”);&#x2F;&#x2F;在第一行第一个位置显示字符串<br>    DisplayOneChar(0,0,’P’);&#x2F;&#x2F;在指定位置显示一个字符<br>    DisplayOneChar(1,0,’e’);<br>    DisplayOneChar(2,0,’r’);<br>    DisplayOneChar(3,0,’s’);<br>    DisplayOneChar(4,0,’e’);<br>    DisplayOneChar(5,0,’v’);<br>    DisplayOneChar(6,0,’e’);<br>    DisplayOneChar(7,0,’r’);<br>    DisplayOneChar(8,0,’a’);<br>    DisplayOneChar(9,0,’n’);<br>    DisplayOneChar(10,0,’c’);<br>    DisplayOneChar(11,0,’e’);<br>                while(1);<br>}&#96;</p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1HVlULFfyv5-evyozXqWS6A </span><br><span class="line">提取码：149w</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1HVlULFfyv5-evyozXqWS6A  提取码：149w</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15W408AS+ LCD1602转IIC接口屏幕驱动显示</title>
      <link href="/2024/03/Stc15-STC15W408AS-LCD1602%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Stc15-STC15W408AS-LCD1602%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E5%B1%8F%E5%B9%95%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15W408AS-LCD1602转IIC接口屏幕驱动显示"><a href="#STC15W408AS-LCD1602转IIC接口屏幕驱动显示" class="headerlink" title="STC15W408AS+ LCD1602转IIC接口屏幕驱动显示"></a>STC15W408AS+ LCD1602转IIC接口屏幕驱动显示</h1><h3 id="STC15W408AS-LCD1602转IIC接口屏幕驱动显示-1"><a href="#STC15W408AS-LCD1602转IIC接口屏幕驱动显示-1" class="headerlink" title="STC15W408AS+ LCD1602转IIC接口屏幕驱动显示"></a>STC15W408AS+ LCD1602转IIC接口屏幕驱动显示</h3><ul><li>液晶屏资料</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1Gkcpa_sG0M12yK2233GYfQ </span><br><span class="line">提取码：7cz7</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1Gkcpa_sG0M12yK2233GYfQ  提取码：7cz7</code></p><ul><li>LCD1602转IIC转接板驱动显示正面</li><li>显示效果</li></ul><p><img src="https://img-blog.csdnimg.cn/a77e0cc1911f4211b477ebf463d451c6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/b8817f9b3fcb4084aa9b28c92ae89265.png" alt="在这里插入图片描述"></p><ul><li>LCD1602转IIC转接板驱动模块反面</li></ul><p><img src="https://img-blog.csdnimg.cn/80fe86cb100741028b4a47d5cb8eb9c7.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2dff11700d02468d96424dc7b8d359e4.png" alt="在这里插入图片描述"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>LCD1602转IIC接口芯片采用的驱动芯片型号不一样，其地址不相同。</li></ul><p>看清楚背面转接板上面芯片型号，我的是带T的PCF8574T</p><p><code>PCF8574T</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ADDR = 0x4E;    // PCF8574T  模块的地址码</span><br><span class="line">//char ADDR = 0x7e;    // PCF8574AT  模块的地址码</span><br></pre></td></tr></table></figure><p><code>char ADDR = 0x4E;    // PCF8574T  模块的地址码 //char ADDR = 0x7e;    // PCF8574AT  模块的地址码</code></p><h4 id="接线方式"><a href="#接线方式" class="headerlink" title="接线方式"></a>接线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STC15W408AS----- LCD1602</span><br><span class="line">P1.0--------SCL</span><br><span class="line">P1.1--------SDA</span><br><span class="line">VCC--------VCC(如果是3.3V供电需要把亮度调至到最大，如果是5V供电不需要调至到最亮)</span><br><span class="line">GND------GND</span><br></pre></td></tr></table></figure><p><code>STC15W408AS----- LCD1602 P1.0--------SCL P1.1--------SDA VCC--------VCC(如果是3.3V供电需要把亮度调至到最大，如果是5V供电不需要调至到最亮) GND------GND</code></p><h4 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//#define   L1                0x80            // 第一行写入地址</span><br><span class="line">//#define   L2                0xc0            // 第二行写入地址</span><br><span class="line"></span><br><span class="line">sbit SCL = P1^0;</span><br><span class="line">sbit SDA = P1^1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ADDR = 0x4E;    // PCF8574  T  模块的地址码</span><br><span class="line">//char ADDR = 0x7e;    // PCF8574   AT  模块的地址码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//***************************** 延时毫秒函数***********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay1(int y)   //</span><br><span class="line">&#123;</span><br><span class="line">    while(y--)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char a,b,c;</span><br><span class="line">        for(c=1; c&gt;0; c--)</span><br><span class="line">            for(b=142; b&gt;0; b--)</span><br><span class="line">                for(a=2; a&gt;0; a--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** IIC 串口开始 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IIC_start(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SDA=0;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//********************************** IIC 串口写1个字节 ******************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IIC_writeByte(char temp)</span><br><span class="line">&#123;</span><br><span class="line">    char i;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SDA=(bit)(temp &amp; 0x80) ;   // 根据规定1602的数据最高位必须为  1</span><br><span class="line">        temp &lt;&lt;=1;</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SCL=1;</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        SCL=0;</span><br><span class="line">    &#125;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SDA=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=1;</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    while(SDA);</span><br><span class="line">    _nop_();</span><br><span class="line">    SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** 1602写命令 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_command(char comm)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp;</span><br><span class="line">    IIC_start();          // 串口开始</span><br><span class="line">    IIC_writeByte(ADDR);  // 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</span><br><span class="line"></span><br><span class="line">    tmp = comm &amp; 0xF0;    // 与0xf0 应该是取第四位的意思吧</span><br><span class="line">    tmp |= 0x0C;         //保留高4位为指令的高四位，低四位为   RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);  //从串口送出</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB;        //Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">    tmp = (comm &amp; 0x0F) &lt;&lt; 4 ;  //将指令的低四位 送到高位置保存</span><br><span class="line">    tmp |= 0x0C;        //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB; // Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//******************************** 1602写数据 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_data(char data1)</span><br><span class="line">&#123;</span><br><span class="line">    char tmp;</span><br><span class="line">    IIC_start();</span><br><span class="line">    IIC_writeByte(ADDR);   // 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</span><br><span class="line"></span><br><span class="line">    tmp = data1 &amp; 0xF0;</span><br><span class="line">    tmp |= 0x0D; //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB; //Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line"></span><br><span class="line">    tmp = (data1 &amp; 0x0F) &lt;&lt; 4 ;</span><br><span class="line">    tmp |= 0x0D; //RS = 0, RW = 0, EN = 1</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">    delay1(20);</span><br><span class="line">    tmp &amp;= 0xFB ; // Make EN = 0</span><br><span class="line">    IIC_writeByte(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//******************************** 1602初始化 ********************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Init_Lcd(void)</span><br><span class="line">&#123;</span><br><span class="line">    LCD_write_command(0x33); //将8位总线转为4位总线</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x32); //</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x28); // 4位数据线，显示2行，5*7点阵字符  ！如果是0x38  则为8位数据线，显示2行，5*7点阵字符</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x0C); // 开显示，关闭光标，不闪烁</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x06); // 设定输入方式，增量不位移</span><br><span class="line">    delay1(50) ;</span><br><span class="line">    LCD_write_command(0x01); // 清屏</span><br><span class="line">    delay1(50) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//*************************************** 在指定位置显示字符串 *************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Write_LCD(int x, int y, char *str)</span><br><span class="line">&#123;</span><br><span class="line">    char addr;</span><br><span class="line">    if( x &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x &gt; 15)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 15;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(y &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        y = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = 0x80 + 0x40 * y + x;   // Move cursor  移动光标</span><br><span class="line">    LCD_write_command(addr);</span><br><span class="line">    while (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_write_data(*str++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------------------------------- 显示字符串的函数 ----------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LCD_write_word(unsigned char *s) //显示字符串的函数</span><br><span class="line">&#123;</span><br><span class="line">    while(*s&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_write_data(*s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//********************************* 指定位置显示一个字符*******************************************</span><br><span class="line">/*</span><br><span class="line">void Print_Char (unsigned char line,unsigned char num,unsigned char date)</span><br><span class="line">&#123;</span><br><span class="line">                LCD_write_command(line+num);</span><br><span class="line">                LCD_write_data(date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//按指定位置显示一个字符(针对1602液晶)-用在温度显示</span><br><span class="line">void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)</span><br><span class="line">&#123;</span><br><span class="line">    Y &amp;= 0x1;</span><br><span class="line">    X &amp;= 0xF;                 //限制X不能大于15，Y不能大于1</span><br><span class="line">    if (Y) X |= 0x40;        //当要显示第二行时地址码+0x40;</span><br><span class="line">    X |= 0x80;               // 算出指令码</span><br><span class="line">    LCD_write_command(X);    //这里不检测忙信号，发送地址码</span><br><span class="line">    LCD_write_data(DData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    Init_Lcd();</span><br><span class="line">Write_LCD(0, 1, &quot;Hell0 World!&quot;);//在第一行第一个位置显示字符串</span><br><span class="line">    DisplayOneChar(0,0,&#x27;P&#x27;);//在指定位置显示一个字符</span><br><span class="line">    DisplayOneChar(1,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(2,0,&#x27;r&#x27;);</span><br><span class="line">    DisplayOneChar(3,0,&#x27;s&#x27;);</span><br><span class="line">    DisplayOneChar(4,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(5,0,&#x27;v&#x27;);</span><br><span class="line">    DisplayOneChar(6,0,&#x27;e&#x27;);</span><br><span class="line">    DisplayOneChar(7,0,&#x27;r&#x27;);</span><br><span class="line">    DisplayOneChar(8,0,&#x27;a&#x27;);</span><br><span class="line">    DisplayOneChar(9,0,&#x27;n&#x27;);</span><br><span class="line">    DisplayOneChar(10,0,&#x27;c&#x27;);</span><br><span class="line">    DisplayOneChar(11,0,&#x27;e&#x27;);</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include “intrins.h”<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>&#x2F;&#x2F;#define   L1                0x80            &#x2F;&#x2F; 第一行写入地址<br>&#x2F;&#x2F;#define   L2                0xc0            &#x2F;&#x2F; 第二行写入地址</p><p>sbit SCL &#x3D; P1^0;<br>sbit SDA &#x3D; P1^1;</p><p>char ADDR &#x3D; 0x4E;    &#x2F;&#x2F; PCF8574  T  模块的地址码<br>&#x2F;&#x2F;char ADDR &#x3D; 0x7e;    &#x2F;&#x2F; PCF8574   AT  模块的地址码</p><p>&#x2F;&#x2F;***************************** 延时毫秒函数***********************************************</p><p>void delay1(int y)   &#x2F;&#x2F;<br>{<br>    while(y–)<br>    {<br>        unsigned char a,b,c;<br>        for(c&#x3D;1; c&gt;0; c–)<br>            for(b&#x3D;142; b&gt;0; b–)<br>                for(a&#x3D;2; a&gt;0; a–);<br>    }<br>}</p><p>&#x2F;&#x2F;******************************** IIC 串口开始 ********************************************</p><p>void IIC_start(void)<br>{<br>    SDA&#x3D;1;<br>    <em>nop</em>();<br>    SCL&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SDA&#x3D;0;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SCL&#x3D;0;<br>}</p><p>&#x2F;&#x2F;********************************** IIC 串口写1个字节 ******************************************</p><p>void IIC_writeByte(char temp)<br>{<br>    char i;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>        SDA&#x3D;(bit)(temp &amp; 0x80) ;   &#x2F;&#x2F; 根据规定1602的数据最高位必须为  1<br>        temp &lt;&lt;&#x3D;1;<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SCL&#x3D;1;<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        <em>nop</em>();<br>        SCL&#x3D;0;<br>    }<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SDA&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    SCL&#x3D;1;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    while(SDA);<br>    <em>nop</em>();<br>    SCL&#x3D;0;<br>}</p><p>&#x2F;&#x2F;******************************** 1602写命令 ********************************************</p><p>void LCD_write_command(char comm)<br>{<br>    char tmp;<br>    IIC_start();          &#x2F;&#x2F; 串口开始<br>    IIC_writeByte(ADDR);  &#x2F;&#x2F; 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</p><pre><code>tmp = comm &amp; 0xF0;    // 与0xf0 应该是取第四位的意思吧tmp |= 0x0C;         //保留高4位为指令的高四位，低四位为   RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);  //从串口送出delay1(20);tmp &amp;= 0xFB;        //Make EN = 0IIC_writeByte(tmp);tmp = (comm &amp; 0x0F) &lt;&lt; 4 ;  //将指令的低四位 送到高位置保存tmp |= 0x0C;        //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB; // Make EN = 0IIC_writeByte(tmp);</code></pre><p>}<br>&#x2F;&#x2F;******************************** 1602写数据 ********************************************</p><p>void LCD_write_data(char data1)<br>{<br>    char tmp;<br>    IIC_start();<br>    IIC_writeByte(ADDR);   &#x2F;&#x2F; 先选PCF 8574T 的地址  （应该是相当于选中的意思吧）</p><pre><code>tmp = data1 &amp; 0xF0;tmp |= 0x0D; //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB; //Make EN = 0IIC_writeByte(tmp);tmp = (data1 &amp; 0x0F) &lt;&lt; 4 ;tmp |= 0x0D; //RS = 0, RW = 0, EN = 1IIC_writeByte(tmp);delay1(20);tmp &amp;= 0xFB ; // Make EN = 0IIC_writeByte(tmp);</code></pre><p>}</p><p>&#x2F;&#x2F;******************************** 1602初始化 ********************************************</p><p>void Init_Lcd(void)<br>{<br>    LCD_write_command(0x33); &#x2F;&#x2F;将8位总线转为4位总线<br>    delay1(50) ;<br>    LCD_write_command(0x32); &#x2F;&#x2F;<br>    delay1(50) ;<br>    LCD_write_command(0x28); &#x2F;&#x2F; 4位数据线，显示2行，5<em>7点阵字符  ！如果是0x38  则为8位数据线，显示2行，5</em>7点阵字符<br>    delay1(50) ;<br>    LCD_write_command(0x0C); &#x2F;&#x2F; 开显示，关闭光标，不闪烁<br>    delay1(50) ;<br>    LCD_write_command(0x06); &#x2F;&#x2F; 设定输入方式，增量不位移<br>    delay1(50) ;<br>    LCD_write_command(0x01); &#x2F;&#x2F; 清屏<br>    delay1(50) ;<br>}</p><p>&#x2F;&#x2F;*************************************** 在指定位置显示字符串 *************************************</p><p>void Write_LCD(int x, int y, char *str)<br>{<br>    char addr;<br>    if( x &lt; 0)<br>    {<br>        x &#x3D; 0;<br>    }<br>    if(x &gt; 15)<br>    {<br>        x &#x3D; 15;<br>    }<br>    if(y&lt;0)<br>    {<br>        y &#x3D; 0;<br>    }<br>    if(y &gt; 1)<br>    {<br>        y &#x3D; 1;<br>    }</p><pre><code>addr = 0x80 + 0x40 * y + x;   // Move cursor  移动光标LCD_write_command(addr);while (*str)&#123;    LCD_write_data(*str++);&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;——————————————– 显示字符串的函数 —————————————————-</p><p>void LCD_write_word(unsigned char *s) &#x2F;&#x2F;显示字符串的函数<br>{<br>    while(*s&gt;0)<br>    {<br>        LCD_write_data(*s);<br>        s++;<br>    }<br>}</p><p>&#x2F;&#x2F;********************************* 指定位置显示一个字符*******************************************<br>&#x2F;*<br>void Print_Char (unsigned char line,unsigned char num,unsigned char date)<br>{<br>                LCD_write_command(line+num);<br>                LCD_write_data(date);<br>}</p><p>*&#x2F;</p><p>&#x2F;&#x2F;按指定位置显示一个字符(针对1602液晶)-用在温度显示<br>void DisplayOneChar(unsigned char X, unsigned char Y, unsigned char DData)<br>{<br>    Y &amp;&#x3D; 0x1;<br>    X &amp;&#x3D; 0xF;                 &#x2F;&#x2F;限制X不能大于15，Y不能大于1<br>    if (Y) X |&#x3D; 0x40;        &#x2F;&#x2F;当要显示第二行时地址码+0x40;<br>    X |&#x3D; 0x80;               &#x2F;&#x2F; 算出指令码<br>    LCD_write_command(X);    &#x2F;&#x2F;这里不检测忙信号，发送地址码<br>    LCD_write_data(DData);<br>}</p><p>void main() {<br>    Init_Lcd();<br>    Write_LCD(0, 1, “Hell0 World!”);&#x2F;&#x2F;在第一行第一个位置显示字符串<br>    DisplayOneChar(0,0,’P’);&#x2F;&#x2F;在指定位置显示一个字符<br>    DisplayOneChar(1,0,’e’);<br>    DisplayOneChar(2,0,’r’);<br>    DisplayOneChar(3,0,’s’);<br>    DisplayOneChar(4,0,’e’);<br>    DisplayOneChar(5,0,’v’);<br>    DisplayOneChar(6,0,’e’);<br>    DisplayOneChar(7,0,’r’);<br>    DisplayOneChar(8,0,’a’);<br>    DisplayOneChar(9,0,’n’);<br>    DisplayOneChar(10,0,’c’);<br>    DisplayOneChar(11,0,’e’);<br>        while(1);<br>}&#96;</p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1HVlULFfyv5-evyozXqWS6A </span><br><span class="line">提取码：149w</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1HVlULFfyv5-evyozXqWS6A  提取码：149w</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值</title>
      <link href="/2024/03/Stc15-STC15W408AS%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%9A%E8%BF%87ADC%E7%AB%AF%E5%8F%A3%E9%87%87%E9%9B%86%E6%A8%A1%E6%8B%9F%E9%87%8F%E5%B9%B6%E4%BB%8E%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E6%95%B0%E5%80%BC/"/>
      <url>/2024/03/Stc15-STC15W408AS%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%9A%E8%BF%87ADC%E7%AB%AF%E5%8F%A3%E9%87%87%E9%9B%86%E6%A8%A1%E6%8B%9F%E9%87%8F%E5%B9%B6%E4%BB%8E%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E6%95%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值"><a href="#STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值" class="headerlink" title="STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值"></a>STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值</h1><h3 id="STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值-1"><a href="#STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值-1" class="headerlink" title="STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值"></a>STC15W408AS单片机通过ADC端口采集模拟量并从串口打印数值</h3><ul><li>📺0-1023数据采集:</li><li>🔖STC15W408AS引脚功能图</li><li>📑STC15系列单片机的A&#x2F;D转换器</li><li>A&#x2F;D转换器的结构</li></ul><p>📺0-1023数据采集:</p><p><img src="https://img-blog.csdnimg.cn/bfacce81dbb648c8a93b2cda478bcf0d.gif#pic_center" alt="在这里插入图片描述"></p><p>🔖STC15W408AS引脚功能图</p><p><img src="https://img-blog.csdnimg.cn/69555f71b1bc49c0be28772c185ee0a9.png" alt="在这里插入图片描述"></p><p>📑STC15系列单片机的A&#x2F;D转换器</p><p><img src="https://img-blog.csdnimg.cn/214a8523fbdc48a9b9218c5288361161.png" alt="在这里插入图片描述"></p><p>A&#x2F;D转换器的结构</p><p><img src="https://img-blog.csdnimg.cn/f3062fd3d4da445da42ff8922a428656.png" alt="在这里插入图片描述"></p><p>STC15系列单片机ADC由多路选择开关、比较器、逐次比较寄存器、10位DAC、转换结果寄存器（ADC_RES和ADC_RESL）以及ADC_CONTR构成。 STC15系列单片机的ADC是逐次比较型ADC。逐次比较型ADC由一个比较器和D&#x2F;A转换器构成，通过逐次比较逻辑，从最高位（MSB）开始，顺序地对每一输入电压与内置D&#x2F;A转换器输出进行比较，经过多次比较，使转换所得的数字量逐次逼近输入模拟量对应值。逐次比较型A&#x2F;D转换器具有速度高，功耗低等优点。 从上图可以看出，通过模拟多路开关，将通过ADCO<del>7的模拟量输入送给比较器。用数 &#x2F;模转换器（DAC）转换的模拟量与输入的模拟量通过比较器进行比较，将比较结果保存到逐次比较寄存器，并通过逐次比较寄存器输出转换结果。A&#x2F;D转换结束后，最终的转换结果保存到ADC转换结果寄存器ADC_RES和ADC_RESL，同时，置位ADC控制寄存器ADC_CONTR中的A&#x2F;D转换结束标志位ADC_FLAG，以供程序查询或发出中断申请。模拟通道的选择控制由ADC控制寄存器ADC_CONTR中的CHS2</del>CHSO确定。ADC的转换速度由ADC控制寄存器中的SPEED1和SPEED0确定。在使用ADC之前，应先给ADC上电，也就是置位ADC控制寄存器中ADC_POWER位。</p><ul><li>当ADRJ&#x3D;0时，如果取10位结果，则按下面公式计算：</li><li>当ADRJ&#x3D;0时，如果取8位结果，按下面公式计算：</li><li>当ADRJ&#x3D;1时，如果取10位结果，则按下面公式计算：</li></ul><p><img src="https://img-blog.csdnimg.cn/3af37b5b7bd24af69c11b472235099f9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/38d6c52e05b24ea0a469ca1ea5411b79.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/5c255190f9cc4c25b8bb90a67fd35e18.png" alt="在这里插入图片描述"></p><p>式中，Vin为模拟输入通道输入电压，Vcc为单片机实际工作电压，用单片机工作电压作为模拟参考电压。</p><h4 id="与A-D转换相关的寄存器"><a href="#与A-D转换相关的寄存器" class="headerlink" title="与A&#x2F;D转换相关的寄存器"></a>与A&#x2F;D转换相关的寄存器</h4><p>与STC15系列单片机A&#x2F;D转换相关的寄存器列于下表所示:</p><p><img src="https://img-blog.csdnimg.cn/df7c7a0211ef45cd91198fe25050b582.png" alt="在这里插入图片描述"></p><ol><li>P1口模拟功能控制寄存器P1ASF</li></ol><p>STC15系列单片机的A&#x2F;D转换口在P1口（P1.7-P1.0），有8路10位高速A&#x2F;D转换器，速度可达到300KHz（30万次&#x2F;秒）。8路电压输入型A&#x2F;D，可做温度检测、电池电压检测、按键扫描、频谱检测等。上电复位后P1口为弱上拉型&#x2F;O口，用户可以通过软件设置将8路中的任何一路设置为A&#x2F;D转换，不需作为A&#x2F;D使用的P1口可继续作为I&#x2F;O口使用（建议只作为输入）。需作为A&#x2F;D使用的口需先将PlASF特殊功能寄存器中的相应位置为‘1’，将相应的口设置为模拟功能。PlASF寄存器的格式如下：</p><p>P1ASF:P1口模拟功能控制寄存器（该寄存器是只写寄存器，读无效）  2. ADC控制寄存器ADC_CONTR ADC_CONTR寄存器的格式如下： ADCCONTR:ADC控制寄存器  对ADCCONTR寄存器进行操作，建议直接用MOV赋值语句，不要用‘与’和‘或’语句。 ADC_POWER:ADC电源控制位。 0：关闭ADC电源； 1：打开A&#x2F;D转换器电源. 建议进入空闲模式和掉电模式前，将ADC电源关闭，即ADCPOWER&#x3D;0，可降低功耗。启动A&#x2F;D转换前一定要确认A&#x2F;D电源已打开，A&#x2F;D转换结束后关闭A&#x2F;D电源可降低功耗，也可不关闭。初次打开内部A&#x2F;D转换模拟电源，需适当延时，等内部模拟电源稳定后，再启动A&#x2F;D转换。 建议启动A&#x2F;D转换后，在A&#x2F;D转换结束之前，不改变任何I&#x2F;0口的状态，有利于高精度A&#x2F;D转换，如能将定时器&#x2F;串行口&#x2F;中断系统关闭更好。 SPEED1，SPEEDO：模数转换器转换速度控制位  ADCFLAG：模数转换器转换结束标志位，当A&#x2F;D转换完成后，ADCFLAG&#x3D;1，要由软件清0。 不管是A&#x2F;D转换完成后由该位申请产生中断，还是由软件查询该标志位A&#x2F;D转换是否结束，当A&#x2F;D转换完成后，ADC_FLAG&#x3D;1，一定要软件清0。 ADC_START：模数转换器（ADC）转换启动控制位，设置为“1”时，开始转换，转换结束后为0。 CHS2&#x2F;CHS1&#x2F;CHSO：模拟输入通道选择，CHS2&#x2F;CHS1&#x2F;CHSO  3. ADC转换结果调整寄存器位—ADRJ ADC转换结果调整寄存器位一—ADRJ位于寄存器CLK_DIV&#x2F;PCON中，用于控制ADC转换结果存放的位置。  ADRJ:ADC转换结果调整 0：ADCRES[7：01存放高8位ADC结果，ADCRESL[1：0]存放低2位ADC结果1：ADC_RES[1：0]存放高2位ADC结果，ADC_RESL[7：0]存放低8位ADC结果 4. A&#x2F;D转换结果寄存器ADC_RES、ADC_RESL特殊功能寄存器ADC_RES和ADC_RESL寄存器用于保存A&#x2F;D转换结果，其格式如下：  CKKO_DIV寄存器的ADRJ位是A&#x2F;D转换结果寄存器（ADC_RES，ADC_RESL）的数据格式调整控制位. 当ADRJ&#x3D;0时，10位A&#x2F;D转换结果的高8位存放在ADC_RES中，低2位存放在ADC_RESL的低2位中。  此时，如果需取完整10位结果，按下面公式计算：  如果用户只需取8位结果，按下面公式计算：  式中，Vin为模拟输入通道输入电压，Vcc为单片机实际工作电压，用单片机工作电压作为模拟参考电压。 当ADRJ&#x3D;1时，10位A&#x2F;D转换结果的高2位存放在ADC_RES的低2位中，低8位存放在ADC_RESL中。 此时，如果用户需取完整10位结果，按下面公式计算：</p><p><img src="https://img-blog.csdnimg.cn/912a48a9a4db4a27b079d1304c5e20c5.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/23b6970898534399a767dd6a64cbdb2c.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/415f7821fd3f4f9fb9f5b8e43734701e.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2b8362b4f13d41a4ad4f9eabacb8a8b8.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/5964df02cdf04e4db7be51027d15d43d.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/ad2d99e494da4b7aaf3d31a1f9e3703e.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/1da2524700364793a3758cd8c0f74c2f.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/657d073f65e84077a65ac669cb4b56a6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/3b8e679552ea457bb8d5f5f5d95a2799.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/18737ad3b6ff4945aaf4a121f15de7c4.png" alt="在这里插入图片描述"></p><p>式中，Vin为模拟输入通道输入电压，Vcc为单片机实际工作电压，用单片机工作电压作为模拟参考电压。</p><p><img src="https://img-blog.csdnimg.cn/a050a81568cf434db81a5df1ceeb35cd.png" alt="在这里插入图片描述"></p><p>以上资料来自STC单片机资料。</p><h4 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h4><p><img src="https://img-blog.csdnimg.cn/2ebf0a2ce20f40bba6b6a66a1df46928.png" alt="在这里插入图片描述"></p><ul><li>可调定位器接线图</li></ul><p><img src="https://img-blog.csdnimg.cn/b5d80a46e06d45a593e9d1791dc78db1.png" alt="在这里插入图片描述"></p><h4 id="主程序实例代码"><a href="#主程序实例代码" class="headerlink" title="主程序实例代码"></a>主程序实例代码</h4><ul><li>采集P1.4端口的模拟量数值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/*--------------------------------------------------------------------------------</span><br><span class="line"> * 项目名称:</span><br><span class="line"></span><br><span class="line">     AD模拟量采集测试程序 V1.0.0</span><br><span class="line"></span><br><span class="line"> * 功能描述:</span><br><span class="line"></span><br><span class="line">     1、采集ADC口的数据发送到串口显示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> * 配置说明:</span><br><span class="line">     MCU:             STC15W408AS</span><br><span class="line">     开发板:         STC15W408AS开发板</span><br><span class="line">     晶振:        内部时钟：11.0592MHz</span><br><span class="line">     扩展模块:    -</span><br><span class="line">     软件:            Keil.C51.V9.01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> * 备注:</span><br><span class="line">     - 将开发板的串口与电脑串口连接</span><br><span class="line">-------------------------------------------------------------------------------------*/</span><br><span class="line">/************************包含头文件***************************************************/</span><br><span class="line"></span><br><span class="line">#include&lt;STC15W.h&gt;</span><br><span class="line">#include&lt;USART.h&gt;</span><br><span class="line">#include&lt;ADC.h&gt;</span><br><span class="line"></span><br><span class="line">//定义要采集AD通道</span><br><span class="line">#define ch4//即P1.4端口</span><br><span class="line"></span><br><span class="line">//sfr P1M1 = 0x91;    //PxM1.n,PxM0.n     =00---&gt;Standard,    01---&gt;push-pull</span><br><span class="line">//sfr P1M0 = 0x92;    //                  =10---&gt;pure input,  11---&gt;open drain</span><br><span class="line"></span><br><span class="line">/************************主函数******************************************************/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int res=0;</span><br><span class="line">    unsigned char result[4]= &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    P1M1=0;</span><br><span class="line">    P1M0=0;</span><br><span class="line"></span><br><span class="line">    InitSerialPort(); //初始化串口,波特率9600，8bit数据位，1停止位，无校验</span><br><span class="line">    OpenADC_CHx(ch);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        //发送数据采集结果</span><br><span class="line">        SendByte(&#x27;\t&#x27;);</span><br><span class="line">        SendString(&quot;AD_Value = &quot;);</span><br><span class="line">        GetADCResult_Char(ch,result);</span><br><span class="line">        SendString(result);</span><br><span class="line">        //SendByte(GetADCResult_High(ch));</span><br><span class="line">        //SendByte(GetADCResult_Low(ch));</span><br><span class="line">        //换行</span><br><span class="line">        SendByte(&#x27;\n&#x27;);</span><br><span class="line">        //延时</span><br><span class="line">        Delay(30);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*********************************The End****************************************/</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*——————————————————————————–</p><ul><li><p>项目名称:</p><p>  AD模拟量采集测试程序 V1.0.0</p></li><li><p>功能描述:</p><p>  1、采集ADC口的数据发送到串口显示</p></li><li><p>配置说明:<br>  MCU:             STC15W408AS<br>  开发板:         STC15W408AS开发板<br>  晶振:        内部时钟：11.0592MHz<br>  扩展模块:    -<br>  软件:            Keil.C51.V9.01</p></li><li><p>备注:</p><ul><li>将开发板的串口与电脑串口连接<br>————————————————————————————-<em>&#x2F;<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>包含头文件</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>**************************&#x2F;</li></ul></li></ul><p>#include&lt;STC15W.h&gt;<br>#include&lt;USART.h&gt;<br>#include&lt;ADC.h&gt;</p><p>&#x2F;&#x2F;定义要采集AD通道<br>#define ch4&#x2F;&#x2F;即P1.4端口</p><p>&#x2F;&#x2F;sfr P1M1 &#x3D; 0x91;    &#x2F;&#x2F;PxM1.n,PxM0.n     &#x3D;00—&gt;Standard,    01—&gt;push-pull<br>&#x2F;&#x2F;sfr P1M0 &#x3D; 0x92;    &#x2F;&#x2F;                  &#x3D;10—&gt;pure input,  11—&gt;open drain</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>主函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>******************************&#x2F;<br>void main()<br>{<br>    unsigned int res&#x3D;0;<br>    unsigned char result[4]&#x3D; {0};</p><pre><code>P1M1=0;P1M0=0;InitSerialPort(); //初始化串口,波特率9600，8bit数据位，1停止位，无校验OpenADC_CHx(ch);while(1)&#123;    //发送数据采集结果    SendByte(&#39;\t&#39;);    SendString(&quot;AD_Value = &quot;);    GetADCResult_Char(ch,result);    SendString(result);    //SendByte(GetADCResult_High(ch));    //SendByte(GetADCResult_Low(ch));    //换行    SendByte(&#39;\n&#39;);    //延时    Delay(30);&#125;</code></pre><p>}<br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>The End</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>*******&#x2F;&#96;</p><h4 id="📚工程资源代码"><a href="#📚工程资源代码" class="headerlink" title="📚工程资源代码"></a>📚工程资源代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1eeBckMwQ0Lt1e9QMxYL4Jw </span><br><span class="line">提取码：ijc2</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1eeBckMwQ0Lt1e9QMxYL4Jw  提取码：ijc2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印</title>
      <link href="/2024/03/Stc15-STC15W408AS%E8%AF%BB%E5%8F%96DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6OLED%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/"/>
      <url>/2024/03/Stc15-STC15W408AS%E8%AF%BB%E5%8F%96DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6OLED%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印"><a href="#STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印" class="headerlink" title="STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印"></a>STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印</h1><h3 id="STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印-1"><a href="#STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印-1" class="headerlink" title="STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印"></a>STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印</h3><ul><li>📌相关篇《STC15W408AS读取DHT11温湿度+数据串口打印详解》</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121788606">STC15W408AS读取DHT11温湿度+数据串口打印详解</a></p><ul><li>只要读取到DHT11数据了，基本上只要解决的问题就是OLED驱动显示了。</li><li>本程序，没有阉割OLED的主要功能代码，保留原有的驱动显示函数，由于字库编译的容量有限，没有使用的函数做了注释，程序工程做到了0 error 0 warning！，可以作为IIC OLED驱动模板或者串口输出模板来使用，里面包含完整的OLED驱动显示函数，以及串口重映射printf函数打印，方便使用者移植到其他同类型单片机的工程项目当中，一个好的工程项目不仅用来学习，还应该向模板工程方向发展。</li></ul><p><code>0 error 0 warning！</code></p><p><code>printf</code></p><p><img src="https://img-blog.csdnimg.cn/93e89df25cbd47f5a9b13c2e61f7a50a.gif#pic_center" alt="在这里插入图片描述"></p><ul><li>📋串口输出打印</li></ul><p><img src="https://img-blog.csdnimg.cn/3a55afe09ae140e7a6f09242f919edee.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="汉字取模方式"><a href="#汉字取模方式" class="headerlink" title="汉字取模方式"></a>汉字取模方式</h4><p><img src="https://img-blog.csdnimg.cn/02d8fd181f624175a4f8720a6360e5de.png" alt="在这里插入图片描述"></p><h4 id="接线说明"><a href="#接线说明" class="headerlink" title="接线说明"></a>接线说明</h4><ul><li>4线 IIC OLED 0.96寸” 屏幕接线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//              GND    电源地</span><br><span class="line">//              VCC  接5V或3.3v电源</span><br><span class="line">//             IIC OLED 0.96寸&quot;  </span><br><span class="line">// P1^0 -----SCL</span><br><span class="line">//       P1^1 -----SDA</span><br></pre></td></tr></table></figure><p><code>//              GND    电源地 //              VCC  接5V或3.3v电源 //             IIC OLED 0.96寸&quot;   // P1^0 -----SCL //       P1^1 -----SDA</code></p><p>DHT11接线</p><p><img src="https://img-blog.csdnimg.cn/c325deb87b1c4d54bfb2d7d15e93be16.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1^4---DATA</span><br></pre></td></tr></table></figure><p><code>P1^4---DATA</code></p><h4 id="工程概览"><a href="#工程概览" class="headerlink" title="工程概览"></a>工程概览</h4><p><img src="https://img-blog.csdnimg.cn/d4be22c1c3f94a5696d83d8166b33d76.png" alt="在这里插入图片描述"></p><ul><li>编译信息</li></ul><p><img src="https://img-blog.csdnimg.cn/fa7cd2e9c4d140969977dea005f503f4.png" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">//#include &quot;string.h&quot;</span><br><span class="line">//#include &quot;stdarg.h&quot; </span><br><span class="line">#include&quot;USART1.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line">#include &quot;oled.h&quot;</span><br><span class="line">#define uint unsigned int </span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">/*************功能说明**************</span><br><span class="line"></span><br><span class="line">双串口全双工中断方式收发通讯程序。</span><br><span class="line"></span><br><span class="line">通过PC向MCU发送数据, MCU收到后通过串口把收到的数据原样返回.</span><br><span class="line"></span><br><span class="line">******************************************/</span><br><span class="line"></span><br><span class="line">/*************本地常量声明**************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sbit Temp_data = P1^4 ;</span><br><span class="line">sbit led = P1^5;//DHT响应指示灯</span><br><span class="line">sbit led2 = P1^6;//效验数据指示灯</span><br><span class="line">unsigned int  rec_dat[4];</span><br><span class="line"></span><br><span class="line">void DHT11_start();//DHT开始信号</span><br><span class="line">unsigned char DHT11_rec_byte();</span><br><span class="line">void DHT11_receive();</span><br><span class="line"></span><br><span class="line">/*************  外部函数和变量声明 *****************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*************  串口1初始化函数 *****************/</span><br><span class="line">voidUART_config(void)</span><br><span class="line">&#123;</span><br><span class="line">COMx_InitDefineCOMx_InitStructure;//结构定义</span><br><span class="line">COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;//模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span><br><span class="line">COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span><br><span class="line">COMx_InitStructure.UART_BaudRate  = 115200ul;//波特率, 一般 110 ~ 115200</span><br><span class="line">COMx_InitStructure.UART_RxEnable  = ENABLE;//接收允许,   ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.BaudRateDouble = DISABLE;//波特率加倍, ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.UART_Interrupt = ENABLE;//中断允许,   ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.UART_Polity    = PolityLow;//中断优先级, PolityLow,PolityHigh</span><br><span class="line">COMx_InitStructure.UART_P_SW      = UART1_SW_P30_P31;//切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17(必须使用内部时钟)</span><br><span class="line">COMx_InitStructure.UART_RXD_TXD_Short = DISABLE;//内部短路RXD与TXD, 做中继, ENABLE,DISABLE</span><br><span class="line">USART_Configuration(USART1, &amp;COMx_InitStructure);//初始化串口1 USART1,USART2</span><br><span class="line"></span><br><span class="line">PrintString1(&quot;STC15W408AS UART1 \r\n&quot;);//SUART1发送一个字符串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display()&#123;</span><br><span class="line">OLED_Clear();</span><br><span class="line">        OLED_ShowCHinese(18,0,0);//温湿度监测</span><br><span class="line">        OLED_ShowCHinese(36,0,1);//</span><br><span class="line">        OLED_ShowCHinese(54,0,2);//</span><br><span class="line">        OLED_ShowCHinese(72,0,3);//</span><br><span class="line">        OLED_ShowCHinese(90,0,4);//</span><br><span class="line"></span><br><span class="line">        OLED_ShowCHinese(15,3,0);</span><br><span class="line">        OLED_ShowCHinese(32,3,2);</span><br><span class="line"></span><br><span class="line">        OLED_ShowCHinese(15,5,1);</span><br><span class="line">        OLED_ShowCHinese(32,5,2);</span><br><span class="line">        OLED_ShowChar(50,3,&#x27;:&#x27;,16);</span><br><span class="line">        OLED_ShowChar(50,5,&#x27;:&#x27;,16);</span><br><span class="line">&#125;</span><br><span class="line">/**********************************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">float tem = 0.0,hum = 0.0;</span><br><span class="line"> unsigned char Tempbuf[5],Humbuf[5];</span><br><span class="line">led = 1;</span><br><span class="line">led2 = 1;</span><br><span class="line">UART_config();</span><br><span class="line">EA = 1;</span><br><span class="line">    OLED_Init();//初始化OLED</span><br><span class="line">    OLED_Clear();</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">delayms(150);</span><br><span class="line">        DHT11_receive();</span><br><span class="line">hum = rec_dat[0] + rec_dat[1]/10.0;//修订第一版显示精度问题</span><br><span class="line">tem = rec_dat[2] + rec_dat[3]/10.0;</span><br><span class="line"></span><br><span class="line">sprintf(Tempbuf, &quot;%3.1f&quot;,tem);</span><br><span class="line">sprintf(Humbuf, &quot;%2.0f %%&quot;, hum);</span><br><span class="line">display();</span><br><span class="line">OLED_ShowString(62,3,Tempbuf,16);//</span><br><span class="line">OLED_ShowCHinese(98,3,5);</span><br><span class="line">OLED_ShowString(62,5,Humbuf,16);</span><br><span class="line">/******串口打印******/ </span><br><span class="line">printf(&quot;温度:%3.1f ℃\r\n&quot;,tem);</span><br><span class="line">printf(&quot;湿度:%2.0f ％\r\n&quot;,hum);</span><br><span class="line"></span><br><span class="line">delayms(2000);</span><br><span class="line">led = 1;</span><br><span class="line">led2 = 1;</span><br><span class="line">OLED_Clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//DHT11起始信号</span><br><span class="line"></span><br><span class="line">void DHT11_start()</span><br><span class="line">&#123;</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(10);</span><br><span class="line">    Temp_data=0;</span><br><span class="line">     delayms(25);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(50);//MCU释放总线20~40us,需要在40微秒到100微秒之间</span><br><span class="line">//if(Temp_data==0)&#123;</span><br><span class="line">//led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line">// while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线,跳过ME</span><br><span class="line">       // Delayus(80);  //50拉高后延时80us</span><br><span class="line">// while(Temp_data==1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF</span><br><span class="line">//&#125;else&#123;led=1;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收一个字节</span><br><span class="line">unsigned char DHT11_rec_byte()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i,dat=0;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(!Temp_data);//跳过数据前段的50us</span><br><span class="line">Delayus(33);//过了数据0和数据1相同区域，再做检测      </span><br><span class="line">         dat &lt;&lt;=1;</span><br><span class="line">if(Temp_data==1)</span><br><span class="line">        &#123;//如果读到的数据是1</span><br><span class="line">  dat +=1;</span><br><span class="line">        &#125;</span><br><span class="line">while(Temp_data);</span><br><span class="line">    &#125;</span><br><span class="line">    return dat;</span><br><span class="line">&#125;</span><br><span class="line">//接收温湿度数据</span><br><span class="line">void DHT11_receive()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int R_H,R_L,T_H,T_L;</span><br><span class="line">    unsigned char RH,RL,TH,TL,revise;</span><br><span class="line">DHT11_start();</span><br><span class="line">    if(Temp_data==0)</span><br><span class="line">    &#123;led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line">while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线</span><br><span class="line">while(Temp_data==1); //等待DHT响应信号，80us内来拉低总线</span><br><span class="line">  </span><br><span class="line">      R_H=DHT11_rec_byte();    //接收湿度高八位</span><br><span class="line">        R_L=DHT11_rec_byte();    //接收湿度低八位</span><br><span class="line">        T_H=DHT11_rec_byte();    //接收温度高八位</span><br><span class="line">        T_L=DHT11_rec_byte();    //接收温度低八位</span><br><span class="line">        revise=DHT11_rec_byte(); //接收校正位</span><br><span class="line">        Delayus(25);    //结束</span><br><span class="line">/******串口打印******/</span><br><span class="line">printf(&quot;湿度: %d.%d%% 温度: %d.%d℃ \r\n&quot;,R_H,R_L,T_H,T_L);</span><br><span class="line">        if((R_H+R_L+T_H+T_L)==revise)      //校正</span><br><span class="line">        &#123;</span><br><span class="line">led2 = 0;</span><br><span class="line">            RH=R_H;</span><br><span class="line">            RL=R_L;</span><br><span class="line">            TH=T_H;</span><br><span class="line">            TL=T_L;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /*数据处理，方便显示*/</span><br><span class="line">        rec_dat[0]=RH;</span><br><span class="line">        rec_dat[1]=RL;</span><br><span class="line">        rec_dat[2]=TH;</span><br><span class="line">        rec_dat[3]=TL;</span><br><span class="line"></span><br><span class="line">  &#125;else&#123;led=1;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “stdio.h”<br>&#x2F;&#x2F;#include “string.h”<br>&#x2F;&#x2F;#include “stdarg.h”<br>#include“USART1.h”<br>#include“delay.h”<br>#include “oled.h”<br>#define uint unsigned int<br>#define uchar unsigned char</p><p>&#x2F;*************功能说明**************</p><p>双串口全双工中断方式收发通讯程序。</p><p>通过PC向MCU发送数据, MCU收到后通过串口把收到的数据原样返回.</p><p>******************************************&#x2F;</p><p>&#x2F;*************本地常量声明**************&#x2F;</p><p>sbit Temp_data &#x3D; P1^4 ;<br>sbit led &#x3D; P1^5;&#x2F;&#x2F;DHT响应指示灯<br>sbit led2 &#x3D; P1^6;&#x2F;&#x2F;效验数据指示灯<br>unsigned int  rec_dat[4];</p><p>void DHT11_start();&#x2F;&#x2F;DHT开始信号<br>unsigned char DHT11_rec_byte();<br>void DHT11_receive();</p><p>&#x2F;*************  外部函数和变量声明 *****************&#x2F;</p><p>&#x2F;*************  串口1初始化函数 *****************&#x2F;<br>voidUART_config(void)<br>{<br>    COMx_InitDefineCOMx_InitStructure;&#x2F;&#x2F;结构定义<br>    COMx_InitStructure.UART_Mode      &#x3D; UART_8bit_BRTx;&#x2F;&#x2F;模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx<br>    COMx_InitStructure.UART_BRT_Use   &#x3D; BRT_Timer2;&#x2F;&#x2F;使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)<br>    COMx_InitStructure.UART_BaudRate  &#x3D; 115200ul;&#x2F;&#x2F;波特率, 一般 110 ~ 115200<br>    COMx_InitStructure.UART_RxEnable  &#x3D; ENABLE;&#x2F;&#x2F;接收允许,   ENABLE或DISABLE<br>    COMx_InitStructure.BaudRateDouble &#x3D; DISABLE;&#x2F;&#x2F;波特率加倍, ENABLE或DISABLE<br>    COMx_InitStructure.UART_Interrupt &#x3D; ENABLE;&#x2F;&#x2F;中断允许,   ENABLE或DISABLE<br>    COMx_InitStructure.UART_Polity    &#x3D; PolityLow;&#x2F;&#x2F;中断优先级, PolityLow,PolityHigh<br>    COMx_InitStructure.UART_P_SW      &#x3D; UART1_SW_P30_P31;&#x2F;&#x2F;切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17(必须使用内部时钟)<br>    COMx_InitStructure.UART_RXD_TXD_Short &#x3D; DISABLE;&#x2F;&#x2F;内部短路RXD与TXD, 做中继, ENABLE,DISABLE<br>    USART_Configuration(USART1, &amp;COMx_InitStructure);&#x2F;&#x2F;初始化串口1 USART1,USART2</p><pre><code>PrintString1(&quot;STC15W408AS UART1 \r\n&quot;);//SUART1发送一个字符串</code></pre><p>}</p><p>void display(){<br>                OLED_Clear();<br>        OLED_ShowCHinese(18,0,0);&#x2F;&#x2F;温湿度监测<br>        OLED_ShowCHinese(36,0,1);&#x2F;&#x2F;<br>        OLED_ShowCHinese(54,0,2);&#x2F;&#x2F;<br>        OLED_ShowCHinese(72,0,3);&#x2F;&#x2F;<br>        OLED_ShowCHinese(90,0,4);&#x2F;&#x2F;</p><pre><code>    OLED_ShowCHinese(15,3,0);    OLED_ShowCHinese(32,3,2);    OLED_ShowCHinese(15,5,1);    OLED_ShowCHinese(32,5,2);    OLED_ShowChar(50,3,&#39;:&#39;,16);    OLED_ShowChar(50,5,&#39;:&#39;,16);</code></pre><p>}<br>&#x2F;**********************************************&#x2F;<br>void main(void)<br>{<br>    float tem &#x3D; 0.0,hum &#x3D; 0.0;<br> unsigned char Tempbuf[5],Humbuf[5];<br>    led &#x3D; 1;<br>    led2 &#x3D; 1;<br>    UART_config();<br>    EA &#x3D; 1;<br>    OLED_Init();&#x2F;&#x2F;初始化OLED<br>    OLED_Clear();<br>    while (1)<br>    {</p><pre><code>            delayms(150);    DHT11_receive();    hum = rec_dat[0] + rec_dat[1]/10.0;//修订第一版显示精度问题    tem = rec_dat[2] + rec_dat[3]/10.0;        sprintf(Tempbuf, &quot;%3.1f&quot;,tem);    sprintf(Humbuf, &quot;%2.0f %%&quot;, hum);    display();    OLED_ShowString(62,3,Tempbuf,16);//    OLED_ShowCHinese(98,3,5);    OLED_ShowString(62,5,Humbuf,16);        /******串口打印******/     printf(&quot;温度:%3.1f ℃\r\n&quot;,tem);    printf(&quot;湿度:%2.0f ％\r\n&quot;,hum);    delayms(2000);        led = 1;        led2 = 1;        OLED_Clear();&#125;</code></pre><p>}<br>&#x2F;&#x2F;DHT11起始信号</p><p>void DHT11_start()<br>{<br>    Temp_data&#x3D;1;<br>    Delayus(10);<br>    Temp_data&#x3D;0;<br>     delayms(25);&#x2F;&#x2F;这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据<br>    Temp_data&#x3D;1;<br>    Delayus(50);&#x2F;&#x2F;MCU释放总线20~40us,需要在40微秒到100微秒之间<br>&#x2F;&#x2F;if(Temp_data&#x3D;&#x3D;0){<br>&#x2F;&#x2F;led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>            &#x2F;&#x2F; while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线,跳过ME<br>       &#x2F;&#x2F; Delayus(80);  &#x2F;&#x2F;50拉高后延时80us<br>            &#x2F;&#x2F; while(Temp_data&#x3D;&#x3D;1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF<br>&#x2F;&#x2F;}else{led&#x3D;1;}</p><p>}</p><p>&#x2F;&#x2F;接收一个字节<br>unsigned char DHT11_rec_byte()<br>{<br>    unsigned char i,dat&#x3D;0;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>        while(!Temp_data);&#x2F;&#x2F;跳过数据前段的50us<br>                    Delayus(33);&#x2F;&#x2F;过了数据0和数据1相同区域，再做检测<br>         dat &lt;&lt;&#x3D;1;<br>            if(Temp_data&#x3D;&#x3D;1)<br>        {&#x2F;&#x2F;如果读到的数据是1<br>                      dat +&#x3D;1;<br>        }<br>            while(Temp_data);<br>    }<br>    return dat;<br>}<br>&#x2F;&#x2F;接收温湿度数据<br>void DHT11_receive()<br>{<br>    unsigned int R_H,R_L,T_H,T_L;<br>    unsigned char RH,RL,TH,TL,revise;<br>        DHT11_start();<br>        if(Temp_data&#x3D;&#x3D;0)<br>    {led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>            while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线<br>            while(Temp_data&#x3D;&#x3D;1); &#x2F;&#x2F;等待DHT响应信号，80us内来拉低总线</p><pre><code>  R_H=DHT11_rec_byte();    //接收湿度高八位    R_L=DHT11_rec_byte();    //接收湿度低八位    T_H=DHT11_rec_byte();    //接收温度高八位    T_L=DHT11_rec_byte();    //接收温度低八位    revise=DHT11_rec_byte(); //接收校正位    Delayus(25);    //结束            /******串口打印******/        printf(&quot;湿度: %d.%d%% 温度: %d.%d℃ \r\n&quot;,R_H,R_L,T_H,T_L);    if((R_H+R_L+T_H+T_L)==revise)      //校正    &#123;    led2 = 0;        RH=R_H;        RL=R_L;        TH=T_H;        TL=T_L;                    &#125;    /*数据处理，方便显示*/    rec_dat[0]=RH;    rec_dat[1]=RL;    rec_dat[2]=TH;    rec_dat[3]=TL;</code></pre><p>  }else{led&#x3D;1;}<br>}&#96;</p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/14T_vfAJNF3a4zg-YKNj-_w </span><br><span class="line">提取码：f0oi</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/14T_vfAJNF3a4zg-YKNj-_w  提取码：f0oi</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印【修订版】</title>
      <link href="/2024/03/Stc15-STC15W408AS%E8%AF%BB%E5%8F%96DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6OLED%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E4%BF%AE%E8%AE%A2%E7%89%88/"/>
      <url>/2024/03/Stc15-STC15W408AS%E8%AF%BB%E5%8F%96DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6OLED%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E4%BF%AE%E8%AE%A2%E7%89%88/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印【修订版】"><a href="#STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印【修订版】" class="headerlink" title="STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印【修订版】"></a>STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印【修订版】</h1><h3 id="STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印【修订版】-1"><a href="#STC15W408AS读取DHT11温湿度-OLED显示-数据串口打印【修订版】-1" class="headerlink" title="STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印【修订版】"></a>STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印【修订版】</h3><ul><li>📌相关篇《STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印》</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121798933">STC15W408AS读取DHT11温湿度+OLED显示+数据串口打印</a></p><p>✨该版本主要修正了温度显示精度问题。</p><p><img src="https://img-blog.csdnimg.cn/5a3f7c89739c4b0488423654e7ed1d14.gif#pic_center" alt="在这里插入图片描述"></p><ul><li>🌿所使用的单片机：STC15W408AS，</li><li>📍《【开源分享】自制STC15W408AS开发板》</li><li>🔖也可以自己去TB购买现成的开发板</li></ul><p><code>STC15W408AS</code></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/122150323">【开源分享】自制STC15W408AS开发板</a></p><p><img src="https://img-blog.csdnimg.cn/050febe37f7248c68980e36d856e1371.png" alt="在这里插入图片描述"></p><h4 id="⛳注意事项"><a href="#⛳注意事项" class="headerlink" title="⛳注意事项"></a>⛳注意事项</h4><ul><li>🌿所使用的晶振频率来自芯片内部的，频率是22.1184MHz，可以自行修改</li><li>🌿波特率默认设置的是：115200，也可以自行修改。</li><li>🌿获取传感器数据，是通过单总线的通讯协议读取的，读数据过程中，对通讯当中时间需要比较精准，否则读不到数据。如果自行调整频率，请注意通讯协议相关的代码是否有影响，请自行考虑和评估。</li><li>🌿一般涉及到通讯相关的数据获取对时间控制方面要求都是比较高的。</li></ul><p><img src="https://img-blog.csdnimg.cn/2dfd0456ed3f4c1a9797903764be1431.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="🛠接线说明"><a href="#🛠接线说明" class="headerlink" title="🛠接线说明"></a>🛠接线说明</h4><ul><li>4线 IIC OLED 0.96寸” 屏幕接线</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//              GND    电源地</span><br><span class="line">//              VCC  接5V或3.3v电源</span><br><span class="line">//             IIC OLED 0.96寸&quot;  </span><br><span class="line">// P1^0 -----SCL</span><br><span class="line">//       P1^1 -----SDA</span><br></pre></td></tr></table></figure><p><code>//              GND    电源地 //              VCC  接5V或3.3v电源 //             IIC OLED 0.96寸&quot;   // P1^0 -----SCL //       P1^1 -----SDA</code></p><ul><li>DHT11接线</li></ul><p><img src="https://img-blog.csdnimg.cn/c325deb87b1c4d54bfb2d7d15e93be16.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1^4---DATA</span><br></pre></td></tr></table></figure><p><code>P1^4---DATA</code></p><p><img src="https://img-blog.csdnimg.cn/288d28d6e0574f0381cbde160aaadea4.png" alt="在这里插入图片描述"></p><h4 id="📝主程序代码"><a href="#📝主程序代码" class="headerlink" title="📝主程序代码"></a>📝主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">//#include &quot;string.h&quot;</span><br><span class="line">//#include &quot;stdarg.h&quot; </span><br><span class="line">#include&quot;USART1.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line">#include &quot;oled.h&quot;</span><br><span class="line">#define uint unsigned int </span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">/*************本地常量声明**************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sbit Temp_data = P1^4 ;</span><br><span class="line">sbit led = P1^5;//DHT响应指示灯</span><br><span class="line">sbit led2 = P1^6;//效验数据指示灯</span><br><span class="line">unsigned int rec_dat[4];</span><br><span class="line"></span><br><span class="line">void DHT11_start();//DHT开始信号</span><br><span class="line">unsigned char DHT11_rec_byte();</span><br><span class="line">void DHT11_receive();</span><br><span class="line"></span><br><span class="line">/*************  外部函数和变量声明 *****************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*************  串口1初始化函数 *****************/</span><br><span class="line">voidUART_config(void)</span><br><span class="line">&#123;</span><br><span class="line">COMx_InitDefineCOMx_InitStructure;//结构定义</span><br><span class="line">COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;//模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span><br><span class="line">COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span><br><span class="line">COMx_InitStructure.UART_BaudRate  = 115200ul;//波特率, 一般 110 ~ 115200</span><br><span class="line">COMx_InitStructure.UART_RxEnable  = ENABLE;//接收允许,   ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.BaudRateDouble = DISABLE;//波特率加倍, ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.UART_Interrupt = ENABLE;//中断允许,   ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.UART_Polity    = PolityLow;//中断优先级, PolityLow,PolityHigh</span><br><span class="line">COMx_InitStructure.UART_P_SW      = UART1_SW_P30_P31;//切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17(必须使用内部时钟)</span><br><span class="line">COMx_InitStructure.UART_RXD_TXD_Short = DISABLE;//内部短路RXD与TXD, 做中继, ENABLE,DISABLE</span><br><span class="line">USART_Configuration(USART1, &amp;COMx_InitStructure);//初始化串口1 USART1,USART2</span><br><span class="line"></span><br><span class="line">PrintString1(&quot;STC15W408AS UART1 \r\n&quot;);//SUART1发送一个字符串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display()&#123;</span><br><span class="line">OLED_Clear();</span><br><span class="line">        OLED_ShowCHinese(18,0,0);//温湿度监测</span><br><span class="line">        OLED_ShowCHinese(36,0,1);//</span><br><span class="line">        OLED_ShowCHinese(54,0,2);//</span><br><span class="line">        OLED_ShowCHinese(72,0,3);//</span><br><span class="line">        OLED_ShowCHinese(90,0,4);//</span><br><span class="line"></span><br><span class="line">        OLED_ShowCHinese(15,3,0);</span><br><span class="line">        OLED_ShowCHinese(32,3,2);</span><br><span class="line"></span><br><span class="line">        OLED_ShowCHinese(15,5,1);</span><br><span class="line">        OLED_ShowCHinese(32,5,2);</span><br><span class="line">        OLED_ShowChar(50,3,&#x27;:&#x27;,16);</span><br><span class="line">        OLED_ShowChar(50,5,&#x27;:&#x27;,16);</span><br><span class="line">&#125;</span><br><span class="line">/**********************************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">//unsigned char i;</span><br><span class="line">float tem = 0.0,hum = 0.0;</span><br><span class="line"> unsigned char Tempbuf[5],Humbuf[5];</span><br><span class="line">led = 1;</span><br><span class="line">led2 = 1;</span><br><span class="line">UART_config();</span><br><span class="line">EA = 1;</span><br><span class="line">    OLED_Init();//初始化OLED</span><br><span class="line">    OLED_Clear();</span><br><span class="line">while (1)</span><br><span class="line">&#123;   </span><br><span class="line">delayms(150);</span><br><span class="line">        DHT11_receive();</span><br><span class="line"></span><br><span class="line">hum = rec_dat[0] + rec_dat[1]/10.0;</span><br><span class="line">tem = rec_dat[2] + rec_dat[3]/10.0;</span><br><span class="line">sprintf(Tempbuf, &quot;%3.1f&quot;,tem);</span><br><span class="line">sprintf(Humbuf, &quot;%2.0f %%&quot;, hum);</span><br><span class="line"></span><br><span class="line">display();</span><br><span class="line">OLED_ShowString(62,3,Tempbuf,16);//</span><br><span class="line">OLED_ShowCHinese(98,3,5);</span><br><span class="line">OLED_ShowString(62,5,Humbuf,16);</span><br><span class="line">/******串口打印******/</span><br><span class="line"></span><br><span class="line">printf(&quot;湿度: %d.%d%% 温度: %d.%d℃ \r\n&quot;,rec_dat[0],rec_dat[1],rec_dat[2],rec_dat[3]);</span><br><span class="line">delayms(2000);</span><br><span class="line">led = 1;</span><br><span class="line">led2 = 1;</span><br><span class="line">OLED_Clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//DHT11起始信号</span><br><span class="line"></span><br><span class="line">void DHT11_start()</span><br><span class="line">&#123;</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(10);</span><br><span class="line">    Temp_data=0;</span><br><span class="line">     delayms(25);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(50);//MCU释放总线20~40us,需要在40微秒到100微秒之间</span><br><span class="line">//if(Temp_data==0)&#123;</span><br><span class="line">//led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line">// while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线,跳过ME</span><br><span class="line">       // Delayus(80);  //50拉高后延时80us</span><br><span class="line">// while(Temp_data==1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF</span><br><span class="line">//&#125;else&#123;led=1;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收一个字节</span><br><span class="line">unsigned char DHT11_rec_byte()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i,dat=0;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(!Temp_data);//跳过数据前段的50us</span><br><span class="line">Delayus(33);//过了数据0和数据1相同区域，再做检测      </span><br><span class="line">         dat &lt;&lt;=1;</span><br><span class="line">if(Temp_data==1)</span><br><span class="line">        &#123;//如果读到的数据是1</span><br><span class="line">  dat +=1;</span><br><span class="line">        &#125;</span><br><span class="line">while(Temp_data);</span><br><span class="line">    &#125;</span><br><span class="line">    return dat;</span><br><span class="line">&#125;</span><br><span class="line">//接收温湿度数据</span><br><span class="line">void DHT11_receive()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int R_H,R_L,T_H,T_L;</span><br><span class="line">    unsigned char RH,RL,TH,TL,revise;</span><br><span class="line">DHT11_start();</span><br><span class="line">    if(Temp_data==0)</span><br><span class="line">    &#123;led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line">while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线</span><br><span class="line">while(Temp_data==1); //等待DHT响应信号，80us内来拉低总线</span><br><span class="line">  </span><br><span class="line">        R_H=DHT11_rec_byte();    //接收湿度高八位</span><br><span class="line">        R_L=DHT11_rec_byte();    //接收湿度低八位</span><br><span class="line">        T_H=DHT11_rec_byte();    //接收温度高八位</span><br><span class="line">        T_L=DHT11_rec_byte();    //接收温度低八位</span><br><span class="line">        revise=DHT11_rec_byte(); //接收校正位</span><br><span class="line">        Delayus(25);    //结束</span><br><span class="line">/******串口打印******/</span><br><span class="line">//printf(&quot;湿度: %d.%d%% 温度: %d.%d℃ \r\n&quot;,R_H,R_L,T_H,T_L);</span><br><span class="line"></span><br><span class="line">        if((R_H+R_L+T_H+T_L)==revise)      //校正</span><br><span class="line">        &#123;</span><br><span class="line"> led2 = 0;</span><br><span class="line">            RH=R_H;</span><br><span class="line">            RL=R_L;</span><br><span class="line">            TH=T_H;</span><br><span class="line">            TL=T_L;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /*数据处理，方便显示*/</span><br><span class="line">        rec_dat[0]=RH;</span><br><span class="line">        rec_dat[1]=RL;</span><br><span class="line">        rec_dat[2]=TH;</span><br><span class="line">        rec_dat[3]=TL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;else&#123;led=1;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “stdio.h”<br>&#x2F;&#x2F;#include “string.h”<br>&#x2F;&#x2F;#include “stdarg.h”<br>#include“USART1.h”<br>#include“delay.h”<br>#include “oled.h”<br>#define uint unsigned int<br>#define uchar unsigned char</p><p>&#x2F;*************本地常量声明**************&#x2F;</p><p>sbit Temp_data &#x3D; P1^4 ;<br>sbit led &#x3D; P1^5;&#x2F;&#x2F;DHT响应指示灯<br>sbit led2 &#x3D; P1^6;&#x2F;&#x2F;效验数据指示灯<br>unsigned int rec_dat[4];</p><p>void DHT11_start();&#x2F;&#x2F;DHT开始信号<br>unsigned char DHT11_rec_byte();<br>void DHT11_receive();</p><p>&#x2F;*************  外部函数和变量声明 *****************&#x2F;</p><p>&#x2F;*************  串口1初始化函数 *****************&#x2F;<br>voidUART_config(void)<br>{<br>    COMx_InitDefineCOMx_InitStructure;&#x2F;&#x2F;结构定义<br>    COMx_InitStructure.UART_Mode      &#x3D; UART_8bit_BRTx;&#x2F;&#x2F;模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx<br>    COMx_InitStructure.UART_BRT_Use   &#x3D; BRT_Timer2;&#x2F;&#x2F;使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)<br>    COMx_InitStructure.UART_BaudRate  &#x3D; 115200ul;&#x2F;&#x2F;波特率, 一般 110 ~ 115200<br>    COMx_InitStructure.UART_RxEnable  &#x3D; ENABLE;&#x2F;&#x2F;接收允许,   ENABLE或DISABLE<br>    COMx_InitStructure.BaudRateDouble &#x3D; DISABLE;&#x2F;&#x2F;波特率加倍, ENABLE或DISABLE<br>    COMx_InitStructure.UART_Interrupt &#x3D; ENABLE;&#x2F;&#x2F;中断允许,   ENABLE或DISABLE<br>    COMx_InitStructure.UART_Polity    &#x3D; PolityLow;&#x2F;&#x2F;中断优先级, PolityLow,PolityHigh<br>    COMx_InitStructure.UART_P_SW      &#x3D; UART1_SW_P30_P31;&#x2F;&#x2F;切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17(必须使用内部时钟)<br>    COMx_InitStructure.UART_RXD_TXD_Short &#x3D; DISABLE;&#x2F;&#x2F;内部短路RXD与TXD, 做中继, ENABLE,DISABLE<br>    USART_Configuration(USART1, &amp;COMx_InitStructure);&#x2F;&#x2F;初始化串口1 USART1,USART2</p><pre><code>PrintString1(&quot;STC15W408AS UART1 \r\n&quot;);//SUART1发送一个字符串</code></pre><p>}</p><p>void display(){<br>                OLED_Clear();<br>        OLED_ShowCHinese(18,0,0);&#x2F;&#x2F;温湿度监测<br>        OLED_ShowCHinese(36,0,1);&#x2F;&#x2F;<br>        OLED_ShowCHinese(54,0,2);&#x2F;&#x2F;<br>        OLED_ShowCHinese(72,0,3);&#x2F;&#x2F;<br>        OLED_ShowCHinese(90,0,4);&#x2F;&#x2F;</p><pre><code>    OLED_ShowCHinese(15,3,0);    OLED_ShowCHinese(32,3,2);    OLED_ShowCHinese(15,5,1);    OLED_ShowCHinese(32,5,2);    OLED_ShowChar(50,3,&#39;:&#39;,16);    OLED_ShowChar(50,5,&#39;:&#39;,16);</code></pre><p>}<br>&#x2F;**********************************************&#x2F;<br>void main(void)<br>{<br>    &#x2F;&#x2F;unsigned char i;<br>    float tem &#x3D; 0.0,hum &#x3D; 0.0;<br> unsigned char Tempbuf[5],Humbuf[5];<br>    led &#x3D; 1;<br>    led2 &#x3D; 1;<br>    UART_config();<br>    EA &#x3D; 1;<br>    OLED_Init();&#x2F;&#x2F;初始化OLED<br>    OLED_Clear();<br>    while (1)<br>    {<br>                delayms(150);<br>        DHT11_receive();</p><pre><code>    hum = rec_dat[0] + rec_dat[1]/10.0;    tem = rec_dat[2] + rec_dat[3]/10.0;    sprintf(Tempbuf, &quot;%3.1f&quot;,tem);    sprintf(Humbuf, &quot;%2.0f %%&quot;, hum);    display();    OLED_ShowString(62,3,Tempbuf,16);//    OLED_ShowCHinese(98,3,5);    OLED_ShowString(62,5,Humbuf,16);        /******串口打印******/</code></pre><p>printf(“湿度: %d.%d%% 温度: %d.%d℃ \r\n”,rec_dat[0],rec_dat[1],rec_dat[2],rec_dat[3]);<br>                delayms(2000);<br>            led &#x3D; 1;<br>            led2 &#x3D; 1;<br>            OLED_Clear();</p><pre><code>&#125;</code></pre><p>}<br>&#x2F;&#x2F;DHT11起始信号</p><p>void DHT11_start()<br>{<br>    Temp_data&#x3D;1;<br>    Delayus(10);<br>    Temp_data&#x3D;0;<br>     delayms(25);&#x2F;&#x2F;这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据<br>    Temp_data&#x3D;1;<br>    Delayus(50);&#x2F;&#x2F;MCU释放总线20~40us,需要在40微秒到100微秒之间<br>&#x2F;&#x2F;if(Temp_data&#x3D;&#x3D;0){<br>&#x2F;&#x2F;led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>            &#x2F;&#x2F; while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线,跳过ME<br>       &#x2F;&#x2F; Delayus(80);  &#x2F;&#x2F;50拉高后延时80us<br>            &#x2F;&#x2F; while(Temp_data&#x3D;&#x3D;1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF<br>&#x2F;&#x2F;}else{led&#x3D;1;}</p><p>}</p><p>&#x2F;&#x2F;接收一个字节<br>unsigned char DHT11_rec_byte()<br>{<br>    unsigned char i,dat&#x3D;0;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>        while(!Temp_data);&#x2F;&#x2F;跳过数据前段的50us<br>                    Delayus(33);&#x2F;&#x2F;过了数据0和数据1相同区域，再做检测<br>         dat &lt;&lt;&#x3D;1;<br>            if(Temp_data&#x3D;&#x3D;1)<br>        {&#x2F;&#x2F;如果读到的数据是1<br>                      dat +&#x3D;1;<br>        }<br>            while(Temp_data);<br>    }<br>    return dat;<br>}<br>&#x2F;&#x2F;接收温湿度数据<br>void DHT11_receive()<br>{<br>    unsigned int R_H,R_L,T_H,T_L;<br>    unsigned char RH,RL,TH,TL,revise;<br>        DHT11_start();<br>        if(Temp_data&#x3D;&#x3D;0)<br>    {led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>            while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线<br>            while(Temp_data&#x3D;&#x3D;1); &#x2F;&#x2F;等待DHT响应信号，80us内来拉低总线</p><pre><code>    R_H=DHT11_rec_byte();    //接收湿度高八位    R_L=DHT11_rec_byte();    //接收湿度低八位    T_H=DHT11_rec_byte();    //接收温度高八位    T_L=DHT11_rec_byte();    //接收温度低八位    revise=DHT11_rec_byte(); //接收校正位    Delayus(25);    //结束            /******串口打印******/</code></pre><p>&#x2F;&#x2F;printf(“湿度: %d.%d%% 温度: %d.%d℃ \r\n”,R_H,R_L,T_H,T_L);</p><pre><code>    if((R_H+R_L+T_H+T_L)==revise)      //校正    &#123;         led2 = 0;        RH=R_H;        RL=R_L;        TH=T_H;        TL=T_L;            &#125;    /*数据处理，方便显示*/    rec_dat[0]=RH;    rec_dat[1]=RL;    rec_dat[2]=TH;    rec_dat[3]=TL;            </code></pre><p>  }else{led&#x3D;1;}<br>}&#96;</p><ul><li>修订内容和时间（2022-5-10）</li></ul><p>对于printf打印输出，进行调整。 具体细节参考《printf函数在Keil 开发C51单片机当中的使用细节》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/124656745">printf函数在Keil 开发C51单片机当中的使用细节</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;DHT11 TEMP:%02bd.%02bd;Hum:%02bd.%02bd \n&quot;, rec_dat[0], rec_dat[1], rec_dat[2], rec_dat[3]);</span><br><span class="line"></span><br><span class="line">/******串口打印******/ </span><br><span class="line">printf(&quot;温度:%g℃\r\n&quot;,tem);</span><br><span class="line">printf(&quot;湿度:%g％\r\n&quot;,hum);</span><br></pre></td></tr></table></figure><p>&#96;printf(“DHT11 TEMP:%02bd.%02bd;Hum:%02bd.%02bd \n”, rec_dat[0], rec_dat[1], rec_dat[2], rec_dat[3]);</p><pre><code>        /******串口打印******/     printf(&quot;温度:%g℃\r\n&quot;,tem);    printf(&quot;湿度:%g％\r\n&quot;,hum);`</code></pre><h4 id="📚程序源码"><a href="#📚程序源码" class="headerlink" title="📚程序源码"></a>📚程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1Y-tt0B5LF2tccMheX0RRxQ </span><br><span class="line">提取码：139y</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1Y-tt0B5LF2tccMheX0RRxQ  提取码：139y</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TM1638芯片的显存地址详细解读</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-TM1638%E8%8A%AF%E7%89%87%E7%9A%84%E6%98%BE%E5%AD%98%E5%9C%B0%E5%9D%80%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-TM1638%E8%8A%AF%E7%89%87%E7%9A%84%E6%98%BE%E5%AD%98%E5%9C%B0%E5%9D%80%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="TM1638芯片的显存地址详细解读"><a href="#TM1638芯片的显存地址详细解读" class="headerlink" title="TM1638芯片的显存地址详细解读"></a>TM1638芯片的显存地址详细解读</h1><h3 id="TM1638芯片的显存地址详细解读-1"><a href="#TM1638芯片的显存地址详细解读-1" class="headerlink" title="TM1638芯片的显存地址详细解读"></a>TM1638芯片的显存地址详细解读</h3><ul><li>相关篇《Arduino UNO 利用3个IO口 + TM1638+驱动8位数码管显示+24个独立按键》</li><li>《51单片机驱动TM1638芯片+Proteus仿真》</li><li>《Arduino UNO + DS1302 + TM1638时间显示+Proteus仿真二》</li><li>《Arduino UNO + DS1302 + TM1638时间显示+Proteus仿真》</li><li>驱动8位共阴数码管仿真</li><li>驱动独立的24个按键并显示仿真</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121914458">Arduino UNO 利用3个IO口 + TM1638+驱动8位数码管显示+24个独立按键</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121942355">51单片机驱动TM1638芯片+Proteus仿真</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121881461">Arduino UNO + DS1302 + TM1638时间显示+Proteus仿真二</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121879483">Arduino UNO + DS1302 + TM1638时间显示+Proteus仿真</a></p><p><img src="https://img-blog.csdnimg.cn/990da67ce57d43b4aed0405903acb991.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fdd8a9c2d8b141ef820018ed5e591df7.gif#pic_center#pic_center" alt="在这里插入图片描述"></p><p>这一篇单独来讲驱动剩余的两组SEG8-SEG9两个IO口驱动2X8LED灯。</p><p><code>2X8</code></p><ul><li>电路连接图</li></ul><p><img src="https://img-blog.csdnimg.cn/76dd3703358a4e0abdaf8826622b83fe.png" alt="在这里插入图片描述"></p><h4 id="回到TM1638数据手册看对应部分的内容"><a href="#回到TM1638数据手册看对应部分的内容" class="headerlink" title="回到TM1638数据手册看对应部分的内容"></a>回到TM1638数据手册看对应部分的内容</h4><p>需要单独点亮LED灯，需要利用固定地址模式给指定的地址写数据。</p><h5 id="固定地址模式"><a href="#固定地址模式" class="headerlink" title="固定地址模式"></a>固定地址模式</h5><p>使用固定地址模式，设置地址其实际上是设置需要传送的1BYTE数据存放的地址。地址发送完 毕，“STB”不需要置高，紧跟着传1BYTE数据，数据传送完毕才将“STB”置高。然后重新设置第2 个数据需要存放的地址，最多14BYTE数据传送完毕，“STB”置高。</p><ul><li>固定地址模式下通讯时序图</li><li>流程图</li></ul><p><img src="https://img-blog.csdnimg.cn/92b9f75382ab48a898a4cae125132c9e.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/e6a0df74ff394a5cb2efee1d2e4733f8.png" alt="在这里插入图片描述"></p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li>初始化部分，设置写显存的数据命令，如果是采用地址自动加 1，那么初始地址就是0x40,</li></ol><p><code>0x40</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Write_COM(unsigned char cmd)//发送命令字</span><br><span class="line">&#123;</span><br><span class="line">STB=0;</span><br><span class="line">TM1638_Write(cmd);</span><br><span class="line">STB=1;</span><br><span class="line">&#125;</span><br><span class="line">//TM1638初始化函数</span><br><span class="line">void init_TM1638(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">Write_COM(0x8b);       //亮度 (0x88-0x8f)8级亮度可调</span><br><span class="line">Write_COM(0x40);       //采用地址自动加1</span><br><span class="line">STB=0;           //</span><br><span class="line">TM1638_Write(0xc0);    //设置起始地址</span><br><span class="line">for(i=0;i&lt;16;i++)   //传送16个字节的数据0x00-0x0f</span><br><span class="line">TM1638_Write(0x00);</span><br><span class="line">STB=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void Write_COM(unsigned char cmd)//发送命令字 &#123;     STB=0;     TM1638_Write(cmd);     STB=1; &#125; //TM1638初始化函数 void init_TM1638(void) &#123;     unsigned char i;     Write_COM(0x8b);       //亮度 (0x88-0x8f)8级亮度可调     Write_COM(0x40);       //采用地址自动加1     STB=0;           //     TM1638_Write(0xc0);    //设置起始地址     for(i=0;i&lt;16;i++)   //传送16个字节的数据0x00-0x0f     TM1638_Write(0x00);     STB=1; &#125;</code></p><p>2.设置显示模式：固定模式，写指定地址用来点亮对应的LED灯</p><p>这里要说明一下，写法有很多，根据个人喜好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*****指定地址写入数据*******/</span><br><span class="line">void Write_DATA(unsigned char addr,unsigned char DATA)//指定地址写入数据</span><br><span class="line">&#123;</span><br><span class="line">Write_COM(0x44);//设置写显存的数据命令,采用固定地址</span><br><span class="line">STB=0;</span><br><span class="line">TM1638_Write(0xc0|addr);C0起始地址+led位置地址</span><br><span class="line">_nop_();</span><br><span class="line">TM1638_Write(DATA);</span><br><span class="line">STB=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/*****指定地址写入数据*******/ void Write_DATA(unsigned char addr,unsigned char DATA)//指定地址写入数据 &#123;     Write_COM(0x44);//设置写显存的数据命令,采用固定地址     STB=0;     TM1638_Write(0xc0|addr);C0起始地址+led位置地址     _nop_();     TM1638_Write(DATA);     STB=1; &#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*****固定地址传送*******/</span><br><span class="line">void TM1638_display_Fix(unsigned char add,unsigned char DATA)</span><br><span class="line">&#123;//固定地址传送</span><br><span class="line">Write_COM(0X44);</span><br><span class="line">STB=0;</span><br><span class="line">TM1638_Write(0xC0+2*add);</span><br><span class="line">_nop_();</span><br><span class="line">TM1638_Write(buff[DATA]);</span><br><span class="line">STB=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/*****固定地址传送*******/ void TM1638_display_Fix(unsigned char add,unsigned char DATA) &#123;//固定地址传送     Write_COM(0X44);     STB=0;     TM1638_Write(0xC0+2*add);         _nop_();     TM1638_Write(buff[DATA]);     STB=1; &#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Write_oneLED(unsigned char num,unsigned char flag)//单独控制一个LED函数，num为需要控制的led序号，flag为0时熄灭，不为0时点亮</span><br><span class="line">&#123;</span><br><span class="line">unsigned char TM1638_Addr_LED[8]= &#123;0xc1,0xC3,0xC5,0xC7,0xC9,0xCB,0xCD,0xCF&#125;; //模块从右到左的八个发光二极管</span><br><span class="line">Write_COM(0x44);</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">Write_COM(0x44);//设置写显存的数据命令,采用固定地址</span><br><span class="line">STB=0;</span><br><span class="line">TM1638_Write(TM1638_Addr_LED[num]);//C0起始地址，</span><br><span class="line">TM1638_Write(flag);</span><br><span class="line">STB=1;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">Write_COM(0x44);//设置写显存的数据命令,采用固定地址</span><br><span class="line">STB=0;</span><br><span class="line">TM1638_Write(TM1638_Addr_LED[num]);//C0起始地址，</span><br><span class="line">TM1638_Write(flag);</span><br><span class="line">STB=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void Write_oneLED(unsigned char num,unsigned char flag)//单独控制一个LED函数，num为需要控制的led序号，flag为0时熄灭，不为0时点亮 &#123; unsigned char TM1638_Addr_LED[8]= &#123;0xc1,0xC3,0xC5,0xC7,0xC9,0xCB,0xCD,0xCF&#125;; //模块从右到左的八个发光二极管     Write_COM(0x44);     if(flag)     &#123;     Write_COM(0x44);//设置写显存的数据命令,采用固定地址     STB=0;     TM1638_Write(TM1638_Addr_LED[num]);//C0起始地址，     TM1638_Write(flag);     STB=1;     &#125;     else&#123;     Write_COM(0x44);//设置写显存的数据命令,采用固定地址     STB=0;     TM1638_Write(TM1638_Addr_LED[num]);//C0起始地址，     TM1638_Write(flag);     STB=1;     &#125; &#125;</code></p><ul><li>8个led的地址，依次为led1-led8</li><li>unsigned char TM1638_Addr_LED[8]&#x3D; {0xc1,0xC3,0xC5,0xC7,0xC9,0xCB,0xCD,0xCF};</li></ul><p><code>unsigned char TM1638_Addr_LED[8]= &#123;0xc1,0xC3,0xC5,0xC7,0xC9,0xCB,0xCD,0xCF&#125;;</code></p><p>解析：为什么地址不是0x01,从上面的流程图上第三步，可以看到设置初始化地址位设置起始地 址 ：0xC0,再依据下面的赌赢关系我们可以推测，指定LED灯的具体地址：初始地址0xC0 + LED地址</p><p><code>0x01</code></p><p><code>0xC0</code></p><p><code>0xC0</code></p><p><code>LED地址</code></p><ul><li>初始地址0xC0 + 0x01,0x03,0x05,0x07,0x09,0x0B,0x0D,0x0F,也就是上面的数组。</li></ul><p><code>0xC0 + 0x01</code></p><p><code>0x03</code></p><p><code>0x05</code></p><p><code>0x07</code></p><p><code>0x09</code></p><p><code>0x0B</code></p><p><code>0x0D</code></p><p><code>0x0F</code></p><p><img src="https://img-blog.csdnimg.cn/439b1abf001445dfa28d61072b216006.png" alt="在这里插入图片描述"></p><ul><li>找到了地址后，现在就是写值。组一（SEG9）,和组二（SEG10）</li><li>SEG9LED灯</li><li>SEG9LED灯</li><li>参照下图：点亮LED1-LED8，那么只需要写B0的bit位写0x01即可。0000 0001（依照下面的bit位排列顺序）</li><li>同理，SEG10这组的LED1-LED8，那么只需要写0x02即可。0000 0010，（依照下面的bit位排列顺序）</li><li>同理，SEG10这组的LED1-LED8，那么只需要写0x02即可。0000 0010，（依照下面的bit位排列顺序）</li></ul><p>找到了地址后，现在就是写值。组一（SEG9）,和组二（SEG10）</p><ul><li>SEG9LED灯</li></ul><p><code>SEG9</code></p><p><img src="https://img-blog.csdnimg.cn/a778e984891e419ea96ae2507be47b3d.png" alt="在这里插入图片描述"></p><p>参照下图：点亮LED1-LED8，那么只需要写B0的bit位写0x01即可。0000 0001（依照下面的bit位排列顺序）</p><p><code>LED1-LED8</code></p><p><code>0x01</code></p><p><code>0000 0001</code></p><p><img src="https://img-blog.csdnimg.cn/4afeb71567014d2ea2d1193865adc1da.png" alt="在这里插入图片描述"></p><ul><li>同理，SEG10这组的LED1-LED8，那么只需要写0x02即可。0000 0010，（依照下面的bit位排列顺序）</li></ul><p><code>SEG10</code></p><p><code>LED1-LED8</code></p><p><code>0x02</code></p><p><code>0000 0010</code></p><p><img src="https://img-blog.csdnimg.cn/bb42bf5fc29b4cfa9a64dad61867a5e0.png" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;REGX51.H&gt;</span><br><span class="line">#include&lt;tm1638.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">unsigned char num[8];//各个数码管显示的值</span><br><span class="line">//8个led的地址，依次为led1-led8</span><br><span class="line">const unsigned char TM1638_LedAddrTab[] =</span><br><span class="line">&#123;</span><br><span class="line">0xC1,0xC3,0xC5,0xC7,0xC9,0xCB,0xCD,0xCF</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">init_TM1638();                           //初始化TM1638</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">Write_DATA(2*i,tab[16]);//初始化寄存器,显示&quot;--- ----&quot;</span><br><span class="line">Delay1000ms();</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">for(i=0;i&lt;8;i++)&#123;//LED灯闪烁</span><br><span class="line">Write_oneLED(i,1);//0-7位置.1对应SEG9的LED灯</span><br><span class="line"> Write_oneLED(i,2);//0-7位置.2对应SEG10的LED灯</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">for(i=0;i&lt;8;i++)&#123;//显示01234567</span><br><span class="line">Write_DATA(2*i,tab[i]);Delay1000ms();&#125;</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;8;i++)&#123;//显示带点的01234567</span><br><span class="line">TM1638_display_Fix(i,18-i);Delay1000ms();&#125;</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">Write_DATA(2*i,tab[17]);//初始化寄存器,熄灭</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include&lt;REGX51.H&gt;<br>#include&lt;tm1638.h&gt;<br>#include&lt;intrins.h&gt;<br>unsigned char num[8];&#x2F;&#x2F;各个数码管显示的值<br>&#x2F;&#x2F;8个led的地址，依次为led1-led8<br>const unsigned char TM1638_LedAddrTab[] &#x3D;<br>{<br>    0xC1,0xC3,0xC5,0xC7,0xC9,0xCB,0xCD,0xCF<br>};<br>int main(void)<br>{<br>    unsigned char i;<br>    init_TM1638();                           &#x2F;&#x2F;初始化TM1638<br>    for(i&#x3D;0;i&lt;8;i++)<br>    Write_DATA(2*i,tab[16]);&#x2F;&#x2F;初始化寄存器,显示”— —-“<br>    Delay1000ms();</p><pre><code>while(1)&#123;        for(i=0;i&lt;8;i++)&#123;//LED灯闪烁Write_oneLED(i,1);//0-7位置.1对应SEG9的LED灯 Write_oneLED(i,2);//0-7位置.2对应SEG10的LED灯        &#125;</code></pre><p>&#x2F;*<br>            for(i&#x3D;0;i&lt;8;i++){&#x2F;&#x2F;显示01234567<br>    Write_DATA(2*i,tab[i]);Delay1000ms();}</p><pre><code>for(i=0;i&lt;8;i++)&#123;//显示带点的01234567TM1638_display_Fix(i,18-i);Delay1000ms();&#125;            for(i=0;i&lt;8;i++)Write_DATA(2*i,tab[17]);//初始化寄存器,熄灭</code></pre><p>*&#x2F;<br>}<br>}&#96;</p><p><img src="https://img-blog.csdnimg.cn/53629b0a5bed453e9668b2a722b4f7e6.gif#pic_center" alt="在这里插入图片描述"></p><h5 id="到这里为止，围绕TM1638芯片基本功能都已经做完了除了共阳数码管的驱动。在此过程中，全靠自己不断采坑摸索和总结。"><a href="#到这里为止，围绕TM1638芯片基本功能都已经做完了除了共阳数码管的驱动。在此过程中，全靠自己不断采坑摸索和总结。" class="headerlink" title="到这里为止，围绕TM1638芯片基本功能都已经做完了除了共阳数码管的驱动。在此过程中，全靠自己不断采坑摸索和总结。"></a>到这里为止，围绕TM1638芯片基本功能都已经做完了除了共阳数码管的驱动。在此过程中，全靠自己不断采坑摸索和总结。</h5><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1bvGm7squ7-1ejPGEaHfQXA </span><br><span class="line">提取码：dt68</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1bvGm7squ7-1ejPGEaHfQXA  提取码：dt68</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FDHT11%E5%92%8C%E5%AE%9E%E9%99%85%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%AE%E5%BC%82%E4%BB%A5%E5%8F%8A%E8%AF%BB%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FDHT11%E5%92%8C%E5%AE%9E%E9%99%85%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%AE%E5%BC%82%E4%BB%A5%E5%8F%8A%E8%AF%BB%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析"><a href="#Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析" class="headerlink" title="Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析"></a>Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析</h1><h3 id="Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析-1"><a href="#Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析-1" class="headerlink" title="Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析"></a>Proteus仿真DHT11和实际硬件的差异以及读不到数据原因分析</h3><p><img src="https://img-blog.csdnimg.cn/061dc02343c7436e977c3cc49f6ccc77.png" alt="在这里插入图片描述"></p><p>在Proteus仿真里面，仿真LCD1602显示DHT11数据，发现不能显示，有点尴尬，读取DHT11明明是按照数据手册上的时序来写的，为什么不能显示？</p><ul><li>第一种原因，可能是我们在使用延时函数的时候，习惯用下面这种函数来延时，这种函数在的延时精度很难保证。</li><li>Proteus中51单片机的默认时钟频率是12MHz。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DHT11_delay_us(unsigned char n)</span><br><span class="line">&#123;</span><br><span class="line">    while(--n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void DHT11_delay_us(unsigned char n) &#123;     while(--n); &#125;</code></p><h4 id="在调试阶段，在各个数据读取阶段设置标志位。"><a href="#在调试阶段，在各个数据读取阶段设置标志位。" class="headerlink" title="在调试阶段，在各个数据读取阶段设置标志位。"></a>在调试阶段，在各个数据读取阶段设置标志位。</h4><p>有时候真的不出数据，让人摸不着头脑。</p><ul><li>总时序</li></ul><p>在单片机拉高电平时间在20-40us阶段，设置一个标志位，判断数据IO口状态是否被DHT拉低，如果拉低，则点亮Led灯，用来观察信号到底有没有拉低，这样很直观就可以看出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void DHT11_start()</span><br><span class="line">&#123;</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(10);</span><br><span class="line">    Temp_data=0;</span><br><span class="line">     delayms(25);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(50);//MCU释放总线20~40us,需要在40微秒到100微秒之间</span><br><span class="line">if(Temp_data==0)&#123;</span><br><span class="line">led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line"> while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线,跳过</span><br><span class="line">      Delayus(80);  //50拉高后延时80us</span><br><span class="line"> while(Temp_data==1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF</span><br><span class="line">&#125;else&#123;led=1;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;void DHT11_start()<br>{<br>    Temp_data&#x3D;1;<br>    Delayus(10);<br>    Temp_data&#x3D;0;<br>     delayms(25);&#x2F;&#x2F;这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据<br>    Temp_data&#x3D;1;<br>    Delayus(50);&#x2F;&#x2F;MCU释放总线20~40us,需要在40微秒到100微秒之间<br>    if(Temp_data&#x3D;&#x3D;0){<br>                    led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>             while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线,跳过<br>      Delayus(80);  &#x2F;&#x2F;50拉高后延时80us<br>             while(Temp_data&#x3D;&#x3D;1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF<br>        }else{led&#x3D;1;}</p><p>}&#96;</p><p><img src="https://img-blog.csdnimg.cn/403664851ae4474dae9ab4c519663ddd.png" alt="在这里插入图片描述"></p><ul><li>读数据0的时序</li><li>读数据1的时序</li></ul><p><img src="https://img-blog.csdnimg.cn/9867f562d4f147ce9afc7b6a702cc145.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/ba52d46c122e47a8aa07f12df2993a20.png" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">/*******************************************************************************</span><br><span class="line">* 实验名   :温度显示实验</span><br><span class="line">* 使用的IO     :</span><br><span class="line">* 实验效果       :1602显示温度</span><br><span class="line">*注意 ：</span><br><span class="line">*******************************************************************************/</span><br><span class="line"></span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">#include&quot;lcd.h&quot;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">sbit Temp_data=P3^6;</span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函数名         : main</span><br><span class="line">* 函数功能   : 主函数</span><br><span class="line">* 输入           : 无</span><br><span class="line">* 输出          : 无</span><br><span class="line">*******************************************************************************/</span><br><span class="line">unsigned int rec_dat[4];</span><br><span class="line"></span><br><span class="line">unsigned char rec_dat_lcd0[6];</span><br><span class="line">unsigned char rec_dat_lcd1[6];</span><br><span class="line">unsigned char rec_dat_lcd2[6];</span><br><span class="line">unsigned char rec_dat_lcd3[6];</span><br><span class="line"></span><br><span class="line">//定义</span><br><span class="line">void DHT11_delay_us(unsigned char n);</span><br><span class="line">void DHT11_delay_ms(unsigned int z);</span><br><span class="line">void DHT11_start();</span><br><span class="line">unsigned char DHT11_rec_byte();</span><br><span class="line">void DHT11_receive();</span><br><span class="line">void InitUART(void);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//主函数</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    InitUART();</span><br><span class="line">P1=0xf0;</span><br><span class="line">    InitLcd1602();</span><br><span class="line">    LcdShowStr(0,0,&quot;Humi:&quot;);</span><br><span class="line">    LcdShowStr(0,1,&quot;Temp:&quot;);</span><br><span class="line">    EA = 1;                  //开总中断</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        DHT11_delay_ms(150);</span><br><span class="line">        DHT11_receive();</span><br><span class="line">        sprintf(rec_dat_lcd0,&quot;%d&quot;,rec_dat[0]);</span><br><span class="line">        sprintf(rec_dat_lcd1,&quot;%d&quot;,rec_dat[1]);</span><br><span class="line">        sprintf(rec_dat_lcd2,&quot;%d&quot;,rec_dat[2]);</span><br><span class="line">        sprintf(rec_dat_lcd3,&quot;%d&quot;,rec_dat[3]);</span><br><span class="line">        DHT11_delay_ms(100);</span><br><span class="line"></span><br><span class="line">        //湿度</span><br><span class="line">        LcdShowStr(6,0,rec_dat_lcd0);</span><br><span class="line">        LcdShowStr(8,0,&quot;.&quot;);</span><br><span class="line">        LcdShowStr(9,0,rec_dat_lcd1);</span><br><span class="line">        LcdShowStr(10,0,&quot; %&quot;);</span><br><span class="line"></span><br><span class="line">        //温度</span><br><span class="line">        LcdShowStr(6,1,rec_dat_lcd2);</span><br><span class="line">        LcdShowStr(8,1,&quot;.&quot;);</span><br><span class="line">        LcdShowStr(9,1,rec_dat_lcd3);</span><br><span class="line">        LcdShowStr(10,1,&quot;*C&quot;);</span><br><span class="line"></span><br><span class="line">        //下面通过串口助手打印温度</span><br><span class="line">        printf(&quot;Humi:%d.%d %%\n&quot;,rec_dat[0],rec_dat[1]);</span><br><span class="line">        printf(&quot;Temp:%d.%d ℃\n&quot;,rec_dat[2],rec_dat[3]);</span><br><span class="line">DHT11_delay_ms(3000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//DHT11起始信号</span><br><span class="line"></span><br><span class="line">void DHT11_start()</span><br><span class="line">&#123;</span><br><span class="line">    Temp_data=1;</span><br><span class="line"></span><br><span class="line">    DHT11_delay_us(10);</span><br><span class="line"></span><br><span class="line">    Temp_data=0;</span><br><span class="line"></span><br><span class="line">    DHT11_delay_ms(50);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据</span><br><span class="line"></span><br><span class="line">    Temp_data=1;</span><br><span class="line"></span><br><span class="line">    DHT11_delay_us(50);//这个延时不能过短</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收一个字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char DHT11_rec_byte()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i,dat=0;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">while(!Temp_data);//开始发送数据，50us</span><br><span class="line">//proteus仿真里面下面的延时范围最好在10&lt;delay&lt;20,实际硬件电路需要30us到40us</span><br><span class="line">        DHT11_delay_us(20);//数据高电平阶段判断数据0还是1</span><br><span class="line">        dat &lt;&lt;=1;</span><br><span class="line">        if(Temp_data==1)</span><br><span class="line">        &#123;</span><br><span class="line">            dat +=1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(Temp_data);</span><br><span class="line">    &#125;</span><br><span class="line">    return dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//接收温湿度数据</span><br><span class="line">void DHT11_receive()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int R_H,R_L,T_H,T_L;</span><br><span class="line">    unsigned char RH,RL,TH,TL,revise;</span><br><span class="line"></span><br><span class="line">    DHT11_start();</span><br><span class="line">  //  Temp_data=1;</span><br><span class="line">    if(Temp_data==0)//DHT拉低IO口，响应信号</span><br><span class="line">    &#123;</span><br><span class="line">        while(Temp_data==0);   //等待拉高80us</span><br><span class="line">       // DHT11_delay_us(40);  //拉高后延时80us</span><br><span class="line">while(Temp_data==1);   //等待拉高80us</span><br><span class="line">        R_H=DHT11_rec_byte();    //接收湿度高八位</span><br><span class="line">        R_L=DHT11_rec_byte();    //接收湿度低八位</span><br><span class="line">        T_H=DHT11_rec_byte();    //接收温度高八位</span><br><span class="line">        T_L=DHT11_rec_byte();    //接收温度低八位</span><br><span class="line">        revise=DHT11_rec_byte(); //接收校正位</span><br><span class="line"></span><br><span class="line">        DHT11_delay_us(25);    //结束</span><br><span class="line"></span><br><span class="line">        if((R_H+R_L+T_H+T_L)==revise)      //校正</span><br><span class="line">        &#123;</span><br><span class="line">            RH=R_H;</span><br><span class="line">            RL=R_L;</span><br><span class="line">            TH=T_H;</span><br><span class="line">            TL=T_L;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /*数据处理，方便显示*/</span><br><span class="line">        rec_dat[0]=RH;</span><br><span class="line">        rec_dat[1]=RL;</span><br><span class="line">        rec_dat[2]=TH;</span><br><span class="line">        rec_dat[3]=TL;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时us   --2*n+5us</span><br><span class="line">void DHT11_delay_us(unsigned char n)</span><br><span class="line">&#123;</span><br><span class="line">    while(--n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时ms</span><br><span class="line">void DHT11_delay_ms(unsigned int z)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int i,j;</span><br><span class="line">    for(i=z; i&gt;0; i--)</span><br><span class="line">        for(j=110; j&gt;0; j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void InitUART(void)//使用定时器1作为串口波特率发生器</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    SCON=0x40;//串口通信工作方式1</span><br><span class="line">    REN=1;//允许接收</span><br><span class="line">    TMOD=0x20;//定时器1的工作方式2</span><br><span class="line">    TH1=0xF3,TL1=0xF3;</span><br><span class="line">    TI=1;                       //这里一定要注意</span><br><span class="line">    TR1=1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*******************************************************************************</p><ul><li>实验名   :温度显示实验</li><li>使用的IO     :</li><li>实验效果       :1602显示温度</li><li>   注意 ：<br>*******************************************************************************&#x2F;</li></ul><p>#include&lt;reg51.h&gt;<br>#include”lcd.h”<br>#include&lt;intrins.h&gt;<br>#include&lt;stdio.h&gt;</p><p>sbit Temp_data&#x3D;P3^6;<br>&#x2F;*******************************************************************************</p><ul><li>函数名         : main</li><li>函数功能   : 主函数</li><li>输入           : 无</li><li>输出          : 无<br>*******************************************************************************&#x2F;<br>unsigned int rec_dat[4];</li></ul><p>unsigned char rec_dat_lcd0[6];<br>unsigned char rec_dat_lcd1[6];<br>unsigned char rec_dat_lcd2[6];<br>unsigned char rec_dat_lcd3[6];</p><p>&#x2F;&#x2F;定义<br>void DHT11_delay_us(unsigned char n);<br>void DHT11_delay_ms(unsigned int z);<br>void DHT11_start();<br>unsigned char DHT11_rec_byte();<br>void DHT11_receive();<br>void InitUART(void);</p><p>&#x2F;&#x2F;主函数<br>void main()<br>{<br>    InitUART();<br>        P1&#x3D;0xf0;<br>    InitLcd1602();<br>    LcdShowStr(0,0,”Humi:”);<br>    LcdShowStr(0,1,”Temp:”);<br>    EA &#x3D; 1;                  &#x2F;&#x2F;开总中断<br>    while(1)<br>    {<br>        DHT11_delay_ms(150);<br>        DHT11_receive();<br>        sprintf(rec_dat_lcd0,”%d”,rec_dat[0]);<br>        sprintf(rec_dat_lcd1,”%d”,rec_dat[1]);<br>        sprintf(rec_dat_lcd2,”%d”,rec_dat[2]);<br>        sprintf(rec_dat_lcd3,”%d”,rec_dat[3]);<br>        DHT11_delay_ms(100);</p><pre><code>    //湿度    LcdShowStr(6,0,rec_dat_lcd0);    LcdShowStr(8,0,&quot;.&quot;);    LcdShowStr(9,0,rec_dat_lcd1);    LcdShowStr(10,0,&quot; %&quot;);    //温度    LcdShowStr(6,1,rec_dat_lcd2);    LcdShowStr(8,1,&quot;.&quot;);    LcdShowStr(9,1,rec_dat_lcd3);    LcdShowStr(10,1,&quot;*C&quot;);    //下面通过串口助手打印温度    printf(&quot;Humi:%d.%d %%\n&quot;,rec_dat[0],rec_dat[1]);    printf(&quot;Temp:%d.%d ℃\n&quot;,rec_dat[2],rec_dat[3]);            DHT11_delay_ms(3000);&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;DHT11起始信号</p><p>void DHT11_start()<br>{<br>    Temp_data&#x3D;1;</p><pre><code>DHT11_delay_us(10);Temp_data=0;DHT11_delay_ms(50);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据Temp_data=1;DHT11_delay_us(50);//这个延时不能过短</code></pre><p>}</p><p>&#x2F;&#x2F;接收一个字节</p><p>unsigned char DHT11_rec_byte()<br>{<br>    unsigned char i,dat&#x3D;0;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>            while(!Temp_data);&#x2F;&#x2F;开始发送数据，50us<br>            &#x2F;&#x2F;proteus仿真里面下面的延时范围最好在10&lt;delay&lt;20,实际硬件电路需要30us到40us<br>        DHT11_delay_us(20);&#x2F;&#x2F;数据高电平阶段判断数据0还是1<br>        dat &lt;&lt;&#x3D;1;<br>        if(Temp_data&#x3D;&#x3D;1)<br>        {<br>            dat +&#x3D;1;<br>        }<br>        while(Temp_data);<br>    }<br>    return dat;<br>}</p><p>&#x2F;&#x2F;接收温湿度数据<br>void DHT11_receive()<br>{<br>    unsigned int R_H,R_L,T_H,T_L;<br>    unsigned char RH,RL,TH,TL,revise;</p><pre><code>DHT11_start();</code></pre><p>  &#x2F;&#x2F;  Temp_data&#x3D;1;<br>    if(Temp_data&#x3D;&#x3D;0)&#x2F;&#x2F;DHT拉低IO口，响应信号<br>    {<br>        while(Temp_data&#x3D;&#x3D;0);   &#x2F;&#x2F;等待拉高80us<br>       &#x2F;&#x2F; DHT11_delay_us(40);  &#x2F;&#x2F;拉高后延时80us<br>while(Temp_data&#x3D;&#x3D;1);   &#x2F;&#x2F;等待拉高80us<br>        R_H&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收湿度高八位<br>        R_L&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收湿度低八位<br>        T_H&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收温度高八位<br>        T_L&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收温度低八位<br>        revise&#x3D;DHT11_rec_byte(); &#x2F;&#x2F;接收校正位</p><pre><code>    DHT11_delay_us(25);    //结束    if((R_H+R_L+T_H+T_L)==revise)      //校正    &#123;        RH=R_H;        RL=R_L;        TH=T_H;        TL=T_L;    &#125;    /*数据处理，方便显示*/    rec_dat[0]=RH;    rec_dat[1]=RL;    rec_dat[2]=TH;    rec_dat[3]=TL;&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;延时us   –2*n+5us<br>void DHT11_delay_us(unsigned char n)<br>{<br>    while(–n);<br>}</p><p>&#x2F;&#x2F;延时ms<br>void DHT11_delay_ms(unsigned int z)<br>{<br>    unsigned int i,j;<br>    for(i&#x3D;z; i&gt;0; i–)<br>        for(j&#x3D;110; j&gt;0; j–);<br>}</p><p>void InitUART(void)&#x2F;&#x2F;使用定时器1作为串口波特率发生器<br>{</p><pre><code>SCON=0x40;//串口通信工作方式1REN=1;//允许接收TMOD=0x20;//定时器1的工作方式2TH1=0xF3,TL1=0xF3;TI=1;                       //这里一定要注意TR1=1;</code></pre><p>}&#96;</p><ul><li>lcd.c</li></ul><p><code>lcd.c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;lcd.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//void Read_Busy()           //忙检测函数，判断bit7是0，允许执行；1禁止</span><br><span class="line">//&#123;</span><br><span class="line">//    unsigned char sta;      //</span><br><span class="line">//    LCD1602_DB = 0xff;</span><br><span class="line">//    LCD1602_RS = 0;</span><br><span class="line">//    LCD1602_RW = 1;</span><br><span class="line">//    do</span><br><span class="line">//    &#123;</span><br><span class="line">//        LCD1602_EN = 1;</span><br><span class="line">//        sta = LCD1602_DB;</span><br><span class="line">//        LCD1602_EN = 0;    //使能，用完就拉低，释放总线</span><br><span class="line">//    &#125;while(sta &amp; 0x80);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Lcd1602_Write_Cmd(unsigned char cmd)     //写命令</span><br><span class="line">&#123;</span><br><span class="line">    //Read_Busy();</span><br><span class="line">    LCD1602_RS = 0;</span><br><span class="line">    LCD1602_RW = 0;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD_Delay10ms(1);</span><br><span class="line">    LCD1602_EN = 1;</span><br><span class="line">    LCD_Delay10ms(1);</span><br><span class="line">    LCD1602_EN = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Lcd1602_Write_Data(unsigned char dat)   //写数据</span><br><span class="line">&#123;</span><br><span class="line">    //Read_Busy();</span><br><span class="line">    LCD1602_RS = 1;</span><br><span class="line">    LCD1602_RW = 0;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD_Delay10ms(1);</span><br><span class="line">    LCD1602_EN = 1;</span><br><span class="line">    LCD_Delay10ms(1);</span><br><span class="line">    LCD1602_EN = 0;</span><br><span class="line">&#125;</span><br><span class="line">//指定位置开始显示数据！</span><br><span class="line">void LcdSetCursor(unsigned char x,unsigned char y)  //坐标显示</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char addr;</span><br><span class="line">    if(y == 0)</span><br><span class="line">        addr = 0x00 + x;//第一行开始，x表示一行的第x个</span><br><span class="line">    else</span><br><span class="line">        addr = 0x40 + x;//第二行开始，x表示一行的第x个</span><br><span class="line"></span><br><span class="line">    Lcd1602_Write_Cmd(addr|0x80);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LcdShowStr(unsigned char x,unsigned char y,unsigned char *str)     //显示字符串</span><br><span class="line">&#123;</span><br><span class="line">    LcdSetCursor(x,y);      //当前字符的坐标</span><br><span class="line">    while(*str != &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd1602_Write_Data(*str++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitLcd1602()              //1602初始化</span><br><span class="line">&#123;</span><br><span class="line">    Lcd1602_Write_Cmd(0x38);    //打开，5*8,8位数据</span><br><span class="line">    Lcd1602_Write_Cmd(0x0c);</span><br><span class="line">    Lcd1602_Write_Cmd(0x06);</span><br><span class="line">    Lcd1602_Write_Cmd(0x01);    //清屏</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LCD_Delay10ms(unsigned int c)   //误差 0us</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a,b;</span><br><span class="line">    for(; c&gt;0; c--)</span><br><span class="line">        for(b=38; b&gt;0; b--)</span><br><span class="line">            for(a=130; a&gt;0; a--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include”lcd.h”</p><p>&#x2F;&#x2F;void Read_Busy()           &#x2F;&#x2F;忙检测函数，判断bit7是0，允许执行；1禁止<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F;    unsigned char sta;      &#x2F;&#x2F;<br>&#x2F;&#x2F;    LCD1602_DB &#x3D; 0xff;<br>&#x2F;&#x2F;    LCD1602_RS &#x3D; 0;<br>&#x2F;&#x2F;    LCD1602_RW &#x3D; 1;<br>&#x2F;&#x2F;    do<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        LCD1602_EN &#x3D; 1;<br>&#x2F;&#x2F;        sta &#x3D; LCD1602_DB;<br>&#x2F;&#x2F;        LCD1602_EN &#x3D; 0;    &#x2F;&#x2F;使能，用完就拉低，释放总线<br>&#x2F;&#x2F;    }while(sta &amp; 0x80);<br>&#x2F;&#x2F;}</p><p>void Lcd1602_Write_Cmd(unsigned char cmd)     &#x2F;&#x2F;写命令<br>{<br>    &#x2F;&#x2F;Read_Busy();<br>    LCD1602_RS &#x3D; 0;<br>    LCD1602_RW &#x3D; 0;<br>    LCD1602_DB &#x3D; cmd;<br>    LCD_Delay10ms(1);<br>    LCD1602_EN &#x3D; 1;<br>    LCD_Delay10ms(1);<br>    LCD1602_EN &#x3D; 0;<br>}</p><p>void Lcd1602_Write_Data(unsigned char dat)   &#x2F;&#x2F;写数据<br>{<br>    &#x2F;&#x2F;Read_Busy();<br>    LCD1602_RS &#x3D; 1;<br>    LCD1602_RW &#x3D; 0;<br>    LCD1602_DB &#x3D; dat;<br>    LCD_Delay10ms(1);<br>    LCD1602_EN &#x3D; 1;<br>    LCD_Delay10ms(1);<br>    LCD1602_EN &#x3D; 0;<br>}<br>&#x2F;&#x2F;指定位置开始显示数据！<br>void LcdSetCursor(unsigned char x,unsigned char y)  &#x2F;&#x2F;坐标显示<br>{<br>    unsigned char addr;<br>    if(y &#x3D;&#x3D; 0)<br>        addr &#x3D; 0x00 + x;&#x2F;&#x2F;第一行开始，x表示一行的第x个<br>    else<br>        addr &#x3D; 0x40 + x;&#x2F;&#x2F;第二行开始，x表示一行的第x个</p><pre><code>Lcd1602_Write_Cmd(addr|0x80);</code></pre><p>}</p><p>void LcdShowStr(unsigned char x,unsigned char y,unsigned char *str)     &#x2F;&#x2F;显示字符串<br>{<br>    LcdSetCursor(x,y);      &#x2F;&#x2F;当前字符的坐标<br>    while(*str !&#x3D; ‘\0’)<br>    {<br>        Lcd1602_Write_Data(*str++);<br>    }<br>}</p><p>void InitLcd1602()              &#x2F;&#x2F;1602初始化<br>{<br>    Lcd1602_Write_Cmd(0x38);    &#x2F;&#x2F;打开，5*8,8位数据<br>    Lcd1602_Write_Cmd(0x0c);<br>    Lcd1602_Write_Cmd(0x06);<br>    Lcd1602_Write_Cmd(0x01);    &#x2F;&#x2F;清屏<br>}</p><p>void LCD_Delay10ms(unsigned int c)   &#x2F;&#x2F;误差 0us<br>{<br>    unsigned char a,b;<br>    for(; c&gt;0; c–)<br>        for(b&#x3D;38; b&gt;0; b–)<br>            for(a&#x3D;130; a&gt;0; a–);<br>}&#96;</p><ul><li>lcd.h</li></ul><p><code>lcd.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __LCD_H_</span><br><span class="line">#define __LCD_H_</span><br><span class="line">/**********************************</span><br><span class="line">当使用的是4位数据传输的时候定义，</span><br><span class="line">使用8位取消这个定义</span><br><span class="line">**********************************/</span><br><span class="line">//#define LCD1602_4PINS</span><br><span class="line"></span><br><span class="line">/**********************************</span><br><span class="line">包含头文件</span><br><span class="line">**********************************/</span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line">//---重定义关键词---//</span><br><span class="line">#ifndef uchar</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef uint</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/**********************************</span><br><span class="line">PIN口定义</span><br><span class="line">**********************************/</span><br><span class="line">#define LCD1602_DB  P0      //data bus 数据总线</span><br><span class="line">sbit LCD1602_RS = P2^0;</span><br><span class="line">sbit LCD1602_RW = P2^1;</span><br><span class="line">sbit LCD1602_EN = P2^2;</span><br><span class="line"></span><br><span class="line">/**********************************</span><br><span class="line">函数声明</span><br><span class="line">**********************************/</span><br><span class="line">/*在51单片机12MHZ时钟下的延时函数*/</span><br><span class="line">//void Lcd1602_Delay1ms(uint c);   //误差 0usvo</span><br><span class="line">void LCD_Delay10ms(unsigned int c);</span><br><span class="line">//void Read_Busy();           //忙检测函数，判断bit7是0，允许执行；1禁止</span><br><span class="line">void Lcd1602_Write_Cmd(unsigned char cmd);     //写命令</span><br><span class="line">void Lcd1602_Write_Data(unsigned char dat);   //写数据</span><br><span class="line">void LcdSetCursor(unsigned char x,unsigned char y);  //坐标显示</span><br><span class="line">void LcdShowStr(unsigned char x,unsigned char y,unsigned char *str);     //显示字符串</span><br><span class="line">void InitLcd1602();              //1602初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>&#96;#ifndef _<em>LCD_H</em><br>#define _<em>LCD_H</em><br>&#x2F;**********************************<br>当使用的是4位数据传输的时候定义，<br>使用8位取消这个定义<br>**********************************&#x2F;<br>&#x2F;&#x2F;#define LCD1602_4PINS</p><p>&#x2F;**********************************<br>包含头文件<br>**********************************&#x2F;<br>#include&lt;reg51.h&gt;</p><p>&#x2F;&#x2F;—重定义关键词—&#x2F;&#x2F;<br>#ifndef uchar<br>#define uchar unsigned char<br>#endif</p><p>#ifndef uint<br>#define uint unsigned int<br>#endif</p><p>&#x2F;**********************************<br>PIN口定义<br>**********************************&#x2F;<br>#define LCD1602_DB  P0      &#x2F;&#x2F;data bus 数据总线<br>sbit LCD1602_RS &#x3D; P2^0;<br>sbit LCD1602_RW &#x3D; P2^1;<br>sbit LCD1602_EN &#x3D; P2^2;</p><p>&#x2F;**********************************<br>函数声明<br>**********************************&#x2F;<br>&#x2F;<em>在51单片机12MHZ时钟下的延时函数</em>&#x2F;<br>&#x2F;&#x2F;void Lcd1602_Delay1ms(uint c);   &#x2F;&#x2F;误差 0usvo<br>void LCD_Delay10ms(unsigned int c);<br>&#x2F;&#x2F;void Read_Busy();           &#x2F;&#x2F;忙检测函数，判断bit7是0，允许执行；1禁止<br>void Lcd1602_Write_Cmd(unsigned char cmd);     &#x2F;&#x2F;写命令<br>void Lcd1602_Write_Data(unsigned char dat);   &#x2F;&#x2F;写数据<br>void LcdSetCursor(unsigned char x,unsigned char y);  &#x2F;&#x2F;坐标显示<br>void LcdShowStr(unsigned char x,unsigned char y,unsigned char *str);     &#x2F;&#x2F;显示字符串<br>void InitLcd1602();              &#x2F;&#x2F;1602初始化</p><p>#endif&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15W408AS读取DHT11温湿度+数据串口打印详解</title>
      <link href="/2024/03/Stc15-STC15W408AS%E8%AF%BB%E5%8F%96DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/03/Stc15-STC15W408AS%E8%AF%BB%E5%8F%96DHT11%E6%B8%A9%E6%B9%BF%E5%BA%A6%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15W408AS读取DHT11温湿度-数据串口打印详解"><a href="#STC15W408AS读取DHT11温湿度-数据串口打印详解" class="headerlink" title="STC15W408AS读取DHT11温湿度+数据串口打印详解"></a>STC15W408AS读取DHT11温湿度+数据串口打印详解</h1><h3 id="STC15W408AS读取DHT11温湿度-数据串口打印输出详解"><a href="#STC15W408AS读取DHT11温湿度-数据串口打印输出详解" class="headerlink" title="STC15W408AS读取DHT11温湿度+数据串口打印输出详解"></a>STC15W408AS读取DHT11温湿度+数据串口打印输出详解</h3><p><img src="https://img-blog.csdnimg.cn/81086c7af8f54b309593b67346d173ca.gif#pic_center" alt="在这里插入图片描述"></p><p>这个数据结果做了我2天时间来验证，主要难点是读取DHT11时序上，弄懂了时序，读这类传感器就很简单拿到数据了。</p><ul><li>网络上对于这类传感器的资料一搜索一箩筐不光是从源码到原理实现的相关方面的资料很多，满目琳琅，只想说一句参差不齐。不了解前，不要一股脑儿的在网上搜索答案，有可能把你带入找不到北的怪圈。只有从原理上读懂了，你才能在浩瀚的网络中甄别数据资料的可信度。</li><li>STC15W408AS最新系统开发板</li><li>DHT11</li></ul><p><img src="https://img-blog.csdnimg.cn/bae78bd671f640f98058e30339b77394.jpg#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/19d8351173fb43fdafc97cce35da86a9.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/3c47c6cc4d9a49d0906e0b20abf0709a.png" alt="在这里插入图片描述"></p><h4 id="接线说明"><a href="#接线说明" class="headerlink" title="接线说明"></a>接线说明</h4><ul><li>DHT11如果是独立供电，那么需要将DHT11的GND与单片机的GND相连，否则无法读到数据。</li><li>DHT11的数据引脚最好接一个4.7K-5.1K的上拉电阻到VCC。</li></ul><p><img src="https://img-blog.csdnimg.cn/84c76a6e19e0488e88916a6a0c8e2c25.png" alt="在这里插入图片描述"></p><h4 id="验证步骤"><a href="#验证步骤" class="headerlink" title="验证步骤"></a>验证步骤</h4><h5 id="确定好自己需要在什么开发板上来读取DHT11的数据。"><a href="#确定好自己需要在什么开发板上来读取DHT11的数据。" class="headerlink" title="确定好自己需要在什么开发板上来读取DHT11的数据。"></a>确定好自己需要在什么开发板上来读取DHT11的数据。</h5><p>不同的开发板或芯片，时钟频率不同，DHT读取数据的时候，需要利用延时时间来控制IO口的高低电平状态保持的时间。这一点很关键!一句话总结：你要提前准备好较为精准的延时函数。都是为了后面读时序做好准备。</p><ul><li>延时函数确定方法</li></ul><p>使用STC烧录工具上的软件延时，自动生成即可。参数有STC型号，工作频率。指令集（看右侧的描述，不同的型号对应不同的指令集，适用于什么系列，就选择什么指令集）</p><p><img src="https://img-blog.csdnimg.cn/12caf164291a46578a7b7bf36d180e6b.png" alt="在这里插入图片描述"></p><h5 id="看懂DHT11时序"><a href="#看懂DHT11时序" class="headerlink" title="看懂DHT11时序"></a>看懂DHT11时序</h5><p>我们不要急于直接去copy代码，先听讲解。</p><p>DHT11温湿度传感器</p><p>看这个视频讲解，第一遍没看懂的话，多看一遍。</p><ul><li>整个时序图</li></ul><p><img src="https://img-blog.csdnimg.cn/d1a568baa24d4b4aad5a5a14bed56b41.png" alt="在这里插入图片描述"></p><ul><li>开始信号时序图</li><li>数据时序图</li></ul><p><img src="https://img-blog.csdnimg.cn/03e7cabc47324c9ab081514d2bf7eed9.png" alt="在这里插入图片描述"></p><p>位数据“0”的格式为： 50 微秒的低电平和 26-28 微秒的高电平，位数据“1”的格式为： 50 微秒的低电平加 70微秒的高电平。</p><p><code>50</code></p><p><code>26-28</code></p><p><code>50</code></p><p><code>70</code></p><ul><li>根据数据位的高电平时间不一样，来判断接收的是0还是1，接收数据时可以先等待低电平过去，即等待数据线拉高，再延时60us，因为60us大于28us且小于70us，再检测此时数据线是否为高，如果为高，则数据判定为1，否则为0。 – 读取数据0时序  – 读取数据1时序图</li></ul><p><code>0</code></p><p><code>1</code></p><p><code>0</code></p><p><img src="https://img-blog.csdnimg.cn/e6f394e8e1ed4311b20cac03a9acfdb4.png" alt="在这里插入图片描述"></p><p><code>1</code></p><p><img src="https://img-blog.csdnimg.cn/c34424aa797c413392f4c4d399317263.png" alt="在这里插入图片描述"></p><h4 id="时序与代码对应关系"><a href="#时序与代码对应关系" class="headerlink" title="时序与代码对应关系"></a>时序与代码对应关系</h4><ol><li>起始信号段</li></ol><p><img src="https://img-blog.csdnimg.cn/2a20258e0c36466ca92bde73681fd117.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void DHT11_start()</span><br><span class="line">&#123;</span><br><span class="line">    Temp_data=1;//通讯前，将DHT11数据IO口置为高电平</span><br><span class="line">    Delayus(10);</span><br><span class="line">    Temp_data=0;//mcu开始通讯，主动拉点数据IO口</span><br><span class="line">     delayms(25);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(50);/MCU拉高数据IO口电平时间20~40us之后,等待DHT11将数据IO口来拉低电平，这是单片机变成了读取IO口信号。之前单片机数据IO口都是用来作为输出高低电平IO口，到了这里，单片机数据IO口变成读取输入信号的IO口，需要在40微秒到100微秒之间</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>void DHT11_start() &#123;     Temp_data=1;//通讯前，将DHT11数据IO口置为高电平     Delayus(10);     Temp_data=0;//mcu开始通讯，主动拉点数据IO口      delayms(25);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据     Temp_data=1;     Delayus(50);/MCU拉高数据IO口电平时间20~40us之后,等待DHT11将数据IO口来拉低电平，这是单片机变成了读取IO口信号。之前单片机数据IO口都是用来作为输出高低电平IO口，到了这里，单片机数据IO口变成读取输入信号的IO口，需要在40微秒到100微秒之间     &#125;</code></p><ol><li>应答信号和读数据</li></ol><p><img src="https://img-blog.csdnimg.cn/efed1873cc5146f7b8cdd95eaaafdffd.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//接收温湿度数据</span><br><span class="line">void DHT11_receive()</span><br><span class="line">&#123;</span><br><span class="line">DHT11_start();//这部分是开始信号</span><br><span class="line">    if(Temp_data==0)//这里的条件判断对应的是上图中红虚线框内应答信号区域&quot;DHT响应信号80us区段&quot;</span><br><span class="line">    &#123;led=0;//检测从设备DHT拉低总线信号，led作为响应信号的标志，为了方便观察信号是否被DHT响应到，如果拉低电平，说明DHT响应了，并进入if条件里面执行内容</span><br><span class="line">while(Temp_data==0); //一直等待DHT响应信号，80us内来拉高数据IO口的电平状态，才结束这个while循环。</span><br><span class="line">while(Temp_data==1); //一直等待等待DHT响应信号，80us内来拉低总线数据IO口的电平状态，才结束这个while循环。</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;else&#123;led=1;//程序运行到这里，说明DHT数据IO口没有被DHT传感器响应到&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>//接收温湿度数据 void DHT11_receive() &#123;         DHT11_start();//这部分是开始信号         if(Temp_data==0)//这里的条件判断对应的是上图中红虚线框内应答信号区域&quot;DHT响应信号80us区段&quot;     &#123;led=0;//检测从设备DHT拉低总线信号，led作为响应信号的标志，为了方便观察信号是否被DHT响应到，如果拉低电平，说明DHT响应了，并进入if条件里面执行内容             while(Temp_data==0); //一直等待DHT响应信号，80us内来拉高数据IO口的电平状态，才结束这个while循环。             while(Temp_data==1); //一直等待等待DHT响应信号，80us内来拉低总线数据IO口的电平状态，才结束这个while循环。         &#125;   &#125;else&#123;led=1;//程序运行到这里，说明DHT数据IO口没有被DHT传感器响应到&#125; &#125;</code></p><ol><li>读取DHT11数据 – 读取数据0时序  – 读取数据1时序图</li></ol><p><code>0</code></p><p><img src="https://img-blog.csdnimg.cn/e6f394e8e1ed4311b20cac03a9acfdb4.png" alt="在这里插入图片描述"></p><p><code>1</code></p><p><img src="https://img-blog.csdnimg.cn/c34424aa797c413392f4c4d399317263.png" alt="在这里插入图片描述"></p><p>上面这两张图一起来看。所读到的数据是0还是1结果的时序上的差异就是高电平保持时间不一样长。前面50us相同的低电平保持时间和读取数据结束后的数据IO口状态都是低电平时间可以先不用管它，我们主要是查看差异部分来分析数据，并转换为C代码来判断数据结果。</p><p><code>0</code></p><p><code>1</code></p><p><code>高电平保持时间不一样长</code></p><p><code>前面50us相同的低电平保持时间</code></p><p><code>读取数据结束后的数据IO口状态都是低电平时间</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//接收一个字节</span><br><span class="line">unsigned char DHT11_rec_byte()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i,dat=0;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;//一个字节的数据8bit位，所以需要连续读8次，才是一个完整的字节数据。</span><br><span class="line">        while(!Temp_data);//读数据时跳过数据前段的50us，当DHT数据IO口变高时，就跳出while，也就是数据传输的前段50us时间。</span><br><span class="line">Delayus(33);//这个延时是为了过滤掉“26-28us”数据0和1的相同高电平时间，之后，再做DHT数据IO口的电平状态监测。 </span><br><span class="line">// 这个延时取值范围28us&lt;delay&lt;70us区间的值    </span><br><span class="line">          dat &lt;&lt;=1;//每读一次信号数据左移一位。</span><br><span class="line">if(Temp_data==1)</span><br><span class="line">        &#123;//如果读到的数据IO口状态为高，那么就是数据1，</span><br><span class="line">  dat +=1;//当前位为1</span><br><span class="line">        &#125;</span><br><span class="line">while(Temp_data);//不管是数据0还是1，只要数据IO口状态变低，那么就表示该bit位数据就读取结束了。</span><br><span class="line">    &#125;</span><br><span class="line">    return dat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>//接收一个字节 unsigned char DHT11_rec_byte() &#123;     unsigned char i,dat=0;     for(i=0; i&lt;8; i++)     &#123;//一个字节的数据8bit位，所以需要连续读8次，才是一个完整的字节数据。         while(!Temp_data);//读数据时跳过数据前段的50us，当DHT数据IO口变高时，就跳出while，也就是数据传输的前段50us时间。         Delayus(33);//这个延时是为了过滤掉“26-28us”数据0和1的相同高电平时间，之后，再做DHT数据IO口的电平状态监测。          // 这个延时取值范围28us&lt;delay&lt;70us区间的值               dat &lt;&lt;=1;//每读一次信号数据左移一位。             if(Temp_data==1)         &#123;//如果读到的数据IO口状态为高，那么就是数据1，                       dat +=1;//当前位为1         &#125;             while(Temp_data);//不管是数据0还是1，只要数据IO口状态变低，那么就表示该bit位数据就读取结束了。     &#125;     return dat; &#125;</code></p><ul><li>一次完整的数据传输是40bit，也就是5X8bit&#x3D;5Byte个字节。换句话就是：上面的函数 DHT11_rec_byte()需要连续执行5次才算读完一次完整的数据。</li><li>一次传送 40 位数据，高位先出.</li><li>数据校正</li><li>判断“8bit 湿度整数数据 + 8bit 湿度小数数据+8bit 温度整数数据 + 8bit 温度小数数据”的结果是否等于8bit 校验位。如果等于则数据接收正确，否则应该放弃这一次的数据，重新接收。</li></ul><p><code>DHT11_rec_byte()</code></p><p>8bit 湿度整数数据 + 8bit 湿度小数数据+8bit 温度整数数据 + 8bit 温度小数数据+8bit 校验位。</p><p><img src="https://img-blog.csdnimg.cn/dd2a65bc7eeb4b32afe194cd80f6abe5.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//接收温湿度数据</span><br><span class="line">void DHT11_receive()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int R_H,R_L,T_H,T_L;</span><br><span class="line">    unsigned char RH,RL,TH,TL,revise;</span><br><span class="line">DHT11_start();//开始信号</span><br><span class="line">    if(Temp_data==0)//应答信号</span><br><span class="line">    &#123;led=0;//检测从设备DHT拉低总线信号，添加led作为响应信号方便观察</span><br><span class="line">while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线</span><br><span class="line">while(Temp_data==1); //等待DHT响应信号，80us内来拉低总线</span><br><span class="line">        R_H=DHT11_rec_byte();    //接收第一次湿度高八位</span><br><span class="line">        R_L=DHT11_rec_byte();    //接收第二次湿度低八位</span><br><span class="line">        T_H=DHT11_rec_byte();    //接收第三次温度高八位</span><br><span class="line">        T_L=DHT11_rec_byte();    //接收第四次温度低八位</span><br><span class="line">        revise=DHT11_rec_byte(); //接收第五次，为数据校正位</span><br><span class="line">        Delayus(25);    //这个延时不是很重要，用于数据缓冲。</span><br><span class="line"></span><br><span class="line">        if((R_H+R_L+T_H+T_L)==revise)//数据校正</span><br><span class="line">        &#123;</span><br><span class="line">led2 = 0;//如果数据校正没问题，让LED2灯亮起，方便观察</span><br><span class="line">            RH=R_H;</span><br><span class="line">            RL=R_L;</span><br><span class="line">            TH=T_H;</span><br><span class="line">            TL=T_L;</span><br><span class="line">        &#125;</span><br><span class="line">        /*数据处理，方便显示*/</span><br><span class="line">        rec_dat[0]=RH;//将数据分别对应存进全局数组变量里面</span><br><span class="line">        rec_dat[1]=RL;</span><br><span class="line">        rec_dat[2]=TH;</span><br><span class="line">        rec_dat[3]=TL;</span><br><span class="line">  &#125;else&#123;led=1;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;&#x2F;接收温湿度数据<br>void DHT11_receive()<br>{<br>    unsigned int R_H,R_L,T_H,T_L;<br>    unsigned char RH,RL,TH,TL,revise;<br>        DHT11_start();&#x2F;&#x2F;开始信号<br>        if(Temp_data&#x3D;&#x3D;0)&#x2F;&#x2F;应答信号<br>    {led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，添加led作为响应信号方便观察<br>            while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线<br>            while(Temp_data&#x3D;&#x3D;1); &#x2F;&#x2F;等待DHT响应信号，80us内来拉低总线<br>        R_H&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收第一次湿度高八位<br>        R_L&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收第二次湿度低八位<br>        T_H&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收第三次温度高八位<br>        T_L&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收第四次温度低八位<br>        revise&#x3D;DHT11_rec_byte(); &#x2F;&#x2F;接收第五次，为数据校正位<br>        Delayus(25);    &#x2F;&#x2F;这个延时不是很重要，用于数据缓冲。</p><pre><code>    if((R_H+R_L+T_H+T_L)==revise)//数据校正    &#123;        led2 = 0;//如果数据校正没问题，让LED2灯亮起，方便观察        RH=R_H;        RL=R_L;        TH=T_H;        TL=T_L;    &#125;    /*数据处理，方便显示*/    rec_dat[0]=RH;//将数据分别对应存进全局数组变量里面    rec_dat[1]=RL;    rec_dat[2]=TH;    rec_dat[3]=TL;</code></pre><p>  }else{led&#x3D;1;}<br>}&#96;</p><h4 id="示例程序程序"><a href="#示例程序程序" class="headerlink" title="示例程序程序"></a>示例程序程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">//#include &quot;string.h&quot;</span><br><span class="line">//#include &quot;stdarg.h&quot; </span><br><span class="line"></span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;USART1.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line"></span><br><span class="line">#define uint unsigned int </span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">/*************功能说明**************</span><br><span class="line"></span><br><span class="line">双串口全双工中断方式收发通讯程序。</span><br><span class="line"></span><br><span class="line">通过PC向MCU发送数据, MCU收到后通过串口把收到的数据原样返回.</span><br><span class="line"></span><br><span class="line">******************************************/</span><br><span class="line"></span><br><span class="line">/*************本地常量声明**************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sbit Temp_data = P1^4 ;</span><br><span class="line">sbit led = P1^5;//DHT响应指示灯</span><br><span class="line">sbit led2 = P1^6;//效验数据指示灯</span><br><span class="line">unsigned int rec_dat[4];</span><br><span class="line">unsigned char dht_dat[4];</span><br><span class="line">unsigned char rec_dat_lcd0[6];</span><br><span class="line">unsigned char rec_dat_lcd1[6];</span><br><span class="line">unsigned char rec_dat_lcd2[6];</span><br><span class="line">unsigned char rec_dat_lcd3[6];</span><br><span class="line"></span><br><span class="line">//定义</span><br><span class="line"></span><br><span class="line">void DHT11_start();//DHT开始信号</span><br><span class="line">unsigned char DHT11_rec_byte();</span><br><span class="line">void DHT11_receive();</span><br><span class="line"></span><br><span class="line">/*************  外部函数和变量声明 *****************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*************  串口1初始化函数 *****************/</span><br><span class="line">voidUART_config(void)</span><br><span class="line">&#123;</span><br><span class="line">COMx_InitDefineCOMx_InitStructure;//结构定义</span><br><span class="line">COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;//模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx</span><br><span class="line">COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)</span><br><span class="line">COMx_InitStructure.UART_BaudRate  = 115200ul;//波特率, 一般 110 ~ 115200</span><br><span class="line">COMx_InitStructure.UART_RxEnable  = ENABLE;//接收允许,   ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.BaudRateDouble = DISABLE;//波特率加倍, ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.UART_Interrupt = ENABLE;//中断允许,   ENABLE或DISABLE</span><br><span class="line">COMx_InitStructure.UART_Polity    = PolityLow;//中断优先级, PolityLow,PolityHigh</span><br><span class="line">COMx_InitStructure.UART_P_SW      = UART1_SW_P30_P31;//切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17(必须使用内部时钟)</span><br><span class="line">COMx_InitStructure.UART_RXD_TXD_Short = DISABLE;//内部短路RXD与TXD, 做中继, ENABLE,DISABLE</span><br><span class="line">USART_Configuration(USART1, &amp;COMx_InitStructure);//初始化串口1 USART1,USART2</span><br><span class="line"></span><br><span class="line">PrintString1(&quot;STC15W408AS UART1 \r\n&quot;);//SUART1发送一个字符串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**********************************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">float tem = 0.0,hum = 0.0;</span><br><span class="line">led = 1;</span><br><span class="line">led2 = 1;</span><br><span class="line">UART_config();</span><br><span class="line">EA = 1;</span><br><span class="line"></span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">delayms(150);</span><br><span class="line">        DHT11_receive();</span><br><span class="line">        sprintf(rec_dat_lcd0,&quot;%d&quot;,rec_dat[0]);</span><br><span class="line">        sprintf(rec_dat_lcd1,&quot;%d&quot;,rec_dat[1]);</span><br><span class="line">        sprintf(rec_dat_lcd2,&quot;%d&quot;,rec_dat[2]);</span><br><span class="line">        sprintf(rec_dat_lcd3,&quot;%d&quot;,rec_dat[3]);</span><br><span class="line">hum = rec_dat[0] + rec_dat[1]/256.0;</span><br><span class="line">tem = rec_dat[2] + rec_dat[3]/256.0;</span><br><span class="line">printf(&quot;温度:%.2f ℃\r\n&quot;,tem);</span><br><span class="line">printf(&quot;湿度:%.2f ％\r\n&quot;,hum);</span><br><span class="line">//        printf(&quot;湿度:%d%d %%\t&quot;,rec_dat[0],rec_dat[1]);</span><br><span class="line">//        printf(&quot;温度:%d%d ℃\r\n&quot;,rec_dat[2],rec_dat[3]);</span><br><span class="line">delayms(2000);</span><br><span class="line">led = 1;</span><br><span class="line">led2 = 1;</span><br><span class="line">//DHT11_start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//DHT11起始信号</span><br><span class="line"></span><br><span class="line">void DHT11_start()</span><br><span class="line">&#123;</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(10);</span><br><span class="line">    Temp_data=0;</span><br><span class="line">     delayms(25);//这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据</span><br><span class="line">    Temp_data=1;</span><br><span class="line">    Delayus(50);//MCU释放总线20~40us,需要在40微秒到100微秒之间</span><br><span class="line">//if(Temp_data==0)&#123;</span><br><span class="line">//led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line">// while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线,跳过ME</span><br><span class="line">       // Delayus(80);  //50拉高后延时80us</span><br><span class="line">// while(Temp_data==1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF</span><br><span class="line">//&#125;else&#123;led=1;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收一个字节</span><br><span class="line">unsigned char DHT11_rec_byte()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i,dat=0;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(!Temp_data);//跳过数据前段的50us</span><br><span class="line">Delayus(33);//过了数据0和数据1相同区域，再做检测      </span><br><span class="line">         dat &lt;&lt;=1;</span><br><span class="line">if(Temp_data==1)</span><br><span class="line">        &#123;//如果读到的数据是1</span><br><span class="line">  dat +=1;</span><br><span class="line">        &#125;</span><br><span class="line">while(Temp_data);</span><br><span class="line">    &#125;</span><br><span class="line">    return dat;</span><br><span class="line">&#125;</span><br><span class="line">//接收温湿度数据</span><br><span class="line">void DHT11_receive()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int R_H,R_L,T_H,T_L;</span><br><span class="line">    unsigned char RH,RL,TH,TL,revise;</span><br><span class="line">DHT11_start();</span><br><span class="line">    if(Temp_data==0)</span><br><span class="line">    &#123;led=0;//检测从设备DHT拉低总线信号，作为响应信号</span><br><span class="line">while(Temp_data==0); //等待DHT响应信号，80us内来拉高总线</span><br><span class="line">while(Temp_data==1); //等待DHT响应信号，80us内来拉低总线</span><br><span class="line">        R_H=DHT11_rec_byte();    //接收湿度高八位</span><br><span class="line">        R_L=DHT11_rec_byte();    //接收湿度低八位</span><br><span class="line">        T_H=DHT11_rec_byte();    //接收温度高八位</span><br><span class="line">        T_L=DHT11_rec_byte();    //接收温度低八位</span><br><span class="line">        revise=DHT11_rec_byte(); //接收校正位</span><br><span class="line">        Delayus(25);    //结束</span><br><span class="line"></span><br><span class="line">        if((R_H+R_L+T_H+T_L)==revise)      //校正</span><br><span class="line">        &#123;</span><br><span class="line"> led2 = 0;</span><br><span class="line">            RH=R_H;</span><br><span class="line">            RL=R_L;</span><br><span class="line">            TH=T_H;</span><br><span class="line">            TL=T_L;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /*数据处理，方便显示*/</span><br><span class="line">        rec_dat[0]=RH;</span><br><span class="line">        rec_dat[1]=RL;</span><br><span class="line">        rec_dat[2]=TH;</span><br><span class="line">        rec_dat[3]=TL;</span><br><span class="line">  &#125;else&#123;led=1;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “stdio.h”<br>&#x2F;&#x2F;#include “string.h”<br>&#x2F;&#x2F;#include “stdarg.h” </p><p>#include“config.h”<br>#include“USART1.h”<br>#include“delay.h”</p><p>#define uint unsigned int<br>#define uchar unsigned char</p><p>&#x2F;*************功能说明**************</p><p>双串口全双工中断方式收发通讯程序。</p><p>通过PC向MCU发送数据, MCU收到后通过串口把收到的数据原样返回.</p><p>******************************************&#x2F;</p><p>&#x2F;*************本地常量声明**************&#x2F;</p><p>sbit Temp_data &#x3D; P1^4 ;<br>sbit led &#x3D; P1^5;&#x2F;&#x2F;DHT响应指示灯<br>sbit led2 &#x3D; P1^6;&#x2F;&#x2F;效验数据指示灯<br>unsigned int rec_dat[4];<br>unsigned char dht_dat[4];<br>unsigned char rec_dat_lcd0[6];<br>unsigned char rec_dat_lcd1[6];<br>unsigned char rec_dat_lcd2[6];<br>unsigned char rec_dat_lcd3[6];</p><p>&#x2F;&#x2F;定义</p><p>void DHT11_start();&#x2F;&#x2F;DHT开始信号<br>unsigned char DHT11_rec_byte();<br>void DHT11_receive();</p><p>&#x2F;*************  外部函数和变量声明 *****************&#x2F;</p><p>&#x2F;*************  串口1初始化函数 *****************&#x2F;<br>voidUART_config(void)<br>{<br>    COMx_InitDefineCOMx_InitStructure;&#x2F;&#x2F;结构定义<br>    COMx_InitStructure.UART_Mode      &#x3D; UART_8bit_BRTx;&#x2F;&#x2F;模式,       UART_ShiftRight,UART_8bit_BRTx,UART_9bit,UART_9bit_BRTx<br>    COMx_InitStructure.UART_BRT_Use   &#x3D; BRT_Timer2;&#x2F;&#x2F;使用波特率,   BRT_Timer1, BRT_Timer2 (注意: 串口2固定使用BRT_Timer2)<br>    COMx_InitStructure.UART_BaudRate  &#x3D; 115200ul;&#x2F;&#x2F;波特率, 一般 110 ~ 115200<br>    COMx_InitStructure.UART_RxEnable  &#x3D; ENABLE;&#x2F;&#x2F;接收允许,   ENABLE或DISABLE<br>    COMx_InitStructure.BaudRateDouble &#x3D; DISABLE;&#x2F;&#x2F;波特率加倍, ENABLE或DISABLE<br>    COMx_InitStructure.UART_Interrupt &#x3D; ENABLE;&#x2F;&#x2F;中断允许,   ENABLE或DISABLE<br>    COMx_InitStructure.UART_Polity    &#x3D; PolityLow;&#x2F;&#x2F;中断优先级, PolityLow,PolityHigh<br>    COMx_InitStructure.UART_P_SW      &#x3D; UART1_SW_P30_P31;&#x2F;&#x2F;切换端口,   UART1_SW_P30_P31,UART1_SW_P36_P37,UART1_SW_P16_P17(必须使用内部时钟)<br>    COMx_InitStructure.UART_RXD_TXD_Short &#x3D; DISABLE;&#x2F;&#x2F;内部短路RXD与TXD, 做中继, ENABLE,DISABLE<br>    USART_Configuration(USART1, &amp;COMx_InitStructure);&#x2F;&#x2F;初始化串口1 USART1,USART2</p><pre><code>PrintString1(&quot;STC15W408AS UART1 \r\n&quot;);//SUART1发送一个字符串</code></pre><p>}</p><p>&#x2F;**********************************************&#x2F;<br>void main(void)<br>{<br>    float tem &#x3D; 0.0,hum &#x3D; 0.0;<br>    led &#x3D; 1;<br>    led2 &#x3D; 1;<br>    UART_config();<br>    EA &#x3D; 1;</p><pre><code>while (1)&#123;                   delayms(150);    DHT11_receive();    sprintf(rec_dat_lcd0,&quot;%d&quot;,rec_dat[0]);    sprintf(rec_dat_lcd1,&quot;%d&quot;,rec_dat[1]);    sprintf(rec_dat_lcd2,&quot;%d&quot;,rec_dat[2]);    sprintf(rec_dat_lcd3,&quot;%d&quot;,rec_dat[3]);    hum = rec_dat[0] + rec_dat[1]/256.0;    tem = rec_dat[2] + rec_dat[3]/256.0;    printf(&quot;温度:%.2f ℃\r\n&quot;,tem);    printf(&quot;湿度:%.2f ％\r\n&quot;,hum);</code></pre><p>&#x2F;&#x2F;        printf(“湿度:%d%d %%\t”,rec_dat[0],rec_dat[1]);<br>&#x2F;&#x2F;        printf(“温度:%d%d ℃\r\n”,rec_dat[2],rec_dat[3]);<br>                delayms(2000);<br>            led &#x3D; 1;<br>            led2 &#x3D; 1;<br>&#x2F;&#x2F;DHT11_start();</p><pre><code>&#125;</code></pre><p>}<br>&#x2F;&#x2F;DHT11起始信号</p><p>void DHT11_start()<br>{<br>    Temp_data&#x3D;1;<br>    Delayus(10);<br>    Temp_data&#x3D;0;<br>     delayms(25);&#x2F;&#x2F;这个延时不能过短,18ms以上,实际在仿真当中要想读到数据延时要在延时参数要在40以上才能出数据<br>    Temp_data&#x3D;1;<br>    Delayus(50);&#x2F;&#x2F;MCU释放总线20~40us,需要在40微秒到100微秒之间<br>&#x2F;&#x2F;if(Temp_data&#x3D;&#x3D;0){<br>&#x2F;&#x2F;led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>            &#x2F;&#x2F; while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线,跳过ME<br>       &#x2F;&#x2F; Delayus(80);  &#x2F;&#x2F;50拉高后延时80us<br>            &#x2F;&#x2F; while(Temp_data&#x3D;&#x3D;1);等待DHT响应信号，80us内来拉低总线,等待拉低,跳过EF<br>&#x2F;&#x2F;}else{led&#x3D;1;}</p><p>}</p><p>&#x2F;&#x2F;接收一个字节<br>unsigned char DHT11_rec_byte()<br>{<br>    unsigned char i,dat&#x3D;0;<br>    for(i&#x3D;0; i&lt;8; i++)<br>    {<br>        while(!Temp_data);&#x2F;&#x2F;跳过数据前段的50us<br>                    Delayus(33);&#x2F;&#x2F;过了数据0和数据1相同区域，再做检测<br>         dat &lt;&lt;&#x3D;1;<br>            if(Temp_data&#x3D;&#x3D;1)<br>        {&#x2F;&#x2F;如果读到的数据是1<br>                      dat +&#x3D;1;<br>        }<br>            while(Temp_data);<br>    }<br>    return dat;<br>}<br>&#x2F;&#x2F;接收温湿度数据<br>void DHT11_receive()<br>{<br>    unsigned int R_H,R_L,T_H,T_L;<br>    unsigned char RH,RL,TH,TL,revise;<br>        DHT11_start();<br>        if(Temp_data&#x3D;&#x3D;0)<br>    {led&#x3D;0;&#x2F;&#x2F;检测从设备DHT拉低总线信号，作为响应信号<br>            while(Temp_data&#x3D;&#x3D;0); &#x2F;&#x2F;等待DHT响应信号，80us内来拉高总线<br>            while(Temp_data&#x3D;&#x3D;1); &#x2F;&#x2F;等待DHT响应信号，80us内来拉低总线<br>        R_H&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收湿度高八位<br>        R_L&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收湿度低八位<br>        T_H&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收温度高八位<br>        T_L&#x3D;DHT11_rec_byte();    &#x2F;&#x2F;接收温度低八位<br>        revise&#x3D;DHT11_rec_byte(); &#x2F;&#x2F;接收校正位<br>        Delayus(25);    &#x2F;&#x2F;结束</p><pre><code>    if((R_H+R_L+T_H+T_L)==revise)      //校正    &#123;                 led2 = 0;        RH=R_H;        RL=R_L;        TH=T_H;        TL=T_L;                    &#125;    /*数据处理，方便显示*/    rec_dat[0]=RH;    rec_dat[1]=RL;    rec_dat[2]=TH;    rec_dat[3]=TL;</code></pre><p>  }else{led&#x3D;1;}<br>}&#96;</p><h4 id="程序完整源码工程"><a href="#程序完整源码工程" class="headerlink" title="程序完整源码工程"></a>程序完整源码工程</h4><p>创作不易！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1Bm8VW8S0CbFC5sw0taGB_w </span><br><span class="line">提取码：gkjj</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1Bm8VW8S0CbFC5sw0taGB_w  提取码：gkjj</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】4-16译码器（74HC154 ）流水灯</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F416%E8%AF%91%E7%A0%81%E5%99%A874HC154-%E6%B5%81%E6%B0%B4%E7%81%AF/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F416%E8%AF%91%E7%A0%81%E5%99%A874HC154-%E6%B5%81%E6%B0%B4%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】4-16译码器（74HC154-）流水灯"><a href="#【Proteus仿真】4-16译码器（74HC154-）流水灯" class="headerlink" title="【Proteus仿真】4-16译码器（74HC154 ）流水灯"></a>【Proteus仿真】4-16译码器（74HC154 ）流水灯</h1><h3 id="【Proteus仿真】4-16译码器（74HC154-）流水灯-1"><a href="#【Proteus仿真】4-16译码器（74HC154-）流水灯-1" class="headerlink" title="【Proteus仿真】4-16译码器（74HC154 ）流水灯"></a>【Proteus仿真】4-16译码器（74HC154 ）流水灯</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/38a7d5893ad94afbba446ff0fce32668.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="74HC154简介"><a href="#74HC154简介" class="headerlink" title="74HC154简介"></a>74HC154简介</h4><p>74HC154；74HCT154是一种高速硅栅CMOS器件，与低功耗肖特基TTL（LSTTL）引脚兼容。 74HC154解码器接受四个活动的高二进制地址输入并提供16个互斥的活动低输出。双输入使能门可以用来选通解码器，以消除输出上的正常解码“小故障”，或者可以用来扩展解码器。 使能门有两个输入,必须接低电平，以使能输出。 74HC154可以通过使用使能输入之一作为多路复用数据输入来用作1-到16的解复用器。 当另一个启用输入为LOW时，寻址输出将遵循应用数据的状态。</p><ul><li>74HC154功能图</li><li>逻辑功能图</li><li>引脚图</li></ul><p><img src="https://img-blog.csdnimg.cn/f27422fb1f7b47528de9154a2b8d8b58.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/68d06876c8364487bb7aa5f2097098ef.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/d49b3caffbe44cd7af77fc94be1ffa4d.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/039ecbbb5a4648dcb698885b84b48fd8.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a2aa8688076b4de6ad74cc8c443b9fda.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/23ad22344420486882b8163b044dd475.png" alt="在这里插入图片描述"></p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://img-blog.csdnimg.cn/5b0989615c384d0eb97f25aa029cc469.png" alt="在这里插入图片描述"></p><ul><li>供电参数</li></ul><p><img src="https://img-blog.csdnimg.cn/fd267362e2f74211b9afb14087b090a3.png" alt="在这里插入图片描述"></p><h4 id="仿真资源和程序源码以及数据手册资料"><a href="#仿真资源和程序源码以及数据手册资料" class="headerlink" title="仿真资源和程序源码以及数据手册资料"></a>仿真资源和程序源码以及数据手册资料</h4><p><img src="https://img-blog.csdnimg.cn/ea3f108a37a2475a9a9082a940e86f7e.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1055dXTKsHzXnKdNIAbCs4Q </span><br><span class="line">提取码：iefm</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1055dXTKsHzXnKdNIAbCs4Q  提取码：iefm</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】PCF8591 AD电压采集8X8点阵显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FPCF8591-AD%E7%94%B5%E5%8E%8B%E9%87%87%E9%9B%868X8%E7%82%B9%E9%98%B5%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FPCF8591-AD%E7%94%B5%E5%8E%8B%E9%87%87%E9%9B%868X8%E7%82%B9%E9%98%B5%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】PCF8591-AD电压采集8X8点阵显示"><a href="#【Proteus仿真】PCF8591-AD电压采集8X8点阵显示" class="headerlink" title="【Proteus仿真】PCF8591 AD电压采集8X8点阵显示"></a>【Proteus仿真】PCF8591 AD电压采集8X8点阵显示</h1><h3 id="【Proteus仿真】PCF8591-AD电压采集8X8点阵显示-1"><a href="#【Proteus仿真】PCF8591-AD电压采集8X8点阵显示-1" class="headerlink" title="【Proteus仿真】PCF8591 AD电压采集8X8点阵显示"></a>【Proteus仿真】PCF8591 AD电压采集8X8点阵显示</h3><ul><li>Proteus仿真效果</li><li>采用的是8X8点阵来作为数据显示的，显示精度是小数点后2位，显示方式是轮流显示。</li><li>读取的电压范围是：0 ~ 4.98V（滑动电阻在0欧姆是的电压值为最高4.98V，滑动电阻阻值最大时，电压值最低0.）</li><li>采用数据锁存器74HC573来驱动显示的。</li></ul><p>Proteus仿真效果</p><p><img src="https://img-blog.csdnimg.cn/27eb77c85edc4419b087b6254acba635.gif#pic_center" alt="在这里插入图片描述"></p><p>采用的是8X8点阵来作为数据显示的，显示精度是小数点后2位，显示方式是轮流显示。</p><p>读取的电压范围是：0 ~ 4.98V（滑动电阻在0欧姆是的电压值为最高4.98V，滑动电阻阻值最大时，电压值最低0.）</p><p><code>0 ~ 4.98V</code></p><p>采用数据锁存器74HC573来驱动显示的。</p><h4 id="主程序示例代码"><a href="#主程序示例代码" class="headerlink" title="主程序示例代码"></a>主程序示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">/**********************************************************************************</span><br><span class="line"></span><br><span class="line">--------------------------------*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include &lt;I2C.H&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define  PCF8591 0x90    //PCF8591 地址</span><br><span class="line"></span><br><span class="line">unsigned char code tab[]= &#123;0xfe,0xfd,0xfb,0xf7,</span><br><span class="line">                           0xef,0xdf,0xbf,0x7f</span><br><span class="line">                          &#125;;</span><br><span class="line">unsigned char code graph[11][8]= &#123;</span><br><span class="line">    &#123;0x0,0x18,0x24,0x24,0x24,0x24,0x24,0x18&#125;,//0</span><br><span class="line">    &#123;0x0,0x8,0x18,0x8,0x8,0x8,0x8,0x8&#125;,//1</span><br><span class="line">    &#123;0x0,0x18,0x24,0x24,0x8,0x10,0x20,0x3C&#125;,//2</span><br><span class="line">    &#123;0x0,0x18,0x24,0x4,0x8,0x24,0x24,0x18&#125;,//3</span><br><span class="line">    &#123;0x0,0x8,0x8,0x18,0x28,0x3C,0x8,0x8&#125;,//4</span><br><span class="line">    &#123;0x0,0x3C,0x20,0x38,0x4,0x4,0x24,0x18&#125;,//5</span><br><span class="line">    &#123;0x0,0x18,0x24,0x20,0x38,0x24,0x24,0x18&#125;,//6</span><br><span class="line">    &#123;0x0,0x3C,0x24,0x4,0x8,0x10,0x10,0x10&#125;,//7</span><br><span class="line">    &#123;0x0,0x18,0x24,0x24,0x18,0x24,0x24,0x18&#125;,//8</span><br><span class="line">    &#123;0x0,0x18,0x24,0x24,0x1C,0x4,0x24,0x18&#125;,//9</span><br><span class="line">    &#123;0x4C,0xD2,0x52,0x52,0x52,0x52,0x52,0xEC&#125;,//10</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned char count;</span><br><span class="line">unsigned char cnta;</span><br><span class="line"></span><br><span class="line">unsigned char AD_CHANNEL;</span><br><span class="line">unsigned int  D[4];</span><br><span class="line"></span><br><span class="line">void delay11(unsigned int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    while(--cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*******************************************************************</span><br><span class="line">ADC发送字节[命令]数据函数</span><br><span class="line">*******************************************************************/</span><br><span class="line">bit ISendByte(unsigned char sla,unsigned char c)</span><br><span class="line">&#123;</span><br><span class="line">    Start_I2c();              //启动总线</span><br><span class="line">    SendByte(sla);            //发送器件地址</span><br><span class="line">    if(ack==0)return(0);</span><br><span class="line">    SendByte(c);              //发送数据</span><br><span class="line">    if(ack==0)return(0);</span><br><span class="line">    Stop_I2c();               //结束总线</span><br><span class="line">    return(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*******************************************************************</span><br><span class="line">ADC读字节数据函数</span><br><span class="line">*******************************************************************/</span><br><span class="line">unsigned char IRcvByte(unsigned char sla)</span><br><span class="line">&#123;   unsigned char c;</span><br><span class="line"></span><br><span class="line">    Start_I2c();          //启动总线</span><br><span class="line">    SendByte(sla+1);      //发送器件地址</span><br><span class="line">    if(ack==0)return(0);</span><br><span class="line">    c=RcvByte();          //读取数据0</span><br><span class="line"></span><br><span class="line">    Ack_I2c(1);           //发送非就答位</span><br><span class="line">    Stop_I2c();           //结束总线</span><br><span class="line">    return(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******************************************************************/</span><br><span class="line">main()</span><br><span class="line">&#123;   unsigned char jj,kk,ll,bb,cc,dd;</span><br><span class="line">    double Data; //</span><br><span class="line">    double V; //转化成的电压值</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        ISendByte(PCF8591,0x40);</span><br><span class="line">        Data=IRcvByte(PCF8591);  //ADC0 模数转换1</span><br><span class="line">        V=Data*5/256;</span><br><span class="line">        D[0]=V*100;</span><br><span class="line"></span><br><span class="line">        for(bb=0; bb&lt;10; bb++) &#123;</span><br><span class="line">            for(jj=0; jj&lt;8; jj++) //共要扫描八行</span><br><span class="line">            &#123;</span><br><span class="line">                P1=graph[D[0]/100][jj];   //送字模数据</span><br><span class="line">                P2=tab[jj];</span><br><span class="line">                delay11(200);   //选中第一行</span><br><span class="line">                P2=0xff;</span><br><span class="line">                delay11(500);</span><br><span class="line">            &#125;</span><br><span class="line">            delay11(500);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(bb=0; bb&lt;10; bb++) &#123;</span><br><span class="line">            for(jj=0; jj&lt;8; jj++) //共要扫描八行</span><br><span class="line">            &#123;</span><br><span class="line">                P1=0x06;</span><br><span class="line">                P2=0x7f;</span><br><span class="line">                delay11(500);</span><br><span class="line">                P2=0xbf;</span><br><span class="line">                delay11(500);</span><br><span class="line">            &#125;</span><br><span class="line">            delay11(500);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(cc=0; cc&lt;10; cc++) &#123;</span><br><span class="line">            for(kk=0; kk&lt;8; kk++) //共要扫描八行</span><br><span class="line">            &#123;</span><br><span class="line">                P1=graph[D[0]%100/10][kk];   //送字模数据</span><br><span class="line">                P2=tab[kk];</span><br><span class="line">                delay11(200);   //选中第一行</span><br><span class="line">                P2=0xff;</span><br><span class="line">                delay11(500);</span><br><span class="line">            &#125;</span><br><span class="line">            delay11(500);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(dd=0; dd&lt;10; dd++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(ll=0; ll&lt;8; ll++) //共要扫描八行</span><br><span class="line">            &#123;</span><br><span class="line">                P1=graph[D[0]%10][ll];   //送字模数据</span><br><span class="line">                P2=tab[ll];</span><br><span class="line">                delay11(200);   //选中第一行</span><br><span class="line">                P2=0xff;</span><br><span class="line">                delay11(500);</span><br><span class="line">            &#125;</span><br><span class="line">            delay11(500);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;**********************************************************************************</p><p>——————————–*&#x2F;</p><p>#include&lt;reg52.h&gt;<br>#include &lt;I2C.H&gt;<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>#define  PCF8591 0x90    &#x2F;&#x2F;PCF8591 地址</p><p>unsigned char code tab[]&#x3D; {0xfe,0xfd,0xfb,0xf7,<br>                           0xef,0xdf,0xbf,0x7f<br>                          };<br>unsigned char code graph[11][8]&#x3D; {<br>    {0x0,0x18,0x24,0x24,0x24,0x24,0x24,0x18},&#x2F;&#x2F;0<br>    {0x0,0x8,0x18,0x8,0x8,0x8,0x8,0x8},&#x2F;&#x2F;1<br>    {0x0,0x18,0x24,0x24,0x8,0x10,0x20,0x3C},&#x2F;&#x2F;2<br>    {0x0,0x18,0x24,0x4,0x8,0x24,0x24,0x18},&#x2F;&#x2F;3<br>    {0x0,0x8,0x8,0x18,0x28,0x3C,0x8,0x8},&#x2F;&#x2F;4<br>    {0x0,0x3C,0x20,0x38,0x4,0x4,0x24,0x18},&#x2F;&#x2F;5<br>    {0x0,0x18,0x24,0x20,0x38,0x24,0x24,0x18},&#x2F;&#x2F;6<br>    {0x0,0x3C,0x24,0x4,0x8,0x10,0x10,0x10},&#x2F;&#x2F;7<br>    {0x0,0x18,0x24,0x24,0x18,0x24,0x24,0x18},&#x2F;&#x2F;8<br>    {0x0,0x18,0x24,0x24,0x1C,0x4,0x24,0x18},&#x2F;&#x2F;9<br>    {0x4C,0xD2,0x52,0x52,0x52,0x52,0x52,0xEC},&#x2F;&#x2F;10<br>};</p><p>unsigned char count;<br>unsigned char cnta;</p><p>unsigned char AD_CHANNEL;<br>unsigned int  D[4];</p><p>void delay11(unsigned int cnt)<br>{<br>    while(–cnt);<br>}</p><p>&#x2F;*******************************************************************<br>ADC发送字节[命令]数据函数<br>*******************************************************************&#x2F;<br>bit ISendByte(unsigned char sla,unsigned char c)<br>{<br>    Start_I2c();              &#x2F;&#x2F;启动总线<br>    SendByte(sla);            &#x2F;&#x2F;发送器件地址<br>    if(ack&#x3D;&#x3D;0)return(0);<br>    SendByte(c);              &#x2F;&#x2F;发送数据<br>    if(ack&#x3D;&#x3D;0)return(0);<br>    Stop_I2c();               &#x2F;&#x2F;结束总线<br>    return(1);<br>}</p><p>&#x2F;*******************************************************************<br>ADC读字节数据函数<br>*******************************************************************&#x2F;<br>unsigned char IRcvByte(unsigned char sla)<br>{   unsigned char c;</p><pre><code>Start_I2c();          //启动总线SendByte(sla+1);      //发送器件地址if(ack==0)return(0);c=RcvByte();          //读取数据0Ack_I2c(1);           //发送非就答位Stop_I2c();           //结束总线return(c);</code></pre><p>}</p><p>&#x2F;&#x2F;******************************************************************&#x2F;<br>main()<br>{   unsigned char jj,kk,ll,bb,cc,dd;<br>    double Data; &#x2F;&#x2F;<br>    double V; &#x2F;&#x2F;转化成的电压值</p><pre><code>while(1)&#123;    ISendByte(PCF8591,0x40);    Data=IRcvByte(PCF8591);  //ADC0 模数转换1    V=Data*5/256;    D[0]=V*100;    for(bb=0; bb&lt;10; bb++) &#123;        for(jj=0; jj&lt;8; jj++) //共要扫描八行        &#123;            P1=graph[D[0]/100][jj];   //送字模数据            P2=tab[jj];            delay11(200);   //选中第一行            P2=0xff;            delay11(500);        &#125;        delay11(500);    &#125;    for(bb=0; bb&lt;10; bb++) &#123;        for(jj=0; jj&lt;8; jj++) //共要扫描八行        &#123;            P1=0x06;            P2=0x7f;            delay11(500);            P2=0xbf;            delay11(500);        &#125;        delay11(500);    &#125;    for(cc=0; cc&lt;10; cc++) &#123;        for(kk=0; kk&lt;8; kk++) //共要扫描八行        &#123;            P1=graph[D[0]%100/10][kk];   //送字模数据            P2=tab[kk];            delay11(200);   //选中第一行            P2=0xff;            delay11(500);        &#125;        delay11(500);    &#125;    for(dd=0; dd&lt;10; dd++)    &#123;        for(ll=0; ll&lt;8; ll++) //共要扫描八行        &#123;            P1=graph[D[0]%10][ll];   //送字模数据            P2=tab[ll];            delay11(200);   //选中第一行            P2=0xff;            delay11(500);        &#125;        delay11(500);    &#125;&#125;</code></pre><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1IQYZ9810e0Nr3Z_BnriRMw </span><br><span class="line">提取码：xtrt</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1IQYZ9810e0Nr3Z_BnriRMw  提取码：xtrt</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】TLC5615输出256点正弦波（振幅可调）</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FTLC5615%E8%BE%93%E5%87%BA256%E7%82%B9%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E5%B9%85%E5%8F%AF%E8%B0%83/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FTLC5615%E8%BE%93%E5%87%BA256%E7%82%B9%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E5%B9%85%E5%8F%AF%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】TLC5615输出256点正弦波（振幅可调）"><a href="#【Proteus仿真】TLC5615输出256点正弦波（振幅可调）" class="headerlink" title="【Proteus仿真】TLC5615输出256点正弦波（振幅可调）"></a>【Proteus仿真】TLC5615输出256点正弦波（振幅可调）</h1><h3 id="【Proteus仿真】TLC5615输出256点正弦波（振幅可调）-1"><a href="#【Proteus仿真】TLC5615输出256点正弦波（振幅可调）-1" class="headerlink" title="【Proteus仿真】TLC5615输出256点正弦波（振幅可调）"></a>【Proteus仿真】TLC5615输出256点正弦波（振幅可调）</h3><ul><li>相关篇《【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）》</li><li>Proteus仿真</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/124524009">【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）</a></p><p><img src="https://img-blog.csdnimg.cn/9a9219760e8343a1a6ed159b8637ca81.gif#pic_center" alt="在这里插入图片描述"></p><p>通过可调电阻，调节参考引脚输入的电压值，从而改变输出振幅</p><ul><li>所需要使用到的工具</li></ul><p>正弦波数据生成器（最大4096点）</p><p><img src="https://img-blog.csdnimg.cn/b7424cec79de4160b6d68be51c85b5a1.png" alt="在这里插入图片描述"></p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/************************************************************************************</span><br><span class="line">1.TLC5615 DA模块</span><br><span class="line">【程序功能】TLC5615输出256点正弦波</span><br><span class="line">TLC5615 DA模块本身必须使用5V电源，控制信号可以接受3.3V或者5V。</span><br><span class="line">【IO配置】</span><br><span class="line">DIN---&gt;P1.0</span><br><span class="line">SCLK---&gt;P1.1</span><br><span class="line">CS---&gt;P1.2</span><br><span class="line">Dout---&gt;空，未定义</span><br><span class="line">************************************************************************************/</span><br><span class="line">#include&lt;reg52.h&gt;//包含51单片机寄存器定义的头文件</span><br><span class="line">#include&lt;intrins.h&gt;//包含nop函数的头文件</span><br><span class="line">#define uchar unsigned char//宏定义</span><br><span class="line">#define uint unsigned int//宏定义</span><br><span class="line"></span><br><span class="line">sbit DIN=P1^0;//IO定义</span><br><span class="line">sbit SCLK=P1^1;</span><br><span class="line">sbit CS=P1^2;</span><br><span class="line"></span><br><span class="line">uint code sin1[256]=//256点12位数据的正弦波表</span><br><span class="line">&#123;</span><br><span class="line">0x7F,0x82,0x85,0x88,0x8B,0x8F,0x92,0x95,0x98,0x9B,0x9E,0xA1,0xA4,0xA7,0xAA,0xAD</span><br><span class="line">,0xB0,0xB3,0xB6,0xB8,0xBB,0xBE,0xC1,0xC3,0xC6,0xC8,0xCB,0xCD,0xD0,0xD2,0xD5,0xD7</span><br><span class="line">,0xD9,0xDB,0xDD,0xE0,0xE2,0xE4,0xE5,0xE7,0xE9,0xEB,0xEC,0xEE,0xEF,0xF1,0xF2,0xF4</span><br><span class="line">,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFB,0xFC,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFE</span><br><span class="line">,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFD,0xFD,0xFC,0xFB,0xFB,0xFA,0xF9,0xF8,0xF7,0xF6</span><br><span class="line">,0xF5,0xF4,0xF2,0xF1,0xEF,0xEE,0xEC,0xEB,0xE9,0xE7,0xE5,0xE4,0xE2,0xE0,0xDD,0xDB</span><br><span class="line">,0xD9,0xD7,0xD5,0xD2,0xD0,0xCD,0xCB,0xC8,0xC6,0xC3,0xC1,0xBE,0xBB,0xB8,0xB6,0xB3</span><br><span class="line">,0xB0,0xAD,0xAA,0xA7,0xA4,0xA1,0x9E,0x9B,0x98,0x95,0x92,0x8F,0x8B,0x88,0x85,0x82</span><br><span class="line">,0x7F,0x7C,0x79,0x76,0x73,0x6F,0x6C,0x69,0x66,0x63,0x60,0x5D,0x5A,0x57,0x54,0x51</span><br><span class="line">,0x4E,0x4B,0x48,0x46,0x43,0x40,0x3D,0x3B,0x38,0x36,0x33,0x31,0x2E,0x2C,0x29,0x27</span><br><span class="line">,0x25,0x23,0x21,0x1E,0x1C,0x1A,0x19,0x17,0x15,0x13,0x12,0x10,0x0F,0x0D,0x0C,0x0A</span><br><span class="line">,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00</span><br><span class="line">,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08</span><br><span class="line">,0x09,0x0A,0x0C,0x0D,0x0F,0x10,0x12,0x13,0x15,0x17,0x19,0x1A,0x1C,0x1E,0x21,0x23</span><br><span class="line">,0x25,0x27,0x29,0x2C,0x2E,0x31,0x33,0x36,0x38,0x3B,0x3D,0x40,0x43,0x46,0x48,0x4B</span><br><span class="line">,0x4E,0x51,0x54,0x57,0x5A,0x5D,0x60,0x63,0x66,0x69,0x6C,0x6F,0x73,0x76,0x79,0x7C</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> void delay_us(unsigned char n)//us级延时函数</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char i;</span><br><span class="line"> for(i=0;i&lt;n;i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************</span><br><span class="line">1.sclk的上升沿数据进入输入寄存器</span><br><span class="line">2.在sclk为低的时候，CS的上升沿数据开始DA转化</span><br><span class="line">3.连续输入12位数据，高位在前，其中前10位有效，后两位补0</span><br><span class="line">***************************************************************/</span><br><span class="line">void output(uint DA_Value)//TLC5615驱动函数</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">DA_Value=DA_Value&lt;&lt;6;//将DA_Value左移6位，即nnnn nnnn nnnn变为nnnn nnnn nn00 0000</span><br><span class="line">SCLK=0;//为低，准备输入数据</span><br><span class="line">CS=0;//片选</span><br><span class="line">for(i=12;i&gt;0;i--)//从高位开始，连续取出12位数据，</span><br><span class="line">&#123;</span><br><span class="line">if(DA_Value&amp;0x8000)//和1000 0000 0000 0000求与，获取最高位的值。</span><br><span class="line">DIN=1;</span><br><span class="line">else</span><br><span class="line">DIN=0;</span><br><span class="line">SCLK=1;//上升沿，进入输入寄存器</span><br><span class="line">SCLK=0;//准备下一次输入</span><br><span class="line">DA_Value=DA_Value&lt;&lt;1;//左移1位，准备输入下一位数据</span><br><span class="line">&#125;</span><br><span class="line">CS=1;//在sclk为低的时候，CS上升沿，数据开始DA转化</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   uint i;</span><br><span class="line">   while(1)</span><br><span class="line">&#123;</span><br><span class="line">i=0;</span><br><span class="line">for(i=0;i&lt;255;i++)//连续取出256点正弦数据</span><br><span class="line">output(sin1[i]);//输出正弦波</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;************************************************************************************<br>1.TLC5615 DA模块<br>【程序功能】TLC5615输出256点正弦波<br>TLC5615 DA模块本身必须使用5V电源，控制信号可以接受3.3V或者5V。<br>【IO配置】<br>DIN—&gt;P1.0<br>SCLK—&gt;P1.1<br>CS—&gt;P1.2<br>Dout—&gt;空，未定义<br>************************************************************************************&#x2F;<br>#include&lt;reg52.h&gt;&#x2F;&#x2F;包含51单片机寄存器定义的头文件<br>#include&lt;intrins.h&gt;&#x2F;&#x2F;包含nop函数的头文件<br>#define uchar unsigned char&#x2F;&#x2F;宏定义<br>#define uint unsigned int&#x2F;&#x2F;宏定义</p><p>sbit DIN&#x3D;P1^0;&#x2F;&#x2F;IO定义<br>sbit SCLK&#x3D;P1^1;<br>sbit CS&#x3D;P1^2;</p><p>uint code sin1[256]&#x3D;&#x2F;&#x2F;256点12位数据的正弦波表<br>{<br>    0x7F,0x82,0x85,0x88,0x8B,0x8F,0x92,0x95,0x98,0x9B,0x9E,0xA1,0xA4,0xA7,0xAA,0xAD<br>,0xB0,0xB3,0xB6,0xB8,0xBB,0xBE,0xC1,0xC3,0xC6,0xC8,0xCB,0xCD,0xD0,0xD2,0xD5,0xD7<br>,0xD9,0xDB,0xDD,0xE0,0xE2,0xE4,0xE5,0xE7,0xE9,0xEB,0xEC,0xEE,0xEF,0xF1,0xF2,0xF4<br>,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFB,0xFC,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFE<br>,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFD,0xFD,0xFC,0xFB,0xFB,0xFA,0xF9,0xF8,0xF7,0xF6<br>,0xF5,0xF4,0xF2,0xF1,0xEF,0xEE,0xEC,0xEB,0xE9,0xE7,0xE5,0xE4,0xE2,0xE0,0xDD,0xDB<br>,0xD9,0xD7,0xD5,0xD2,0xD0,0xCD,0xCB,0xC8,0xC6,0xC3,0xC1,0xBE,0xBB,0xB8,0xB6,0xB3<br>,0xB0,0xAD,0xAA,0xA7,0xA4,0xA1,0x9E,0x9B,0x98,0x95,0x92,0x8F,0x8B,0x88,0x85,0x82<br>,0x7F,0x7C,0x79,0x76,0x73,0x6F,0x6C,0x69,0x66,0x63,0x60,0x5D,0x5A,0x57,0x54,0x51<br>,0x4E,0x4B,0x48,0x46,0x43,0x40,0x3D,0x3B,0x38,0x36,0x33,0x31,0x2E,0x2C,0x29,0x27<br>,0x25,0x23,0x21,0x1E,0x1C,0x1A,0x19,0x17,0x15,0x13,0x12,0x10,0x0F,0x0D,0x0C,0x0A<br>,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00<br>,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08<br>,0x09,0x0A,0x0C,0x0D,0x0F,0x10,0x12,0x13,0x15,0x17,0x19,0x1A,0x1C,0x1E,0x21,0x23<br>,0x25,0x27,0x29,0x2C,0x2E,0x31,0x33,0x36,0x38,0x3B,0x3D,0x40,0x43,0x46,0x48,0x4B<br>,0x4E,0x51,0x54,0x57,0x5A,0x5D,0x60,0x63,0x66,0x69,0x6C,0x6F,0x73,0x76,0x79,0x7C<br> };</p><p> void delay_us(unsigned char n)&#x2F;&#x2F;us级延时函数<br>    {<br>         unsigned char i;<br>         for(i&#x3D;0;i&lt;n;i++);<br>    }</p><p>&#x2F;******************************************************************<br>    1.sclk的上升沿数据进入输入寄存器<br>    2.在sclk为低的时候，CS的上升沿数据开始DA转化<br>    3.连续输入12位数据，高位在前，其中前10位有效，后两位补0<br>    ***************************************************************&#x2F;<br>void output(uint DA_Value)&#x2F;&#x2F;TLC5615驱动函数<br>    {<br>        unsigned char i;<br>        DA_Value&#x3D;DA_Value&lt;&lt;6;&#x2F;&#x2F;将DA_Value左移6位，即nnnn nnnn nnnn变为nnnn nnnn nn00 0000<br>        SCLK&#x3D;0;&#x2F;&#x2F;为低，准备输入数据<br>        CS&#x3D;0;&#x2F;&#x2F;片选<br>        for(i&#x3D;12;i&gt;0;i–)&#x2F;&#x2F;从高位开始，连续取出12位数据，<br>            {<br>                if(DA_Value&amp;0x8000)&#x2F;&#x2F;和1000 0000 0000 0000求与，获取最高位的值。<br>                DIN&#x3D;1;<br>                else<br>                DIN&#x3D;0;<br>                SCLK&#x3D;1;&#x2F;&#x2F;上升沿，进入输入寄存器<br>                SCLK&#x3D;0;&#x2F;&#x2F;准备下一次输入<br>                DA_Value&#x3D;DA_Value&lt;&lt;1;&#x2F;&#x2F;左移1位，准备输入下一位数据<br>            }<br>            CS&#x3D;1;&#x2F;&#x2F;在sclk为低的时候，CS上升沿，数据开始DA转化<br>    }<br>void main()<br>{<br>   uint i;<br>   while(1)<br>        {<br>            i&#x3D;0;<br>            for(i&#x3D;0;i&lt;255;i++)&#x2F;&#x2F;连续取出256点正弦数据<br>            output(sin1[i]);&#x2F;&#x2F;输出正弦波<br>        }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1pk0HpbHSKmH8Wwav-_VrwQ </span><br><span class="line">提取码：bkb4</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1pk0HpbHSKmH8Wwav-_VrwQ  提取码：bkb4</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】uln2003驱动二相四线制步进电机正转</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9Fuln2003%E9%A9%B1%E5%8A%A8%E4%BA%8C%E7%9B%B8%E5%9B%9B%E7%BA%BF%E5%88%B6%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E6%AD%A3%E8%BD%AC/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9Fuln2003%E9%A9%B1%E5%8A%A8%E4%BA%8C%E7%9B%B8%E5%9B%9B%E7%BA%BF%E5%88%B6%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E6%AD%A3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】uln2003驱动二相四线制步进电机正转"><a href="#【Proteus仿真】uln2003驱动二相四线制步进电机正转" class="headerlink" title="【Proteus仿真】uln2003驱动二相四线制步进电机正转"></a>【Proteus仿真】uln2003驱动二相四线制步进电机正转</h1><h3 id="【Proteus仿真】二相四线制步进电机控制正转"><a href="#【Proteus仿真】二相四线制步进电机控制正转" class="headerlink" title="【Proteus仿真】二相四线制步进电机控制正转"></a>【Proteus仿真】二相四线制步进电机控制正转</h3><ul><li>Proteus演示</li><li>两相四线步进电机内部线圈</li></ul><p><img src="https://img-blog.csdnimg.cn/72248836e34946cbad93566e381fbac4.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/853da9ddeb84411282a11498fe513e0f.png" alt="在这里插入图片描述"></p><h4 id="正转测试代码"><a href="#正转测试代码" class="headerlink" title="正转测试代码"></a>正转测试代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//2线四相八拍</span><br><span class="line">#include &lt;STC89C5xRC.H&gt;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">while(1)&#123;</span><br><span class="line"></span><br><span class="line">unsigned int i,j,k;</span><br><span class="line"></span><br><span class="line"> for(k=0;k&lt;255;k++)&#123;</span><br><span class="line">//四线八拍</span><br><span class="line">for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x01;//0001</span><br><span class="line"> for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x03;//0011</span><br><span class="line">   for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x02;//0010</span><br><span class="line">  for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x06;//0110</span><br><span class="line"> for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x04;//0100</span><br><span class="line"> for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x0c;//1100</span><br><span class="line">   for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x08;//1000</span><br><span class="line">  for(i=0;i&lt;75;i++)</span><br><span class="line">for(j=0;j&lt;255;j++);</span><br><span class="line"></span><br><span class="line">P2=0x09;//1001</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;&#x2F;2线四相八拍<br>#include &lt;STC89C5xRC.H&gt;</p><p>main(){</p><p>while(1){</p><p>unsigned int i,j,k;</p><p> for(k&#x3D;0;k&lt;255;k++){<br>&#x2F;&#x2F;四线八拍<br>for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x01;&#x2F;&#x2F;0001<br> for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x03;&#x2F;&#x2F;0011<br>   for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x02;&#x2F;&#x2F;0010<br>  for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x06;&#x2F;&#x2F;0110<br> for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x04;&#x2F;&#x2F;0100<br> for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x0c;&#x2F;&#x2F;1100<br>   for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x08;&#x2F;&#x2F;1000<br>  for(i&#x3D;0;i&lt;75;i++)<br>for(j&#x3D;0;j&lt;255;j++);</p><p>P2&#x3D;0x09;&#x2F;&#x2F;1001<br> }</p><p>  }<br>}&#96;</p><h4 id="仿真文件和代码资源"><a href="#仿真文件和代码资源" class="headerlink" title="仿真文件和代码资源"></a>仿真文件和代码资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/12mUuafhSGwk7EWwUjQ1pNA </span><br><span class="line">提取码：1j59</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/12mUuafhSGwk7EWwUjQ1pNA  提取码：1j59</code></p><h4 id="改进型"><a href="#改进型" class="headerlink" title="改进型"></a>改进型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">unsigned char code F_Rotation[]=&#123;0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09&#125;;//正转表格</span><br><span class="line">unsigned char code B_Rotation[]=&#123;0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01&#125;;//反转表格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void DelayMS(uint t)</span><br><span class="line">&#123;</span><br><span class="line"> uchar k;</span><br><span class="line">   while(t--)</span><br><span class="line">   &#123;</span><br><span class="line">    for(k=0; k&lt;125; k++);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> unsigned char i;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">  for(i=0;i&lt;8;i++)      //4相</span><br><span class="line">     &#123;</span><br><span class="line">//     P2=F_Rotation[i];  //输出对应的相 可以自行换成正转表格</span><br><span class="line">  P2=B_Rotation[i];   //输出对应的相 可以自行换成反转表格</span><br><span class="line">     DelayMS(80);        //改变这个参数可以调整电机转速</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char</p><p>unsigned char code F_Rotation[]&#x3D;{0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09};&#x2F;&#x2F;正转表格<br>unsigned char code B_Rotation[]&#x3D;{0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01};&#x2F;&#x2F;反转表格</p><p>void DelayMS(uint t)<br>{<br> uchar k;<br>   while(t–)<br>   {<br>    for(k&#x3D;0; k&lt;125; k++);<br>}<br>     }<br>void main()<br>{</p><p> unsigned char i;</p><p> while(1)<br> {<br>  for(i&#x3D;0;i&lt;8;i++)      &#x2F;&#x2F;4相<br>     {<br>&#x2F;&#x2F;     P2&#x3D;F_Rotation[i];  &#x2F;&#x2F;输出对应的相 可以自行换成正转表格<br>              P2&#x3D;B_Rotation[i];   &#x2F;&#x2F;输出对应的相 可以自行换成反转表格<br>         DelayMS(80);        &#x2F;&#x2F;改变这个参数可以调整电机转速<br>     }<br>  }<br>}&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】单片机+DS18B20+LCD1602显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%8D%95%E7%89%87%E6%9C%BADS18B20LCD1602%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%8D%95%E7%89%87%E6%9C%BADS18B20LCD1602%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】单片机-DS18B20-LCD1602显示"><a href="#【Proteus仿真】单片机-DS18B20-LCD1602显示" class="headerlink" title="【Proteus仿真】单片机+DS18B20+LCD1602显示"></a>【Proteus仿真】单片机+DS18B20+LCD1602显示</h1><h3 id="【Proteus仿真】单片机-DS18B20-LCD1602显示-1"><a href="#【Proteus仿真】单片机-DS18B20-LCD1602显示-1" class="headerlink" title="【Proteus仿真】单片机+DS18B20+LCD1602显示"></a>【Proteus仿真】单片机+DS18B20+LCD1602显示</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/17b5d4fa50e642fdb90f0b823520c4fd.gif#pic_center" alt="在这里插入图片描述"></p><p>带小数点显示，处理小数点显示，温度符号采用ASCII码，0xdf来表示”句号”</p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;absacc.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;DS18B20.h&gt;</span><br><span class="line">#include &quot;LCD1602.h&quot;液晶显示头文件</span><br><span class="line">//sbit DQ = P3^4;//定义DQ引脚为P3.4</span><br><span class="line">unsigned char t[2],*pt;//用来存放温度值,测温程序就是通过这个数组与主函数通信的</span><br><span class="line">unsigned char  TempBuffer1[9]=&#123;0x2b,0x31,0x32,0x32,0x2e,0x30,0x30,0xdf,&#x27;C&#x27;&#125;;</span><br><span class="line">//显示实时温度,0xdf代表℃</span><br><span class="line">unsigned char  TempBuffer0[16]=&#123;0x48,0x3a,0x2b,0x31,0x32,0x35,0x20,</span><br><span class="line">0x4c,0x3a,0x31,0x32,0x34,0x30,0xdf,&#x27;C&#x27;&#125;;</span><br><span class="line">//显示温度上下限,上电时显示TH:+110 TL:+124C</span><br><span class="line">unsigned char code dotcode[4]=&#123;0,25,50,75&#125;;</span><br><span class="line">/***因显示分辨率为0.25,但小数运算比较麻烦,故采用查表的方法*******</span><br><span class="line">再将表值分离出十位和个位后送到十分位和百分位********************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void covert0( unsigned char TH, unsigned char TL)//将温度上下限转换为LCD显示的数据</span><br><span class="line">&#123; </span><br><span class="line">   if(TH&gt;0x7F)                    //判断正负,如果为负温,将其转化为其绝对值</span><br><span class="line">   &#123;</span><br><span class="line">    TempBuffer0[2]=0x2d;     //0x2d为&quot;-&quot;的ASCII码</span><br><span class="line">TH=~TH;</span><br><span class="line">TH++;</span><br><span class="line">   &#125;</span><br><span class="line">   else TempBuffer0[2]=0x2b;//0x2B为&quot;+&quot;的ASCII码</span><br><span class="line"></span><br><span class="line">   if(TL&gt;0x7f)</span><br><span class="line">   &#123;</span><br><span class="line">   TempBuffer0[9]=0x2d;     //0x2d为&quot;-&quot;的ASCII码</span><br><span class="line">   TL=~TL+1;</span><br><span class="line">   &#125;</span><br><span class="line">   else TempBuffer0[9]=0x2b;//0x2B为&quot;+&quot;的ASCII码</span><br><span class="line"></span><br><span class="line">  TempBuffer0[3]=TH/100+0x30;             //分离出TH的百十个位</span><br><span class="line">  if( TempBuffer0[3]==0x30) TempBuffer0[4]=0xfe; //百位数消隐</span><br><span class="line">  TempBuffer0[4]=(TH%100)/10+0x30;//分离出十位</span><br><span class="line">  TempBuffer0[5]=(TH%100)%10+0x30; //分离出个位</span><br><span class="line">  TempBuffer0[10]=TL/100+0x30;             //分离出TL的百十个位</span><br><span class="line">  if( TempBuffer0[10]==0x30) TempBuffer0[10]=0xfe; //百位数消隐</span><br><span class="line">  TempBuffer0[11]=(TL%100)/10+0x30;//分离出十位</span><br><span class="line">  TempBuffer0[12]=(TL%100)%10+0x30; //分离出个位</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void covert1(void)//将温度转换为LCD显示的数据</span><br><span class="line">&#123;</span><br><span class="line">   unsigned char x=0x00,y=0x00;</span><br><span class="line">   t[0]=*pt;</span><br><span class="line">   pt++;</span><br><span class="line">   t[1]=*pt;</span><br><span class="line">   if(t[1]&gt;0x07)                    //判断正负温度</span><br><span class="line">   &#123;</span><br><span class="line">    TempBuffer1[0]=0x2d;     //0x2d为&quot;-&quot;的ASCII码</span><br><span class="line">t[1]=~t[1]; /*下面几句把负数的补码*/</span><br><span class="line">t[0]=~t[0];  /* 换算成绝对值*********/</span><br><span class="line">x=t[0]+1; /***********************/</span><br><span class="line">t[0]=x; /***********************/</span><br><span class="line">if(x&gt;255)                /**********************/</span><br><span class="line">t[1]++; /*********************/</span><br><span class="line">   &#125;</span><br><span class="line">   else TempBuffer1[0]=0x2b;//0xfe为变&quot;+&quot;的ASCII码</span><br><span class="line">  t[1]&lt;&lt;=4;//将高字节左移4位</span><br><span class="line">  t[1]=t[1]&amp;0x70;//取出高字节的3个有效数字位</span><br><span class="line">  x=t[0];//将t[0]暂存到X,因为取小数部分还要用到它</span><br><span class="line">  x&gt;&gt;=4;//右移4位</span><br><span class="line">  x=x&amp;0x0f;//和前面两句就是取出t[0]的高四位</span><br><span class="line">  t[1]=t[1]|x;//将高低字节的有效值的整数部分拼成一个字节</span><br><span class="line">  TempBuffer1[1]=t[1]/100+0x30;             //+0x30 为变 0~9 ASCII码</span><br><span class="line">   if( TempBuffer1[1]==0x30) TempBuffer1[1]=0xfe; //百位数消隐</span><br><span class="line">  TempBuffer1[2]=(t[1]%100)/10+&#x27;0&#x27;;//分离出十位</span><br><span class="line">  TempBuffer1[3]=(t[1]%100)%10+&#x27;0&#x27;; //分离出个位</span><br><span class="line">  t[0]=t[0]&amp;0x0c;//取有效的两位小数</span><br><span class="line">  t[0]&gt;&gt;=2;//左移两位,以便查表</span><br><span class="line">  x=t[0];</span><br><span class="line">  y=dotcode[x];//查表换算成实际的小数</span><br><span class="line">  TempBuffer1[5]=y/10+0x30;//分离出十分位</span><br><span class="line">  TempBuffer1[6]=y%10+0x30;//分离出百分位</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delay(unsigned char i)</span><br><span class="line">&#123;</span><br><span class="line">while(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  char TH=110,TL=-20;    //下一步扩展时可能通过这两个变量,调节上下限</span><br><span class="line">        //测温函数返回这个数组的头地址</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">    pt=ReadTemperature(TH,TL,0x3f); //上限温度-22,下限-24,分辨率10位,也就是0.25C</span><br><span class="line"> //读取温度,温度值存放在一个两个字节的数组中,</span><br><span class="line">delay(100); </span><br><span class="line">covert1();</span><br><span class="line">covert0(TH,TL);</span><br><span class="line">LCD_Initial();//第一个参数列号,第二个为行号,为0表示第一行</span><br><span class="line">//为1表示第二行,第三个参数为显示数据的首地址</span><br><span class="line">LCD_Print(0,0,TempBuffer0);</span><br><span class="line">LCD_Print(0,1,TempBuffer1); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;absacc.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;DS18B20.h&gt;<br>#include “LCD1602.h”液晶显示头文件<br>&#x2F;&#x2F;sbit DQ &#x3D; P3^4;&#x2F;&#x2F;定义DQ引脚为P3.4<br>unsigned char t[2],<em>pt;&#x2F;&#x2F;用来存放温度值,测温程序就是通过这个数组与主函数通信的<br>unsigned char  TempBuffer1[9]&#x3D;{0x2b,0x31,0x32,0x32,0x2e,0x30,0x30,0xdf,’C’};<br>                                &#x2F;&#x2F;显示实时温度,0xdf代表℃<br>unsigned char  TempBuffer0[16]&#x3D;{0x48,0x3a,0x2b,0x31,0x32,0x35,0x20,<br>                                0x4c,0x3a,0x31,0x32,0x34,0x30,0xdf,’C’};<br>                                &#x2F;&#x2F;显示温度上下限,上电时显示TH:+110 TL:+124C<br>unsigned char code dotcode[4]&#x3D;{0,25,50,75};<br>&#x2F;<em><strong>因显示分辨率为0.25,但小数运算比较麻烦,故采用查表的方法</strong></em></em>***<br>再将表值分离出十位和个位后送到十分位和百分位********************&#x2F;</p><p>void covert0( unsigned char TH, unsigned char TL)&#x2F;&#x2F;将温度上下限转换为LCD显示的数据<br>{<br>   if(TH&gt;0x7F)                    &#x2F;&#x2F;判断正负,如果为负温,将其转化为其绝对值<br>   {<br>    TempBuffer0[2]&#x3D;0x2d;     &#x2F;&#x2F;0x2d为”-“的ASCII码<br>    TH&#x3D;~TH;<br>    TH++;<br>   }<br>   else TempBuffer0[2]&#x3D;0x2b;&#x2F;&#x2F;0x2B为”+”的ASCII码</p><p>   if(TL&gt;0x7f)<br>   {<br>   TempBuffer0[9]&#x3D;0x2d;     &#x2F;&#x2F;0x2d为”-“的ASCII码<br>   TL&#x3D;~TL+1;<br>   }<br>   else TempBuffer0[9]&#x3D;0x2b;&#x2F;&#x2F;0x2B为”+”的ASCII码</p><p>  TempBuffer0[3]&#x3D;TH&#x2F;100+0x30;             &#x2F;&#x2F;分离出TH的百十个位<br>  if( TempBuffer0[3]&#x3D;&#x3D;0x30) TempBuffer0[4]&#x3D;0xfe; &#x2F;&#x2F;百位数消隐<br>  TempBuffer0[4]&#x3D;(TH%100)&#x2F;10+0x30;&#x2F;&#x2F;分离出十位<br>  TempBuffer0[5]&#x3D;(TH%100)%10+0x30; &#x2F;&#x2F;分离出个位<br>  TempBuffer0[10]&#x3D;TL&#x2F;100+0x30;             &#x2F;&#x2F;分离出TL的百十个位<br>  if( TempBuffer0[10]&#x3D;&#x3D;0x30) TempBuffer0[10]&#x3D;0xfe; &#x2F;&#x2F;百位数消隐<br>  TempBuffer0[11]&#x3D;(TL%100)&#x2F;10+0x30;&#x2F;&#x2F;分离出十位<br>  TempBuffer0[12]&#x3D;(TL%100)%10+0x30; &#x2F;&#x2F;分离出个位<br>}</p><p>void covert1(void)&#x2F;&#x2F;将温度转换为LCD显示的数据<br>{<br>   unsigned char x&#x3D;0x00,y&#x3D;0x00;<br>   t[0]&#x3D;<em>pt;<br>   pt++;<br>   t[1]&#x3D;<em>pt;<br>   if(t[1]&gt;0x07)                    &#x2F;&#x2F;判断正负温度<br>   {<br>    TempBuffer1[0]&#x3D;0x2d;     &#x2F;&#x2F;0x2d为”-“的ASCII码<br>    t[1]&#x3D;<del>t[1]; &#x2F;<em>下面几句把负数的补码</em>&#x2F;<br>    t[0]&#x3D;</del>t[0];  &#x2F;</em> 换算成绝对值</em><strong><strong><strong><strong>&#x2F;<br>    x&#x3D;t[0]+1; &#x2F;</strong></strong></strong></strong><em><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>    t[0]&#x3D;x; &#x2F;</strong></strong></strong></strong></strong></strong></strong></em><strong><strong><strong><strong>&#x2F;<br>    if(x&gt;255)                &#x2F;</strong></strong></strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>    t[1]++; &#x2F;</strong></strong></strong></strong></strong></strong></strong></strong>***</strong>&#x2F;<br>   }<br>   else TempBuffer1[0]&#x3D;0x2b;&#x2F;&#x2F;0xfe为变”+”的ASCII码<br>  t[1]&lt;&lt;&#x3D;4;&#x2F;&#x2F;将高字节左移4位<br>  t[1]&#x3D;t[1]&0x70;&#x2F;&#x2F;取出高字节的3个有效数字位<br>  x&#x3D;t[0];&#x2F;&#x2F;将t[0]暂存到X,因为取小数部分还要用到它<br>  x&gt;&gt;&#x3D;4;&#x2F;&#x2F;右移4位<br>  x&#x3D;x&0x0f;&#x2F;&#x2F;和前面两句就是取出t[0]的高四位<br>  t[1]&#x3D;t[1]|x;&#x2F;&#x2F;将高低字节的有效值的整数部分拼成一个字节<br>  TempBuffer1[1]&#x3D;t[1]&#x2F;100+0x30;             &#x2F;&#x2F;+0x30 为变 0~9 ASCII码<br>   if( TempBuffer1[1]&#x3D;&#x3D;0x30) TempBuffer1[1]&#x3D;0xfe; &#x2F;&#x2F;百位数消隐<br>  TempBuffer1[2]&#x3D;(t[1]%100)&#x2F;10+’0’;&#x2F;&#x2F;分离出十位<br>  TempBuffer1[3]&#x3D;(t[1]%100)%10+’0’; &#x2F;&#x2F;分离出个位<br>  t[0]&#x3D;t[0]&0x0c;&#x2F;&#x2F;取有效的两位小数<br>  t[0]&gt;&gt;&#x3D;2;&#x2F;&#x2F;左移两位,以便查表<br>  x&#x3D;t[0];<br>  y&#x3D;dotcode[x];&#x2F;&#x2F;查表换算成实际的小数<br>  TempBuffer1[5]&#x3D;y&#x2F;10+0x30;&#x2F;&#x2F;分离出十分位<br>  TempBuffer1[6]&#x3D;y%10+0x30;&#x2F;&#x2F;分离出百分位<br>}</p><p>void delay(unsigned char i)<br>{<br>    while(i–);<br>}</p><p>void main()<br>{<br>  char TH&#x3D;110,TL&#x3D;-20;    &#x2F;&#x2F;下一步扩展时可能通过这两个变量,调节上下限<br>                                            &#x2F;&#x2F;测温函数返回这个数组的头地址<br> while(1)<br> {<br>    pt&#x3D;ReadTemperature(TH,TL,0x3f); &#x2F;&#x2F;上限温度-22,下限-24,分辨率10位,也就是0.25C<br>                                         &#x2F;&#x2F;读取温度,温度值存放在一个两个字节的数组中,<br>    delay(100);<br>    covert1();<br>    covert0(TH,TL);<br>    LCD_Initial();&#x2F;&#x2F;第一个参数列号,第二个为行号,为0表示第一行<br>                                            &#x2F;&#x2F;为1表示第二行,第三个参数为显示数据的首地址<br>    LCD_Print(0,0,TempBuffer0);<br>    LCD_Print(0,1,TempBuffer1); <br> }<br>}&#96;</p><h4 id="程序源码仿真资源"><a href="#程序源码仿真资源" class="headerlink" title="程序源码仿真资源"></a>程序源码仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1I9zxuTAft5Y_Uv27P0CP_Q </span><br><span class="line">提取码：ua3g</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1I9zxuTAft5Y_Uv27P0CP_Q  提取码：ua3g</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】外部中断触发倒计时5秒</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91%E5%80%92%E8%AE%A1%E6%97%B65%E7%A7%92/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91%E5%80%92%E8%AE%A1%E6%97%B65%E7%A7%92/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】外部中断触发倒计时5秒"><a href="#【Proteus仿真】外部中断触发倒计时5秒" class="headerlink" title="【Proteus仿真】外部中断触发倒计时5秒"></a>【Proteus仿真】外部中断触发倒计时5秒</h1><h3 id="【Proteus仿真】外部中断触发倒计时5秒-1"><a href="#【Proteus仿真】外部中断触发倒计时5秒-1" class="headerlink" title="【Proteus仿真】外部中断触发倒计时5秒"></a>【Proteus仿真】外部中断触发倒计时5秒</h3><ul><li>相关篇《【Proteus仿真】51单片机外部中断控制输出10秒，后关闭输出》</li><li>Proteus仿真</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/124158563">【Proteus仿真】51单片机外部中断控制输出10秒，后关闭输出</a></p><p><img src="https://img-blog.csdnimg.cn/23f62f693fe745bba6ef1932046a8ef3.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">sbit a = P2^1;</span><br><span class="line">sbit b = P2^0;</span><br><span class="line">uchar code table[]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90&#125;; //共阳极段码0-9 </span><br><span class="line"></span><br><span class="line">uint num=5;</span><br><span class="line">uchar shi=0;</span><br><span class="line">void delayms(uint xms)//延时程序</span><br><span class="line">&#123;</span><br><span class="line">uint i,j;</span><br><span class="line">for(i=xms;i&gt;0;i--)</span><br><span class="line">for(j=110;j&gt;0;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display(uint num)</span><br><span class="line">&#123;</span><br><span class="line">a=1;//共阳极数码管高电平有效</span><br><span class="line">P0=table[num%10];//循环显示0-9</span><br><span class="line">delayms(5);//刷新</span><br><span class="line">P0=0XFF;//消隐</span><br><span class="line">a=0;</span><br><span class="line"></span><br><span class="line">b=1;//共阳极数码管高电平有效</span><br><span class="line">P0=table[(num/10)%10];//循环显示0-9</span><br><span class="line">delayms(5);//刷新</span><br><span class="line">P0=0XFF;//消隐</span><br><span class="line">b=0;</span><br><span class="line">&#125;</span><br><span class="line">//外部中断服务程序</span><br><span class="line">void exint0() interrupt 0 </span><br><span class="line">&#123;</span><br><span class="line">EX0=0;//关闭外部请求中断允许位</span><br><span class="line">TL0 = 0xb0;//设置定时初始值</span><br><span class="line">TH0 = 0x3c;//设置定时初始值</span><br><span class="line">TR0=1;//开启定时器0中断</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Timer0 interrupt routine */</span><br><span class="line">void tm0_isr() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">//EX0 = 0; //关闭INT0中断</span><br><span class="line">if(shi==20)</span><br><span class="line">&#123;//20*50MS定时时间为1秒</span><br><span class="line">shi=0;</span><br><span class="line">if(!num--)&#123;</span><br><span class="line">TR0=0;</span><br><span class="line">EX0=1;//启用外部请求中断允许位</span><br><span class="line">num =5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">TL0 = 0xb0;//设置定时初始值(65536-50000)%256</span><br><span class="line">TH0 = 0x3c;//设置定时初始值(65536-50000)/256</span><br><span class="line"></span><br><span class="line"> shi++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">TMOD = 0x01; /*定时器工作方式1*/</span><br><span class="line">EA=1;//中断总开关</span><br><span class="line">EX0 = 1; //使能INT0中断</span><br><span class="line">ET0=1;//使能定时器0中断</span><br><span class="line">IT0=1;//外部中断采用下降沿触发</span><br><span class="line">INT0 = 1;//外部中断引脚置1</span><br><span class="line">TR0=0;//定时器0允许中断位关闭</span><br><span class="line">TF0 = 0;//清除TF0标志</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">display(num);//调用函数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char</p><p>sbit a &#x3D; P2^1;<br>sbit b &#x3D; P2^0;<br>uchar code table[]&#x3D;{0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90}; &#x2F;&#x2F;共阳极段码0-9 </p><p>uint num&#x3D;5;<br>uchar shi&#x3D;0;<br>void delayms(uint xms)&#x2F;&#x2F;延时程序<br>{<br>    uint i,j;<br>    for(i&#x3D;xms;i&gt;0;i–)<br>        for(j&#x3D;110;j&gt;0;j–);<br>}</p><p>void display(uint num)<br>{<br>        a&#x3D;1;&#x2F;&#x2F;共阳极数码管高电平有效<br>        P0&#x3D;table[num%10];&#x2F;&#x2F;循环显示0-9<br>        delayms(5);&#x2F;&#x2F;刷新<br>        P0&#x3D;0XFF;&#x2F;&#x2F;消隐<br>        a&#x3D;0;</p><pre><code>    b=1;//共阳极数码管高电平有效    P0=table[(num/10)%10];//循环显示0-9    delayms(5);//刷新    P0=0XFF;//消隐    b=0;</code></pre><p>}<br>&#x2F;&#x2F;外部中断服务程序<br>void exint0() interrupt 0<br>{<br>        EX0&#x3D;0;&#x2F;&#x2F;关闭外部请求中断允许位<br>    TL0 &#x3D; 0xb0;&#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0x3c;&#x2F;&#x2F;设置定时初始值<br>        TR0&#x3D;1;&#x2F;&#x2F;开启定时器0中断</p><p>}</p><p>&#x2F;* Timer0 interrupt routine <em>&#x2F;<br>void tm0_isr() interrupt 1<br>{<br>&#x2F;&#x2F;EX0 &#x3D; 0; &#x2F;&#x2F;关闭INT0中断<br>    if(shi&#x3D;&#x3D;20)<br>    {&#x2F;&#x2F;20</em>50MS定时时间为1秒<br>        shi&#x3D;0;<br>        if(!num–){<br>        TR0&#x3D;0;<br>        EX0&#x3D;1;&#x2F;&#x2F;启用外部请求中断允许位<br>        num &#x3D;5;<br>    }<br>    }<br>    TL0 &#x3D; 0xb0;&#x2F;&#x2F;设置定时初始值(65536-50000)%256<br>    TH0 &#x3D; 0x3c;&#x2F;&#x2F;设置定时初始值(65536-50000)&#x2F;256</p><p> shi++;</p><p>}</p><p>void main()<br>{<br>    TMOD &#x3D; 0x01; &#x2F;<em>定时器工作方式1</em>&#x2F;<br>    EA&#x3D;1;&#x2F;&#x2F;中断总开关<br>    EX0 &#x3D; 1; &#x2F;&#x2F;使能INT0中断<br>    ET0&#x3D;1;&#x2F;&#x2F;使能定时器0中断<br>    IT0&#x3D;1;&#x2F;&#x2F;外部中断采用下降沿触发<br>    INT0 &#x3D; 1;&#x2F;&#x2F;外部中断引脚置1<br>    TR0&#x3D;0;&#x2F;&#x2F;定时器0允许中断位关闭<br>    TF0 &#x3D; 0;&#x2F;&#x2F;清除TF0标志<br>    while(1)<br>    {<br>        display(num);&#x2F;&#x2F;调用函数<br>    }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/19rcxhfV_dVtq0frkXR-7kQ </span><br><span class="line">提取码：xkwh</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/19rcxhfV_dVtq0frkXR-7kQ  提取码：xkwh</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】外部中断通过双继电器控制直流电机正反转</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%80%9A%E8%BF%87%E5%8F%8C%E7%BB%A7%E7%94%B5%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%80%9A%E8%BF%87%E5%8F%8C%E7%BB%A7%E7%94%B5%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】外部中断通过双继电器控制直流电机正反转"><a href="#【Proteus仿真】外部中断通过双继电器控制直流电机正反转" class="headerlink" title="【Proteus仿真】外部中断通过双继电器控制直流电机正反转"></a>【Proteus仿真】外部中断通过双继电器控制直流电机正反转</h1><h3 id="【Proteus仿真】外部中断通过双继电器控制直流电机正反转-1"><a href="#【Proteus仿真】外部中断通过双继电器控制直流电机正反转-1" class="headerlink" title="【Proteus仿真】外部中断通过双继电器控制直流电机正反转"></a>【Proteus仿真】外部中断通过双继电器控制直流电机正反转</h3><ul><li>Proteus仿真</li><li>说明</li></ul><p><img src="https://img-blog.csdnimg.cn/e9dd5a547c5f42be9533f38c0fb756dc.gif#pic_center" alt="在这里插入图片描述"></p><p>使用了外部中断0和1，分别控制电机正反转，启动和停止都在两个按键上，第一次是启动，在按同一个按键就是是停止，程序现在不足的地方是如果启动时正转或反转，让后去按另外一个控制按钮就不起作用，然后去按前一次的按键时，继电器会出现同时跳动的情况。如果使用哪个启动哪个就有停止的权限就不会出现两个继电器同时跳动的情况。</p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STC89C5xRC.H&gt;</span><br><span class="line"></span><br><span class="line">sbit LED1 = P1^0 ;</span><br><span class="line">sbit LED2 = P1^1 ;</span><br><span class="line"></span><br><span class="line">static void Init0(void)    </span><br><span class="line">&#123;</span><br><span class="line">  IT0 = 1;      //设置INT0的中断类型 (1:下降沿 0:低电平)</span><br><span class="line">  EX0 = 1;      //INT0中断使能</span><br><span class="line">&#125;</span><br><span class="line">static void Init1(void)    </span><br><span class="line">&#123;</span><br><span class="line">  IT1 = 1;      //设置INT0的中断类型 (1:下降沿 0:低电平)</span><br><span class="line">  EX1 = 1;      //INT0中断使能</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">Init0();</span><br><span class="line">Init1();</span><br><span class="line">EA = 1;             //开启总中断</span><br><span class="line">P1 =0x00;</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EXIT0_isr(void) interrupt 0 using 0</span><br><span class="line">&#123;  </span><br><span class="line">   static volatile unsigned char flag0 = 0;</span><br><span class="line">  if(flag0 == 0)  //亮灯</span><br><span class="line">  &#123;</span><br><span class="line">LED1 = 1 ;</span><br><span class="line">    flag0 = 1;</span><br><span class="line">EX1 = 0;      //如果LED2关闭了，就关闭INT1中断</span><br><span class="line">  &#125;</span><br><span class="line">  else         //灭灯</span><br><span class="line">  &#123;</span><br><span class="line">    LED1 = 0;</span><br><span class="line">    flag0 = !flag0;</span><br><span class="line">EX1 = 1;      //如果LED2关闭了，就开启INT1中断</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void EXIT1_isr(void) interrupt 2 using 0</span><br><span class="line">&#123;  </span><br><span class="line">   static volatile unsigned char flag1 = 1;</span><br><span class="line">  if(flag1 == 0)  //亮灯</span><br><span class="line">  &#123;</span><br><span class="line">LED2 = 1;</span><br><span class="line">    flag1 = 1;</span><br><span class="line">EX0 = 0;      //如果LED2开启了，就关闭INT0中断</span><br><span class="line">  &#125;</span><br><span class="line">  else         //灭灯</span><br><span class="line">  &#123;</span><br><span class="line">    LED2 = 0;</span><br><span class="line">    flag1 = !flag1;</span><br><span class="line">EX0 = 1;      //如果LED2关闭了，就开启INT0中断</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;STC89C5xRC.H&gt;</p><p>sbit LED1 &#x3D; P1^0 ;<br>sbit LED2 &#x3D; P1^1 ;</p><p>static void Init0(void)<br>{<br>  IT0 &#x3D; 1;      &#x2F;&#x2F;设置INT0的中断类型 (1:下降沿 0:低电平)<br>  EX0 &#x3D; 1;      &#x2F;&#x2F;INT0中断使能<br>}<br>static void Init1(void)<br>{<br>  IT1 &#x3D; 1;      &#x2F;&#x2F;设置INT0的中断类型 (1:下降沿 0:低电平)<br>  EX1 &#x3D; 1;      &#x2F;&#x2F;INT0中断使能<br>}<br>void main(){</p><pre><code>Init0();Init1();EA = 1;             //开启总中断P1 =0x00;while(1);</code></pre><p>}</p><p>void EXIT0_isr(void) interrupt 0 using 0<br>{<br>   static volatile unsigned char flag0 &#x3D; 0;<br>  if(flag0 &#x3D;&#x3D; 0)  &#x2F;&#x2F;亮灯<br>  {<br>        LED1 &#x3D; 1 ;<br>    flag0 &#x3D; 1;<br>        EX1 &#x3D; 0;      &#x2F;&#x2F;如果LED2关闭了，就关闭INT1中断<br>  }<br>  else         &#x2F;&#x2F;灭灯<br>  {<br>    LED1 &#x3D; 0;<br>    flag0 &#x3D; !flag0;<br>        EX1 &#x3D; 1;      &#x2F;&#x2F;如果LED2关闭了，就开启INT1中断<br>  }<br>}<br>void EXIT1_isr(void) interrupt 2 using 0<br>{<br>   static volatile unsigned char flag1 &#x3D; 1;<br>  if(flag1 &#x3D;&#x3D; 0)  &#x2F;&#x2F;亮灯<br>  {<br>        LED2 &#x3D; 1;<br>    flag1 &#x3D; 1;<br>        EX0 &#x3D; 0;      &#x2F;&#x2F;如果LED2开启了，就关闭INT0中断<br>  }<br>  else         &#x2F;&#x2F;灭灯<br>  {<br>    LED2 &#x3D; 0;<br>    flag1 &#x3D; !flag1;<br>        EX0 &#x3D; 1;      &#x2F;&#x2F;如果LED2关闭了，就开启INT0中断<br>  }<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1sgacmzP6YSxGmxeTDqWv9A </span><br><span class="line">提取码：edxt</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1sgacmzP6YSxGmxeTDqWv9A  提取码：edxt</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】按键设置+数码管显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%8C%89%E9%94%AE%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%8C%89%E9%94%AE%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】按键设置-数码管显示"><a href="#【Proteus仿真】按键设置-数码管显示" class="headerlink" title="【Proteus仿真】按键设置+数码管显示"></a>【Proteus仿真】按键设置+数码管显示</h1><h3 id="【Proteus仿真】按键设置-数码管显示-1"><a href="#【Proteus仿真】按键设置-数码管显示-1" class="headerlink" title="【Proteus仿真】按键设置+数码管显示"></a>【Proteus仿真】按键设置+数码管显示</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/96a134bb919d4a4da8d891c80cb0fed0.gif#pic_center" alt="在这里插入图片描述"></p><p>采用的是7位共阴数码管段码作为显示，可以用于移植到所需的其他项目上，作为模板或参考程序来使用，其中包含了按键扫描功能的实现，显示和设置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">实验说明：</span><br><span class="line">实验接线：</span><br><span class="line">1，动态数码管模块--&gt;单片机管脚</span><br><span class="line">2，独立按键模块--&gt;单片机管脚 </span><br><span class="line">K1--&gt;P10</span><br><span class="line">K2--&gt;P11</span><br><span class="line">K3--&gt;P12</span><br><span class="line">K4--&gt;P13</span><br><span class="line"></span><br><span class="line">实验现象：</span><br><span class="line">按K4键进入数字设置，按K1和K3键对闪烁的数字进行加和减，按K2键进行数码管移位设置</span><br><span class="line">再次按下K4键退出设置。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;reg52.h&quot; //此文件中定义了单片机的一些特殊功能寄存器</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;  //对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit LSA=P2^2;</span><br><span class="line">sbit LSB=P2^3;</span><br><span class="line">sbit LSC=P2^4;</span><br><span class="line"></span><br><span class="line">sbit k1=P1^0;</span><br><span class="line">sbit k2=P1^1;</span><br><span class="line">sbit k3=P1^2;</span><br><span class="line">sbit k4=P1^3; //定义按键端口</span><br><span class="line"></span><br><span class="line">#define KEY1 1</span><br><span class="line">#define KEY2 2</span><br><span class="line">#define KEY3 3</span><br><span class="line">#define KEY4 4</span><br><span class="line"></span><br><span class="line">u8 code smgduan[17]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,</span><br><span class="line">0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;//共阴数码管段码显示0~F的值</span><br><span class="line"></span><br><span class="line">u8 DisplayData[8];</span><br><span class="line">char datnum1=0,datnum2=0,datnum3=0,datnum4=0;</span><br><span class="line">u8 setflag=0;</span><br><span class="line">u8 wei_change=0;</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名         : delay</span><br><span class="line">* 函数功能   : 延时函数，i=1时，大约延时10us</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">while(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名         : Timer0Init</span><br><span class="line">* 函数功能   : 定时器0初始化</span><br><span class="line">* 输    入         : 无</span><br><span class="line">* 输    出         : 无</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void Timer0Init()</span><br><span class="line">&#123;</span><br><span class="line">TMOD|=0X01;//选择为定时器0模式，工作方式1，仅用TR0打开启动。</span><br><span class="line"></span><br><span class="line">TH0=0Xd8;//给定时器赋初值，定时10ms</span><br><span class="line">TL0=0Xf0;</span><br><span class="line">ET0=1;//打开定时器0中断允许</span><br><span class="line">EA=1;//打开总中断</span><br><span class="line">//TR0=1;//打开定时器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名         : DigDisplay</span><br><span class="line">* 函数功能   : 数码管动态扫描函数，循环扫描8个数码管显示</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void DigDisplay()</span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">switch(i) //位选，选择点亮的数码管，</span><br><span class="line">&#123;</span><br><span class="line">case(0):</span><br><span class="line">LSA=1;LSB=1;LSC=1; break;//显示第7位</span><br><span class="line">case(1):</span><br><span class="line">LSA=0;LSB=1;LSC=1; break;//显示第6位</span><br><span class="line">case(2):</span><br><span class="line">LSA=1;LSB=0;LSC=1; break;//显示第5位</span><br><span class="line">case(3):</span><br><span class="line">LSA=0;LSB=0;LSC=1; break;//显示第4位</span><br><span class="line">case(4):</span><br><span class="line">LSA=1;LSB=1;LSC=0; break;//显示第3位 </span><br><span class="line">case(5):</span><br><span class="line">LSA=0;LSB=1;LSC=0; break;//显示第2位 </span><br><span class="line">case(6):</span><br><span class="line">LSA=1;LSB=0;LSC=0; break;//显示第1位 </span><br><span class="line">case(7):</span><br><span class="line">LSA=0;LSB=0;LSC=0; break;//显示第0位</span><br><span class="line">&#125;</span><br><span class="line">P0=DisplayData[i];//发送段码</span><br><span class="line">delay(100); //间隔一段时间扫描</span><br><span class="line">P0=0x00;//消隐</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//mode=0 单次   1：连续</span><br><span class="line">u8 KeyScan(u8 mode)</span><br><span class="line">&#123;</span><br><span class="line">static u8 keyen=1;</span><br><span class="line">if(mode==1)</span><br><span class="line">&#123;</span><br><span class="line">keyen=1;</span><br><span class="line">&#125;</span><br><span class="line">if(keyen==1&amp;&amp;(k1==0||k2==0||k3==0||k4==0))</span><br><span class="line">&#123;</span><br><span class="line">delay(1000);  //消抖处理</span><br><span class="line">keyen=0;</span><br><span class="line">if(k1==0)return KEY1;</span><br><span class="line">else if(k2==0)return KEY2;</span><br><span class="line">else if(k3==0)return KEY3;</span><br><span class="line">else if(k4==0)return KEY4;</span><br><span class="line">&#125;</span><br><span class="line">else if(k1==1&amp;&amp;k2==1&amp;&amp;k3==1&amp;&amp;k4==1)</span><br><span class="line">&#123;</span><br><span class="line">keyen=1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void datapros()</span><br><span class="line">&#123;</span><br><span class="line">u8 key;</span><br><span class="line">key=KeyScan(0);</span><br><span class="line"></span><br><span class="line">if(key==KEY4)   //设置</span><br><span class="line">&#123;</span><br><span class="line">setflag++;</span><br><span class="line">TR0=1;   //开启定时器</span><br><span class="line">if(setflag==2)</span><br><span class="line">&#123;</span><br><span class="line">TR0=0;//关闭定时器</span><br><span class="line">setflag=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(setflag==0) //默认/退出设置显示</span><br><span class="line">&#123;</span><br><span class="line">DisplayData[0]=smgduan[datnum4];</span><br><span class="line">DisplayData[1]=smgduan[datnum3];</span><br><span class="line">DisplayData[2]=smgduan[datnum2];</span><br><span class="line">DisplayData[3]=smgduan[datnum1];</span><br><span class="line">&#125;</span><br><span class="line">else  //进入设置  数码管选中闪烁</span><br><span class="line">&#123;</span><br><span class="line">if(key==KEY2)    //数据位数移动变化</span><br><span class="line">&#123;</span><br><span class="line">wei_change++;</span><br><span class="line">if(wei_change&gt;3)wei_change=0;</span><br><span class="line">DisplayData[0]=smgduan[datnum4];</span><br><span class="line">DisplayData[1]=smgduan[datnum3];</span><br><span class="line">DisplayData[2]=smgduan[datnum2];</span><br><span class="line">DisplayData[3]=smgduan[datnum1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if(key==KEY1) //数据加</span><br><span class="line">&#123;</span><br><span class="line">switch(wei_change)</span><br><span class="line">&#123;</span><br><span class="line">case 0:  datnum1++;</span><br><span class="line">if(datnum1&gt;9)datnum1=0;</span><br><span class="line">break;</span><br><span class="line">case 1:  datnum2++;</span><br><span class="line">if(datnum2&gt;9)datnum2=0;</span><br><span class="line">break;</span><br><span class="line">case 2:  datnum3++;</span><br><span class="line">if(datnum3&gt;9)datnum3=0;</span><br><span class="line">break;</span><br><span class="line">case 3:  datnum4++;</span><br><span class="line">if(datnum4&gt;9)datnum4=0;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if(key==KEY3) //数据减</span><br><span class="line">&#123;</span><br><span class="line">switch(wei_change)</span><br><span class="line">&#123;</span><br><span class="line">case 0:  datnum1--;</span><br><span class="line">if(datnum1&lt;=0)datnum1=9;</span><br><span class="line">break;</span><br><span class="line">case 1:  datnum2--;</span><br><span class="line">if(datnum2&lt;=0)datnum2=9;</span><br><span class="line">break;</span><br><span class="line">case 2:  datnum3--;</span><br><span class="line">if(datnum3&lt;=0)datnum3=9;</span><br><span class="line">break;</span><br><span class="line">case 3:  datnum4--;</span><br><span class="line">if(datnum4&lt;=0)datnum4=9;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名       : main</span><br><span class="line">* 函数功能 : 主函数</span><br><span class="line">* 输    入       : 无</span><br><span class="line">* 输    出     : 无</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">Timer0Init();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">datapros();</span><br><span class="line">DigDisplay();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名         : void Timer0() interrupt 1</span><br><span class="line">* 函数功能   : 定时器0中断函数</span><br><span class="line">* 输    入         : 无</span><br><span class="line">* 输    出         : 无</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void Timer0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">static u8 i;</span><br><span class="line">TH0=0Xd8;//给定时器赋初值，定时10ms</span><br><span class="line">TL0=0Xf0;</span><br><span class="line">i++;</span><br><span class="line">if(i==50)  //500ms</span><br><span class="line">&#123;</span><br><span class="line">switch(wei_change)</span><br><span class="line">&#123;</span><br><span class="line">case 0: DisplayData[3]=0x00;break;</span><br><span class="line">case 1: DisplayData[2]=0x00;break;</span><br><span class="line">case 2: DisplayData[1]=0x00;break;</span><br><span class="line">case 3: DisplayData[0]=0x00;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i==100)   //1s</span><br><span class="line">&#123;</span><br><span class="line">i=0;</span><br><span class="line">switch(wei_change)</span><br><span class="line">&#123;</span><br><span class="line">case 0: DisplayData[3]=smgduan[datnum1];break;</span><br><span class="line">case 1: DisplayData[2]=smgduan[datnum2];break;</span><br><span class="line">case 2: DisplayData[1]=smgduan[datnum3];break;</span><br><span class="line">case 3: DisplayData[0]=smgduan[datnum4];break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*<br>实验说明：<br>实验接线：<br>    1，动态数码管模块–&gt;单片机管脚<br>    2，独立按键模块–&gt;单片机管脚<br>    K1–&gt;P10<br>    K2–&gt;P11<br>    K3–&gt;P12<br>    K4–&gt;P13</p><p>实验现象：<br>    按K4键进入数字设置，按K1和K3键对闪烁的数字进行加和减，按K2键进行数码管移位设置<br>    再次按下K4键退出设置。<br>*&#x2F;</p><p>#include “reg52.h” &#x2F;&#x2F;此文件中定义了单片机的一些特殊功能寄存器</p><p>typedef unsigned int u16;  &#x2F;&#x2F;对数据类型进行声明定义<br>typedef unsigned char u8;</p><p>sbit LSA&#x3D;P2^2;<br>sbit LSB&#x3D;P2^3;<br>sbit LSC&#x3D;P2^4;</p><p>sbit k1&#x3D;P1^0;<br>sbit k2&#x3D;P1^1;<br>sbit k3&#x3D;P1^2;<br>sbit k4&#x3D;P1^3; &#x2F;&#x2F;定义按键端口</p><p>#define KEY1 1<br>#define KEY2 2<br>#define KEY3 3<br>#define KEY4 4</p><p>u8 code smgduan[17]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,<br>                    0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};&#x2F;&#x2F;共阴数码管段码显示0~F的值</p><p>u8 DisplayData[8];<br>char datnum1&#x3D;0,datnum2&#x3D;0,datnum3&#x3D;0,datnum4&#x3D;0;<br>u8 setflag&#x3D;0;<br>u8 wei_change&#x3D;0;</p><p>&#x2F;*******************************************************************************</p><ul><li>函 数 名         : delay</li><li>函数功能   : 延时函数，i&#x3D;1时，大约延时10us<br>*******************************************************************************&#x2F;<br>void delay(u16 i)<br>{<br>  while(i–);<br>}</li></ul><p>&#x2F;*******************************************************************************</p><ul><li><p>函 数 名         : Timer0Init</p></li><li><p>函数功能   : 定时器0初始化</p></li><li><p>输    入         : 无</p></li><li><p>输    出         : 无<br>*******************************************************************************&#x2F;<br>void Timer0Init()<br>{<br>  TMOD|&#x3D;0X01;&#x2F;&#x2F;选择为定时器0模式，工作方式1，仅用TR0打开启动。</p><p>  TH0&#x3D;0Xd8;&#x2F;&#x2F;给定时器赋初值，定时10ms<br>  TL0&#x3D;0Xf0;<br>  ET0&#x3D;1;&#x2F;&#x2F;打开定时器0中断允许<br>  EA&#x3D;1;&#x2F;&#x2F;打开总中断<br>  &#x2F;&#x2F;TR0&#x3D;1;&#x2F;&#x2F;打开定时器</p></li></ul><p><br>}</p><p>&#x2F;*******************************************************************************</p><ul><li>函 数 名         : DigDisplay</li><li>函数功能   : 数码管动态扫描函数，循环扫描8个数码管显示<br>*******************************************************************************&#x2F;<br>void DigDisplay()<br>{<br>  u8 i;<br>  for(i&#x3D;0;i&lt;8;i++)<br>  {<br>  switch(i) &#x2F;&#x2F;位选，选择点亮的数码管，<br>  {<br>      case(0):<br>          LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;1; break;&#x2F;&#x2F;显示第7位<br>      case(1):<br>          LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;1; break;&#x2F;&#x2F;显示第6位<br>      case(2):<br>          LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;1; break;&#x2F;&#x2F;显示第5位<br>      case(3):<br>          LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;1; break;&#x2F;&#x2F;显示第4位<br>      case(4):<br>          LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;0; break;&#x2F;&#x2F;显示第3位<br>      case(5):<br>          LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;0; break;&#x2F;&#x2F;显示第2位<br>      case(6):<br>          LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;0; break;&#x2F;&#x2F;显示第1位<br>      case(7):<br>          LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;0; break;&#x2F;&#x2F;显示第0位<br>  }<br>  P0&#x3D;DisplayData[i];&#x2F;&#x2F;发送段码<br>  delay(100); &#x2F;&#x2F;间隔一段时间扫描<br>  P0&#x3D;0x00;&#x2F;&#x2F;消隐<br>  }<br>}</li></ul><p>&#x2F;&#x2F;mode&#x3D;0 单次   1：连续<br>u8 KeyScan(u8 mode)<br>{<br>    static u8 keyen&#x3D;1;<br>    if(mode&#x3D;&#x3D;1)<br>    {<br>        keyen&#x3D;1;<br>    }<br>    if(keyen&#x3D;&#x3D;1&amp;&amp;(k1&#x3D;&#x3D;0||k2&#x3D;&#x3D;0||k3&#x3D;&#x3D;0||k4&#x3D;&#x3D;0))<br>    {<br>        delay(1000);  &#x2F;&#x2F;消抖处理<br>        keyen&#x3D;0;<br>        if(k1&#x3D;&#x3D;0)return KEY1;<br>        else if(k2&#x3D;&#x3D;0)return KEY2;<br>        else if(k3&#x3D;&#x3D;0)return KEY3;<br>        else if(k4&#x3D;&#x3D;0)return KEY4;<br>    }<br>    else if(k1&#x3D;&#x3D;1&amp;&amp;k2&#x3D;&#x3D;1&amp;&amp;k3&#x3D;&#x3D;1&amp;&amp;k4&#x3D;&#x3D;1)<br>    {<br>        keyen&#x3D;1;<br>    }<br>    return 0;<br>}</p><p>void datapros()<br>{<br>    u8 key;<br>    key&#x3D;KeyScan(0);</p><pre><code>if(key==KEY4)   //设置&#123;    setflag++;    TR0=1;   //开启定时器    if(setflag==2)    &#123;        TR0=0;//关闭定时器        setflag=0;    &#125;&#125;if(setflag==0) //默认/退出设置显示&#123;    DisplayData[0]=smgduan[datnum4];    DisplayData[1]=smgduan[datnum3];    DisplayData[2]=smgduan[datnum2];    DisplayData[3]=smgduan[datnum1];&#125;else  //进入设置  数码管选中闪烁&#123;    if(key==KEY2)    //数据位数移动变化    &#123;        wei_change++;        if(wei_change&gt;3)wei_change=0;        DisplayData[0]=smgduan[datnum4];        DisplayData[1]=smgduan[datnum3];        DisplayData[2]=smgduan[datnum2];        DisplayData[3]=smgduan[datnum1];    &#125;    else if(key==KEY1) //数据加    &#123;        switch(wei_change)        &#123;            case 0:  datnum1++;                    if(datnum1&gt;9)datnum1=0;                    break;            case 1:  datnum2++;                    if(datnum2&gt;9)datnum2=0;                    break;            case 2:  datnum3++;                    if(datnum3&gt;9)datnum3=0;                    break;            case 3:  datnum4++;                    if(datnum4&gt;9)datnum4=0;                    break;        &#125;    &#125;    else if(key==KEY3) //数据减    &#123;        switch(wei_change)        &#123;            case 0:  datnum1--;                    if(datnum1&lt;=0)datnum1=9;                    break;            case 1:  datnum2--;                    if(datnum2&lt;=0)datnum2=9;                    break;            case 2:  datnum3--;                    if(datnum3&lt;=0)datnum3=9;                    break;            case 3:  datnum4--;                    if(datnum4&lt;=0)datnum4=9;                    break;        &#125;    &#125;        &#125;</code></pre><p>}<br>&#x2F;*******************************************************************************</p><ul><li>函 数 名       : main</li><li>函数功能 : 主函数</li><li>输    入       : 无</li><li>输    出     : 无<br>*******************************************************************************&#x2F;<br>void main()<br>{<br>  Timer0Init();<br>  while(1)<br>  {<br>  datapros();<br>  DigDisplay();<br>  }<br>}</li></ul><p>&#x2F;*******************************************************************************</p><ul><li>函 数 名         : void Timer0() interrupt 1</li><li>函数功能   : 定时器0中断函数</li><li>输    入         : 无</li><li>输    出         : 无<br>*******************************************************************************&#x2F;<br>void Timer0() interrupt 1<br>{<br>  static u8 i;<br>  TH0&#x3D;0Xd8;&#x2F;&#x2F;给定时器赋初值，定时10ms<br>  TL0&#x3D;0Xf0;<br>  i++;<br>  if(i&#x3D;&#x3D;50)  &#x2F;&#x2F;500ms<br>  {<br>  switch(wei_change)<br>  {<br>      case 0: DisplayData[3]&#x3D;0x00;break;<br>      case 1: DisplayData[2]&#x3D;0x00;break;<br>      case 2: DisplayData[1]&#x3D;0x00;break;<br>      case 3: DisplayData[0]&#x3D;0x00;break;<br>  }<br>  }<br>  if(i&#x3D;&#x3D;100)   &#x2F;&#x2F;1s<br>  {<br>  i&#x3D;0;<br>  switch(wei_change)<br>  {<br>      case 0: DisplayData[3]&#x3D;smgduan[datnum1];break;<br>      case 1: DisplayData[2]&#x3D;smgduan[datnum2];break;<br>      case 2: DisplayData[1]&#x3D;smgduan[datnum3];break;<br>      case 3: DisplayData[0]&#x3D;smgduan[datnum4];break;<br>  }<br>  }<br>}&#96;</li></ul><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/15Aak_hkC96iZayfbUrctFg </span><br><span class="line">提取码：pxdd</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/15Aak_hkC96iZayfbUrctFg  提取码：pxdd</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】波形信号发生器（4种波形可选，频率可调）</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A84%E7%A7%8D%E6%B3%A2%E5%BD%A2%E5%8F%AF%E9%80%89%E9%A2%91%E7%8E%87%E5%8F%AF%E8%B0%83/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A84%E7%A7%8D%E6%B3%A2%E5%BD%A2%E5%8F%AF%E9%80%89%E9%A2%91%E7%8E%87%E5%8F%AF%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】波形信号发生器（4种波形可选，频率可调）"><a href="#【Proteus仿真】波形信号发生器（4种波形可选，频率可调）" class="headerlink" title="【Proteus仿真】波形信号发生器（4种波形可选，频率可调）"></a>【Proteus仿真】波形信号发生器（4种波形可选，频率可调）</h1><h3 id="【Proteus仿真】波形信号发生器（4种波形可选，频率可调）-1"><a href="#【Proteus仿真】波形信号发生器（4种波形可选，频率可调）-1" class="headerlink" title="【Proteus仿真】波形信号发生器（4种波形可选，频率可调）"></a>【Proteus仿真】波形信号发生器（4种波形可选，频率可调）</h3><ul><li>📌相关篇《【Proteus仿真】51单片机+DAC0832+LM358放大电路波形发生器》</li><li>📺Proteus仿真演示：</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/122897111">【Proteus仿真】51单片机+DAC0832+LM358放大电路波形发生器</a></p><p><img src="https://img-blog.csdnimg.cn/dafa9b400e8d4afeb2f7c886ab8aa068.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/67ada69593b841908ca5f4989d339cd5.png" alt="在这里插入图片描述"></p><h4 id="📝主程序代码"><a href="#📝主程序代码" class="headerlink" title="📝主程序代码"></a>📝主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;reg51.h&quot; </span><br><span class="line">#include &lt;data.h&gt;</span><br><span class="line">#include &lt;LCD1602.h&gt;</span><br><span class="line">#define uchar unsigned char   </span><br><span class="line">#define uint unsigned int   </span><br><span class="line">#define key P1   </span><br><span class="line">#define dataout P3   </span><br><span class="line">uchar fre[5] =&quot;001Hz&quot;;</span><br><span class="line">uint data THHL=65536-3906;</span><br><span class="line">uchar data keyword,n=0;   </span><br><span class="line">uchar data Signal_chose = 0; </span><br><span class="line">uchar data div = 1; </span><br><span class="line">void keyscan()   </span><br><span class="line">&#123;    </span><br><span class="line"> keyword=key&amp;0x3f;   </span><br><span class="line"> if(keyword!=0x3f)   </span><br><span class="line"> &#123;   </span><br><span class="line">  while((key&amp;0x3f)!=0x3f);//等待按键松开   </span><br><span class="line">  switch(keyword)   </span><br><span class="line">  &#123;   </span><br><span class="line">case 62: &#123;</span><br><span class="line">if(div&gt;=100) THHL=65536-39; else &#123;div++;THHL=65536-3906/div;&#125;//频率up</span><br><span class="line">fre[0]=div/100 + &#x27;0&#x27;;fre[1]=div/10%10 + &#x27;0&#x27;;fre[2]=div%10 + &#x27;0&#x27;;</span><br><span class="line">TR1=0;LCD_send(2,11,fre,5);TR1=1; break;</span><br><span class="line">&#125;   </span><br><span class="line">case 61: &#123;</span><br><span class="line">if(div&lt;=1) THHL=65536-3906; else &#123;div--;THHL=65536-3906/div;&#125;//频率down</span><br><span class="line">fre[0]=div/100 + &#x27;0&#x27;;fre[1]=div/10%10 + &#x27;0&#x27;;fre[2]=div%10 + &#x27;0&#x27;;</span><br><span class="line">TR1=0;LCD_send(2,11,fre,5);TR1=1; break;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case 59: &#123;Signal_chose=0;TR1=0;LCD_send(1,5,&quot;Sin       &quot;,10);TR1=1; break;&#125;  //正弦波</span><br><span class="line">case 55:&#123;Signal_chose=1;TR1=0;LCD_send(1,5,&quot;Triangular&quot;,10);TR1=1; break;&#125;//三角波</span><br><span class="line">case 47:&#123;Signal_chose=2;TR1=0;LCD_send(1,5,&quot;Square    &quot;,10);TR1=1; break;&#125;//方波</span><br><span class="line">case 31: &#123;Signal_chose=3;TR1=0;LCD_send(1,5,&quot;Sawtooth  &quot;,10);TR1=1; break;&#125;//锯齿波</span><br><span class="line">default:&#123;break;&#125;   </span><br><span class="line">   &#125;   </span><br><span class="line"> &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">void init()//初始化 </span><br><span class="line">&#123;   </span><br><span class="line"> key=0x3f;P2=0x00;dataout=0x00;THHL=65536-3906;  ///初始频率为1Hz</span><br><span class="line"> TH1=THHL/256;TL1=THHL%256;   </span><br><span class="line"> TMOD=0x11;ET1=1;TR1=1;EA=1;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">void main()   </span><br><span class="line">&#123;   </span><br><span class="line">LCD_init();</span><br><span class="line">LCD_send(1,0,&quot;Type:Sin&quot;,8);</span><br><span class="line">LCD_send(2,0,&quot;frequency:&quot;,10);</span><br><span class="line">LCD_send(2,11,fre,5);</span><br><span class="line">init();</span><br><span class="line">while(1)   </span><br><span class="line">&#123;   </span><br><span class="line">keyscan(); </span><br><span class="line">switch(Signal_chose)   </span><br><span class="line">&#123;   </span><br><span class="line">case 0: &#123;dataout=sin_tab[n]; break;&#125;  //正弦波</span><br><span class="line">case 1: &#123;dataout=thr_tab[n]; break;&#125;  //三角波</span><br><span class="line">case 2: &#123;dataout=squ_tab[n]; break;&#125;  //方波</span><br><span class="line">case 3: &#123;dataout=255-n;break;&#125;//锯齿波</span><br><span class="line">default:&#123;break;&#125;   </span><br><span class="line"> &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line">void time_intt1(void) interrupt 3   </span><br><span class="line">&#123;   </span><br><span class="line">TL1=THHL%256;TH1=THHL/256;  </span><br><span class="line">//if(n&gt;=255) &#123;n=0;&#125; else &#123;n++;&#125;   </span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “reg51.h”<br>#include &lt;data.h&gt;<br>#include &lt;LCD1602.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>#define key P1<br>#define dataout P3<br>uchar fre[5] &#x3D;”001Hz”;<br>uint data THHL&#x3D;65536-3906;<br>uchar data keyword,n&#x3D;0;<br>uchar data Signal_chose &#x3D; 0;<br>uchar data div &#x3D; 1;<br>void keyscan()<br>{<br> keyword&#x3D;key&0x3f;<br> if(keyword!&#x3D;0x3f)<br> {<br>  while((key&amp;0x3f)!&#x3D;0x3f);&#x2F;&#x2F;等待按键松开<br>  switch(keyword)<br>  {<br>        case 62: {<br>                            if(div&gt;&#x3D;100) THHL&#x3D;65536-39; else {div++;THHL&#x3D;65536-3906&#x2F;div;}&#x2F;&#x2F;频率up<br>                            fre[0]&#x3D;div&#x2F;100 + ‘0’;fre[1]&#x3D;div&#x2F;10%10 + ‘0’;fre[2]&#x3D;div%10 + ‘0’;<br>                            TR1&#x3D;0;LCD_send(2,11,fre,5);TR1&#x3D;1; break;<br>                            }<br>        case 61: {<br>                            if(div&lt;&#x3D;1) THHL&#x3D;65536-3906; else {div–;THHL&#x3D;65536-3906&#x2F;div;}&#x2F;&#x2F;频率down<br>                            fre[0]&#x3D;div&#x2F;100 + ‘0’;fre[1]&#x3D;div&#x2F;10%10 + ‘0’;fre[2]&#x3D;div%10 + ‘0’;<br>                            TR1&#x3D;0;LCD_send(2,11,fre,5);TR1&#x3D;1; break;<br>                            }   </p><pre><code>    case 59: &#123;Signal_chose=0;TR1=0;LCD_send(1,5,&quot;Sin       &quot;,10);TR1=1; break;&#125;  //正弦波    case 55:&#123;Signal_chose=1;TR1=0;LCD_send(1,5,&quot;Triangular&quot;,10);TR1=1; break;&#125;//三角波    case 47:&#123;Signal_chose=2;TR1=0;LCD_send(1,5,&quot;Square    &quot;,10);TR1=1; break;&#125;//方波    case 31: &#123;Signal_chose=3;TR1=0;LCD_send(1,5,&quot;Sawtooth  &quot;,10);TR1=1; break;&#125;//锯齿波    default:&#123;break;&#125;   </code></pre><p>   }<br> }<br>}   </p><p>void init()&#x2F;&#x2F;初始化<br>{<br> key&#x3D;0x3f;P2&#x3D;0x00;dataout&#x3D;0x00;THHL&#x3D;65536-3906;  &#x2F;&#x2F;&#x2F;初始频率为1Hz<br> TH1&#x3D;THHL&#x2F;256;TL1&#x3D;THHL%256;<br> TMOD&#x3D;0x11;ET1&#x3D;1;TR1&#x3D;1;EA&#x3D;1;<br>}   </p><p>void main()<br>{<br>    LCD_init();<br>    LCD_send(1,0,”Type:Sin”,8);<br>    LCD_send(2,0,”frequency:”,10);<br>    LCD_send(2,11,fre,5);<br>    init();<br>    while(1)<br>    {<br>        keyscan();<br>        switch(Signal_chose)<br>            {<br>                case 0: {dataout&#x3D;sin_tab[n]; break;}  &#x2F;&#x2F;正弦波<br>                case 1: {dataout&#x3D;thr_tab[n]; break;}  &#x2F;&#x2F;三角波<br>                case 2: {dataout&#x3D;squ_tab[n]; break;}  &#x2F;&#x2F;方波<br>                case 3: {dataout&#x3D;255-n;break;}&#x2F;&#x2F;锯齿波<br>                default:{break;}<br>             }   <br>    }<br>}   </p><p>void time_intt1(void) interrupt 3<br>{<br>    TL1&#x3D;THHL%256;TH1&#x3D;THHL&#x2F;256;<br>&#x2F;&#x2F;if(n&gt;&#x3D;255) {n&#x3D;0;} else {n++;}<br>    n++;<br>}&#96;</p><h4 id="📚程序源码和仿真资源"><a href="#📚程序源码和仿真资源" class="headerlink" title="📚程序源码和仿真资源"></a>📚程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1zgFzzDAer8ItDjCP5LxZSw </span><br><span class="line">提取码：u2to</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1zgFzzDAer8ItDjCP5LxZSw  提取码：u2to</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】自动量程(范围＜10V)切换数字电压表</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E8%87%AA%E5%8A%A8%E9%87%8F%E7%A8%8B%E8%8C%83%E5%9B%B410V%E5%88%87%E6%8D%A2%E6%95%B0%E5%AD%97%E7%94%B5%E5%8E%8B%E8%A1%A8/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E8%87%AA%E5%8A%A8%E9%87%8F%E7%A8%8B%E8%8C%83%E5%9B%B410V%E5%88%87%E6%8D%A2%E6%95%B0%E5%AD%97%E7%94%B5%E5%8E%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】自动量程-范围＜10V-切换数字电压表"><a href="#【Proteus仿真】自动量程-范围＜10V-切换数字电压表" class="headerlink" title="【Proteus仿真】自动量程(范围＜10V)切换数字电压表"></a>【Proteus仿真】自动量程(范围＜10V)切换数字电压表</h1><h3 id="【Proteus仿真】自动量程-范围"><a href="#【Proteus仿真】自动量程-范围" class="headerlink" title="【Proteus仿真】自动量程(范围&lt;10V)切换数字电压表"></a>【Proteus仿真】自动量程(范围&lt;10V)切换数字电压表</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/a5e1d1a9e385468db0ca014606f5827f.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例程序代码"><a href="#示例程序代码" class="headerlink" title="示例程序代码"></a>示例程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">unsigned char code dispbitcode[]= &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;//共阴数码管断码</span><br><span class="line">unsigned char dispbuf[4];</span><br><span class="line">unsigned int i;</span><br><span class="line">unsigned int j;</span><br><span class="line">unsigned int getdata;</span><br><span class="line">unsigned int temp;</span><br><span class="line">unsigned int temp1;</span><br><span class="line">unsigned char count;</span><br><span class="line">unsigned char d;</span><br><span class="line">sbit ST=P2^4;</span><br><span class="line">sbit OE=P2^5;</span><br><span class="line">sbit EOC=P2^6;</span><br><span class="line">sbit CLK=P2^7;</span><br><span class="line">sbit ADD_A=P3^4;  //选择AD的输入端</span><br><span class="line">sbit ADD_B=P3^5;</span><br><span class="line">sbit ADD_C=P3^6;</span><br><span class="line">sbit D0=P2^0;  //数码管的位控制端</span><br><span class="line">sbit D1=P2^1;</span><br><span class="line">sbit D2=P2^2;</span><br><span class="line">sbit D3=P2^3;</span><br><span class="line">sbit P17=P1^7;  //确定小数点的位置</span><br><span class="line">sbit s1=P3^2;</span><br><span class="line">sbit s2=P3^3;</span><br><span class="line">#define _v0_5 &#123;s1=1;s2=0;&#125;</span><br><span class="line">#define _v10 &#123;s1=0;s2=1;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char m;</span><br><span class="line"></span><br><span class="line">void TimeInitial();</span><br><span class="line">void Delay(unsigned int i);</span><br><span class="line"></span><br><span class="line">/*定时器1初始化函数*/</span><br><span class="line">void TimeInitial()</span><br><span class="line">&#123;   TMOD=0x10;</span><br><span class="line">    TH1=(65536-200)/256;</span><br><span class="line">    TL1=(65536-200)%256;</span><br><span class="line">    EA=1;</span><br><span class="line">    ET1=1;</span><br><span class="line">    TR1=1;</span><br><span class="line">&#125;</span><br><span class="line">/*延时函数*/</span><br><span class="line">void Delay(unsigned int i)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int j;</span><br><span class="line">    for(; i&gt;0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0; j&lt;125; j++)</span><br><span class="line">        &#123;;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*数码管显示函数*/</span><br><span class="line">void Display()</span><br><span class="line">&#123;</span><br><span class="line">    P1=dispbitcode[dispbuf[3]];</span><br><span class="line"></span><br><span class="line">    D0=0;</span><br><span class="line">    D1=1;</span><br><span class="line">    D2=1;</span><br><span class="line">    D3=1;</span><br><span class="line">    Delay(10);</span><br><span class="line">    P1=0x00;</span><br><span class="line"></span><br><span class="line">    P1=dispbitcode[dispbuf[2]];</span><br><span class="line">    if(m==2)</span><br><span class="line">    &#123;</span><br><span class="line">        P17=1;</span><br><span class="line">    &#125;</span><br><span class="line">    D0=1;</span><br><span class="line">    D1=0;</span><br><span class="line">    D2=1;</span><br><span class="line">    D3=1;</span><br><span class="line">    Delay(10);</span><br><span class="line">    P1=0x00;</span><br><span class="line">    P1=dispbitcode[dispbuf[1]];</span><br><span class="line">    if(m==10)</span><br><span class="line">    &#123;</span><br><span class="line">        P17=1;</span><br><span class="line">    &#125;</span><br><span class="line">    D0=1;</span><br><span class="line">    D1=1;</span><br><span class="line">    D2=0;</span><br><span class="line">    D3=1;</span><br><span class="line">    Delay(10);</span><br><span class="line">    P1=0x00;</span><br><span class="line">    P1=dispbitcode[dispbuf[0]];</span><br><span class="line">    D0=1;</span><br><span class="line">    D1=1;</span><br><span class="line">    D2=1;</span><br><span class="line">    D3=0;</span><br><span class="line">    Delay(10);</span><br><span class="line">    P1=0x00;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    TimeInitial();</span><br><span class="line">    ADD_A=0;</span><br><span class="line">    ADD_B=0;</span><br><span class="line">    ADD_C=0;</span><br><span class="line">    _v10;</span><br><span class="line">    m=2;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ST=0;</span><br><span class="line">        OE=0;</span><br><span class="line">        ST=1;</span><br><span class="line">        ST=0;</span><br><span class="line">        while(EOC==0);</span><br><span class="line">        OE=1;</span><br><span class="line">        getdata=P0;</span><br><span class="line">        OE=0;</span><br><span class="line">        if ((s1==0) &amp;&amp; (s2==1) &amp;&amp; (getdata&lt;6))</span><br><span class="line">        &#123;</span><br><span class="line">            ADD_A=1;</span><br><span class="line">            _v0_5;</span><br><span class="line"></span><br><span class="line">            m=10;</span><br><span class="line">        &#125;</span><br><span class="line">        else if((s1==1)&amp;&amp;(s2==0) &amp;&amp; (getdata&gt;254))</span><br><span class="line">        &#123;</span><br><span class="line">            ADD_A=0;</span><br><span class="line">            _v10;</span><br><span class="line"></span><br><span class="line">            m=2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        temp=(getdata*1.0/255)*500*m;</span><br><span class="line">        dispbuf[0]=temp%10;</span><br><span class="line">        dispbuf[1]=temp/10%10;</span><br><span class="line">        dispbuf[2]=temp/100%10;</span><br><span class="line">        dispbuf[3]=temp/1000;</span><br><span class="line">        Display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void t1(void) interrupt 3 using 0</span><br><span class="line">&#123;</span><br><span class="line">    TH1=(65536-200)/256;</span><br><span class="line">    TL1=(65536-200)%256;</span><br><span class="line">    CLK=~CLK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include&lt;reg52.h&gt;<br>unsigned char code dispbitcode[]&#x3D; {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F;共阴数码管断码<br>unsigned char dispbuf[4];<br>unsigned int i;<br>unsigned int j;<br>unsigned int getdata;<br>unsigned int temp;<br>unsigned int temp1;<br>unsigned char count;<br>unsigned char d;<br>sbit ST&#x3D;P2^4;<br>sbit OE&#x3D;P2^5;<br>sbit EOC&#x3D;P2^6;<br>sbit CLK&#x3D;P2^7;<br>sbit ADD_A&#x3D;P3^4;  &#x2F;&#x2F;选择AD的输入端<br>sbit ADD_B&#x3D;P3^5;<br>sbit ADD_C&#x3D;P3^6;<br>sbit D0&#x3D;P2^0;  &#x2F;&#x2F;数码管的位控制端<br>sbit D1&#x3D;P2^1;<br>sbit D2&#x3D;P2^2;<br>sbit D3&#x3D;P2^3;<br>sbit P17&#x3D;P1^7;  &#x2F;&#x2F;确定小数点的位置<br>sbit s1&#x3D;P3^2;<br>sbit s2&#x3D;P3^3;<br>#define _v0_5 {s1&#x3D;1;s2&#x3D;0;}<br>#define _v10 {s1&#x3D;0;s2&#x3D;1;}</p><p>unsigned char m;</p><p>void TimeInitial();<br>void Delay(unsigned int i);</p><p>&#x2F;<em>定时器1初始化函数</em>&#x2F;<br>void TimeInitial()<br>{   TMOD&#x3D;0x10;<br>    TH1&#x3D;(65536-200)&#x2F;256;<br>    TL1&#x3D;(65536-200)%256;<br>    EA&#x3D;1;<br>    ET1&#x3D;1;<br>    TR1&#x3D;1;<br>}<br>&#x2F;<em>延时函数</em>&#x2F;<br>void Delay(unsigned int i)<br>{<br>    unsigned int j;<br>    for(; i&gt;0; i–)<br>    {<br>        for(j&#x3D;0; j&lt;125; j++)<br>        {;}<br>    }<br>}<br>&#x2F;<em>数码管显示函数</em>&#x2F;<br>void Display()<br>{<br>    P1&#x3D;dispbitcode[dispbuf[3]];</p><pre><code>D0=0;D1=1;D2=1;D3=1;Delay(10);P1=0x00;P1=dispbitcode[dispbuf[2]];if(m==2)&#123;    P17=1;&#125;D0=1;D1=0;D2=1;D3=1;Delay(10);P1=0x00;P1=dispbitcode[dispbuf[1]];if(m==10)&#123;    P17=1;&#125;D0=1;D1=1;D2=0;D3=1;Delay(10);P1=0x00;P1=dispbitcode[dispbuf[0]];D0=1;D1=1;D2=1;D3=0;Delay(10);P1=0x00;</code></pre><p>}<br>void main()<br>{<br>    TimeInitial();<br>    ADD_A&#x3D;0;<br>    ADD_B&#x3D;0;<br>    ADD_C&#x3D;0;<br>    _v10;<br>    m&#x3D;2;<br>    while(1)<br>    {</p><pre><code>    ST=0;    OE=0;    ST=1;    ST=0;    while(EOC==0);    OE=1;    getdata=P0;    OE=0;    if ((s1==0) &amp;&amp; (s2==1) &amp;&amp; (getdata&lt;6))    &#123;        ADD_A=1;        _v0_5;        m=10;    &#125;    else if((s1==1)&amp;&amp;(s2==0) &amp;&amp; (getdata&gt;254))    &#123;        ADD_A=0;        _v10;        m=2;    &#125;    temp=(getdata*1.0/255)*500*m;    dispbuf[0]=temp%10;    dispbuf[1]=temp/10%10;    dispbuf[2]=temp/100%10;    dispbuf[3]=temp/1000;    Display();&#125;</code></pre><p>}</p><p>void t1(void) interrupt 3 using 0<br>{<br>    TH1&#x3D;(65536-200)&#x2F;256;<br>    TL1&#x3D;(65536-200)%256;<br>    CLK&#x3D;~CLK;<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/12-rNBvoMRujGYpEN550fEQ </span><br><span class="line">提取码：986e</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/12-rNBvoMRujGYpEN550fEQ  提取码：986e</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TLC5615输出256点正弦波（振幅和频率可调）</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-TLC5615%E8%BE%93%E5%87%BA256%E7%82%B9%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E5%B9%85%E5%92%8C%E9%A2%91%E7%8E%87%E5%8F%AF%E8%B0%83/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-TLC5615%E8%BE%93%E5%87%BA256%E7%82%B9%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E5%B9%85%E5%92%8C%E9%A2%91%E7%8E%87%E5%8F%AF%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="TLC5615输出256点正弦波（振幅和频率可调）"><a href="#TLC5615输出256点正弦波（振幅和频率可调）" class="headerlink" title="TLC5615输出256点正弦波（振幅和频率可调）"></a>TLC5615输出256点正弦波（振幅和频率可调）</h1><h3 id="TLC5615输出256点正弦波（振幅和频率可调）-1"><a href="#TLC5615输出256点正弦波（振幅和频率可调）-1" class="headerlink" title="TLC5615输出256点正弦波（振幅和频率可调）"></a>TLC5615输出256点正弦波（振幅和频率可调）</h3><ul><li>相关篇《【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）》</li><li>《【Proteus仿真】TLC5615输出256点正弦波（振幅可调）》</li><li>Proteus仿真</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/124524009?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22124524009%22,%22source%22:%22weixin_42880082%22%7D&ctrtid=8suHz">【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/124525074">【Proteus仿真】TLC5615输出256点正弦波（振幅可调）</a></p><p><img src="https://img-blog.csdnimg.cn/74a582e7b40e420a851ec5d4af3abeac.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li>正弦波数据生成器（最大4096点）</li></ul><p>采用输出点数256，10位精度，</p><p><img src="https://img-blog.csdnimg.cn/96d71fe48d4d4fedba5da839d61c4802.png" alt="在这里插入图片描述"></p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/************************************************************************************</span><br><span class="line">1.TLC5615 DA模块</span><br><span class="line">2.TLC5615 正弦波模块</span><br><span class="line">【程序功能】TLC5615输出256点正弦波</span><br><span class="line">TLC5615 DA模块本身必须使用5V电源，控制信号可以接受3.3V或者5V。</span><br><span class="line">【IO配置】</span><br><span class="line">DIN---&gt;P1.0</span><br><span class="line">SCLK---&gt;P1.1</span><br><span class="line">CS---&gt;P1.2</span><br><span class="line">Dout---&gt;空，未定义</span><br><span class="line">************************************************************************************/</span><br><span class="line">#include&lt;reg52.h&gt;//包含51单片机寄存器定义的头文件</span><br><span class="line">#include&lt;intrins.h&gt;//包含nop函数的头文件</span><br><span class="line">#define uchar unsigned char//宏定义</span><br><span class="line">#define uint unsigned int//宏定义</span><br><span class="line"></span><br><span class="line">sbit DIN=P1^0;//IO定义</span><br><span class="line">sbit SCLK=P1^1;</span><br><span class="line">sbit CS=P1^2;</span><br><span class="line"></span><br><span class="line">sbit key1 = P2^1;  //控制频率的加按键</span><br><span class="line">sbit key2 = P2^0;  //控制频率的减按键</span><br><span class="line">uint val = 1000; //初始值</span><br><span class="line">uint code sin1[]=//256点8位数据的正弦波表</span><br><span class="line">&#123;</span><br><span class="line"> 0x1FF,0x20C,0x218,0x225,0x231,0x23E,0x24A,0x256,0x263,0x26F,0x27B,0x287,0x293,0x29F,0x2AB,0x2B7</span><br><span class="line">,0x2C3,0x2CE,0x2DA,0x2E5,0x2F0,0x2FB,0x306,0x311,0x31B,0x326,0x330,0x33A,0x343,0x34D,0x357,0x360</span><br><span class="line">,0x369,0x371,0x37A,0x382,0x38A,0x392,0x39A,0x3A1,0x3A8,0x3AF,0x3B6,0x3BC,0x3C2,0x3C8,0x3CD,0x3D3</span><br><span class="line">,0x3D8,0x3DC,0x3E1,0x3E5,0x3E8,0x3EC,0x3EF,0x3F2,0x3F5,0x3F7,0x3F9,0x3FB,0x3FC,0x3FD,0x3FE,0x3FE</span><br><span class="line">,0x3FE,0x3FE,0x3FE,0x3FD,0x3FC,0x3FB,0x3F9,0x3F7,0x3F5,0x3F2,0x3EF,0x3EC,0x3E8,0x3E5,0x3E1,0x3DC</span><br><span class="line">,0x3D8,0x3D3,0x3CD,0x3C8,0x3C2,0x3BC,0x3B6,0x3AF,0x3A8,0x3A1,0x39A,0x392,0x38A,0x382,0x37A,0x371</span><br><span class="line">,0x369,0x360,0x357,0x34D,0x343,0x33A,0x330,0x326,0x31B,0x311,0x306,0x2FB,0x2F0,0x2E5,0x2DA,0x2CE</span><br><span class="line">,0x2C3,0x2B7,0x2AB,0x29F,0x293,0x287,0x27B,0x26F,0x263,0x256,0x24A,0x23E,0x231,0x225,0x218,0x20C</span><br><span class="line">,0x1FF,0x1F2,0x1E6,0x1D9,0x1CD,0x1C0,0x1B4,0x1A8,0x19B,0x18F,0x183,0x177,0x16B,0x15F,0x153,0x147</span><br><span class="line">,0x13B,0x130,0x124,0x119,0x10E,0x103,0x0F8,0x0ED,0x0E3,0x0D8,0x0CE,0x0C4,0x0BB,0x0B1,0x0A7,0x09E</span><br><span class="line">,0x095,0x08D,0x084,0x07C,0x074,0x06C,0x064,0x05D,0x056,0x04F,0x048,0x042,0x03C,0x036,0x031,0x02B</span><br><span class="line">,0x026,0x022,0x01D,0x019,0x016,0x012,0x00F,0x00C,0x009,0x007,0x005,0x003,0x002,0x001,0x000,0x000</span><br><span class="line">,0x000,0x000,0x000,0x001,0x002,0x003,0x005,0x007,0x009,0x00C,0x00F,0x012,0x016,0x019,0x01D,0x022</span><br><span class="line">,0x026,0x02B,0x031,0x036,0x03C,0x042,0x048,0x04F,0x056,0x05D,0x064,0x06C,0x074,0x07C,0x084,0x08D</span><br><span class="line">,0x095,0x09E,0x0A8,0x0B1,0x0BB,0x0C4,0x0CE,0x0D8,0x0E3,0x0ED,0x0F8,0x103,0x10E,0x119,0x124,0x130</span><br><span class="line">,0x13B,0x147,0x153,0x15F,0x16B,0x177,0x183,0x18F,0x19B,0x1A8,0x1B4,0x1C0,0x1CD,0x1D9,0x1E6,0x1F2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// void delay_us(unsigned char n)//us级延时函数</span><br><span class="line">//&#123;</span><br><span class="line">// unsigned char i;</span><br><span class="line">// for(i=0;i&lt;n;i++);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">void delay(uint y)</span><br><span class="line">&#123;</span><br><span class="line">   uint x,z;</span><br><span class="line">  for(x = y;x&gt;0;x--);</span><br><span class="line">   for(z = 120;z&gt;0;z--);</span><br><span class="line">&#125;</span><br><span class="line">void key_scan()  //按键扫描程序</span><br><span class="line">&#123;</span><br><span class="line">  if(!key1)  //key1按下</span><br><span class="line"> &#123;  </span><br><span class="line">  delay(1);</span><br><span class="line">  while(!key1);//等待按键弹起</span><br><span class="line">     val+=1000; //频率减小</span><br><span class="line">    if(val==10000) //下限值</span><br><span class="line">   &#123;</span><br><span class="line">     val = 10000;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">else if(!key2)  //key2按下</span><br><span class="line"> &#123;</span><br><span class="line">    delay(1);</span><br><span class="line">    while(!key2);//等待按键弹起    </span><br><span class="line">        val-=1000; //频率增加</span><br><span class="line">       if(val==1000) //上限值</span><br><span class="line">      &#123;</span><br><span class="line">        val = 1000;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/******************************************************************</span><br><span class="line">1.sclk的上升沿数据进入输入寄存器</span><br><span class="line">2.在sclk为低的时候，CS的上升沿数据开始DA转化</span><br><span class="line">3.连续输入12位数据，高位在前，其中前10位有效，后两位补0</span><br><span class="line">***************************************************************/</span><br><span class="line">void output(uint DA_Value)//TLC5615驱动函数</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">DA_Value=DA_Value&lt;&lt;6;//将DA_Value左移6位，即nnnn nnnn nnnn变为nnnn nnnn nn00 0000</span><br><span class="line">SCLK=0;//为低，准备输入数据</span><br><span class="line">CS=0;//片选</span><br><span class="line">for(i=12;i&gt;0;i--)//从高位开始，连续取出12位数据，</span><br><span class="line">&#123;</span><br><span class="line">if(DA_Value&amp;0x8000)//和1000 0000 0000 0000求与，获取最高位的值。</span><br><span class="line">DIN=1;//信号1写入芯片</span><br><span class="line">else</span><br><span class="line">DIN=0;//信号0写入芯片</span><br><span class="line"></span><br><span class="line">//  _nop_();</span><br><span class="line">//_nop_();</span><br><span class="line">SCLK=1;//上升沿，进入输入寄存器</span><br><span class="line">SCLK=0;//开启下一个数据写入//准备下一次输入</span><br><span class="line">DA_Value &lt;&lt;=1;//左移1位，准备输入下一位数据</span><br><span class="line">&#125;</span><br><span class="line">CS=1;//芯片关闭//在sclk为低的时候，CS上升沿，数据开始DA转化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Timer0Init(void)//定时器0初始化</span><br><span class="line">&#123;</span><br><span class="line"> TMOD = 0x01;</span><br><span class="line"> TH0 = (65536 - val)/256;</span><br><span class="line"> TL0 = (65536 - val)%256;</span><br><span class="line"> TR0 = 1;</span><br><span class="line"> ET0 = 1;</span><br><span class="line"> EA = 1;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">Timer0Init();</span><br><span class="line">   while(1)</span><br><span class="line">&#123;</span><br><span class="line">key_scan();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Timer0_isr() interrupt 1 using 0</span><br><span class="line">&#123;</span><br><span class="line"> static volatile uint i=0;</span><br><span class="line">  TH0 = (65536 - val)/256;</span><br><span class="line">TL0 = (65536 - val)%256;</span><br><span class="line">output(sin1[i++]);//输出正弦波</span><br><span class="line"> if(i&gt;256) i = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;************************************************************************************<br>1.TLC5615 DA模块<br>2.TLC5615 正弦波模块<br>【程序功能】TLC5615输出256点正弦波<br>TLC5615 DA模块本身必须使用5V电源，控制信号可以接受3.3V或者5V。<br>【IO配置】<br>DIN—&gt;P1.0<br>SCLK—&gt;P1.1<br>CS—&gt;P1.2<br>Dout—&gt;空，未定义<br>************************************************************************************&#x2F;<br>#include&lt;reg52.h&gt;&#x2F;&#x2F;包含51单片机寄存器定义的头文件<br>#include&lt;intrins.h&gt;&#x2F;&#x2F;包含nop函数的头文件<br>#define uchar unsigned char&#x2F;&#x2F;宏定义<br>#define uint unsigned int&#x2F;&#x2F;宏定义</p><p>sbit DIN&#x3D;P1^0;&#x2F;&#x2F;IO定义<br>sbit SCLK&#x3D;P1^1;<br>sbit CS&#x3D;P1^2;</p><p>sbit key1 &#x3D; P2^1;  &#x2F;&#x2F;控制频率的加按键<br>sbit key2 &#x3D; P2^0;  &#x2F;&#x2F;控制频率的减按键<br>uint val &#x3D; 1000; &#x2F;&#x2F;初始值<br>uint code sin1[]&#x3D;&#x2F;&#x2F;256点8位数据的正弦波表<br>{<br>     0x1FF,0x20C,0x218,0x225,0x231,0x23E,0x24A,0x256,0x263,0x26F,0x27B,0x287,0x293,0x29F,0x2AB,0x2B7<br>,0x2C3,0x2CE,0x2DA,0x2E5,0x2F0,0x2FB,0x306,0x311,0x31B,0x326,0x330,0x33A,0x343,0x34D,0x357,0x360<br>,0x369,0x371,0x37A,0x382,0x38A,0x392,0x39A,0x3A1,0x3A8,0x3AF,0x3B6,0x3BC,0x3C2,0x3C8,0x3CD,0x3D3<br>,0x3D8,0x3DC,0x3E1,0x3E5,0x3E8,0x3EC,0x3EF,0x3F2,0x3F5,0x3F7,0x3F9,0x3FB,0x3FC,0x3FD,0x3FE,0x3FE<br>,0x3FE,0x3FE,0x3FE,0x3FD,0x3FC,0x3FB,0x3F9,0x3F7,0x3F5,0x3F2,0x3EF,0x3EC,0x3E8,0x3E5,0x3E1,0x3DC<br>,0x3D8,0x3D3,0x3CD,0x3C8,0x3C2,0x3BC,0x3B6,0x3AF,0x3A8,0x3A1,0x39A,0x392,0x38A,0x382,0x37A,0x371<br>,0x369,0x360,0x357,0x34D,0x343,0x33A,0x330,0x326,0x31B,0x311,0x306,0x2FB,0x2F0,0x2E5,0x2DA,0x2CE<br>,0x2C3,0x2B7,0x2AB,0x29F,0x293,0x287,0x27B,0x26F,0x263,0x256,0x24A,0x23E,0x231,0x225,0x218,0x20C<br>,0x1FF,0x1F2,0x1E6,0x1D9,0x1CD,0x1C0,0x1B4,0x1A8,0x19B,0x18F,0x183,0x177,0x16B,0x15F,0x153,0x147<br>,0x13B,0x130,0x124,0x119,0x10E,0x103,0x0F8,0x0ED,0x0E3,0x0D8,0x0CE,0x0C4,0x0BB,0x0B1,0x0A7,0x09E<br>,0x095,0x08D,0x084,0x07C,0x074,0x06C,0x064,0x05D,0x056,0x04F,0x048,0x042,0x03C,0x036,0x031,0x02B<br>,0x026,0x022,0x01D,0x019,0x016,0x012,0x00F,0x00C,0x009,0x007,0x005,0x003,0x002,0x001,0x000,0x000<br>,0x000,0x000,0x000,0x001,0x002,0x003,0x005,0x007,0x009,0x00C,0x00F,0x012,0x016,0x019,0x01D,0x022<br>,0x026,0x02B,0x031,0x036,0x03C,0x042,0x048,0x04F,0x056,0x05D,0x064,0x06C,0x074,0x07C,0x084,0x08D<br>,0x095,0x09E,0x0A8,0x0B1,0x0BB,0x0C4,0x0CE,0x0D8,0x0E3,0x0ED,0x0F8,0x103,0x10E,0x119,0x124,0x130<br>,0x13B,0x147,0x153,0x15F,0x16B,0x177,0x183,0x18F,0x19B,0x1A8,0x1B4,0x1C0,0x1CD,0x1D9,0x1E6,0x1F2<br>};</p><p>&#x2F;&#x2F; void delay_us(unsigned char n)&#x2F;&#x2F;us级延时函数<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F; unsigned char i;<br>&#x2F;&#x2F; for(i&#x3D;0;i&lt;n;i++);<br>&#x2F;&#x2F;}</p><pre><code>void delay(uint y)</code></pre><p>{<br>   uint x,z;<br>  for(x &#x3D; y;x&gt;0;x–);<br>   for(z &#x3D; 120;z&gt;0;z–);<br>}<br>void key_scan()  &#x2F;&#x2F;按键扫描程序<br>{<br>  if(!key1)  &#x2F;&#x2F;key1按下<br> {<br>  delay(1);<br>  while(!key1);&#x2F;&#x2F;等待按键弹起<br>     val+&#x3D;1000; &#x2F;&#x2F;频率减小<br>    if(val&#x3D;&#x3D;10000) &#x2F;&#x2F;下限值<br>   {<br>     val &#x3D; 10000;<br>   }<br> }<br>else if(!key2)  &#x2F;&#x2F;key2按下<br> {<br>    delay(1);<br>    while(!key2);&#x2F;&#x2F;等待按键弹起<br>        val-&#x3D;1000; &#x2F;&#x2F;频率增加<br>       if(val&#x3D;&#x3D;1000) &#x2F;&#x2F;上限值<br>      {<br>        val &#x3D; 1000;<br>       }<br>  }<br> }</p><p>&#x2F;******************************************************************<br>    1.sclk的上升沿数据进入输入寄存器<br>    2.在sclk为低的时候，CS的上升沿数据开始DA转化<br>    3.连续输入12位数据，高位在前，其中前10位有效，后两位补0<br>    ***************************************************************&#x2F;<br>void output(uint DA_Value)&#x2F;&#x2F;TLC5615驱动函数<br>    {<br>        unsigned char i;<br>        DA_Value&#x3D;DA_Value&lt;&lt;6;&#x2F;&#x2F;将DA_Value左移6位，即nnnn nnnn nnnn变为nnnn nnnn nn00 0000<br>        SCLK&#x3D;0;&#x2F;&#x2F;为低，准备输入数据<br>        CS&#x3D;0;&#x2F;&#x2F;片选<br>        for(i&#x3D;12;i&gt;0;i–)&#x2F;&#x2F;从高位开始，连续取出12位数据，<br>            {<br>                if(DA_Value&amp;0x8000)&#x2F;&#x2F;和1000 0000 0000 0000求与，获取最高位的值。<br>                DIN&#x3D;1;&#x2F;&#x2F;信号1写入芯片<br>                else<br>                DIN&#x3D;0;&#x2F;&#x2F;信号0写入芯片</p><p>&#x2F;&#x2F;  <em>nop</em>();<br>&#x2F;&#x2F;<em>nop</em>();<br>                SCLK&#x3D;1;&#x2F;&#x2F;上升沿，进入输入寄存器<br>                SCLK&#x3D;0;&#x2F;&#x2F;开启下一个数据写入&#x2F;&#x2F;准备下一次输入<br>                DA_Value &lt;&lt;&#x3D;1;&#x2F;&#x2F;左移1位，准备输入下一位数据<br>            }<br>            CS&#x3D;1;&#x2F;&#x2F;芯片关闭&#x2F;&#x2F;在sclk为低的时候，CS上升沿，数据开始DA转化<br>    }</p><p>void Timer0Init(void)&#x2F;&#x2F;定时器0初始化<br>{<br>         TMOD &#x3D; 0x01;<br>         TH0 &#x3D; (65536 - val)&#x2F;256;<br>         TL0 &#x3D; (65536 - val)%256;<br>         TR0 &#x3D; 1;<br>         ET0 &#x3D; 1;<br>         EA &#x3D; 1;<br>}<br>void main()<br>{<br>    Timer0Init();<br>   while(1)<br>        {<br>        key_scan();<br>}<br>}<br>void Timer0_isr() interrupt 1 using 0<br>{<br> static volatile uint i&#x3D;0;<br>  TH0 &#x3D; (65536 - val)&#x2F;256;<br>    TL0 &#x3D; (65536 - val)%256;<br>    output(sin1[i++]);&#x2F;&#x2F;输出正弦波<br> if(i&gt;256) i &#x3D; 0;<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1gK8_czsBje3kp_NbVQw5_Q </span><br><span class="line">提取码：pcud</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1gK8_czsBje3kp_NbVQw5_Q  提取码：pcud</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FTLC5615%E8%BE%93%E5%87%BA1024%E7%82%B9%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E5%B9%85%E5%8F%AF%E8%B0%83/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FTLC5615%E8%BE%93%E5%87%BA1024%E7%82%B9%E6%AD%A3%E5%BC%A6%E6%B3%A2%E6%8C%AF%E5%B9%85%E5%8F%AF%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）"><a href="#【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）" class="headerlink" title="【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）"></a>【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）</h1><h3 id="【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）-1"><a href="#【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）-1" class="headerlink" title="【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）"></a>【Proteus仿真】TLC5615输出1024点正弦波（振幅可调）</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/086226131b0e45fda45ef2bce5ab7449.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/437102da5d3041d0b77c3198f7691f37.png" alt="在这里插入图片描述"></p><p>通过可调电阻，调节参考引脚输入的电压值，从而改变输出振幅</p><h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><ul><li>正弦波数据生成器（最大4096点），使用该工具最好去8位精度的，不然在仿真的时候，在调节到高于2.5V电压时，正弦波正半周期峰值会被削掉的情况。</li></ul><p>该工具和程序资源和仿真文件打包在一个文件夹里面。</p><p><img src="https://img-blog.csdnimg.cn/2095350bf5674eec9105f67b0fad48ef.png" alt="在这里插入图片描述"></p><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">/************************************************************************************</span><br><span class="line"></span><br><span class="line">TLC5615输出1024点正弦波</span><br><span class="line">【注意事项】</span><br><span class="line">2.TLC5615 DA模块本身必须使用5V电源，控制信号可以接受3.3V或者5V。</span><br><span class="line">【IO配置】</span><br><span class="line">DIN---&gt;P1.0</span><br><span class="line">SCLK---&gt;P1.1</span><br><span class="line">CS---&gt;P1.2</span><br><span class="line">Dout---&gt;空，未定义</span><br><span class="line">************************************************************************************/</span><br><span class="line">#include&lt;reg52.h&gt;//包含51单片机寄存器定义的头文件</span><br><span class="line">#include&lt;intrins.h&gt;//包含nop函数的头文件</span><br><span class="line">#define uchar unsigned char//宏定义</span><br><span class="line">#define uint unsigned int//宏定义</span><br><span class="line">sbit DIN=P1^0;//IO定义</span><br><span class="line">sbit SCLK=P1^1;</span><br><span class="line">sbit CS=P1^2;</span><br><span class="line"></span><br><span class="line">uint code sin1[1024]=//1024点12位数据的正弦波表</span><br><span class="line">&#123;</span><br><span class="line">0x1FF,0x202,0x205,0x208,0x20C,0x20F,0x212,0x215,0x218,0x21B,0x21E,0x221,0x225,0x228,0x22B,0x22E</span><br><span class="line">,0x231,0x234,0x237,0x23A,0x23E,0x241,0x244,0x247,0x24A,0x24D,0x250,0x253,0x256,0x25A,0x25D,0x260</span><br><span class="line">,0x263,0x266,0x269,0x26C,0x26F,0x272,0x275,0x278,0x27B,0x27E,0x281,0x284,0x287,0x28A,0x28D,0x290</span><br><span class="line">,0x293,0x296,0x299,0x29C,0x29F,0x2A2,0x2A5,0x2A8,0x2AB,0x2AE,0x2B1,0x2B4,0x2B7,0x2BA,0x2BD,0x2C0</span><br><span class="line">,0x2C3,0x2C6,0x2C9,0x2CB,0x2CE,0x2D1,0x2D4,0x2D7,0x2DA,0x2DD,0x2DF,0x2E2,0x2E5,0x2E8,0x2EB,0x2ED</span><br><span class="line">,0x2F0,0x2F3,0x2F6,0x2F8,0x2FB,0x2FE,0x301,0x303,0x306,0x309,0x30B,0x30E,0x311,0x313,0x316,0x319</span><br><span class="line">,0x31B,0x31E,0x320,0x323,0x326,0x328,0x32B,0x32D,0x330,0x332,0x335,0x337,0x33A,0x33C,0x33F,0x341</span><br><span class="line">,0x343,0x346,0x348,0x34B,0x34D,0x34F,0x352,0x354,0x357,0x359,0x35B,0x35D,0x360,0x362,0x364,0x366</span><br><span class="line">,0x369,0x36B,0x36D,0x36F,0x371,0x374,0x376,0x378,0x37A,0x37C,0x37E,0x380,0x382,0x384,0x386,0x388</span><br><span class="line">,0x38A,0x38C,0x38E,0x390,0x392,0x394,0x396,0x398,0x39A,0x39C,0x39E,0x39F,0x3A1,0x3A3,0x3A5,0x3A7</span><br><span class="line">,0x3A8,0x3AA,0x3AC,0x3AD,0x3AF,0x3B1,0x3B2,0x3B4,0x3B6,0x3B7,0x3B9,0x3BA,0x3BC,0x3BE,0x3BF,0x3C1</span><br><span class="line">,0x3C2,0x3C4,0x3C5,0x3C6,0x3C8,0x3C9,0x3CB,0x3CC,0x3CD,0x3CF,0x3D0,0x3D1,0x3D3,0x3D4,0x3D5,0x3D6</span><br><span class="line">,0x3D8,0x3D9,0x3DA,0x3DB,0x3DC,0x3DD,0x3DE,0x3E0,0x3E1,0x3E2,0x3E3,0x3E4,0x3E5,0x3E6,0x3E7,0x3E8</span><br><span class="line">,0x3E8,0x3E9,0x3EA,0x3EB,0x3EC,0x3ED,0x3EE,0x3EE,0x3EF,0x3F0,0x3F1,0x3F1,0x3F2,0x3F3,0x3F3,0x3F4</span><br><span class="line">,0x3F5,0x3F5,0x3F6,0x3F6,0x3F7,0x3F7,0x3F8,0x3F8,0x3F9,0x3F9,0x3FA,0x3FA,0x3FB,0x3FB,0x3FB,0x3FC</span><br><span class="line">,0x3FC,0x3FC,0x3FD,0x3FD,0x3FD,0x3FD,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE</span><br><span class="line">,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FD,0x3FD,0x3FD,0x3FD,0x3FC</span><br><span class="line">,0x3FC,0x3FC,0x3FB,0x3FB,0x3FB,0x3FA,0x3FA,0x3F9,0x3F9,0x3F8,0x3F8,0x3F7,0x3F7,0x3F6,0x3F6,0x3F5</span><br><span class="line">,0x3F5,0x3F4,0x3F3,0x3F3,0x3F2,0x3F1,0x3F1,0x3F0,0x3EF,0x3EE,0x3EE,0x3ED,0x3EC,0x3EB,0x3EA,0x3E9</span><br><span class="line">,0x3E8,0x3E8,0x3E7,0x3E6,0x3E5,0x3E4,0x3E3,0x3E2,0x3E1,0x3E0,0x3DE,0x3DD,0x3DC,0x3DB,0x3DA,0x3D9</span><br><span class="line">,0x3D8,0x3D6,0x3D5,0x3D4,0x3D3,0x3D1,0x3D0,0x3CF,0x3CD,0x3CC,0x3CB,0x3C9,0x3C8,0x3C6,0x3C5,0x3C4</span><br><span class="line">,0x3C2,0x3C1,0x3BF,0x3BE,0x3BC,0x3BA,0x3B9,0x3B7,0x3B6,0x3B4,0x3B2,0x3B1,0x3AF,0x3AD,0x3AC,0x3AA</span><br><span class="line">,0x3A8,0x3A7,0x3A5,0x3A3,0x3A1,0x39F,0x39E,0x39C,0x39A,0x398,0x396,0x394,0x392,0x390,0x38E,0x38C</span><br><span class="line">,0x38A,0x388,0x386,0x384,0x382,0x380,0x37E,0x37C,0x37A,0x378,0x376,0x374,0x371,0x36F,0x36D,0x36B</span><br><span class="line">,0x369,0x366,0x364,0x362,0x360,0x35D,0x35B,0x359,0x357,0x354,0x352,0x34F,0x34D,0x34B,0x348,0x346</span><br><span class="line">,0x343,0x341,0x33F,0x33C,0x33A,0x337,0x335,0x332,0x330,0x32D,0x32B,0x328,0x326,0x323,0x320,0x31E</span><br><span class="line">,0x31B,0x319,0x316,0x313,0x311,0x30E,0x30B,0x309,0x306,0x303,0x301,0x2FE,0x2FB,0x2F8,0x2F6,0x2F3</span><br><span class="line">,0x2F0,0x2ED,0x2EB,0x2E8,0x2E5,0x2E2,0x2DF,0x2DD,0x2DA,0x2D7,0x2D4,0x2D1,0x2CE,0x2CB,0x2C9,0x2C6</span><br><span class="line">,0x2C3,0x2C0,0x2BD,0x2BA,0x2B7,0x2B4,0x2B1,0x2AE,0x2AB,0x2A8,0x2A5,0x2A2,0x29F,0x29C,0x299,0x296</span><br><span class="line">,0x293,0x290,0x28D,0x28A,0x287,0x284,0x281,0x27E,0x27B,0x278,0x275,0x272,0x26F,0x26C,0x269,0x266</span><br><span class="line">,0x263,0x260,0x25D,0x25A,0x256,0x253,0x250,0x24D,0x24A,0x247,0x244,0x241,0x23E,0x23A,0x237,0x234</span><br><span class="line">,0x231,0x22E,0x22B,0x228,0x225,0x221,0x21E,0x21B,0x218,0x215,0x212,0x20F,0x20C,0x208,0x205,0x202</span><br><span class="line">,0x1FF,0x1FC,0x1F9,0x1F6,0x1F2,0x1EF,0x1EC,0x1E9,0x1E6,0x1E3,0x1E0,0x1DC,0x1D9,0x1D6,0x1D3,0x1D0</span><br><span class="line">,0x1CD,0x1CA,0x1C7,0x1C3,0x1C0,0x1BD,0x1BA,0x1B7,0x1B4,0x1B1,0x1AE,0x1AB,0x1A8,0x1A4,0x1A1,0x19E</span><br><span class="line">,0x19B,0x198,0x195,0x192,0x18F,0x18C,0x189,0x186,0x183,0x180,0x17D,0x17A,0x177,0x174,0x171,0x16E</span><br><span class="line">,0x16B,0x168,0x165,0x162,0x15F,0x15C,0x159,0x156,0x153,0x150,0x14D,0x14A,0x147,0x144,0x141,0x13E</span><br><span class="line">,0x13B,0x138,0x135,0x133,0x130,0x12D,0x12A,0x127,0x124,0x121,0x11F,0x11C,0x119,0x116,0x113,0x111</span><br><span class="line">,0x10E,0x10B,0x108,0x106,0x103,0x100,0x0FD,0x0FB,0x0F8,0x0F5,0x0F3,0x0F0,0x0ED,0x0EB,0x0E8,0x0E5</span><br><span class="line">,0x0E3,0x0E0,0x0DE,0x0DB,0x0D8,0x0D6,0x0D3,0x0D1,0x0CE,0x0CC,0x0C9,0x0C7,0x0C4,0x0C2,0x0BF,0x0BD</span><br><span class="line">,0x0BB,0x0B8,0x0B6,0x0B3,0x0B1,0x0AF,0x0AC,0x0AA,0x0A7,0x0A5,0x0A3,0x0A1,0x09E,0x09C,0x09A,0x098</span><br><span class="line">,0x095,0x093,0x091,0x08F,0x08D,0x08A,0x088,0x086,0x084,0x082,0x080,0x07E,0x07C,0x07A,0x078,0x076</span><br><span class="line">,0x074,0x072,0x070,0x06E,0x06C,0x06A,0x068,0x066,0x064,0x062,0x060,0x05F,0x05D,0x05B,0x059,0x057</span><br><span class="line">,0x056,0x054,0x052,0x051,0x04F,0x04D,0x04C,0x04A,0x048,0x047,0x045,0x044,0x042,0x040,0x03F,0x03D</span><br><span class="line">,0x03C,0x03A,0x039,0x038,0x036,0x035,0x033,0x032,0x031,0x02F,0x02E,0x02D,0x02B,0x02A,0x029,0x028</span><br><span class="line">,0x026,0x025,0x024,0x023,0x022,0x021,0x020,0x01E,0x01D,0x01C,0x01B,0x01A,0x019,0x018,0x017,0x016</span><br><span class="line">,0x016,0x015,0x014,0x013,0x012,0x011,0x010,0x010,0x00F,0x00E,0x00D,0x00D,0x00C,0x00B,0x00B,0x00A</span><br><span class="line">,0x009,0x009,0x008,0x008,0x007,0x007,0x006,0x006,0x005,0x005,0x004,0x004,0x003,0x003,0x003,0x002</span><br><span class="line">,0x002,0x002,0x001,0x001,0x001,0x001,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000</span><br><span class="line">,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x001,0x001,0x001,0x001,0x002</span><br><span class="line">,0x002,0x002,0x003,0x003,0x003,0x004,0x004,0x005,0x005,0x006,0x006,0x007,0x007,0x008,0x008,0x009</span><br><span class="line">,0x009,0x00A,0x00B,0x00B,0x00C,0x00D,0x00D,0x00E,0x00F,0x010,0x010,0x011,0x012,0x013,0x014,0x015</span><br><span class="line">,0x016,0x016,0x017,0x018,0x019,0x01A,0x01B,0x01C,0x01D,0x01E,0x020,0x021,0x022,0x023,0x024,0x025</span><br><span class="line">,0x026,0x028,0x029,0x02A,0x02B,0x02D,0x02E,0x02F,0x031,0x032,0x033,0x035,0x036,0x038,0x039,0x03A</span><br><span class="line">,0x03C,0x03D,0x03F,0x040,0x042,0x044,0x045,0x047,0x048,0x04A,0x04C,0x04D,0x04F,0x051,0x052,0x054</span><br><span class="line">,0x056,0x057,0x059,0x05B,0x05D,0x05F,0x060,0x062,0x064,0x066,0x068,0x06A,0x06C,0x06E,0x070,0x072</span><br><span class="line">,0x074,0x076,0x078,0x07A,0x07C,0x07E,0x080,0x082,0x084,0x086,0x088,0x08A,0x08D,0x08F,0x091,0x093</span><br><span class="line">,0x095,0x098,0x09A,0x09C,0x09E,0x0A1,0x0A3,0x0A5,0x0A8,0x0AA,0x0AC,0x0AF,0x0B1,0x0B3,0x0B6,0x0B8</span><br><span class="line">,0x0BB,0x0BD,0x0BF,0x0C2,0x0C4,0x0C7,0x0C9,0x0CC,0x0CE,0x0D1,0x0D3,0x0D6,0x0D8,0x0DB,0x0DE,0x0E0</span><br><span class="line">,0x0E3,0x0E5,0x0E8,0x0EB,0x0ED,0x0F0,0x0F3,0x0F5,0x0F8,0x0FB,0x0FD,0x100,0x103,0x106,0x108,0x10B</span><br><span class="line">,0x10E,0x111,0x113,0x116,0x119,0x11C,0x11F,0x121,0x124,0x127,0x12A,0x12D,0x130,0x133,0x135,0x138</span><br><span class="line">,0x13B,0x13E,0x141,0x144,0x147,0x14A,0x14D,0x150,0x153,0x156,0x159,0x15C,0x15F,0x162,0x165,0x168</span><br><span class="line">,0x16B,0x16E,0x171,0x174,0x177,0x17A,0x17D,0x180,0x183,0x186,0x189,0x18C,0x18F,0x192,0x195,0x198</span><br><span class="line">,0x19B,0x19E,0x1A1,0x1A4,0x1A8,0x1AB,0x1AE,0x1B1,0x1B4,0x1B7,0x1BA,0x1BD,0x1C0,0x1C4,0x1C7,0x1CA</span><br><span class="line">,0x1CD,0x1D0,0x1D3,0x1D6,0x1D9,0x1DD,0x1E0,0x1E3,0x1E6,0x1E9,0x1EC,0x1EF,0x1F2,0x1F6,0x1F9,0x1FC&#125;;</span><br><span class="line">void delay_us(unsigned char n)//us级延时函数</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char i;</span><br><span class="line"> for(i=0;i&lt;n;i++);</span><br><span class="line">&#125;</span><br><span class="line">/******************************************************************</span><br><span class="line">1.sclk的上升沿数据进入输入寄存器</span><br><span class="line">2.在sclk为低的时候，CS的上升沿数据开始DA转化</span><br><span class="line">3.连续输入12位数据，高位在前，其中前10位有效，后两位补0</span><br><span class="line">***************************************************************/</span><br><span class="line">void output(uint DA_Value)//TLC5615驱动函数</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">DA_Value=DA_Value&lt;&lt;6;//将DA_Value左移6位，即nnnn nnnn nnnn变为nnnn nnnn nn00 0000</span><br><span class="line"></span><br><span class="line">SCLK=0;//为低，准备输入数据</span><br><span class="line">CS=0;//片选</span><br><span class="line">for(i=12;i&gt;0;i--)//从高位开始，连续取出12位数据，</span><br><span class="line">&#123;</span><br><span class="line">if(DA_Value&amp;0x8000)//和1000 0000 0000 0000求与，获取最高位的值。</span><br><span class="line">DIN=1;</span><br><span class="line">else</span><br><span class="line">DIN=0;</span><br><span class="line">SCLK=1;//上升沿，进入输入寄存器</span><br><span class="line">SCLK=0;//准备下一次输入</span><br><span class="line">DA_Value=DA_Value&lt;&lt;1;//左移1位，准备输入下一位数据</span><br><span class="line">&#125;</span><br><span class="line">CS=1;//在sclk为低的时候，CS上升沿，数据开始DA转化</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   uint i;</span><br><span class="line">   while(1)</span><br><span class="line">&#123;</span><br><span class="line">i=0;</span><br><span class="line">for(i=0;i&lt;1023;i++)//连续取出1024点正弦数据</span><br><span class="line">output(sin1[i]);//输出正弦波</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;************************************************************************************</p><p>TLC5615输出1024点正弦波<br>【注意事项】<br>2.TLC5615 DA模块本身必须使用5V电源，控制信号可以接受3.3V或者5V。<br>【IO配置】<br>DIN—&gt;P1.0<br>SCLK—&gt;P1.1<br>CS—&gt;P1.2<br>Dout—&gt;空，未定义<br>************************************************************************************&#x2F;<br>#include&lt;reg52.h&gt;&#x2F;&#x2F;包含51单片机寄存器定义的头文件<br>#include&lt;intrins.h&gt;&#x2F;&#x2F;包含nop函数的头文件<br>#define uchar unsigned char&#x2F;&#x2F;宏定义<br>#define uint unsigned int&#x2F;&#x2F;宏定义<br>sbit DIN&#x3D;P1^0;&#x2F;&#x2F;IO定义<br>sbit SCLK&#x3D;P1^1;<br>sbit CS&#x3D;P1^2;</p><p>uint code sin1[1024]&#x3D;&#x2F;&#x2F;1024点12位数据的正弦波表<br>{<br>0x1FF,0x202,0x205,0x208,0x20C,0x20F,0x212,0x215,0x218,0x21B,0x21E,0x221,0x225,0x228,0x22B,0x22E<br>,0x231,0x234,0x237,0x23A,0x23E,0x241,0x244,0x247,0x24A,0x24D,0x250,0x253,0x256,0x25A,0x25D,0x260<br>,0x263,0x266,0x269,0x26C,0x26F,0x272,0x275,0x278,0x27B,0x27E,0x281,0x284,0x287,0x28A,0x28D,0x290<br>,0x293,0x296,0x299,0x29C,0x29F,0x2A2,0x2A5,0x2A8,0x2AB,0x2AE,0x2B1,0x2B4,0x2B7,0x2BA,0x2BD,0x2C0<br>,0x2C3,0x2C6,0x2C9,0x2CB,0x2CE,0x2D1,0x2D4,0x2D7,0x2DA,0x2DD,0x2DF,0x2E2,0x2E5,0x2E8,0x2EB,0x2ED<br>,0x2F0,0x2F3,0x2F6,0x2F8,0x2FB,0x2FE,0x301,0x303,0x306,0x309,0x30B,0x30E,0x311,0x313,0x316,0x319<br>,0x31B,0x31E,0x320,0x323,0x326,0x328,0x32B,0x32D,0x330,0x332,0x335,0x337,0x33A,0x33C,0x33F,0x341<br>,0x343,0x346,0x348,0x34B,0x34D,0x34F,0x352,0x354,0x357,0x359,0x35B,0x35D,0x360,0x362,0x364,0x366<br>,0x369,0x36B,0x36D,0x36F,0x371,0x374,0x376,0x378,0x37A,0x37C,0x37E,0x380,0x382,0x384,0x386,0x388<br>,0x38A,0x38C,0x38E,0x390,0x392,0x394,0x396,0x398,0x39A,0x39C,0x39E,0x39F,0x3A1,0x3A3,0x3A5,0x3A7<br>,0x3A8,0x3AA,0x3AC,0x3AD,0x3AF,0x3B1,0x3B2,0x3B4,0x3B6,0x3B7,0x3B9,0x3BA,0x3BC,0x3BE,0x3BF,0x3C1<br>,0x3C2,0x3C4,0x3C5,0x3C6,0x3C8,0x3C9,0x3CB,0x3CC,0x3CD,0x3CF,0x3D0,0x3D1,0x3D3,0x3D4,0x3D5,0x3D6<br>,0x3D8,0x3D9,0x3DA,0x3DB,0x3DC,0x3DD,0x3DE,0x3E0,0x3E1,0x3E2,0x3E3,0x3E4,0x3E5,0x3E6,0x3E7,0x3E8<br>,0x3E8,0x3E9,0x3EA,0x3EB,0x3EC,0x3ED,0x3EE,0x3EE,0x3EF,0x3F0,0x3F1,0x3F1,0x3F2,0x3F3,0x3F3,0x3F4<br>,0x3F5,0x3F5,0x3F6,0x3F6,0x3F7,0x3F7,0x3F8,0x3F8,0x3F9,0x3F9,0x3FA,0x3FA,0x3FB,0x3FB,0x3FB,0x3FC<br>,0x3FC,0x3FC,0x3FD,0x3FD,0x3FD,0x3FD,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE<br>,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FE,0x3FD,0x3FD,0x3FD,0x3FD,0x3FC<br>,0x3FC,0x3FC,0x3FB,0x3FB,0x3FB,0x3FA,0x3FA,0x3F9,0x3F9,0x3F8,0x3F8,0x3F7,0x3F7,0x3F6,0x3F6,0x3F5<br>,0x3F5,0x3F4,0x3F3,0x3F3,0x3F2,0x3F1,0x3F1,0x3F0,0x3EF,0x3EE,0x3EE,0x3ED,0x3EC,0x3EB,0x3EA,0x3E9<br>,0x3E8,0x3E8,0x3E7,0x3E6,0x3E5,0x3E4,0x3E3,0x3E2,0x3E1,0x3E0,0x3DE,0x3DD,0x3DC,0x3DB,0x3DA,0x3D9<br>,0x3D8,0x3D6,0x3D5,0x3D4,0x3D3,0x3D1,0x3D0,0x3CF,0x3CD,0x3CC,0x3CB,0x3C9,0x3C8,0x3C6,0x3C5,0x3C4<br>,0x3C2,0x3C1,0x3BF,0x3BE,0x3BC,0x3BA,0x3B9,0x3B7,0x3B6,0x3B4,0x3B2,0x3B1,0x3AF,0x3AD,0x3AC,0x3AA<br>,0x3A8,0x3A7,0x3A5,0x3A3,0x3A1,0x39F,0x39E,0x39C,0x39A,0x398,0x396,0x394,0x392,0x390,0x38E,0x38C<br>,0x38A,0x388,0x386,0x384,0x382,0x380,0x37E,0x37C,0x37A,0x378,0x376,0x374,0x371,0x36F,0x36D,0x36B<br>,0x369,0x366,0x364,0x362,0x360,0x35D,0x35B,0x359,0x357,0x354,0x352,0x34F,0x34D,0x34B,0x348,0x346<br>,0x343,0x341,0x33F,0x33C,0x33A,0x337,0x335,0x332,0x330,0x32D,0x32B,0x328,0x326,0x323,0x320,0x31E<br>,0x31B,0x319,0x316,0x313,0x311,0x30E,0x30B,0x309,0x306,0x303,0x301,0x2FE,0x2FB,0x2F8,0x2F6,0x2F3<br>,0x2F0,0x2ED,0x2EB,0x2E8,0x2E5,0x2E2,0x2DF,0x2DD,0x2DA,0x2D7,0x2D4,0x2D1,0x2CE,0x2CB,0x2C9,0x2C6<br>,0x2C3,0x2C0,0x2BD,0x2BA,0x2B7,0x2B4,0x2B1,0x2AE,0x2AB,0x2A8,0x2A5,0x2A2,0x29F,0x29C,0x299,0x296<br>,0x293,0x290,0x28D,0x28A,0x287,0x284,0x281,0x27E,0x27B,0x278,0x275,0x272,0x26F,0x26C,0x269,0x266<br>,0x263,0x260,0x25D,0x25A,0x256,0x253,0x250,0x24D,0x24A,0x247,0x244,0x241,0x23E,0x23A,0x237,0x234<br>,0x231,0x22E,0x22B,0x228,0x225,0x221,0x21E,0x21B,0x218,0x215,0x212,0x20F,0x20C,0x208,0x205,0x202<br>,0x1FF,0x1FC,0x1F9,0x1F6,0x1F2,0x1EF,0x1EC,0x1E9,0x1E6,0x1E3,0x1E0,0x1DC,0x1D9,0x1D6,0x1D3,0x1D0<br>,0x1CD,0x1CA,0x1C7,0x1C3,0x1C0,0x1BD,0x1BA,0x1B7,0x1B4,0x1B1,0x1AE,0x1AB,0x1A8,0x1A4,0x1A1,0x19E<br>,0x19B,0x198,0x195,0x192,0x18F,0x18C,0x189,0x186,0x183,0x180,0x17D,0x17A,0x177,0x174,0x171,0x16E<br>,0x16B,0x168,0x165,0x162,0x15F,0x15C,0x159,0x156,0x153,0x150,0x14D,0x14A,0x147,0x144,0x141,0x13E<br>,0x13B,0x138,0x135,0x133,0x130,0x12D,0x12A,0x127,0x124,0x121,0x11F,0x11C,0x119,0x116,0x113,0x111<br>,0x10E,0x10B,0x108,0x106,0x103,0x100,0x0FD,0x0FB,0x0F8,0x0F5,0x0F3,0x0F0,0x0ED,0x0EB,0x0E8,0x0E5<br>,0x0E3,0x0E0,0x0DE,0x0DB,0x0D8,0x0D6,0x0D3,0x0D1,0x0CE,0x0CC,0x0C9,0x0C7,0x0C4,0x0C2,0x0BF,0x0BD<br>,0x0BB,0x0B8,0x0B6,0x0B3,0x0B1,0x0AF,0x0AC,0x0AA,0x0A7,0x0A5,0x0A3,0x0A1,0x09E,0x09C,0x09A,0x098<br>,0x095,0x093,0x091,0x08F,0x08D,0x08A,0x088,0x086,0x084,0x082,0x080,0x07E,0x07C,0x07A,0x078,0x076<br>,0x074,0x072,0x070,0x06E,0x06C,0x06A,0x068,0x066,0x064,0x062,0x060,0x05F,0x05D,0x05B,0x059,0x057<br>,0x056,0x054,0x052,0x051,0x04F,0x04D,0x04C,0x04A,0x048,0x047,0x045,0x044,0x042,0x040,0x03F,0x03D<br>,0x03C,0x03A,0x039,0x038,0x036,0x035,0x033,0x032,0x031,0x02F,0x02E,0x02D,0x02B,0x02A,0x029,0x028<br>,0x026,0x025,0x024,0x023,0x022,0x021,0x020,0x01E,0x01D,0x01C,0x01B,0x01A,0x019,0x018,0x017,0x016<br>,0x016,0x015,0x014,0x013,0x012,0x011,0x010,0x010,0x00F,0x00E,0x00D,0x00D,0x00C,0x00B,0x00B,0x00A<br>,0x009,0x009,0x008,0x008,0x007,0x007,0x006,0x006,0x005,0x005,0x004,0x004,0x003,0x003,0x003,0x002<br>,0x002,0x002,0x001,0x001,0x001,0x001,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000<br>,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x001,0x001,0x001,0x001,0x002<br>,0x002,0x002,0x003,0x003,0x003,0x004,0x004,0x005,0x005,0x006,0x006,0x007,0x007,0x008,0x008,0x009<br>,0x009,0x00A,0x00B,0x00B,0x00C,0x00D,0x00D,0x00E,0x00F,0x010,0x010,0x011,0x012,0x013,0x014,0x015<br>,0x016,0x016,0x017,0x018,0x019,0x01A,0x01B,0x01C,0x01D,0x01E,0x020,0x021,0x022,0x023,0x024,0x025<br>,0x026,0x028,0x029,0x02A,0x02B,0x02D,0x02E,0x02F,0x031,0x032,0x033,0x035,0x036,0x038,0x039,0x03A<br>,0x03C,0x03D,0x03F,0x040,0x042,0x044,0x045,0x047,0x048,0x04A,0x04C,0x04D,0x04F,0x051,0x052,0x054<br>,0x056,0x057,0x059,0x05B,0x05D,0x05F,0x060,0x062,0x064,0x066,0x068,0x06A,0x06C,0x06E,0x070,0x072<br>,0x074,0x076,0x078,0x07A,0x07C,0x07E,0x080,0x082,0x084,0x086,0x088,0x08A,0x08D,0x08F,0x091,0x093<br>,0x095,0x098,0x09A,0x09C,0x09E,0x0A1,0x0A3,0x0A5,0x0A8,0x0AA,0x0AC,0x0AF,0x0B1,0x0B3,0x0B6,0x0B8<br>,0x0BB,0x0BD,0x0BF,0x0C2,0x0C4,0x0C7,0x0C9,0x0CC,0x0CE,0x0D1,0x0D3,0x0D6,0x0D8,0x0DB,0x0DE,0x0E0<br>,0x0E3,0x0E5,0x0E8,0x0EB,0x0ED,0x0F0,0x0F3,0x0F5,0x0F8,0x0FB,0x0FD,0x100,0x103,0x106,0x108,0x10B<br>,0x10E,0x111,0x113,0x116,0x119,0x11C,0x11F,0x121,0x124,0x127,0x12A,0x12D,0x130,0x133,0x135,0x138<br>,0x13B,0x13E,0x141,0x144,0x147,0x14A,0x14D,0x150,0x153,0x156,0x159,0x15C,0x15F,0x162,0x165,0x168<br>,0x16B,0x16E,0x171,0x174,0x177,0x17A,0x17D,0x180,0x183,0x186,0x189,0x18C,0x18F,0x192,0x195,0x198<br>,0x19B,0x19E,0x1A1,0x1A4,0x1A8,0x1AB,0x1AE,0x1B1,0x1B4,0x1B7,0x1BA,0x1BD,0x1C0,0x1C4,0x1C7,0x1CA<br>,0x1CD,0x1D0,0x1D3,0x1D6,0x1D9,0x1DD,0x1E0,0x1E3,0x1E6,0x1E9,0x1EC,0x1EF,0x1F2,0x1F6,0x1F9,0x1FC};<br>void delay_us(unsigned char n)&#x2F;&#x2F;us级延时函数<br>    {<br>         unsigned char i;<br>         for(i&#x3D;0;i&lt;n;i++);<br>    }<br>&#x2F;******************************************************************<br>    1.sclk的上升沿数据进入输入寄存器<br>    2.在sclk为低的时候，CS的上升沿数据开始DA转化<br>    3.连续输入12位数据，高位在前，其中前10位有效，后两位补0<br>    ***************************************************************&#x2F;<br>void output(uint DA_Value)&#x2F;&#x2F;TLC5615驱动函数<br>    {<br>        unsigned char i;<br>        DA_Value&#x3D;DA_Value&lt;&lt;6;&#x2F;&#x2F;将DA_Value左移6位，即nnnn nnnn nnnn变为nnnn nnnn nn00 0000</p><pre><code>    SCLK=0;//为低，准备输入数据    CS=0;//片选    for(i=12;i&gt;0;i--)//从高位开始，连续取出12位数据，        &#123;            if(DA_Value&amp;0x8000)//和1000 0000 0000 0000求与，获取最高位的值。            DIN=1;            else            DIN=0;            SCLK=1;//上升沿，进入输入寄存器            SCLK=0;//准备下一次输入            DA_Value=DA_Value&lt;&lt;1;//左移1位，准备输入下一位数据        &#125;        CS=1;//在sclk为低的时候，CS上升沿，数据开始DA转化&#125;</code></pre><p>void main()<br>{<br>   uint i;<br>   while(1)<br>        {<br>            i&#x3D;0;<br>            for(i&#x3D;0;i&lt;1023;i++)&#x2F;&#x2F;连续取出1024点正弦数据<br>            output(sin1[i]);&#x2F;&#x2F;输出正弦波</p><pre><code>&#125;</code></pre><p>   }&#96;</p><h4 id="仿真资源和源码"><a href="#仿真资源和源码" class="headerlink" title="仿真资源和源码"></a>仿真资源和源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1CjJ88b5ax5d9ScD6TNoysw </span><br><span class="line">提取码：0iij</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1CjJ88b5ax5d9ScD6TNoysw  提取码：0iij</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15单片机可设置倒计时（0~9999）报警器+Proteus仿真</title>
      <link href="/2024/03/Proteus-STC15%E5%8D%95%E7%89%87%E6%9C%BA%E5%8F%AF%E8%AE%BE%E7%BD%AE%E5%80%92%E8%AE%A1%E6%97%B609999%E6%8A%A5%E8%AD%A6%E5%99%A8Proteus%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/03/Proteus-STC15%E5%8D%95%E7%89%87%E6%9C%BA%E5%8F%AF%E8%AE%BE%E7%BD%AE%E5%80%92%E8%AE%A1%E6%97%B609999%E6%8A%A5%E8%AD%A6%E5%99%A8Proteus%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15单片机可设置倒计时（0-9999）报警器-Proteus仿真"><a href="#STC15单片机可设置倒计时（0-9999）报警器-Proteus仿真" class="headerlink" title="STC15单片机可设置倒计时（0~9999）报警器+Proteus仿真"></a>STC15单片机可设置倒计时（0~9999）报警器+Proteus仿真</h1><h3 id="STC15单片机可设置倒计时（0-9999）报警器-Proteus仿真-1"><a href="#STC15单片机可设置倒计时（0-9999）报警器-Proteus仿真-1" class="headerlink" title="STC15单片机可设置倒计时（0~9999）报警器+Proteus仿真"></a>STC15单片机可设置倒计时（0~9999）报警器+Proteus仿真</h3><ul><li>📺Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/7cbcde4c609e487b820382f633141fdf.gif#pic_center" alt="在这里插入图片描述"></p><ul><li><p>✨2023-3-3 内容更新：</p></li><li><p>修复原程序bug，新增按键，引脚定义在P34，在设定倒计时的时候，可以减少数值。</p></li><li><p>修复原程序bug，新增按键，引脚定义在P34，在设定倒计时的时候，可以减少数值。</p></li><li><p>仿真中添加了继电器，在倒计时时开启，倒计时结束关闭。</p></li><li><p>仿真中添加了继电器，在倒计时时开启，倒计时结束关闭。</p></li></ul><ol><li><p>修复原程序bug，新增按键，引脚定义在P34，在设定倒计时的时候，可以减少数值。</p></li><li><p>仿真中添加了继电器，在倒计时时开启，倒计时结束关闭。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/8f567839b71b4a8d827c2b8a2c2195aa.png" alt="在这里插入图片描述"></p><h4 id="📝程序代码"><a href="#📝程序代码" class="headerlink" title="📝程序代码"></a>📝程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line">/*------------------------------------------------------------------*/</span><br><span class="line">/* --- STC MCU International Limited -------------------------------*/</span><br><span class="line">/* --- STC 1T Series MCU RC Demo -----------------------------------*/</span><br><span class="line">/* --- Mobile: (86)13922805190 -------------------------------------*/</span><br><span class="line">/* --- Fax: 86-0513-55012956,55012947,55012969 ---------------------*/</span><br><span class="line">/* --- Tel: 86-0513-55012928,55012929,55012966 ---------------------*/</span><br><span class="line">/* --- Web: www.GXWMCU.com -----------------------------------------*/</span><br><span class="line">/* --- QQ:  800003751 ----------------------------------------------*/</span><br><span class="line">/* If you want to use the program or the program referenced in the  */</span><br><span class="line">/* article, please specify in which data and procedures from STC    */</span><br><span class="line">/*------------------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&quot;config.h&quot;</span><br><span class="line">#include&quot;GPIO.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line"></span><br><span class="line">/*************功能说明**************</span><br><span class="line"></span><br><span class="line">本程序演示跑马灯。</span><br><span class="line">程序使用P2口来演示，输出低驱动。用户可以修改为别的口。</span><br><span class="line"></span><br><span class="line">******************************************/</span><br><span class="line"></span><br><span class="line">/*************本地常量声明**************/</span><br><span class="line">#define u8 unsigned char</span><br><span class="line">#define u16 unsigned int</span><br><span class="line">#define u32 unsigned long</span><br><span class="line">#define s8 signed char</span><br><span class="line">#define s16 signed int</span><br><span class="line">#define s32 signed long</span><br><span class="line">#define KEY_TIME 25                        //按键消抖时间 (毫秒)</span><br><span class="line">#define reset()        IAP_CONTR |= 0x20                //芯片复位</span><br><span class="line">#define feed_dog()  WDT_CONTR |= 0x10   //看门狗喂狗</span><br><span class="line">u8 code nbr[16] = &#123;                //共阴数码管段码16进制</span><br><span class="line">    0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71</span><br><span class="line">&#125;;</span><br><span class="line">u8 show[4];                //4位数码管当前显示的段码 更改数码管显示的段码 只需更改此数组</span><br><span class="line">u8 wink;                //闪烁的数码管段码        0x01: 第一位闪烁 0x02:第二位闪烁 0x04: 第三位闪烁 0x0F:全闪烁 0x00:全不闪烁</span><br><span class="line"></span><br><span class="line">sbit P3_0 = P3 ^ 0;                //按键S1 (I/O口定义的按键未经消抖,请勿在中断外直接使用)</span><br><span class="line">sbit P3_1 = P3 ^ 1;                //按键S2</span><br><span class="line">sbit P3_2 = P3 ^ 2;     //有源蜂鸣器 低电平鸣叫</span><br><span class="line">sbit P3_3 = P3 ^ 3;     //继电器或MOS管 低电平吸合(导通)</span><br><span class="line">u16 S1_ms, S2_ms;                //按键0、按键1连续按下的时间 定时器中断计数此变量 最长65535毫秒 松开清零</span><br><span class="line"></span><br><span class="line">u16 delayms;  //定时器中断延时 (毫秒)</span><br><span class="line">u16 time;      //定时时间 (秒)</span><br><span class="line">u16 beep_ms;   //蜂鸣器鸣叫时间 (毫秒)</span><br><span class="line"></span><br><span class="line">u16 bdata Bit16 = 0;    //定义16位可位寻址变量</span><br><span class="line">sbit delay = Bit16 ^ 0;      //定时器中断延时毫秒开关 中断外置1 延时完中断内清0</span><br><span class="line">sbit test = Bit16 ^ 1;       //此值为1数码管全亮 蜂鸣器响 所有按键无效 否则正常</span><br><span class="line">sbit S1 = Bit16 ^ 2;         //按键0 连续按下N毫秒清0, 松开置1(定时器0中断消抖)</span><br><span class="line">sbit S2 = Bit16 ^ 3;         //按键1 (处理方式与按键0相同)</span><br><span class="line">sbit hz10 = Bit16 ^ 4;      //10Hz信号源 (定时器0中断产生,用于控制数码管闪烁)</span><br><span class="line">sbit bak = Bit16 ^ 5;       //按键长按识别处理用</span><br><span class="line">sbit Beep = Bit16 ^ 6;      //有源蜂鸣器 低电平响</span><br><span class="line">sbit start = Bit16 ^ 7;     //倒计时开关 置1倒计时开始 清0则结束</span><br><span class="line">sbit pause = Bit16 ^ 8;     //1暂停倒计时 0正常</span><br><span class="line">sbit relay = Bit16 ^ 9;     //继电器或MOS管 低电平吸合(导通) 1秒只能吸合或释放1次</span><br><span class="line"></span><br><span class="line">/*************本地变量声明**************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*************本地函数声明**************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*************  外部函数和变量声明 *****************/</span><br><span class="line">void InitTimer0() &#123;        //初始化定时器0中断</span><br><span class="line">    TMOD = 0x01;</span><br><span class="line">    TH0 = 0xFC;</span><br><span class="line">    TL0 = 0x18;</span><br><span class="line">    EA = 1;</span><br><span class="line">    ET0 = 1;</span><br><span class="line">    TR0 = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void beep(u16 ms) &#123;     //蜂鸣器鸣叫 参数:鸣叫毫秒</span><br><span class="line">    beep_ms = ms;</span><br><span class="line">    Beep = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 set_time() &#123;        //设定定时时间</span><br><span class="line">    u8 n = 0;       //0:编辑千位 1:百位 2:十位 3:个位</span><br><span class="line">    u8 o[4];</span><br><span class="line">    o[0] = 0; o[1] = 0; o[2] = 0; o[3] = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        feed_dog();</span><br><span class="line">        wink = 8 &gt;&gt; n;</span><br><span class="line">        show[0] = nbr[o[0]];</span><br><span class="line">        show[1] = nbr[o[1]];</span><br><span class="line">        show[2] = nbr[o[2]];</span><br><span class="line">        show[3] = nbr[o[3]];</span><br><span class="line">        if (S2 == 0) &#123;                        //S2按下 短按加1</span><br><span class="line">            beep(50);</span><br><span class="line">            if (o[n]++ &gt;= 9) o[n] = 0;</span><br><span class="line">            show[n] = nbr[o[n]];</span><br><span class="line">            delayms = 500; delay = 1;</span><br><span class="line">            while (delay &amp;&amp; S2 == 0);        //长按延时等待</span><br><span class="line">            while (S2_ms &gt;= 500) &#123;                //按键长按,开始连加</span><br><span class="line">                feed_dog();</span><br><span class="line">                delayms = 125; delay = 1;                //0.125秒连加一次</span><br><span class="line">                while (delay &amp;&amp; S2 == 0);</span><br><span class="line">                beep(50);</span><br><span class="line">                if (o[n]++ &gt;= 9) o[n] = 0;</span><br><span class="line">                show[n] = nbr[o[n]];</span><br><span class="line">            &#125;</span><br><span class="line">            delay = 0;</span><br><span class="line">            delayms = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (S1 == 0) &#123;                //S1按下</span><br><span class="line">            beep(50);</span><br><span class="line">            n++;                //输入下一位</span><br><span class="line">            while (S1 == 0) &#123;</span><br><span class="line">                feed_dog();</span><br><span class="line">                if (S1_ms &gt;= 1000 &amp;&amp; !bak) &#123;                //长按退回编辑</span><br><span class="line">                    beep(50);</span><br><span class="line">                    n = 0;</span><br><span class="line">                    wink = 8 &gt;&gt; n;</span><br><span class="line">                    show[0] = nbr[o[0]];</span><br><span class="line">                    show[1] = nbr[o[1]];</span><br><span class="line">                    show[2] = nbr[o[2]];</span><br><span class="line">                    show[3] = nbr[o[3]];</span><br><span class="line">                    bak = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (bak) &#123;</span><br><span class="line">                bak = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (n &gt;= 4) &#123;                //个位输入完成</span><br><span class="line">                wink = 0;</span><br><span class="line">                return o[0] * 1000 + o[1] * 100 + o[2] * 10 + o[3];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************** IO配置函数 **************************/</span><br><span class="line">voidGPIO_config(void)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDefGPIO_InitStructure;//结构定义</span><br><span class="line">GPIO_InitStructure.Pin  = GPIO_Pin_All;//指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7, 或操作</span><br><span class="line">GPIO_InitStructure.Mode = GPIO_OUT_PP;//指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP</span><br><span class="line">GPIO_Inilize(GPIO_P2,&amp;GPIO_InitStructure);//初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************** 主函数 **************************/</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"> u8 i = 0;</span><br><span class="line">    Beep = 1;</span><br><span class="line">    WDT_CONTR = 0x27;           //初始化看门狗</span><br><span class="line">    P1M0 = 0x0F; P1M1 = 0x00;   //P1.0~P1.3强推挽</span><br><span class="line">    P2M0 = 0xFF; P2M1 = 0x00;   //P2.0~P2.7强推挽</span><br><span class="line">    //上电1秒数码管全亮 蜂鸣器响</span><br><span class="line">    test = 1;</span><br><span class="line">GPIO_config();</span><br><span class="line">    InitTimer0();</span><br><span class="line">    delayms = 1000; delay = 1;</span><br><span class="line">    while (delay);</span><br><span class="line">    test = 0;</span><br><span class="line"></span><br><span class="line">    show[0] = nbr[0];</span><br><span class="line">    show[1] = nbr[0];</span><br><span class="line">    show[2] = nbr[0];</span><br><span class="line">    show[3] = nbr[0];</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">relay = 1;</span><br><span class="line">        pause = 0;</span><br><span class="line">        do &#123;        //时间设定</span><br><span class="line">            time = set_time();</span><br><span class="line">        &#125; while (!time);</span><br><span class="line">        time -= 1;</span><br><span class="line">        start = 1;</span><br><span class="line">        relay = 0;</span><br><span class="line">        while (start) &#123;</span><br><span class="line">            feed_dog();</span><br><span class="line">            if (S1 == 0) &#123;      //S1按下蜂鸣器响1下</span><br><span class="line">                beep(50);</span><br><span class="line">                while (S1 == 0) &#123;</span><br><span class="line">                    feed_dog();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (S2 == 0) &#123;      //S2按下暂停倒计时</span><br><span class="line">                beep(50);</span><br><span class="line">                pause = !pause;</span><br><span class="line">                relay = pause;</span><br><span class="line">                while (S2 == 0) &#123;</span><br><span class="line">                    feed_dog();</span><br><span class="line">                    if (pause &amp;&amp; S2_ms &gt;= 3000) &#123;       //长按3秒复位</span><br><span class="line">                        _nop_(); _nop_(); _nop_(); _nop_();</span><br><span class="line">                        reset();</span><br><span class="line">                        _nop_(); _nop_(); _nop_(); _nop_();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //倒计时结束</span><br><span class="line">        show[0] = 0x79;     //E</span><br><span class="line">        show[1] = 0x54;     //n</span><br><span class="line">        show[2] = 0x5E;     //d</span><br><span class="line">        show[3] = 0x00;</span><br><span class="line">        for (i = 0; i &lt; 6; i++) &#123;       //蜂鸣器响6下</span><br><span class="line">            delayms = 500; delay = 1; while (delay);</span><br><span class="line">            beep(500);</span><br><span class="line">            while (!Beep);</span><br><span class="line">            feed_dog();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (1) &#123;</span><br><span class="line">            feed_dog();</span><br><span class="line">            if (S1 == 0 || S2 == 0) &#123;</span><br><span class="line">                beep(50);</span><br><span class="line">                while (S1 == 0 || S2 == 0) &#123;</span><br><span class="line">                    feed_dog();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Timer0Interrupt() interrupt 1&#123;         //12Mhz 1mS定时器中断</span><br><span class="line">    static u8 seg = 0;  //当前正在扫描的数码管段码 4位数码管 范围:0~3</span><br><span class="line">    static u8 ms1 = 0;</span><br><span class="line">    static u16 ms = 0, ms2 = 0;</span><br><span class="line">    TH0 = 0xFC;</span><br><span class="line">    TL0 = 0x18;</span><br><span class="line">    if (delay &amp;&amp; !--delayms) &#123;    //延时任意毫秒</span><br><span class="line">        delay = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //数码管动态扫描处理</span><br><span class="line">    P1 |= 0xF;          //消影</span><br><span class="line">    P2 = test ? 0xFF : (wink &amp; (1 &lt;&lt; (3 ^ seg)) &amp;&amp; !hz10 ? 0 : show[seg]);      //段码</span><br><span class="line">    P1 &amp;= ~(1 &lt;&lt; seg);   //位码</span><br><span class="line">    if (++seg &gt;= 4) seg = 0;</span><br><span class="line"></span><br><span class="line">    if (test) &#123;     //测试模式</span><br><span class="line">        S1 = 1; S2 = 1;</span><br><span class="line">        P3_2 = 0;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //蜂鸣器处理</span><br><span class="line">    P3_2 = Beep;</span><br><span class="line">    if (!Beep &amp;&amp; !--beep_ms) &#123;</span><br><span class="line">        Beep = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (++ms1 &gt;= 50) &#123;</span><br><span class="line">        ms1 = 0;</span><br><span class="line">        hz10 = !hz10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //按键处理</span><br><span class="line">    if (P3_0 == 0) &#123;</span><br><span class="line">        if (S1_ms != 0xFFFF) S1_ms++;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        S1_ms = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (P3_1 == 0) &#123;</span><br><span class="line">        if (S2_ms != 0xFFFF) S2_ms++;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        S2_ms = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    S1 = !(S1_ms &gt;= KEY_TIME);</span><br><span class="line">    S2 = !(S2_ms &gt;= KEY_TIME);</span><br><span class="line">    //继电器处理</span><br><span class="line">    if (++ms2 &gt;= 1000) &#123;    //继电器1秒只能进行1次吸合或释放，防止频繁开关导致设备损坏</span><br><span class="line">        ms2 = 0;</span><br><span class="line">        P3_3 = relay;</span><br><span class="line">    &#125;</span><br><span class="line">    //时间倒计时处理</span><br><span class="line">    if (start) &#123;</span><br><span class="line">        if (pause) &#123;</span><br><span class="line">            wink = 0xF;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            wink = 0;</span><br><span class="line">            if (++ms &gt;= 1000) &#123;</span><br><span class="line">                ms = 0;</span><br><span class="line">                show[0] = nbr[time / 1000 % 10];</span><br><span class="line">                show[1] = nbr[time / 100 % 10];</span><br><span class="line">                show[2] = nbr[time / 10 % 10];</span><br><span class="line">                show[3] = nbr[time % 10];</span><br><span class="line"></span><br><span class="line">                if (!time--) &#123;      //倒计时结束</span><br><span class="line">                    start = 0;</span><br><span class="line">                    relay = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>——————————————————————</em>&#x2F;<br>&#x2F;* — STC MCU International Limited ——————————-<em>&#x2F;<br>&#x2F;</em> — STC 1T Series MCU RC Demo ———————————–<em>&#x2F;<br>&#x2F;</em> — Mobile: (86)13922805190 ————————————-<em>&#x2F;<br>&#x2F;</em> — Fax: 86-0513-55012956,55012947,55012969 ———————<em>&#x2F;<br>&#x2F;</em> — Tel: 86-0513-55012928,55012929,55012966 ———————<em>&#x2F;<br>&#x2F;</em> — Web: <a href="http://www.gxwmcu.com/">www.GXWMCU.com</a> —————————————–<em>&#x2F;<br>&#x2F;</em> — QQ:  800003751 ———————————————-<em>&#x2F;<br>&#x2F;</em> If you want to use the program or the program referenced in the  <em>&#x2F;<br>&#x2F;</em> article, please specify in which data and procedures from STC    <em>&#x2F;<br>&#x2F;</em>——————————————————————*&#x2F;</p><p>#include“config.h”<br>#include“GPIO.h”<br>#include“delay.h”</p><p>&#x2F;*************功能说明**************</p><p>本程序演示跑马灯。<br>程序使用P2口来演示，输出低驱动。用户可以修改为别的口。</p><p>******************************************&#x2F;</p><p>&#x2F;*************本地常量声明**************&#x2F;<br>#define u8 unsigned char<br>#define u16 unsigned int<br>#define u32 unsigned long<br>#define s8 signed char<br>#define s16 signed int<br>#define s32 signed long<br>#define KEY_TIME 25                        &#x2F;&#x2F;按键消抖时间 (毫秒)<br>#define reset()        IAP_CONTR |&#x3D; 0x20                &#x2F;&#x2F;芯片复位<br>#define feed_dog()  WDT_CONTR |&#x3D; 0x10   &#x2F;&#x2F;看门狗喂狗<br>u8 code nbr[16] &#x3D; {                &#x2F;&#x2F;共阴数码管段码16进制<br>    0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71<br>};<br>u8 show[4];                &#x2F;&#x2F;4位数码管当前显示的段码 更改数码管显示的段码 只需更改此数组<br>u8 wink;                &#x2F;&#x2F;闪烁的数码管段码        0x01: 第一位闪烁 0x02:第二位闪烁 0x04: 第三位闪烁 0x0F:全闪烁 0x00:全不闪烁</p><p>sbit P3_0 &#x3D; P3 ^ 0;                &#x2F;&#x2F;按键S1 (I&#x2F;O口定义的按键未经消抖,请勿在中断外直接使用)<br>sbit P3_1 &#x3D; P3 ^ 1;                &#x2F;&#x2F;按键S2<br>sbit P3_2 &#x3D; P3 ^ 2;     &#x2F;&#x2F;有源蜂鸣器 低电平鸣叫<br>sbit P3_3 &#x3D; P3 ^ 3;     &#x2F;&#x2F;继电器或MOS管 低电平吸合(导通)<br>u16 S1_ms, S2_ms;                &#x2F;&#x2F;按键0、按键1连续按下的时间 定时器中断计数此变量 最长65535毫秒 松开清零</p><p>u16 delayms;  &#x2F;&#x2F;定时器中断延时 (毫秒)<br>u16 time;      &#x2F;&#x2F;定时时间 (秒)<br>u16 beep_ms;   &#x2F;&#x2F;蜂鸣器鸣叫时间 (毫秒)</p><p>u16 bdata Bit16 &#x3D; 0;    &#x2F;&#x2F;定义16位可位寻址变量<br>sbit delay &#x3D; Bit16 ^ 0;      &#x2F;&#x2F;定时器中断延时毫秒开关 中断外置1 延时完中断内清0<br>sbit test &#x3D; Bit16 ^ 1;       &#x2F;&#x2F;此值为1数码管全亮 蜂鸣器响 所有按键无效 否则正常<br>sbit S1 &#x3D; Bit16 ^ 2;         &#x2F;&#x2F;按键0 连续按下N毫秒清0, 松开置1(定时器0中断消抖)<br>sbit S2 &#x3D; Bit16 ^ 3;         &#x2F;&#x2F;按键1 (处理方式与按键0相同)<br>sbit hz10 &#x3D; Bit16 ^ 4;      &#x2F;&#x2F;10Hz信号源 (定时器0中断产生,用于控制数码管闪烁)<br>sbit bak &#x3D; Bit16 ^ 5;       &#x2F;&#x2F;按键长按识别处理用<br>sbit Beep &#x3D; Bit16 ^ 6;      &#x2F;&#x2F;有源蜂鸣器 低电平响<br>sbit start &#x3D; Bit16 ^ 7;     &#x2F;&#x2F;倒计时开关 置1倒计时开始 清0则结束<br>sbit pause &#x3D; Bit16 ^ 8;     &#x2F;&#x2F;1暂停倒计时 0正常<br>sbit relay &#x3D; Bit16 ^ 9;     &#x2F;&#x2F;继电器或MOS管 低电平吸合(导通) 1秒只能吸合或释放1次</p><p>&#x2F;*************本地变量声明**************&#x2F;</p><p>&#x2F;*************本地函数声明**************&#x2F;</p><p>&#x2F;*************  外部函数和变量声明 *****************&#x2F;<br>void InitTimer0() {        &#x2F;&#x2F;初始化定时器0中断<br>    TMOD &#x3D; 0x01;<br>    TH0 &#x3D; 0xFC;<br>    TL0 &#x3D; 0x18;<br>    EA &#x3D; 1;<br>    ET0 &#x3D; 1;<br>    TR0 &#x3D; 1;<br>}</p><p>void beep(u16 ms) {     &#x2F;&#x2F;蜂鸣器鸣叫 参数:鸣叫毫秒<br>    beep_ms &#x3D; ms;<br>    Beep &#x3D; 0;<br>}</p><p>u16 set_time() {        &#x2F;&#x2F;设定定时时间<br>    u8 n &#x3D; 0;       &#x2F;&#x2F;0:编辑千位 1:百位 2:十位 3:个位<br>    u8 o[4];<br>    o[0] &#x3D; 0; o[1] &#x3D; 0; o[2] &#x3D; 0; o[3] &#x3D; 0;<br>    while (1) {<br>        feed_dog();<br>        wink &#x3D; 8 &gt;&gt; n;<br>        show[0] &#x3D; nbr[o[0]];<br>        show[1] &#x3D; nbr[o[1]];<br>        show[2] &#x3D; nbr[o[2]];<br>        show[3] &#x3D; nbr[o[3]];<br>        if (S2 &#x3D;&#x3D; 0) {                        &#x2F;&#x2F;S2按下 短按加1<br>            beep(50);<br>            if (o[n]++ &gt;&#x3D; 9) o[n] &#x3D; 0;<br>            show[n] &#x3D; nbr[o[n]];<br>            delayms &#x3D; 500; delay &#x3D; 1;<br>            while (delay &amp;&amp; S2 &#x3D;&#x3D; 0);        &#x2F;&#x2F;长按延时等待<br>            while (S2_ms &gt;&#x3D; 500) {                &#x2F;&#x2F;按键长按,开始连加<br>                feed_dog();<br>                delayms &#x3D; 125; delay &#x3D; 1;                &#x2F;&#x2F;0.125秒连加一次<br>                while (delay &amp;&amp; S2 &#x3D;&#x3D; 0);<br>                beep(50);<br>                if (o[n]++ &gt;&#x3D; 9) o[n] &#x3D; 0;<br>                show[n] &#x3D; nbr[o[n]];<br>            }<br>            delay &#x3D; 0;<br>            delayms &#x3D; 0;<br>        }</p><pre><code>    if (S1 == 0) &#123;                //S1按下        beep(50);        n++;                //输入下一位        while (S1 == 0) &#123;            feed_dog();            if (S1_ms &gt;= 1000 &amp;&amp; !bak) &#123;                //长按退回编辑                beep(50);                n = 0;                wink = 8 &gt;&gt; n;                show[0] = nbr[o[0]];                show[1] = nbr[o[1]];                show[2] = nbr[o[2]];                show[3] = nbr[o[3]];                bak = 1;            &#125;        &#125;        if (bak) &#123;            bak = 0;            continue;        &#125;        if (n &gt;= 4) &#123;                //个位输入完成            wink = 0;            return o[0] * 1000 + o[1] * 100 + o[2] * 10 + o[3];        &#125;    &#125;&#125;</code></pre><p>&#x2F;&#x2F;    return 0;<br>}</p><p>&#x2F;******************** IO配置函数 **************************&#x2F;<br>voidGPIO_config(void)<br>{<br>    GPIO_InitTypeDefGPIO_InitStructure;&#x2F;&#x2F;结构定义<br>    GPIO_InitStructure.Pin  &#x3D; GPIO_Pin_All;&#x2F;&#x2F;指定要初始化的IO, GPIO_Pin_0 ~ GPIO_Pin_7, 或操作<br>    GPIO_InitStructure.Mode &#x3D; GPIO_OUT_PP;&#x2F;&#x2F;指定IO的输入或输出方式,GPIO_PullUp,GPIO_HighZ,GPIO_OUT_OD,GPIO_OUT_PP<br>    GPIO_Inilize(GPIO_P2,&amp;GPIO_InitStructure);&#x2F;&#x2F;初始化<br>}</p><p>&#x2F;******************** 主函数 **************************&#x2F;<br>void main(void)<br>{<br>     u8 i &#x3D; 0;<br>    Beep &#x3D; 1;<br>    WDT_CONTR &#x3D; 0x27;           &#x2F;&#x2F;初始化看门狗<br>    P1M0 &#x3D; 0x0F; P1M1 &#x3D; 0x00;   &#x2F;&#x2F;P1.0<del>P1.3强推挽<br>    P2M0 &#x3D; 0xFF; P2M1 &#x3D; 0x00;   &#x2F;&#x2F;P2.0</del>P2.7强推挽<br>    &#x2F;&#x2F;上电1秒数码管全亮 蜂鸣器响<br>    test &#x3D; 1;<br>        GPIO_config();<br>    InitTimer0();<br>    delayms &#x3D; 1000; delay &#x3D; 1;<br>    while (delay);<br>    test &#x3D; 0;</p><pre><code>show[0] = nbr[0];show[1] = nbr[0];show[2] = nbr[0];show[3] = nbr[0];while(1)&#123;</code></pre><p>relay &#x3D; 1;<br>        pause &#x3D; 0;<br>        do {        &#x2F;&#x2F;时间设定<br>            time &#x3D; set_time();<br>        } while (!time);<br>        time -&#x3D; 1;<br>        start &#x3D; 1;<br>        relay &#x3D; 0;<br>        while (start) {<br>            feed_dog();<br>            if (S1 &#x3D;&#x3D; 0) {      &#x2F;&#x2F;S1按下蜂鸣器响1下<br>                beep(50);<br>                while (S1 &#x3D;&#x3D; 0) {<br>                    feed_dog();<br>                }<br>            }</p><pre><code>        if (S2 == 0) &#123;      //S2按下暂停倒计时            beep(50);            pause = !pause;            relay = pause;            while (S2 == 0) &#123;                feed_dog();                if (pause &amp;&amp; S2_ms &gt;= 3000) &#123;       //长按3秒复位                    _nop_(); _nop_(); _nop_(); _nop_();                    reset();                    _nop_(); _nop_(); _nop_(); _nop_();                &#125;            &#125;        &#125;    &#125;    //倒计时结束    show[0] = 0x79;     //E    show[1] = 0x54;     //n    show[2] = 0x5E;     //d    show[3] = 0x00;    for (i = 0; i &lt; 6; i++) &#123;       //蜂鸣器响6下        delayms = 500; delay = 1; while (delay);        beep(500);        while (!Beep);        feed_dog();    &#125;    while (1) &#123;        feed_dog();        if (S1 == 0 || S2 == 0) &#123;            beep(50);            while (S1 == 0 || S2 == 0) &#123;                feed_dog();            &#125;            break;        &#125;    &#125;&#125;</code></pre><p>}</p><p>void Timer0Interrupt() interrupt 1{         &#x2F;&#x2F;12Mhz 1mS定时器中断<br>    static u8 seg &#x3D; 0;  &#x2F;&#x2F;当前正在扫描的数码管段码 4位数码管 范围:0~3<br>    static u8 ms1 &#x3D; 0;<br>    static u16 ms &#x3D; 0, ms2 &#x3D; 0;<br>    TH0 &#x3D; 0xFC;<br>    TL0 &#x3D; 0x18;<br>    if (delay &amp;&amp; !–delayms) {    &#x2F;&#x2F;延时任意毫秒<br>        delay &#x3D; 0;<br>    }<br>    &#x2F;&#x2F;数码管动态扫描处理<br>    P1 |&#x3D; 0xF;          &#x2F;&#x2F;消影<br>    P2 &#x3D; test ? 0xFF : (wink &amp; (1 &lt;&lt; (3 ^ seg)) &amp;&amp; !hz10 ? 0 : show[seg]);      &#x2F;&#x2F;段码<br>    P1 &amp;&#x3D; ~(1 &lt;&lt; seg);   &#x2F;&#x2F;位码<br>    if (++seg &gt;&#x3D; 4) seg &#x3D; 0;</p><pre><code>if (test) &#123;     //测试模式    S1 = 1; S2 = 1;    P3_2 = 0;    return;&#125;//蜂鸣器处理P3_2 = Beep;if (!Beep &amp;&amp; !--beep_ms) &#123;    Beep = 1;&#125;if (++ms1 &gt;= 50) &#123;    ms1 = 0;    hz10 = !hz10;&#125;//按键处理if (P3_0 == 0) &#123;    if (S1_ms != 0xFFFF) S1_ms++;&#125;else &#123;    S1_ms = 0;&#125;if (P3_1 == 0) &#123;    if (S2_ms != 0xFFFF) S2_ms++;&#125;else &#123;    S2_ms = 0;&#125;S1 = !(S1_ms &gt;= KEY_TIME);S2 = !(S2_ms &gt;= KEY_TIME);//继电器处理if (++ms2 &gt;= 1000) &#123;    //继电器1秒只能进行1次吸合或释放，防止频繁开关导致设备损坏    ms2 = 0;    P3_3 = relay;&#125;//时间倒计时处理if (start) &#123;    if (pause) &#123;        wink = 0xF;    &#125;    else &#123;        wink = 0;        if (++ms &gt;= 1000) &#123;            ms = 0;            show[0] = nbr[time / 1000 % 10];            show[1] = nbr[time / 100 % 10];            show[2] = nbr[time / 10 % 10];            show[3] = nbr[time % 10];            if (!time--) &#123;      //倒计时结束                start = 0;                relay = 1;            &#125;        &#125;    &#125;&#125;</code></pre><p>}&#96;</p><h4 id="📚程序源码和仿真资源"><a href="#📚程序源码和仿真资源" class="headerlink" title="📚程序源码和仿真资源"></a>📚程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1DjhHyl_yG3VP1gXn8rU5iQ </span><br><span class="line">提取码：07fx</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1DjhHyl_yG3VP1gXn8rU5iQ  提取码：07fx</code></p><ul><li>✅资源更新（2023-3-3）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1xaQZnQ3xNZuZpbiDwixsjg</span><br><span class="line">提取码: 8nr4</span><br></pre></td></tr></table></figure><p><code>链接: https://pan.baidu.com/s/1xaQZnQ3xNZuZpbiDwixsjg 提取码: 8nr4</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】4X4矩阵按键扫描组成的简易加法器</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4X4%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E7%BB%84%E6%88%90%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E6%B3%95%E5%99%A8/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4X4%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E7%BB%84%E6%88%90%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E6%B3%95%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】4X4矩阵按键扫描组成的简易加法器"><a href="#【Proteus仿真】4X4矩阵按键扫描组成的简易加法器" class="headerlink" title="【Proteus仿真】4X4矩阵按键扫描组成的简易加法器"></a>【Proteus仿真】4X4矩阵按键扫描组成的简易加法器</h1><h3 id="【Proteus仿真】4X4矩阵按键扫描组成的简易加法器-1"><a href="#【Proteus仿真】4X4矩阵按键扫描组成的简易加法器-1" class="headerlink" title="【Proteus仿真】4X4矩阵按键扫描组成的简易加法器"></a>【Proteus仿真】4X4矩阵按键扫描组成的简易加法器</h3><ul><li>相关篇《51单片机8x9矩阵键盘+数码管+74HC595+Proteus仿真》</li><li>《51单片机8x8矩阵键盘+数码管+74HC595+Proteus仿真》</li><li>《51单片机4x4矩阵键盘扫描+数码管显示(三)》</li><li>本实验基于Proteus VSM Studio仿真</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120009976">51单片机8x9矩阵键盘+数码管+74HC595+Proteus仿真</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120007533">51单片机8x8矩阵键盘+数码管+74HC595+Proteus仿真</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120002822">51单片机4x4矩阵键盘扫描+数码管显示(三)</a></p><p><img src="https://img-blog.csdnimg.cn/942f6c69c6e0438f9e4e110dfa73f8ad.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="VSM-Studio程序代码"><a href="#VSM-Studio程序代码" class="headerlink" title="VSM Studio程序代码"></a>VSM Studio程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *简易加法计算器</span><br><span class="line"> * Created:   周二 6月 14 2022</span><br><span class="line"> * Processor: AT89C52</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line"> </span><br><span class="line">sbit ADDR0 = P1^0;</span><br><span class="line">sbit ADDR1 = P1^1;</span><br><span class="line">sbit ADDR2 = P1^2;</span><br><span class="line">sbit ADDR3 = P1^3;</span><br><span class="line">sbit ENLED = P1^4;</span><br><span class="line">sbit KEY_IN_1 = P2^4;</span><br><span class="line">sbit KEY_IN_2 = P2^5;</span><br><span class="line">sbit KEY_IN_3 = P2^6;</span><br><span class="line">sbit KEY_IN_4 = P2^7;</span><br><span class="line">sbit KEY_OUT_1 = P2^3;</span><br><span class="line">sbit KEY_OUT_2 = P2^2;</span><br><span class="line">sbit KEY_OUT_3 = P2^1;</span><br><span class="line">sbit KEY_OUT_4 = P2^0;</span><br><span class="line">unsigned char code LedChar[] = &#123; //数码管显示字符转换表</span><br><span class="line">0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,</span><br><span class="line">0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E</span><br><span class="line">&#125;;</span><br><span class="line">unsigned char LedBuff[6]=&#123;0xff,0xff,0xff,0xff,0xff,0xff&#125;; //数码管显示缓冲区 </span><br><span class="line">unsigned char code KeyCodeMap[4][4] = &#123; //矩阵按键编号到标准键盘键码的映射表</span><br><span class="line">&#123; 0x31, 0x32, 0x33, 0x26 &#125;, //数字键 1、数字键 2、数字键 3、向上键</span><br><span class="line">&#123; 0x34, 0x35, 0x36, 0x25 &#125;, //数字键 4、数字键 5、数字键 6、向左键</span><br><span class="line">&#123; 0x37, 0x38, 0x39, 0x28 &#125;, //数字键 7、数字键 8、数字键 9、向下键</span><br><span class="line">&#123; 0x30, 0x1B, 0x0D, 0x27 &#125; //数字键 0、ESC 键、 回车键、 向右键</span><br><span class="line">&#125;;        </span><br><span class="line">unsigned char KeySta[4][4] = &#123; //全部矩阵按键的当前状态</span><br><span class="line">&#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">unsigned char THR0,TLR0;</span><br><span class="line">void KeyDriver();</span><br><span class="line">void ConfigTimer(unsigned long ms);</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">EA = 1;     //使能总中断</span><br><span class="line">ENLED = 0;</span><br><span class="line">ADDR3 = 1;</span><br><span class="line">ConfigTimer(1); //计算定时1ms，需要赋的初值，存在在 THR0,TLR0中</span><br><span class="line">TMOD = TMOD &amp; 0xF0;</span><br><span class="line">TMOD = TMOD | 0x01;//设置定时器模式1 ,不影响高四位</span><br><span class="line">TH0 = THR0; //定时器赋初值</span><br><span class="line">TL0 = TLR0;</span><br><span class="line">ET0= 1;//使能T0中断</span><br><span class="line">TR0 = 1;    //启动定时器T0</span><br><span class="line">LedBuff[0] = LedChar[0];   //数码管默认显示0</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">   KeyDriver();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ConfigTimer(unsigned long ms)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long temp;</span><br><span class="line">temp = 65536 - ms*11059200/1000/12;//ms最大定时71ms</span><br><span class="line">THR0 = (unsigned char)(temp&gt;&gt;8);    //取计数值高八位 ，计数值不会超过65535，最多占用16位。</span><br><span class="line">TLR0 = (char)temp; //取计数值低八位 </span><br><span class="line">&#125;</span><br><span class="line">void ShowNumber(unsigned long num)</span><br><span class="line">&#123;</span><br><span class="line"> signed char i;</span><br><span class="line"> unsigned char buf[6];   //将num六位数字按顺序放入buf数组中</span><br><span class="line"> for(i=0;i&lt;=5;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> buf[i]=num%10;</span><br><span class="line">num = num/10;</span><br><span class="line"> &#125;</span><br><span class="line"> for(i=5;i&gt;=1;i--) //从高位到低位依次扫描，直到某一位不为0</span><br><span class="line"> &#123;</span><br><span class="line"> if(buf[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">LedBuff[i]=0xff;     //如果高位为0，则关闭此对应数码管显示，否则跳出，保留buf[]中不为0的下角标在i中</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> for(;i&gt;=0;i--)</span><br><span class="line"> &#123;</span><br><span class="line"> LedBuff[i]=LedChar[buf[i]];    //将各位数字取出，转换成数码管显示字符放入公有数组变量LedBuff[6]中</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">void KeyAction(unsigned char keycode)</span><br><span class="line">&#123;</span><br><span class="line">static unsigned long result = 0;</span><br><span class="line">static unsigned long addend = 0;</span><br><span class="line">if((keycode&gt;=0x30)&amp;&amp;(keycode&lt;=0x39))    //输入的是数字</span><br><span class="line">&#123;</span><br><span class="line">addend = (addend*10)+(keycode-0x30); //将原有数字顶上去</span><br><span class="line">ShowNumber(addend);</span><br><span class="line">&#125;</span><br><span class="line">else if(keycode == 0x26)     //上键，执行加法操作</span><br><span class="line">&#123;</span><br><span class="line">result += addend; //将上一个数字addend存在result中，清空addend，等待下一次数字</span><br><span class="line">addend = 0;</span><br><span class="line">ShowNumber(result);</span><br><span class="line">&#125;</span><br><span class="line">else if(keycode == 0x0D)  //回车键，作用和上键等同</span><br><span class="line">&#123;</span><br><span class="line">result += addend; //将上一个数字addend存在result中，清空addend，等待下一次数字</span><br><span class="line">addend = 0;</span><br><span class="line">ShowNumber(result);</span><br><span class="line">&#125;</span><br><span class="line">else if(keycode == 0x1B)         //esc键，清零</span><br><span class="line">&#123;</span><br><span class="line">addend = 0;</span><br><span class="line">result = 0;</span><br><span class="line">ShowNumber(addend);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void KeyDriver()  </span><br><span class="line">&#123;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">static unsigned char backup[4][4]=&#123;    //一定定义成静态，否则bug</span><br><span class="line">&#123;1,1,1,1&#125;, &#123;1,1,1,1&#125;,&#123;1,1,1,1&#125;,&#123;1,1,1,1&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> for(i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(j=0;j&lt;4;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(KeySta[i][j]!=backup[i][j])  //当前按键状态和之前按键状态不一致，证明按键已经按下或者抬起</span><br><span class="line">&#123;</span><br><span class="line">if(KeySta[i][j]==0)          //如果当前按键状态为0，说明按键按下；在此我们只对按键按下动作响应</span><br><span class="line">&#123;</span><br><span class="line">KeyAction(KeyCodeMap[i][j]);  //将对应的按键转换成标准键盘码传入KeyAction中，根据传入的键盘码执行相应动作</span><br><span class="line">&#125;</span><br><span class="line">backup[i][j]=KeySta[i][j]; //保存当前按键状态</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void LedScan()</span><br><span class="line">&#123;</span><br><span class="line">static unsigned char i = 0;</span><br><span class="line">P0=0xff;</span><br><span class="line">switch(i)</span><br><span class="line">&#123;</span><br><span class="line">case 0: ADDR2=0;ADDR1=0;ADDR0=0;P0=LedBuff[i];i++;break;</span><br><span class="line">case 1: ADDR2=0;ADDR1=0;ADDR0=1;P0=LedBuff[i];i++;break;</span><br><span class="line">case 2: ADDR2=0;ADDR1=1;ADDR0=0;P0=LedBuff[i];i++;break;</span><br><span class="line">case 3: ADDR2=0;ADDR1=1;ADDR0=1;P0=LedBuff[i];i++;break;</span><br><span class="line">case 4: ADDR2=1;ADDR1=0;ADDR0=0;P0=LedBuff[i];i++;break;</span><br><span class="line">case 5: ADDR2=1;ADDR1=0;ADDR0=1;P0=LedBuff[i];i=0;break;</span><br><span class="line">default:break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void KeyScan()</span><br><span class="line">&#123;</span><br><span class="line">static unsigned char keyout = 0;</span><br><span class="line">unsigned char i;</span><br><span class="line">static unsigned char keybuf[4][4]=&#123;</span><br><span class="line">&#123;0xff,0xff,0xff,0xff&#125;,&#123;0xff,0xff,0xff,0xff&#125;,&#123;0xff,0xff,0xff,0xff&#125;,&#123;0xff,0xff,0xff,0xff&#125;</span><br><span class="line">&#125;;</span><br><span class="line">keybuf[keyout][0] = (keybuf[keyout][0]&lt;&lt;1)| KEY_IN_1;</span><br><span class="line">keybuf[keyout][1] = (keybuf[keyout][1]&lt;&lt;1)| KEY_IN_2;</span><br><span class="line">keybuf[keyout][2] = (keybuf[keyout][2]&lt;&lt;1)| KEY_IN_3;</span><br><span class="line">keybuf[keyout][3] = (keybuf[keyout][3]&lt;&lt;1)| KEY_IN_4;</span><br><span class="line">for(i=0;i&lt;=3;i++)</span><br><span class="line">&#123;</span><br><span class="line">if((keybuf[keyout][i]&amp;0x0f)==0x00)</span><br><span class="line">&#123;</span><br><span class="line">KeySta[keyout][i]=0;</span><br><span class="line">&#125;</span><br><span class="line">else if((keybuf[keyout][i]&amp;0x0f)==0x0f)</span><br><span class="line">&#123;</span><br><span class="line">KeySta[keyout][i]=1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">keyout++;</span><br><span class="line">if(keyout&gt;=4)</span><br><span class="line">&#123;keyout=0;&#125;</span><br><span class="line">switch(keyout) //扫描下一行</span><br><span class="line">&#123;</span><br><span class="line">case 0:KEY_OUT_4=1;KEY_OUT_1=0;break;</span><br><span class="line">case 1:KEY_OUT_1=1;KEY_OUT_2=0;break;</span><br><span class="line">case 2:KEY_OUT_2=1;KEY_OUT_3=0;break;</span><br><span class="line">case 3:KEY_OUT_3=1;KEY_OUT_4=0;break;</span><br><span class="line">default:break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void  InterruptTimer0() interrupt 1      </span><br><span class="line">&#123;</span><br><span class="line">   TH0=THR0;</span><br><span class="line">   TL0=TLR0;</span><br><span class="line">   LedScan();</span><br><span class="line">   KeyScan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *简易加法计算器</p><ul><li>Created:   周二 6月 14 2022</li><li>Processor: AT89C52</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;reg52.h&gt;</p><p>sbit ADDR0 &#x3D; P1^0;<br>sbit ADDR1 &#x3D; P1^1;<br>sbit ADDR2 &#x3D; P1^2;<br>sbit ADDR3 &#x3D; P1^3;<br>sbit ENLED &#x3D; P1^4;<br>sbit KEY_IN_1 &#x3D; P2^4;<br>sbit KEY_IN_2 &#x3D; P2^5;<br>sbit KEY_IN_3 &#x3D; P2^6;<br>sbit KEY_IN_4 &#x3D; P2^7;<br>sbit KEY_OUT_1 &#x3D; P2^3;<br>sbit KEY_OUT_2 &#x3D; P2^2;<br>sbit KEY_OUT_3 &#x3D; P2^1;<br>sbit KEY_OUT_4 &#x3D; P2^0;<br>unsigned char code LedChar[] &#x3D; { &#x2F;&#x2F;数码管显示字符转换表<br>0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,<br>0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E<br>};<br>unsigned char LedBuff[6]&#x3D;{0xff,0xff,0xff,0xff,0xff,0xff}; &#x2F;&#x2F;数码管显示缓冲区<br>unsigned char code KeyCodeMap[4][4] &#x3D; { &#x2F;&#x2F;矩阵按键编号到标准键盘键码的映射表<br>{ 0x31, 0x32, 0x33, 0x26 }, &#x2F;&#x2F;数字键 1、数字键 2、数字键 3、向上键<br>{ 0x34, 0x35, 0x36, 0x25 }, &#x2F;&#x2F;数字键 4、数字键 5、数字键 6、向左键<br>{ 0x37, 0x38, 0x39, 0x28 }, &#x2F;&#x2F;数字键 7、数字键 8、数字键 9、向下键<br>{ 0x30, 0x1B, 0x0D, 0x27 } &#x2F;&#x2F;数字键 0、ESC 键、 回车键、 向右键<br>};<br>unsigned char KeySta[4][4] &#x3D; { &#x2F;&#x2F;全部矩阵按键的当前状态<br>{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}<br>};</p><p>unsigned char THR0,TLR0;<br>void KeyDriver();<br>void ConfigTimer(unsigned long ms);<br>void main()<br>{<br>    EA &#x3D; 1;     &#x2F;&#x2F;使能总中断<br>    ENLED &#x3D; 0;<br>    ADDR3 &#x3D; 1;<br>    ConfigTimer(1); &#x2F;&#x2F;计算定时1ms，需要赋的初值，存在在 THR0,TLR0中<br>    TMOD &#x3D; TMOD &amp; 0xF0;<br>    TMOD &#x3D; TMOD | 0x01;&#x2F;&#x2F;设置定时器模式1 ,不影响高四位<br>    TH0 &#x3D; THR0; &#x2F;&#x2F;定时器赋初值<br>    TL0 &#x3D; TLR0;<br>    ET0&#x3D; 1;&#x2F;&#x2F;使能T0中断<br>    TR0 &#x3D; 1;    &#x2F;&#x2F;启动定时器T0<br>    LedBuff[0] &#x3D; LedChar[0];   &#x2F;&#x2F;数码管默认显示0<br>    while(1)<br>    {<br>       KeyDriver();<br>    }<br>}<br>void ConfigTimer(unsigned long ms)<br>{<br>    unsigned long temp;<br>    temp &#x3D; 65536 - ms<em>11059200&#x2F;1000&#x2F;12;&#x2F;&#x2F;ms最大定时71ms<br>    THR0 &#x3D; (unsigned char)(temp&gt;&gt;8);    &#x2F;&#x2F;取计数值高八位 ，计数值不会超过65535，最多占用16位。<br>    TLR0 &#x3D; (char)temp; &#x2F;&#x2F;取计数值低八位<br>}<br>void ShowNumber(unsigned long num)<br>{<br>     signed char i;<br>     unsigned char buf[6];   &#x2F;&#x2F;将num六位数字按顺序放入buf数组中<br>     for(i&#x3D;0;i&lt;&#x3D;5;i++)<br>     {<br>     buf[i]&#x3D;num%10;<br>        num &#x3D; num&#x2F;10;<br>     }<br>     for(i&#x3D;5;i&gt;&#x3D;1;i–) &#x2F;&#x2F;从高位到低位依次扫描，直到某一位不为0<br>     {<br>     if(buf[i]&#x3D;&#x3D;0)<br>        {<br>            LedBuff[i]&#x3D;0xff;     &#x2F;&#x2F;如果高位为0，则关闭此对应数码管显示，否则跳出，保留buf[]中不为0的下角标在i中<br>        }<br>        else<br>        {<br>            break;<br>        }<br>     }<br>     for(;i&gt;&#x3D;0;i–)<br>     {<br>     LedBuff[i]&#x3D;LedChar[buf[i]];    &#x2F;&#x2F;将各位数字取出，转换成数码管显示字符放入公有数组变量LedBuff[6]中<br>     }<br>}<br>void KeyAction(unsigned char keycode)<br>{<br>    static unsigned long result &#x3D; 0;<br>    static unsigned long addend &#x3D; 0;<br>    if((keycode&gt;&#x3D;0x30)&amp;&amp;(keycode&lt;&#x3D;0x39))    &#x2F;&#x2F;输入的是数字<br>    {<br>        addend &#x3D; (addend</em>10)+(keycode-0x30); &#x2F;&#x2F;将原有数字顶上去<br>        ShowNumber(addend);<br>    }<br>    else if(keycode &#x3D;&#x3D; 0x26)     &#x2F;&#x2F;上键，执行加法操作<br>    {<br>        result +&#x3D; addend; &#x2F;&#x2F;将上一个数字addend存在result中，清空addend，等待下一次数字<br>        addend &#x3D; 0;<br>        ShowNumber(result);<br>    }<br>    else if(keycode &#x3D;&#x3D; 0x0D)  &#x2F;&#x2F;回车键，作用和上键等同<br>    {<br>        result +&#x3D; addend; &#x2F;&#x2F;将上一个数字addend存在result中，清空addend，等待下一次数字<br>        addend &#x3D; 0;<br>        ShowNumber(result);<br>    }<br>    else if(keycode &#x3D;&#x3D; 0x1B)         &#x2F;&#x2F;esc键，清零<br>    {<br>        addend &#x3D; 0;<br>        result &#x3D; 0;<br>        ShowNumber(addend);<br>    }<br>}<br>void KeyDriver()<br>{<br>    unsigned char i,j;<br>    static unsigned char backup[4][4]&#x3D;{    &#x2F;&#x2F;一定定义成静态，否则bug<br>    {1,1,1,1}, {1,1,1,1},{1,1,1,1},{1,1,1,1}<br>    };<br>     for(i&#x3D;0;i&lt;4;i++)<br>    {<br>        for(j&#x3D;0;j&lt;4;j++)<br>        {<br>            if(KeySta[i][j]!&#x3D;backup[i][j])  &#x2F;&#x2F;当前按键状态和之前按键状态不一致，证明按键已经按下或者抬起<br>            {<br>                if(KeySta[i][j]&#x3D;&#x3D;0)          &#x2F;&#x2F;如果当前按键状态为0，说明按键按下；在此我们只对按键按下动作响应<br>                {<br>                    KeyAction(KeyCodeMap[i][j]);  &#x2F;&#x2F;将对应的按键转换成标准键盘码传入KeyAction中，根据传入的键盘码执行相应动作<br>                }<br>                backup[i][j]&#x3D;KeySta[i][j]; &#x2F;&#x2F;保存当前按键状态<br>            }<br>        }<br>    }<br>}</p><p>void LedScan()<br>{<br>    static unsigned char i &#x3D; 0;<br>    P0&#x3D;0xff;<br>    switch(i)<br>    {<br>        case 0: ADDR2&#x3D;0;ADDR1&#x3D;0;ADDR0&#x3D;0;P0&#x3D;LedBuff[i];i++;break;<br>        case 1: ADDR2&#x3D;0;ADDR1&#x3D;0;ADDR0&#x3D;1;P0&#x3D;LedBuff[i];i++;break;<br>        case 2: ADDR2&#x3D;0;ADDR1&#x3D;1;ADDR0&#x3D;0;P0&#x3D;LedBuff[i];i++;break;<br>        case 3: ADDR2&#x3D;0;ADDR1&#x3D;1;ADDR0&#x3D;1;P0&#x3D;LedBuff[i];i++;break;<br>        case 4: ADDR2&#x3D;1;ADDR1&#x3D;0;ADDR0&#x3D;0;P0&#x3D;LedBuff[i];i++;break;<br>        case 5: ADDR2&#x3D;1;ADDR1&#x3D;0;ADDR0&#x3D;1;P0&#x3D;LedBuff[i];i&#x3D;0;break;<br>        default:break;<br>    }<br>}<br>void KeyScan()<br>{<br>    static unsigned char keyout &#x3D; 0;<br>    unsigned char i;<br>    static unsigned char keybuf[4][4]&#x3D;{<br>    {0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff}<br>    };<br>    keybuf[keyout][0] &#x3D; (keybuf[keyout][0]&lt;&lt;1)| KEY_IN_1;<br>    keybuf[keyout][1] &#x3D; (keybuf[keyout][1]&lt;&lt;1)| KEY_IN_2;<br>    keybuf[keyout][2] &#x3D; (keybuf[keyout][2]&lt;&lt;1)| KEY_IN_3;<br>    keybuf[keyout][3] &#x3D; (keybuf[keyout][3]&lt;&lt;1)| KEY_IN_4;<br>    for(i&#x3D;0;i&lt;&#x3D;3;i++)<br>    {<br>        if((keybuf[keyout][i]&amp;0x0f)&#x3D;&#x3D;0x00)<br>        {<br>            KeySta[keyout][i]&#x3D;0;<br>        }<br>        else if((keybuf[keyout][i]&amp;0x0f)&#x3D;&#x3D;0x0f)<br>        {<br>            KeySta[keyout][i]&#x3D;1;<br>        }<br>        else<br>        {}<br>    }<br>    keyout++;<br>    if(keyout&gt;&#x3D;4)<br>    {keyout&#x3D;0;}<br>    switch(keyout) &#x2F;&#x2F;扫描下一行<br>    {<br>        case 0:KEY_OUT_4&#x3D;1;KEY_OUT_1&#x3D;0;break;<br>        case 1:KEY_OUT_1&#x3D;1;KEY_OUT_2&#x3D;0;break;<br>        case 2:KEY_OUT_2&#x3D;1;KEY_OUT_3&#x3D;0;break;<br>        case 3:KEY_OUT_3&#x3D;1;KEY_OUT_4&#x3D;0;break;<br>        default:break;<br>    }<br>}<br>void  InterruptTimer0() interrupt 1<br>{<br>   TH0&#x3D;THR0;<br>   TL0&#x3D;TLR0;<br>   LedScan();<br>   KeyScan();<br>}&#96;</p><ul><li>VSM Studio界面</li></ul><p><img src="https://img-blog.csdnimg.cn/b6ade35cf2c74f218db889de0922ce14.png" alt="在这里插入图片描述"></p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台，本项目另外包含Keil工程。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1o64EZGZlfyirrx1ib13mBQ </span><br><span class="line">提取码：0aho</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1o64EZGZlfyirrx1ib13mBQ  提取码：0aho</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】6位数码管秒计数器（0-999999S）</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F6%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E7%A7%92%E8%AE%A1%E6%95%B0%E5%99%A80999999S/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F6%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E7%A7%92%E8%AE%A1%E6%95%B0%E5%99%A80999999S/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】6位数码管秒计数器（0-999999S）"><a href="#【Proteus仿真】6位数码管秒计数器（0-999999S）" class="headerlink" title="【Proteus仿真】6位数码管秒计数器（0-999999S）"></a>【Proteus仿真】6位数码管秒计数器（0-999999S）</h1><h3 id="【Proteus仿真】6位数码管秒计数器（0-999999S）-1"><a href="#【Proteus仿真】6位数码管秒计数器（0-999999S）-1" class="headerlink" title="【Proteus仿真】6位数码管秒计数器（0-999999S）"></a>【Proteus仿真】6位数码管秒计数器（0-999999S）</h3><ul><li>🎬 Proteus VSM仿真演示</li><li>📺例程二演示：</li></ul><p><img src="https://img-blog.csdnimg.cn/7a4f7d4b645c452da26ac7138b434106.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/52573e61cb424bebb7f54ddf35a27a1e.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="📝例程一：VSM-Studio代码"><a href="#📝例程一：VSM-Studio代码" class="headerlink" title="📝例程一：VSM Studio代码"></a>📝例程一：VSM Studio代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *0-999999秒表</span><br><span class="line"> * Created:   周四 6月 14 2022</span><br><span class="line"> * Processor: AT89C52</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define FOSC 12000000uL</span><br><span class="line">//#define T50MS 15536  //50ms timer calculation method in 12T mode</span><br><span class="line">#define T50MS (65536-FOSC*50/12/1000)   //1ms*50 timer calculation method in 12T mode</span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^0;</span><br><span class="line">sbit ADDR1 = P1^1;</span><br><span class="line">sbit ADDR2 = P1^2;</span><br><span class="line">sbit ADDR3 = P1^3;</span><br><span class="line">sbit ENLED = P1^4;</span><br><span class="line">sbit led = P1^5; </span><br><span class="line">unsigned char code LedChar[] = &#123;  //数码管显示字符转换表</span><br><span class="line">    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,</span><br><span class="line">    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E</span><br><span class="line">&#125;;</span><br><span class="line">unsigned char LedBuff[6] = &#123; //数码管显示缓冲区，初值 0xFF 确保启动时都不亮</span><br><span class="line">    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF</span><br><span class="line">&#125;;</span><br><span class="line">    unsigned int cnt = 0; //记录 T0 中断次数</span><br><span class="line">    unsigned long sec = 0; //记录经过的秒数</span><br><span class="line">void tm0_isr() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TL0 = T50MS;                     //reload timer0 low byte</span><br><span class="line">    TH0 = T50MS &gt;&gt; 8;                //reload timer0 high byte</span><br><span class="line">    if (cnt-- == 0)               //1ms * 1000 -&gt; 1s</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = 20;               //reset counter</span><br><span class="line">sec++;  //秒计数自加 1</span><br><span class="line">        led = ! led;      //work LED flash          </span><br><span class="line">                //以下代码将 sec 按十进制位从低到高依次提取并转为数码管显示字符</span><br><span class="line">                LedBuff[0] = LedChar[sec/100000];</span><br><span class="line">                LedBuff[1] = LedChar[sec%100000/10000];</span><br><span class="line">                LedBuff[2] = LedChar[sec%100000%10000/1000];</span><br><span class="line">                LedBuff[3] = LedChar[sec%100000%10000%1000/100];</span><br><span class="line">                LedBuff[4] = LedChar[sec%100000%10000%1000%100/10];</span><br><span class="line">                LedBuff[5] = LedChar[sec%100000%10000%1000%100%10];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//延时函数</span><br><span class="line">void delay(int xms)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i,j;</span><br><span class="line">for(i=xms;i&gt;0;i--)</span><br><span class="line">for(j=110;j&gt;0;j--);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">    unsigned char i = 0;  //动态扫描的索引      </span><br><span class="line">    ENLED = 0;  //使能 U3，选择控制数码管</span><br><span class="line">    ADDR3 = 1; //因为需要动态改变 ADDR0-2 的值，所以不需要再初始化了</span><br><span class="line">   </span><br><span class="line">    TMOD = 0x01;  //设置 T0 为模式 1</span><br><span class="line">    TL0 = T50MS;                     //initial timer0 low byte</span><br><span class="line">    TH0 = T50MS &gt;&gt; 8; </span><br><span class="line">TR0 = 1;                        //timer0 start running</span><br><span class="line">    ET0 = 1;                        //enable timer0 interrupt</span><br><span class="line">    EA = 1;                         //open global interrupt switch</span><br><span class="line"></span><br><span class="line">    while (1)&#123;</span><br><span class="line">            //以下代码完成数码管动态扫描刷新</span><br><span class="line">            switch (i)&#123;</span><br><span class="line">                case 0: ENLED=1;ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; delay(5);ENLED=0;break;</span><br><span class="line">                case 1: ENLED=1;ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; delay(5);ENLED=0;break;</span><br><span class="line">                case 2: ENLED=1;ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; delay(5);ENLED=0;break;</span><br><span class="line">                case 3: ENLED=1;ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; delay(5);ENLED=0;break;</span><br><span class="line">                case 4: ENLED=1;ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; delay(5);ENLED=0;break;</span><br><span class="line">                case 5: ENLED=1;ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; delay(5);ENLED=0;break;</span><br><span class="line">                default: break;</span><br><span class="line">            &#125; </span><br><span class="line">P0=0xFF;//消隐</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *0-999999秒表</p><ul><li>Created:   周四 6月 14 2022</li><li>Processor: AT89C52</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;reg52.h&gt;<br>#define FOSC 12000000uL<br>&#x2F;&#x2F;#define T50MS 15536  &#x2F;&#x2F;50ms timer calculation method in 12T mode<br>#define T50MS (65536-FOSC<em>50&#x2F;12&#x2F;1000)   &#x2F;&#x2F;1ms</em>50 timer calculation method in 12T mode</p><p>sbit ADDR0 &#x3D; P1^0;<br>sbit ADDR1 &#x3D; P1^1;<br>sbit ADDR2 &#x3D; P1^2;<br>sbit ADDR3 &#x3D; P1^3;<br>sbit ENLED &#x3D; P1^4;<br>sbit led &#x3D; P1^5;<br>unsigned char code LedChar[] &#x3D; {  &#x2F;&#x2F;数码管显示字符转换表<br>    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,<br>    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E<br>};<br>unsigned char LedBuff[6] &#x3D; { &#x2F;&#x2F;数码管显示缓冲区，初值 0xFF 确保启动时都不亮<br>    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF<br>};<br>    unsigned int cnt &#x3D; 0; &#x2F;&#x2F;记录 T0 中断次数<br>    unsigned long sec &#x3D; 0; &#x2F;&#x2F;记录经过的秒数<br>void tm0_isr() interrupt 1<br>{<br>    TL0 &#x3D; T50MS;                     &#x2F;&#x2F;reload timer0 low byte<br>    TH0 &#x3D; T50MS &gt;&gt; 8;                &#x2F;&#x2F;reload timer0 high byte<br>    if (cnt– &#x3D;&#x3D; 0)               &#x2F;&#x2F;1ms * 1000 -&gt; 1s<br>    {<br>        cnt &#x3D; 20;               &#x2F;&#x2F;reset counter<br>        sec++;  &#x2F;&#x2F;秒计数自加 1<br>        led &#x3D; ! led;      &#x2F;&#x2F;work LED flash<br>                &#x2F;&#x2F;以下代码将 sec 按十进制位从低到高依次提取并转为数码管显示字符<br>                LedBuff[0] &#x3D; LedChar[sec&#x2F;100000];<br>                LedBuff[1] &#x3D; LedChar[sec%100000&#x2F;10000];<br>                LedBuff[2] &#x3D; LedChar[sec%100000%10000&#x2F;1000];<br>                LedBuff[3] &#x3D; LedChar[sec%100000%10000%1000&#x2F;100];<br>                LedBuff[4] &#x3D; LedChar[sec%100000%10000%1000%100&#x2F;10];<br>                LedBuff[5] &#x3D; LedChar[sec%100000%10000%1000%100%10];<br>    }<br>}<br>&#x2F;&#x2F;延时函数<br>void delay(int xms)<br>{<br>    unsigned int i,j;<br>    for(i&#x3D;xms;i&gt;0;i–)<br>        for(j&#x3D;110;j&gt;0;j–);<br>}<br>void main(){<br>    unsigned char i &#x3D; 0;  &#x2F;&#x2F;动态扫描的索引<br>    ENLED &#x3D; 0;  &#x2F;&#x2F;使能 U3，选择控制数码管<br>    ADDR3 &#x3D; 1; &#x2F;&#x2F;因为需要动态改变 ADDR0-2 的值，所以不需要再初始化了</p><pre><code>TMOD = 0x01;  //设置 T0 为模式 1TL0 = T50MS;                     //initial timer0 low byteTH0 = T50MS &gt;&gt; 8; TR0 = 1;                        //timer0 start runningET0 = 1;                        //enable timer0 interruptEA = 1;                         //open global interrupt switchwhile (1)&#123;        //以下代码完成数码管动态扫描刷新        switch (i)&#123;            case 0: ENLED=1;ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; delay(5);ENLED=0;break;            case 1: ENLED=1;ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; delay(5);ENLED=0;break;            case 2: ENLED=1;ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; delay(5);ENLED=0;break;            case 3: ENLED=1;ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; delay(5);ENLED=0;break;            case 4: ENLED=1;ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; delay(5);ENLED=0;break;            case 5: ENLED=1;ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; delay(5);ENLED=0;break;            default: break;        &#125;         P0=0xFF;//消隐</code></pre><p>}<br>}&#96;</p><h4 id="📚例程一仿真资源"><a href="#📚例程一仿真资源" class="headerlink" title="📚例程一仿真资源"></a>📚例程一仿真资源</h4><ul><li>🔖 本示例基于Proteus8.12平台，保留Keil工程。</li></ul><p><code>Proteus8.12</code></p><p><img src="https://img-blog.csdnimg.cn/d0a6d5a5b6b9417fb6cee789ee5eba92.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1zx1Y9I5MAs6erV6hgEQ4TQ </span><br><span class="line">提取码：gbij</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1zx1Y9I5MAs6erV6hgEQ4TQ  提取码：gbij</code></p><h4 id="📓例程二"><a href="#📓例程二" class="headerlink" title="📓例程二"></a>📓例程二</h4><ul><li>📋将数码管的一个位用于毫秒计数显示。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line"></span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">uchar Count;</span><br><span class="line">sbit Dot = P0^7;</span><br><span class="line">uchar code DSY_CODE[]=</span><br><span class="line">&#123;</span><br><span class="line"> 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f</span><br><span class="line">&#125;;//共阴数码管断码：0 - 9</span><br><span class="line"></span><br><span class="line">uchar Digits_of_6DSY[]=&#123;0,0,0,0,0,0&#125;;//位选显示</span><br><span class="line"></span><br><span class="line">void Delayms(uint x)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">while(--x)</span><br><span class="line">&#123;</span><br><span class="line"> for(i=0;i&lt;120;i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> uchar i,j;</span><br><span class="line">P0 = 0x00;</span><br><span class="line">P3 = 0xff;</span><br><span class="line">Count =0;</span><br><span class="line">TMOD = 0x01;</span><br><span class="line">TH0  = (65535-50000)/256;</span><br><span class="line">TL0  = (65535-50000)%256;</span><br><span class="line">IE = 0x82;</span><br><span class="line">TR0 = 1;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> j = 0x7f;</span><br><span class="line">for(i=5;i!=-1;i--)</span><br><span class="line">&#123;</span><br><span class="line"> j=_crol_(j,1);</span><br><span class="line">P3 = j;</span><br><span class="line">P0 = DSY_CODE[Digits_of_6DSY[i]];</span><br><span class="line">if(i==1) P0 |= 0x80;</span><br><span class="line">Delayms(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Time0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">TH0  = (65535-50000)/256;</span><br><span class="line">TL0  = (65535-50000)%256;</span><br><span class="line">if(++Count !=2) return;</span><br><span class="line">Count = 0;</span><br><span class="line">Digits_of_6DSY[0]++;</span><br><span class="line">for(i=0;i&lt;=5;i++)</span><br><span class="line">&#123;</span><br><span class="line"> if(Digits_of_6DSY[i] == 10)</span><br><span class="line">&#123;</span><br><span class="line"> Digits_of_6DSY[i] = 0;</span><br><span class="line">if(i != 5) Digits_of_6DSY[i+1]++;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;</p><p>#define uchar unsigned char<br>#define uint unsigned int<br>uchar Count;<br>sbit Dot &#x3D; P0^7;<br>uchar code DSY_CODE[]&#x3D;<br>{<br>     0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f<br>};&#x2F;&#x2F;共阴数码管断码：0 - 9</p><p>uchar Digits_of_6DSY[]&#x3D;{0,0,0,0,0,0};&#x2F;&#x2F;位选显示</p><p>void Delayms(uint x)<br>{<br>     uchar i;<br>    while(–x)<br>    {<br>     for(i&#x3D;0;i&lt;120;i++);<br>    }<br>}</p><p>void main()<br>{<br>     uchar i,j;<br>    P0 &#x3D; 0x00;<br>    P3 &#x3D; 0xff;<br>    Count &#x3D;0;<br>    TMOD &#x3D; 0x01;<br>    TH0  &#x3D; (65535-50000)&#x2F;256;<br>    TL0  &#x3D; (65535-50000)%256;<br>    IE &#x3D; 0x82;<br>    TR0 &#x3D; 1;<br>    while(1)<br>    {<br>     j &#x3D; 0x7f;<br>        for(i&#x3D;5;i!&#x3D;-1;i–)<br>        {<br>         j&#x3D;<em>crol</em>(j,1);<br>            P3 &#x3D; j;<br>            P0 &#x3D; DSY_CODE[Digits_of_6DSY[i]];<br>            if(i&#x3D;&#x3D;1) P0 |&#x3D; 0x80;<br>            Delayms(2);<br>        }<br>    }<br>}</p><p>void Time0() interrupt 1<br>{<br>     uchar i;<br>    TH0  &#x3D; (65535-50000)&#x2F;256;<br>    TL0  &#x3D; (65535-50000)%256;<br>    if(++Count !&#x3D;2) return;<br>    Count &#x3D; 0;<br>    Digits_of_6DSY[0]++;<br>    for(i&#x3D;0;i&lt;&#x3D;5;i++)<br>    {<br>     if(Digits_of_6DSY[i] &#x3D;&#x3D; 10)<br>        {<br>         Digits_of_6DSY[i] &#x3D; 0;<br>            if(i !&#x3D; 5) Digits_of_6DSY[i+1]++;<br>        }<br>        else break;<br>    }<br>}&#96;</p><h4 id="🍁例程二资源文件"><a href="#🍁例程二资源文件" class="headerlink" title="🍁例程二资源文件"></a>🍁例程二资源文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1bn7GZ5WHI84OFwny6RPSIg </span><br><span class="line">提取码：ebaf</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1bn7GZ5WHI84OFwny6RPSIg  提取码：ebaf</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】4X4矩阵按键显示0-F</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4X4%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E6%98%BE%E7%A4%BA0F/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4X4%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E6%98%BE%E7%A4%BA0F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】4X4矩阵按键显示0-F"><a href="#【Proteus仿真】4X4矩阵按键显示0-F" class="headerlink" title="【Proteus仿真】4X4矩阵按键显示0-F"></a>【Proteus仿真】4X4矩阵按键显示0-F</h1><h3 id="【Proteus仿真】4X4矩阵按键显示0-F-1"><a href="#【Proteus仿真】4X4矩阵按键显示0-F-1" class="headerlink" title="【Proteus仿真】4X4矩阵按键显示0-F"></a>【Proteus仿真】4X4矩阵按键显示0-F</h3><ul><li>本实验基于Proteus VSM Studio仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/0f21322ffbd2419e91106a8d0757b483.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="VSM-Studio程序代码"><a href="#VSM-Studio程序代码" class="headerlink" title="VSM Studio程序代码"></a>VSM Studio程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> * 4X4矩阵按键显示0-F</span><br><span class="line"> * Created:   周三 6月 15 2022</span><br><span class="line"> * Processor: AT89C52</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">sbit ADDR0 = P1^0;</span><br><span class="line">sbit ADDR1 = P1^1;</span><br><span class="line">sbit ADDR2 = P1^2;</span><br><span class="line">sbit ADDR3 = P1^3;</span><br><span class="line">sbit ENLED = P1^4;</span><br><span class="line">sbit KEY_IN_1 = P2^4;</span><br><span class="line">sbit KEY_IN_2 = P2^5;</span><br><span class="line">sbit KEY_IN_3 = P2^6;</span><br><span class="line">sbit KEY_IN_4 = P2^7;</span><br><span class="line">sbit KEY_OUT_1 = P2^3;</span><br><span class="line">sbit KEY_OUT_2 = P2^2;</span><br><span class="line">sbit KEY_OUT_3 = P2^1;</span><br><span class="line">sbit KEY_OUT_4 = P2^0;</span><br><span class="line">unsigned char code LedChar[] = &#123; //数码管显示字符转换表</span><br><span class="line"> 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,</span><br><span class="line"> 0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E</span><br><span class="line">&#125;;</span><br><span class="line">unsigned char KeySta[4][4] = &#123; //全部矩阵按键的当前状态</span><br><span class="line"> &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char i, j;</span><br><span class="line"> unsigned char backup[4][4] = &#123; //按键值备份，保存前一次的值</span><br><span class="line"> &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1, 1, 1&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">EA = 1; //使能总中断</span><br><span class="line"> ENLED = 0; //选择数码管 DS1 进行显示</span><br><span class="line"> ADDR3 = 1;</span><br><span class="line"> ADDR2 = 0;</span><br><span class="line"> ADDR1 = 0;</span><br><span class="line"> ADDR0 = 0;</span><br><span class="line"> TMOD = 0x01; //设置 T0 为模式 1</span><br><span class="line"> TH0 = 0xFC; //为 T0 赋初值 0xFC67，定时 1ms</span><br><span class="line"> TL0 = 0x67;</span><br><span class="line"> ET0 = 1; //使能 T0 中断</span><br><span class="line"> TR0 = 1; //启动 T0</span><br><span class="line"> P0 = LedChar[0]; //默认显示 0</span><br><span class="line"> while (1)</span><br><span class="line"> &#123;</span><br><span class="line"> for (i=0; i&lt;4; i++) //循环检测 4*4 的矩阵按键</span><br><span class="line"> &#123;</span><br><span class="line"> for (j=0; j&lt;4; j++)</span><br><span class="line"> &#123;</span><br><span class="line"> if (backup[i][j] != KeySta[i][j]) //检测按键动作</span><br><span class="line"> &#123;</span><br><span class="line"> if (backup[i][j] != 0) //按键按下时执行动作</span><br><span class="line"> &#123;</span><br><span class="line"> P0 = LedChar[i*4+j]; //将编号显示到数码管</span><br><span class="line"> &#125;</span><br><span class="line"> backup[i][j] = KeySta[i][j]; //更新前一次的备份值</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* T0 中断服务函数，扫描矩阵按键状态并消抖 */</span><br><span class="line">void InterruptTimer0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char i;</span><br><span class="line"> static unsigned char keyout = 0; //矩阵按键扫描输出索引</span><br><span class="line"> static unsigned char keybuf[4][4] = &#123; //矩阵按键扫描缓冲区</span><br><span class="line"> &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;, &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,</span><br><span class="line"> &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;, &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> TH0 = 0xFC; //重新加载初值</span><br><span class="line"> TL0 = 0x67;</span><br><span class="line">//将一行的 4 个按键值移入缓冲区</span><br><span class="line"> keybuf[keyout][0] = (keybuf[keyout][0] &lt;&lt; 1) | KEY_IN_1;</span><br><span class="line"> keybuf[keyout][1] = (keybuf[keyout][1] &lt;&lt; 1) | KEY_IN_2;</span><br><span class="line"> keybuf[keyout][2] = (keybuf[keyout][2] &lt;&lt; 1) | KEY_IN_3;</span><br><span class="line"> keybuf[keyout][3] = (keybuf[keyout][3] &lt;&lt; 1) | KEY_IN_4;</span><br><span class="line"> //消抖后更新按键状态</span><br><span class="line"> for (i=0; i&lt;4; i++) //每行 4 个按键，所以循环 4 次</span><br><span class="line"> &#123;</span><br><span class="line"> if ((keybuf[keyout][i] &amp; 0x0F) == 0x00)</span><br><span class="line"> &#123; //连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span><br><span class="line"> KeySta[keyout][i] = 0;</span><br><span class="line"> &#125;</span><br><span class="line"> else if ((keybuf[keyout][i] &amp; 0x0F) == 0x0F)</span><br><span class="line"> &#123; //连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span><br><span class="line"> KeySta[keyout][i] = 1;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //执行下一次的扫描输出</span><br><span class="line"> keyout++; //输出索引递增</span><br><span class="line"> keyout = keyout &amp; 0x03; //索引值加到 4 即归零</span><br><span class="line"> switch (keyout) //根据索引，释放当前输出引脚，拉低下次的输出引脚</span><br><span class="line"> &#123;</span><br><span class="line"> case 0: KEY_OUT_4 = 1; KEY_OUT_1 = 0; break;</span><br><span class="line"> case 1: KEY_OUT_1 = 1; KEY_OUT_2 = 0; break;</span><br><span class="line"> case 2: KEY_OUT_2 = 1; KEY_OUT_3 = 0; break;</span><br><span class="line"> case 3: KEY_OUT_3 = 1; KEY_OUT_4 = 0; break;</span><br><span class="line"> default: break;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard</p><ul><li>4X4矩阵按键显示0-F</li><li>Created:   周三 6月 15 2022</li><li>Processor: AT89C52</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;reg52.h&gt;<br>sbit ADDR0 &#x3D; P1^0;<br>sbit ADDR1 &#x3D; P1^1;<br>sbit ADDR2 &#x3D; P1^2;<br>sbit ADDR3 &#x3D; P1^3;<br>sbit ENLED &#x3D; P1^4;<br>sbit KEY_IN_1 &#x3D; P2^4;<br>sbit KEY_IN_2 &#x3D; P2^5;<br>sbit KEY_IN_3 &#x3D; P2^6;<br>sbit KEY_IN_4 &#x3D; P2^7;<br>sbit KEY_OUT_1 &#x3D; P2^3;<br>sbit KEY_OUT_2 &#x3D; P2^2;<br>sbit KEY_OUT_3 &#x3D; P2^1;<br>sbit KEY_OUT_4 &#x3D; P2^0;<br>unsigned char code LedChar[] &#x3D; { &#x2F;&#x2F;数码管显示字符转换表<br> 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,<br> 0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E<br>};<br>unsigned char KeySta[4][4] &#x3D; { &#x2F;&#x2F;全部矩阵按键的当前状态<br> {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}<br>};<br>void main()<br>{<br> unsigned char i, j;<br> unsigned char backup[4][4] &#x3D; { &#x2F;&#x2F;按键值备份，保存前一次的值<br> {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}<br> };<br>EA &#x3D; 1; &#x2F;&#x2F;使能总中断<br> ENLED &#x3D; 0; &#x2F;&#x2F;选择数码管 DS1 进行显示<br> ADDR3 &#x3D; 1;<br> ADDR2 &#x3D; 0;<br> ADDR1 &#x3D; 0;<br> ADDR0 &#x3D; 0;<br> TMOD &#x3D; 0x01; &#x2F;&#x2F;设置 T0 为模式 1<br> TH0 &#x3D; 0xFC; &#x2F;&#x2F;为 T0 赋初值 0xFC67，定时 1ms<br> TL0 &#x3D; 0x67;<br> ET0 &#x3D; 1; &#x2F;&#x2F;使能 T0 中断<br> TR0 &#x3D; 1; &#x2F;&#x2F;启动 T0<br> P0 &#x3D; LedChar[0]; &#x2F;&#x2F;默认显示 0<br> while (1)<br> {<br> for (i&#x3D;0; i&lt;4; i++) &#x2F;&#x2F;循环检测 4<em>4 的矩阵按键<br> {<br> for (j&#x3D;0; j&lt;4; j++)<br> {<br> if (backup[i][j] !&#x3D; KeySta[i][j]) &#x2F;&#x2F;检测按键动作<br> {<br> if (backup[i][j] !&#x3D; 0) &#x2F;&#x2F;按键按下时执行动作<br> {<br> P0 &#x3D; LedChar[i</em>4+j]; &#x2F;&#x2F;将编号显示到数码管<br> }<br> backup[i][j] &#x3D; KeySta[i][j]; &#x2F;&#x2F;更新前一次的备份值<br> }<br> }<br> }<br> }<br>}<br>&#x2F;* T0 中断服务函数，扫描矩阵按键状态并消抖 *&#x2F;<br>void InterruptTimer0() interrupt 1<br>{<br> unsigned char i;<br> static unsigned char keyout &#x3D; 0; &#x2F;&#x2F;矩阵按键扫描输出索引<br> static unsigned char keybuf[4][4] &#x3D; { &#x2F;&#x2F;矩阵按键扫描缓冲区<br> {0xFF, 0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF},<br> {0xFF, 0xFF, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF}<br> };</p><p> TH0 &#x3D; 0xFC; &#x2F;&#x2F;重新加载初值<br> TL0 &#x3D; 0x67;<br>&#x2F;&#x2F;将一行的 4 个按键值移入缓冲区<br> keybuf[keyout][0] &#x3D; (keybuf[keyout][0] &lt;&lt; 1) | KEY_IN_1;<br> keybuf[keyout][1] &#x3D; (keybuf[keyout][1] &lt;&lt; 1) | KEY_IN_2;<br> keybuf[keyout][2] &#x3D; (keybuf[keyout][2] &lt;&lt; 1) | KEY_IN_3;<br> keybuf[keyout][3] &#x3D; (keybuf[keyout][3] &lt;&lt; 1) | KEY_IN_4;<br> &#x2F;&#x2F;消抖后更新按键状态<br> for (i&#x3D;0; i&lt;4; i++) &#x2F;&#x2F;每行 4 个按键，所以循环 4 次<br> {<br> if ((keybuf[keyout][i] &amp; 0x0F) &#x3D;&#x3D; 0x00)<br> { &#x2F;&#x2F;连续 4 次扫描值为 0，即 4<em>4ms 内都是按下状态时，可认为按键已稳定的按下<br> KeySta[keyout][i] &#x3D; 0;<br> }<br> else if ((keybuf[keyout][i] &amp; 0x0F) &#x3D;&#x3D; 0x0F)<br> { &#x2F;&#x2F;连续 4 次扫描值为 1，即 4</em>4ms 内都是弹起状态时，可认为按键已稳定的弹起<br> KeySta[keyout][i] &#x3D; 1;<br> }<br> }<br> &#x2F;&#x2F;执行下一次的扫描输出<br> keyout++; &#x2F;&#x2F;输出索引递增<br> keyout &#x3D; keyout &amp; 0x03; &#x2F;&#x2F;索引值加到 4 即归零<br> switch (keyout) &#x2F;&#x2F;根据索引，释放当前输出引脚，拉低下次的输出引脚<br> {<br> case 0: KEY_OUT_4 &#x3D; 1; KEY_OUT_1 &#x3D; 0; break;<br> case 1: KEY_OUT_1 &#x3D; 1; KEY_OUT_2 &#x3D; 0; break;<br> case 2: KEY_OUT_2 &#x3D; 1; KEY_OUT_3 &#x3D; 0; break;<br> case 3: KEY_OUT_3 &#x3D; 1; KEY_OUT_4 &#x3D; 0; break;<br> default: break;<br> }<br>}&#96;</p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1CW9FqVMqbrAo9GMZVIsIbQ </span><br><span class="line">提取码：9d3i</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1CW9FqVMqbrAo9GMZVIsIbQ  提取码：9d3i</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】6位数码管计时器(0-10^5)</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F6%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E8%AE%A1%E6%97%B6%E5%99%A80105/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F6%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E8%AE%A1%E6%97%B6%E5%99%A80105/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】6位数码管计时器-0-10-5"><a href="#【Proteus仿真】6位数码管计时器-0-10-5" class="headerlink" title="【Proteus仿真】6位数码管计时器(0-10^5)"></a>【Proteus仿真】6位数码管计时器(0-10^5)</h1><h3 id="【Proteus仿真】6位数码管计时器-0-105"><a href="#【Proteus仿真】6位数码管计时器-0-105" class="headerlink" title="【Proteus仿真】6位数码管计时器(0-105)"></a>【Proteus仿真】6位数码管计时器(0-105)</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/7c805e45d5d54488b8c40d46194cd699.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="仿真难点，如何控制数字显示时不闪屏问题"><a href="#仿真难点，如何控制数字显示时不闪屏问题" class="headerlink" title="仿真难点，如何控制数字显示时不闪屏问题"></a>仿真难点，如何控制数字显示时不闪屏问题</h4><h5 id="数码管第一位显示的是100毫秒递增-1的模式，2-6位是每秒计数，"><a href="#数码管第一位显示的是100毫秒递增-1的模式，2-6位是每秒计数，" class="headerlink" title="数码管第一位显示的是100毫秒递增+1的模式，2-6位是每秒计数，"></a>数码管第一位显示的是100毫秒递增+1的模式，2-6位是每秒计数，</h5><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/*6位数码管计时器*/</span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">uchar Count;</span><br><span class="line">sbit Dot = P0^7;</span><br><span class="line"></span><br><span class="line">uchar code DSY_CODE[]=</span><br><span class="line">&#123;</span><br><span class="line"> 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar Digits_of_6DSY[]=&#123;0,0,0,0,0,0&#125;;</span><br><span class="line"></span><br><span class="line">void DelayMS(uint x)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">while(--x)</span><br><span class="line">&#123;</span><br><span class="line"> for(i=0;i&lt;120;i++);//120</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> uchar i,j;</span><br><span class="line">P0 = 0x00;</span><br><span class="line">P2 = 0xff;</span><br><span class="line">Count =0;</span><br><span class="line">TMOD = 0x01;</span><br><span class="line">TH0  = (65535-50000)/256;</span><br><span class="line">TL0  = (65535-50000)%256;</span><br><span class="line">IE = 0x82;</span><br><span class="line">TR0 = 1;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> j = 0x7f;</span><br><span class="line">for(i=6;i&gt;0;i--)</span><br><span class="line">&#123;</span><br><span class="line">P0 =0x00;//消隐</span><br><span class="line">P2 =0xff;</span><br><span class="line"> j=_crol_(j,1);</span><br><span class="line">P2 = j;</span><br><span class="line">P0 = DSY_CODE[Digits_of_6DSY[i-1]];</span><br><span class="line">if(i==2)&#123;</span><br><span class="line">P0 |= 0x80; //加小数点</span><br><span class="line">&#125;</span><br><span class="line">DelayMS(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Time0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">TH0  = (65535-50000)/256;//50ms定时初值</span><br><span class="line">TL0  = (65535-50000)%256;</span><br><span class="line">if(++Count !=2) return;</span><br><span class="line">Count = 0;</span><br><span class="line">Digits_of_6DSY[0]++;//0.1s位累加</span><br><span class="line">for(i=0;i&lt;=5;i++)//进位处理</span><br><span class="line">&#123;</span><br><span class="line"> if(Digits_of_6DSY[i] == 10)</span><br><span class="line">&#123;</span><br><span class="line"> Digits_of_6DSY[i] = 0;</span><br><span class="line">if(i &lt; 5) Digits_of_6DSY[i+1]++; //如果0~4位则分别向高一位进位 </span><br><span class="line">&#125;</span><br><span class="line">else break;//若某低位没有进位，则循环提前结束 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>6位数码管计时器</em>&#x2F;<br>#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>uchar Count;<br>sbit Dot &#x3D; P0^7;</p><p>uchar code DSY_CODE[]&#x3D;<br>{<br>     0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f<br>};</p><p>uchar Digits_of_6DSY[]&#x3D;{0,0,0,0,0,0};</p><p>void DelayMS(uint x)<br>{<br>     uchar i;<br>    while(–x)<br>    {<br>     for(i&#x3D;0;i&lt;120;i++);&#x2F;&#x2F;120<br>    }<br>}</p><p>void main()<br>{<br>     uchar i,j;<br>    P0 &#x3D; 0x00;<br>    P2 &#x3D; 0xff;<br>    Count &#x3D;0;<br>    TMOD &#x3D; 0x01;<br>    TH0  &#x3D; (65535-50000)&#x2F;256;<br>    TL0  &#x3D; (65535-50000)%256;<br>    IE &#x3D; 0x82;<br>    TR0 &#x3D; 1;<br>    while(1)<br>    {<br>     j &#x3D; 0x7f;<br>        for(i&#x3D;6;i&gt;0;i–)<br>        {<br>                        P0 &#x3D;0x00;&#x2F;&#x2F;消隐<br>                        P2 &#x3D;0xff;<br>         j&#x3D;<em>crol</em>(j,1);<br>            P2 &#x3D; j;<br>            P0 &#x3D; DSY_CODE[Digits_of_6DSY[i-1]];<br>            if(i&#x3D;&#x3D;2){<br>            P0 |&#x3D; 0x80; &#x2F;&#x2F;加小数点<br>            }<br>                    DelayMS(2);<br>        }<br>    }<br>}</p><p>void Time0() interrupt 1<br>{<br>     uchar i;<br>    TH0  &#x3D; (65535-50000)&#x2F;256;&#x2F;&#x2F;50ms定时初值<br>    TL0  &#x3D; (65535-50000)%256;<br>    if(++Count !&#x3D;2) return;<br>    Count &#x3D; 0;<br>    Digits_of_6DSY[0]++;&#x2F;&#x2F;0.1s位累加<br>    for(i&#x3D;0;i&lt;&#x3D;5;i++)&#x2F;&#x2F;进位处理<br>    {<br>     if(Digits_of_6DSY[i] &#x3D;&#x3D; 10)<br>        {<br>         Digits_of_6DSY[i] &#x3D; 0;<br>            if(i &lt; 5) Digits_of_6DSY[i+1]++; &#x2F;&#x2F;如果0~4位则分别向高一位进位<br>        }<br>        else break;&#x2F;&#x2F;若某低位没有进位，则循环提前结束<br>    }<br>}&#96;</p><h4 id="有问题的程序代码"><a href="#有问题的程序代码" class="headerlink" title="有问题的程序代码"></a>有问题的程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*6位数码管计时器*/</span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">uchar Count;</span><br><span class="line">sbit Dot = P0^7;</span><br><span class="line">uchar code DSY_CODE[]=</span><br><span class="line">&#123;</span><br><span class="line"> 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar Digits_of_6DSY[]=&#123;0,0,0,0,0,0&#125;;</span><br><span class="line"></span><br><span class="line">void DelayMS(uint x)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">while(--x)</span><br><span class="line">&#123;</span><br><span class="line"> for(i=0;i&lt;120;i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> uchar i,j;</span><br><span class="line">P0 = 0x00;</span><br><span class="line">P3 = 0xff;</span><br><span class="line">Count =0;</span><br><span class="line">TMOD = 0x01;</span><br><span class="line">TH0  = (65535-50000)/256;</span><br><span class="line">TL0  = (65535-50000)%256;</span><br><span class="line">IE = 0x82;</span><br><span class="line">TR0 = 1;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> j = 0x7f;</span><br><span class="line"> //前面高位，后面低位，循环中 i!=-1 亦可写成 i!=0xff</span><br><span class="line">for(i=5;i!=-1;i--)</span><br><span class="line">&#123;</span><br><span class="line"> j=_crol_(j,1);</span><br><span class="line">P3 = j;</span><br><span class="line">P0 = DSY_CODE[Digits_of_6DSY[i]];</span><br><span class="line">if(i==1) P0 |= 0x80;</span><br><span class="line">DelayMS(2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Time0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">TH0  = (65535-50000)/256;</span><br><span class="line">TL0  = (65535-50000)%256;</span><br><span class="line">if(++Count !=2) return;</span><br><span class="line">Count = 0;</span><br><span class="line">Digits_of_6DSY[0]++;</span><br><span class="line">for(i=0;i&lt;=5;i++)</span><br><span class="line">&#123;</span><br><span class="line"> if(Digits_of_6DSY[i] == 10)</span><br><span class="line">&#123;</span><br><span class="line"> Digits_of_6DSY[i] = 0;</span><br><span class="line">if(i != 5) Digits_of_6DSY[i+1]++;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>6位数码管计时器</em>&#x2F;<br>#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>uchar Count;<br>sbit Dot &#x3D; P0^7;<br>uchar code DSY_CODE[]&#x3D;<br>{<br>     0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f<br>};</p><p>uchar Digits_of_6DSY[]&#x3D;{0,0,0,0,0,0};</p><p>void DelayMS(uint x)<br>{<br>     uchar i;<br>    while(–x)<br>    {<br>     for(i&#x3D;0;i&lt;120;i++);<br>    }<br>}</p><p>void main()<br>{<br>     uchar i,j;<br>    P0 &#x3D; 0x00;<br>    P3 &#x3D; 0xff;<br>    Count &#x3D;0;<br>    TMOD &#x3D; 0x01;<br>    TH0  &#x3D; (65535-50000)&#x2F;256;<br>    TL0  &#x3D; (65535-50000)%256;<br>    IE &#x3D; 0x82;<br>    TR0 &#x3D; 1;<br>    while(1)<br>    {<br>     j &#x3D; 0x7f;<br>     &#x2F;&#x2F;前面高位，后面低位，循环中 i!&#x3D;-1 亦可写成 i!&#x3D;0xff<br>        for(i&#x3D;5;i!&#x3D;-1;i–)<br>        {<br>         j&#x3D;<em>crol</em>(j,1);<br>            P3 &#x3D; j;<br>            P0 &#x3D; DSY_CODE[Digits_of_6DSY[i]];<br>            if(i&#x3D;&#x3D;1) P0 |&#x3D; 0x80;<br>            DelayMS(2);<br>        }<br>    }<br>}</p><p>void Time0() interrupt 1<br>{<br>     uchar i;<br>    TH0  &#x3D; (65535-50000)&#x2F;256;<br>    TL0  &#x3D; (65535-50000)%256;<br>    if(++Count !&#x3D;2) return;<br>    Count &#x3D; 0;<br>    Digits_of_6DSY[0]++;<br>    for(i&#x3D;0;i&lt;&#x3D;5;i++)<br>    {<br>     if(Digits_of_6DSY[i] &#x3D;&#x3D; 10)<br>        {<br>         Digits_of_6DSY[i] &#x3D; 0;<br>            if(i !&#x3D; 5) Digits_of_6DSY[i+1]++;<br>        }<br>        else break;<br>    }<br>}&#96;</p><h4 id="问题点总结和分析"><a href="#问题点总结和分析" class="headerlink" title="问题点总结和分析"></a>问题点总结和分析</h4><h5 id="问题代码的运行出现闪屏，原因：代码中有些语句可能在Keil以往低版本编译的Hex文件仿真时运行可能没有问题，在Keil5-37版本编译后，就出现闪屏。"><a href="#问题代码的运行出现闪屏，原因：代码中有些语句可能在Keil以往低版本编译的Hex文件仿真时运行可能没有问题，在Keil5-37版本编译后，就出现闪屏。" class="headerlink" title="问题代码的运行出现闪屏，原因：代码中有些语句可能在Keil以往低版本编译的Hex文件仿真时运行可能没有问题，在Keil5.37版本编译后，就出现闪屏。"></a>问题代码的运行出现闪屏，原因：代码中有些语句可能在Keil以往低版本编译的Hex文件仿真时运行可能没有问题，在Keil5.37版本编译后，就出现闪屏。</h5><ol><li>编译机制和语法上可能有差异。</li><li>数码管扫描显示的话，需要注意消隐处理。数码管显示的效果呈现的是视觉效果，是根据人视觉响应和停留的时间对应关系。如果将每一帧数据单独拿出来看的话，是间隔的。</li><li>闪屏问题点已经找出，可以参考上面提供的两段代码对比分析</li></ol><h5 id="程序代码在书写表达时，尽量通俗易懂，言简意赅是最上层的修为。不要弄一些生僻，或标新立异的写法，写代码要明白一点，是给自己阅读的，所以写法一定要规范，不要求很高，起码自己能一眼就可以看懂。"><a href="#程序代码在书写表达时，尽量通俗易懂，言简意赅是最上层的修为。不要弄一些生僻，或标新立异的写法，写代码要明白一点，是给自己阅读的，所以写法一定要规范，不要求很高，起码自己能一眼就可以看懂。" class="headerlink" title="程序代码在书写表达时，尽量通俗易懂，言简意赅是最上层的修为。不要弄一些生僻，或标新立异的写法，写代码要明白一点，是给自己阅读的，所以写法一定要规范，不要求很高，起码自己能一眼就可以看懂。"></a>程序代码在书写表达时，尽量通俗易懂，言简意赅是最上层的修为。不要弄一些生僻，或标新立异的写法，写代码要明白一点，是给自己阅读的，所以写法一定要规范，不要求很高，起码自己能一眼就可以看懂。</h5><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>仿真基于proteus8.9SP2</p><p><code>proteus8.9SP2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1AcBl8w6aA71U5QYfPZK1vA </span><br><span class="line">提取码：gi35</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1AcBl8w6aA71U5QYfPZK1vA  提取码：gi35</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】74HC154 四线转12线译码器组成的16路流水灯</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F74HC154-%E5%9B%9B%E7%BA%BF%E8%BD%AC12%E7%BA%BF%E8%AF%91%E7%A0%81%E5%99%A8%E7%BB%84%E6%88%90%E7%9A%8416%E8%B7%AF%E6%B5%81%E6%B0%B4%E7%81%AF/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F74HC154-%E5%9B%9B%E7%BA%BF%E8%BD%AC12%E7%BA%BF%E8%AF%91%E7%A0%81%E5%99%A8%E7%BB%84%E6%88%90%E7%9A%8416%E8%B7%AF%E6%B5%81%E6%B0%B4%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】74HC154-四线转12线译码器组成的16路流水灯"><a href="#【Proteus仿真】74HC154-四线转12线译码器组成的16路流水灯" class="headerlink" title="【Proteus仿真】74HC154 四线转12线译码器组成的16路流水灯"></a>【Proteus仿真】74HC154 四线转12线译码器组成的16路流水灯</h1><h3 id="【Proteus仿真】74HC154-四线转12线译码器组成的16路流水灯-1"><a href="#【Proteus仿真】74HC154-四线转12线译码器组成的16路流水灯-1" class="headerlink" title="【Proteus仿真】74HC154 四线转12线译码器组成的16路流水灯"></a>【Proteus仿真】74HC154 四线转12线译码器组成的16路流水灯</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/ee9140fb368b49aeb77bc6ee59391768.gif#pic_center" alt="在这里插入图片描述"></p><h5 id="74LS154，是在单片机系统中常用的4线－12线译码器，当选通端（G1、G2）均为低电平时，可将地址端（ABCD）的二进制编码在一个对应的输出端，以低电平译出。"><a href="#74LS154，是在单片机系统中常用的4线－12线译码器，当选通端（G1、G2）均为低电平时，可将地址端（ABCD）的二进制编码在一个对应的输出端，以低电平译出。" class="headerlink" title="74LS154，是在单片机系统中常用的4线－12线译码器，当选通端（G1、G2）均为低电平时，可将地址端（ABCD）的二进制编码在一个对应的输出端，以低电平译出。"></a>74LS154，是在单片机系统中常用的4线－12线译码器，当选通端（G1、G2）均为低电平时，可将地址端（ABCD）的二进制编码在一个对应的输出端，以低电平译出。</h5><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://img-blog.csdnimg.cn/e6ff07c2f7994c34841449127935996c.png" alt="在这里插入图片描述"></p><h4 id="由74HC154组成的16路流水灯示例代码"><a href="#由74HC154组成的16路流水灯示例代码" class="headerlink" title="由74HC154组成的16路流水灯示例代码"></a>由74HC154组成的16路流水灯示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">void Delay(uint x)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">while(x--)</span><br><span class="line">&#123;</span><br><span class="line"> for(i=0;i&lt;120;i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line">&#123;</span><br><span class="line"> P2 = (P2+1)%16;</span><br><span class="line">Delay(200);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char</p><p>void Delay(uint x)<br>{<br>     uchar i;<br>    while(x–)<br>    {<br>     for(i&#x3D;0;i&lt;120;i++);<br>    }<br>}</p><p>void main()<br>{<br>     while(1)<br>    {<br>     P2 &#x3D; (P2+1)%16;<br>        Delay(200);<br>    }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1xVIPHevAhUJ1juu8hWkwMA </span><br><span class="line">提取码：9wjm</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1xVIPHevAhUJ1juu8hWkwMA  提取码：9wjm</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】74LS194组成的8个led流水灯</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F74LS194%E7%BB%84%E6%88%90%E7%9A%848%E4%B8%AAled%E6%B5%81%E6%B0%B4%E7%81%AF/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F74LS194%E7%BB%84%E6%88%90%E7%9A%848%E4%B8%AAled%E6%B5%81%E6%B0%B4%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】74LS194组成的8个led流水灯"><a href="#【Proteus仿真】74LS194组成的8个led流水灯" class="headerlink" title="【Proteus仿真】74LS194组成的8个led流水灯"></a>【Proteus仿真】74LS194组成的8个led流水灯</h1><h3 id="【Proteus仿真】74LS194组成的8个led流水灯-1"><a href="#【Proteus仿真】74LS194组成的8个led流水灯-1" class="headerlink" title="【Proteus仿真】74LS194组成的8个led流水灯"></a>【Proteus仿真】74LS194组成的8个led流水灯</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/b014ffc0ecee47878979e05767108239.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><img src="https://img-blog.csdnimg.cn/c3ffe481f2404e9a8199afc0d39ff7c3.png" alt="在这里插入图片描述"></p><ul><li>74LS194</li></ul><p>移位寄存器是指寄存器中所存的代码能够在移位脉冲的作用下依次左移或右移。74LS194是一个4位双向移位寄存器，最高时钟脉冲为36MHZ.  其中：D0～D1为并行输入端；Q0～Q3为并行输出端；SR右移串引输入端；SL–左移串引输入端；S1、S0-操作模式控制端；MR -为直接无条件清零端；CLK为时钟脉冲输入端。 S1S0取值为11时，做置位操作，当为01时，做右移操作。</p><p><img src="https://img-blog.csdnimg.cn/34efb207447f41ad9830e6c065c508d0.png" alt="在这里插入图片描述"></p><p><code>SR</code></p><p><code>SL</code></p><p><code>MR</code></p><p><code>CLK</code></p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1cOm8vGBwkNxDw149DYBPTg </span><br><span class="line">提取码：y9se</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1cOm8vGBwkNxDw149DYBPTg  提取码：y9se</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】74HC595+74LS154驱动显示16X16点阵</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F74HC59574LS154%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BA16X16%E7%82%B9%E9%98%B5/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F74HC59574LS154%E9%A9%B1%E5%8A%A8%E6%98%BE%E7%A4%BA16X16%E7%82%B9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】74HC595-74LS154驱动显示16X16点阵"><a href="#【Proteus仿真】74HC595-74LS154驱动显示16X16点阵" class="headerlink" title="【Proteus仿真】74HC595+74LS154驱动显示16X16点阵"></a>【Proteus仿真】74HC595+74LS154驱动显示16X16点阵</h1><h3 id="【Proteus仿真】74HC595-74LS154驱动显示16X16点阵-1"><a href="#【Proteus仿真】74HC595-74LS154驱动显示16X16点阵-1" class="headerlink" title="【Proteus仿真】74HC595+74LS154驱动显示16X16点阵"></a>【Proteus仿真】74HC595+74LS154驱动显示16X16点阵</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/c5620e9fffb94301826f031f23ac318a.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="取模软件和方式"><a href="#取模软件和方式" class="headerlink" title="取模软件和方式"></a>取模软件和方式</h4><ul><li>pctolcd2002</li><li>取模方式：逐列式、逆向、C51格式</li></ul><p><code>pctolcd2002</code></p><p><img src="https://img-blog.csdnimg.cn/213adc1a156c4efc9291673e87c80e12.png" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//------------------------------------——</span><br><span class="line">//名称：用75LS595与74LS154在16x16点阵屏上显示信息</span><br><span class="line">//说明：本例综合使用了串入并出芯片75LS595,4-16译码器75LS154及</span><br><span class="line">//反相放大器74LS06,在16x16点阵屏上实现了汉字滚动显示效果。</span><br><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">//#include &lt;REGX52.H&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line"></span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int </span><br><span class="line"></span><br><span class="line">sbit Serial_Data_Pin = P0^0;//75LS595串行数据输入</span><br><span class="line">sbit Shift_CLK_Pin = P3^7;//75LS595移位脉冲</span><br><span class="line">sbit RCK_Pin = P0^1;//75LS595输出锁存器控制</span><br><span class="line">sbit Switch_74LS154 = P3^6;//74LS154译码器开关</span><br><span class="line"></span><br><span class="line">uchar data Bit_Stream_8[32];//发送给75LS595的位流,每片接收8位</span><br><span class="line">uchar code Word_Set_OF_16x16[][32]=//待显示文字的点阵</span><br><span class="line">&#123;</span><br><span class="line">&#123;0xFF,0XFF,0x8F,0XF0,0x07,0XE0,0x77,0xEF,0x77,0xEF,0x07,0xE0,0x8F,0xF0,0xFF,0XFF,</span><br><span class="line">0XFF,0XFF,0X0F,0xF0,0x07,0XE0,0xF7,0xEF,0XF7,0xEF,0X07,0xE0,0x0F,0XF0,0XEF,0XFF&#125;,//80</span><br><span class="line"></span><br><span class="line">//&#123;0XFF,0XFF,0x07,0XF6,0X07,0xE6,0x77,0XEF,0x77,0XEF,0x77,0XE0,0XF7,0XF0,0XFF,0XFF,</span><br><span class="line">//0xFF,0XFF,0XEF,0XFF,0XEF,0XFF,0X07,0XE0,0x07,0XE0,0XFF,0XFF,0XFF,0XFF,0XFF,0xFF&#125;,//51</span><br><span class="line">&#123;0xFF,0xFF,0x03,0xCE,0x03,0xCE,0x73,0xCE,0x73,0xCE,0x73,0xCE,0x73,0xCE,0x73,0xC0,</span><br><span class="line">0x73,0xC0,0xFF,0xFF,0xFF,0xFF,0xEF,0xDF,0x03,0xC0,0x03,0xC0,0xFF,0xDF,0xFF,0xFF&#125;,//51</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xEF,0xFF,0xEF,0x07,0xEC,0xB6,0xED,0xB5,0xED,0xB3,0xED,0xB7,0xED,0x07,0x00,</span><br><span class="line">0xB7,0xED,0xB3,0xED,0xB5,0xED,0xB6,0xED,0x07,0xEC,0xFF,0xEF,0xFF,0xEF,0xFF,0xFF&#125;,/*&quot;单&quot;,0*/</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xFF,0xFF,0x7F,0xFF,0x9F,0x01,0xE0,0xDF,0xFD,0xDF,0xFD,0xDF,0xFD,0xDF,0xFD,</span><br><span class="line">0xDF,0xFD,0xC0,0xFD,0xDF,0x01,0xDF,0xFF,0xDF,0xFF,0xDF,0xFF,0xFF,0xFF,0xFF,0xFF&#125;,/*&quot;片&quot;,1*/</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xFF,0xEF,0xF3,0x6F,0xFC,0x01,0x80,0x01,0x80,0x6F,0xBC,0xEF,0x9D,0xFF,0xC7,</span><br><span class="line">0x03,0xF0,0xFB,0xFF,0xFB,0xFF,0x03,0xC0,0x03,0x80,0xFF,0xBF,0xFF,0x9F,0xFF,0xFF&#125;,/*&quot;机&quot;,2*/</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xF0,0x07,0xE0,0xF3,0xCF,0xF3,0xCF,0xF3,0xCF,</span><br><span class="line">0xF3,0xCF,0xF3,0xCF,0xF3,0xCF,0xC3,0xC3,0xC3,0xE3,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF&#125;,/*&quot;C&quot;,0*/</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xFF,0xBF,0xFF,0xB9,0xFF,0x33,0x80,0xFF,0xE7,0x7F,0xF7,0x6D,0xFF,0x6D,0x03,</span><br><span class="line">0x0D,0xBB,0x41,0xBB,0x6D,0xBB,0x6D,0xBB,0x0D,0xBB,0x0D,0x03,0x7D,0xFF,0xFF,0xFF&#125;,/*&quot;语&quot;,1*/</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xFF,0xF7,0xFF,0xF7,0xFF,0xD7,0x82,0xD7,0xDA,0xD7,0xDA,0xD7,0xDA,0xD1,0xDA,</span><br><span class="line">0xD7,0xDA,0xD7,0xDA,0xD7,0xDA,0xD7,0xDA,0xD7,0x82,0xF7,0xFF,0xF7,0xFF,0xFF,0xFF&#125;,/*&quot;言&quot;,2*/</span><br><span class="line"></span><br><span class="line">&#123;0xBF,0xFB,0x8F,0xFB,0xCE,0xFB,0x68,0xFB,0x69,0xFB,0x6F,0xBB,0x6E,0x3B,0x68,0x01,</span><br><span class="line">0x69,0x81,0x6F,0xF8,0x67,0xFA,0x63,0xFB,0xE8,0xFB,0xAC,0xFB,0x8F,0xFB,0xCF,0xFB&#125;,//学&quot;</span><br><span class="line"></span><br><span class="line">&#123;0xFF,0xFF,0xFD,0xF7,0xFD,0xE7,0xFD,0xE7,0xED,0xF3,0xCD,0xFB,0x1D,0xFB,0x3D,0xF9,</span><br><span class="line">0xFD,0xFD,0xFD,0xBC,0xFD,0x3E,0xFD,0x3E,0x01,0x80,0x01,0xC0,0xFF,0xFF,0xFF,0xFF&#125;,//习&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//延时</span><br><span class="line">void Delay(uint x)</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">while(x--)</span><br><span class="line">&#123;</span><br><span class="line"> for(i=0;i&lt;120;i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//向75LS595的串行输入引脚写入一字节</span><br><span class="line">void Serial_Input_Pin(uchar Abyte)</span><br><span class="line">&#123;</span><br><span class="line">uchar i;//</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">Abyte &lt;&lt;=1;</span><br><span class="line">Serial_Data_Pin = CY;</span><br><span class="line">Shift_CLK_Pin = 1;//上升沿移位i</span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">Shift_CLK_Pin = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定时器0中断,在主程序中的延时期间以1ms的间隔动态显示每列数据</span><br><span class="line">//所显示的数据由2片75LS595并行输出</span><br><span class="line">void TO_Led_Display_control()interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">TH0 = -1000/256;//1ms 定时</span><br><span class="line">TL0 = -1000%256;</span><br><span class="line">i=(P2+1)&amp;0x0f;//当前列号加1,屏蔽高4位i=0~15</span><br><span class="line">Serial_Input_Pin(Bit_Stream_8[i*2 +1]);</span><br><span class="line">Serial_Input_Pin(Bit_Stream_8[i*2]);</span><br><span class="line">Switch_74LS154 =1;//关闭译码器</span><br><span class="line">RCK_Pin =1;//上升沿将数据送到输出锁存器</span><br><span class="line">RCK_Pin =0;//锁存显示数据（2x8=16位)</span><br><span class="line">Switch_74LS154 = 0;//打开译码器</span><br><span class="line">P2=i;//列号译码(4-16)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">uchar i,k;</span><br><span class="line">TMOD = 0x01;//定时器T0工作方式1</span><br><span class="line">TH0 = (65536-1000)/256;//1ms 定时</span><br><span class="line">TL0= (65536-1000)%256;</span><br><span class="line">IE = 0x82;//允许定时器T0中断</span><br><span class="line">P2 = 0xFF;//行号端口初值</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">for(k=0;k&lt;10;k++)//显示12项内容</span><br><span class="line">&#123;</span><br><span class="line">for(i= 0;i&lt;32;i++)//将当前待显示内容放入Bit_Stream.8</span><br><span class="line">&#123;</span><br><span class="line">Bit_Stream_8[i]= Word_Set_OF_16x16[k][i];</span><br><span class="line">TR0 = 1;</span><br><span class="line">Delay(50);//在此期间由定时器中断显示信息</span><br><span class="line">TR0 = 0;</span><br><span class="line">P2 = 0XFF;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;&#x2F;——————————————<br>&#x2F;&#x2F;名称：用75LS595与74LS154在16x16点阵屏上显示信息<br>&#x2F;&#x2F;说明：本例综合使用了串入并出芯片75LS595,4-16译码器75LS154及<br>&#x2F;&#x2F;反相放大器74LS06,在16x16点阵屏上实现了汉字滚动显示效果。<br>#include&lt;reg51.h&gt;<br>&#x2F;&#x2F;#include &lt;REGX52.H&gt;<br>#include &lt;intrins.h&gt;</p><p>#define uchar unsigned char<br>#define uint unsigned int </p><p>sbit Serial_Data_Pin &#x3D; P0^0;&#x2F;&#x2F;75LS595串行数据输入<br>sbit Shift_CLK_Pin &#x3D; P3^7;&#x2F;&#x2F;75LS595移位脉冲<br>sbit RCK_Pin &#x3D; P0^1;&#x2F;&#x2F;75LS595输出锁存器控制<br>sbit Switch_74LS154 &#x3D; P3^6;&#x2F;&#x2F;74LS154译码器开关</p><p>uchar data Bit_Stream_8[32];&#x2F;&#x2F;发送给75LS595的位流,每片接收8位<br>uchar code Word_Set_OF_16x16[][32]&#x3D;&#x2F;&#x2F;待显示文字的点阵<br>{<br>{0xFF,0XFF,0x8F,0XF0,0x07,0XE0,0x77,0xEF,0x77,0xEF,0x07,0xE0,0x8F,0xF0,0xFF,0XFF,<br>0XFF,0XFF,0X0F,0xF0,0x07,0XE0,0xF7,0xEF,0XF7,0xEF,0X07,0xE0,0x0F,0XF0,0XEF,0XFF},&#x2F;&#x2F;80</p><p>&#x2F;&#x2F;{0XFF,0XFF,0x07,0XF6,0X07,0xE6,0x77,0XEF,0x77,0XEF,0x77,0XE0,0XF7,0XF0,0XFF,0XFF,<br>&#x2F;&#x2F;0xFF,0XFF,0XEF,0XFF,0XEF,0XFF,0X07,0XE0,0x07,0XE0,0XFF,0XFF,0XFF,0XFF,0XFF,0xFF},&#x2F;&#x2F;51<br>{0xFF,0xFF,0x03,0xCE,0x03,0xCE,0x73,0xCE,0x73,0xCE,0x73,0xCE,0x73,0xCE,0x73,0xC0,<br>0x73,0xC0,0xFF,0xFF,0xFF,0xFF,0xEF,0xDF,0x03,0xC0,0x03,0xC0,0xFF,0xDF,0xFF,0xFF},&#x2F;&#x2F;51</p><p>{0xFF,0xEF,0xFF,0xEF,0x07,0xEC,0xB6,0xED,0xB5,0xED,0xB3,0xED,0xB7,0xED,0x07,0x00,<br>0xB7,0xED,0xB3,0xED,0xB5,0xED,0xB6,0xED,0x07,0xEC,0xFF,0xEF,0xFF,0xEF,0xFF,0xFF},&#x2F;<em>“单”,0</em>&#x2F;</p><p>{0xFF,0xFF,0xFF,0x7F,0xFF,0x9F,0x01,0xE0,0xDF,0xFD,0xDF,0xFD,0xDF,0xFD,0xDF,0xFD,<br>0xDF,0xFD,0xC0,0xFD,0xDF,0x01,0xDF,0xFF,0xDF,0xFF,0xDF,0xFF,0xFF,0xFF,0xFF,0xFF},&#x2F;<em>“片”,1</em>&#x2F;</p><p>{0xFF,0xFF,0xEF,0xF3,0x6F,0xFC,0x01,0x80,0x01,0x80,0x6F,0xBC,0xEF,0x9D,0xFF,0xC7,<br>0x03,0xF0,0xFB,0xFF,0xFB,0xFF,0x03,0xC0,0x03,0x80,0xFF,0xBF,0xFF,0x9F,0xFF,0xFF},&#x2F;<em>“机”,2</em>&#x2F;</p><p>{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xF0,0x07,0xE0,0xF3,0xCF,0xF3,0xCF,0xF3,0xCF,<br>0xF3,0xCF,0xF3,0xCF,0xF3,0xCF,0xC3,0xC3,0xC3,0xE3,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},&#x2F;<em>“C”,0</em>&#x2F;</p><p>{0xFF,0xFF,0xBF,0xFF,0xB9,0xFF,0x33,0x80,0xFF,0xE7,0x7F,0xF7,0x6D,0xFF,0x6D,0x03,<br>0x0D,0xBB,0x41,0xBB,0x6D,0xBB,0x6D,0xBB,0x0D,0xBB,0x0D,0x03,0x7D,0xFF,0xFF,0xFF},&#x2F;<em>“语”,1</em>&#x2F;</p><p>{0xFF,0xFF,0xF7,0xFF,0xF7,0xFF,0xD7,0x82,0xD7,0xDA,0xD7,0xDA,0xD7,0xDA,0xD1,0xDA,<br>0xD7,0xDA,0xD7,0xDA,0xD7,0xDA,0xD7,0xDA,0xD7,0x82,0xF7,0xFF,0xF7,0xFF,0xFF,0xFF},&#x2F;<em>“言”,2</em>&#x2F;</p><p>{0xBF,0xFB,0x8F,0xFB,0xCE,0xFB,0x68,0xFB,0x69,0xFB,0x6F,0xBB,0x6E,0x3B,0x68,0x01,<br>0x69,0x81,0x6F,0xF8,0x67,0xFA,0x63,0xFB,0xE8,0xFB,0xAC,0xFB,0x8F,0xFB,0xCF,0xFB},&#x2F;&#x2F;学”</p><p>{0xFF,0xFF,0xFD,0xF7,0xFD,0xE7,0xFD,0xE7,0xED,0xF3,0xCD,0xFB,0x1D,0xFB,0x3D,0xF9,<br>0xFD,0xFD,0xFD,0xBC,0xFD,0x3E,0xFD,0x3E,0x01,0x80,0x01,0xC0,0xFF,0xFF,0xFF,0xFF},&#x2F;&#x2F;习”</p><p>};</p><p>&#x2F;&#x2F;延时<br>void Delay(uint x)<br>{<br>    uchar i;<br>    while(x–)<br>    {<br>     for(i&#x3D;0;i&lt;120;i++);<br>    }<br>}</p><p>&#x2F;&#x2F;向75LS595的串行输入引脚写入一字节<br>void Serial_Input_Pin(uchar Abyte)<br>{<br>uchar i;&#x2F;&#x2F;<br>for(i&#x3D;0;i&lt;8;i++)<br>{<br>    Abyte &lt;&lt;&#x3D;1;<br>    Serial_Data_Pin &#x3D; CY;<br>    Shift_CLK_Pin &#x3D; 1;&#x2F;&#x2F;上升沿移位i<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    Shift_CLK_Pin &#x3D; 0;<br>    }<br>}</p><p>&#x2F;&#x2F;定时器0中断,在主程序中的延时期间以1ms的间隔动态显示每列数据<br>&#x2F;&#x2F;所显示的数据由2片75LS595并行输出<br>void TO_Led_Display_control()interrupt 1<br>{<br>    uchar i;<br>    TH0 &#x3D; -1000&#x2F;256;&#x2F;&#x2F;1ms 定时<br>    TL0 &#x3D; -1000%256;<br>    i&#x3D;(P2+1)&0x0f;&#x2F;&#x2F;当前列号加1,屏蔽高4位i&#x3D;0~15<br>    Serial_Input_Pin(Bit_Stream_8[i<em>2 +1]);<br>    Serial_Input_Pin(Bit_Stream_8[i</em>2]);<br>    Switch_74LS154 &#x3D;1;&#x2F;&#x2F;关闭译码器<br>    RCK_Pin &#x3D;1;&#x2F;&#x2F;上升沿将数据送到输出锁存器<br>    RCK_Pin &#x3D;0;&#x2F;&#x2F;锁存显示数据（2x8&#x3D;16位)<br>    Switch_74LS154 &#x3D; 0;&#x2F;&#x2F;打开译码器<br>    P2&#x3D;i;&#x2F;&#x2F;列号译码(4-16)</p><p>}<br>void main()<br>{<br>    uchar i,k;<br>    TMOD &#x3D; 0x01;&#x2F;&#x2F;定时器T0工作方式1<br>    TH0 &#x3D; (65536-1000)&#x2F;256;&#x2F;&#x2F;1ms 定时<br>    TL0&#x3D; (65536-1000)%256;<br>    IE &#x3D; 0x82;&#x2F;&#x2F;允许定时器T0中断<br>    P2 &#x3D; 0xFF;&#x2F;&#x2F;行号端口初值<br>    while(1)<br>    {<br>        for(k&#x3D;0;k&lt;10;k++)&#x2F;&#x2F;显示12项内容<br>        {<br>            for(i&#x3D; 0;i&lt;32;i++)&#x2F;&#x2F;将当前待显示内容放入Bit_Stream.8<br>            {<br>    Bit_Stream_8[i]&#x3D; Word_Set_OF_16x16[k][i];<br>                TR0 &#x3D; 1;<br>    Delay(50);&#x2F;&#x2F;在此期间由定时器中断显示信息<br>    TR0 &#x3D; 0;<br>    P2 &#x3D; 0XFF;<br>            }<br>     }<br>    }<br>}&#96;</p><h4 id="程序源码和仿真资源（包含取模工具）"><a href="#程序源码和仿真资源（包含取模工具）" class="headerlink" title="程序源码和仿真资源（包含取模工具）"></a>程序源码和仿真资源（包含取模工具）</h4><p>本示例基于Proteus8.12平台.</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1225O9hBMRh5LG_T1Jr0-8w </span><br><span class="line">提取码：bsk2</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1225O9hBMRh5LG_T1Jr0-8w  提取码：bsk2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】8x8Led点阵数字循环显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F8x8Led%E7%82%B9%E9%98%B5%E6%95%B0%E5%AD%97%E5%BE%AA%E7%8E%AF%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F8x8Led%E7%82%B9%E9%98%B5%E6%95%B0%E5%AD%97%E5%BE%AA%E7%8E%AF%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】8x8Led点阵数字循环显示"><a href="#【Proteus仿真】8x8Led点阵数字循环显示" class="headerlink" title="【Proteus仿真】8x8Led点阵数字循环显示"></a>【Proteus仿真】8x8Led点阵数字循环显示</h1><h3 id="【Proteus仿真】8x8Led点阵数字循环显示-1"><a href="#【Proteus仿真】8x8Led点阵数字循环显示-1" class="headerlink" title="【Proteus仿真】8x8Led点阵数字循环显示"></a>【Proteus仿真】8x8Led点阵数字循环显示</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/55cb9f1d6b8e43fc9e3c6621c5ac0c33.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="8x8点阵取模工具和方法"><a href="#8x8点阵取模工具和方法" class="headerlink" title="8x8点阵取模工具和方法"></a>8x8点阵取模工具和方法</h4><p>通过鼠标点亮要显示的方格，然后点击生成数组，将取模好的数组放到程序代码中，至于是共阴还是共阳，可以调试看效果就明白了，如果显示的效果是反的，那就点击切换共阴&#x2F;共阳按钮即可。</p><p><img src="https://img-blog.csdnimg.cn/62036d68caaf4ffe9dfa64cf939f68b5.png" alt="在这里插入图片描述"></p><h4 id="示例程序代码"><a href="#示例程序代码" class="headerlink" title="示例程序代码"></a>示例程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line">uchar code Table_OF_Digits[]=</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">0x00,0x7E,0x81,0x81,0x81,0x81,0x7E,0x00,/*&#x27;0&#x27;*/</span><br><span class="line">0x00,0x00,0x43,0xFF,0xFF,0x03,0x00,0x00,/*&#x27;1&#x27;*/</span><br><span class="line">0x00,0x00,0x43,0xFF,0xFF,0x03,0x00,0x00,/*&#x27;2&#x27;*/</span><br><span class="line">0x00,0x99,0x99,0x99,0x99,0xFF,0xFF,0x00,/*&#x27;3&#x27;*/</span><br><span class="line">0x00,0x0c,0x14,0x24,0x7f,0x04,0x00,0x00,</span><br><span class="line">0x00,0x72,0x51,0x51,0x51,0x4e,0x00,0x00,</span><br><span class="line">0x00,0x3e,0x49,0x49,0x49,0x26,0x00,0x00,</span><br><span class="line">0x00,0x40,0x40,0x40,0x4f,0x70,0x00,0x00,</span><br><span class="line">0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,</span><br><span class="line">0x00,0x32,0x49,0x49,0x49,0x3e,0x00,0x00,</span><br><span class="line">&#125;;</span><br><span class="line">uchar i=0,t=0,Num_Index = 0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> P3 = 0x80;</span><br><span class="line">Num_Index = 0;</span><br><span class="line">TMOD = 0x00;</span><br><span class="line">TH0 = (8192-2000)/32;</span><br><span class="line">TL0 = (8192-2000)%32;</span><br><span class="line">TR0 = 1;</span><br><span class="line">IE = 0x82;</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LED_Screen_Display() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> TH0 = (8192-2000)/32;</span><br><span class="line">TL0 = (8192-2000)%32;</span><br><span class="line">P3 = _crol_(P3,1);</span><br><span class="line">P0 = ~Table_OF_Digits[Num_Index * 8 +i];</span><br><span class="line">if(++i == 8) i = 0;</span><br><span class="line">if(++t == 250)</span><br><span class="line">&#123;</span><br><span class="line"> t = 0x00;</span><br><span class="line">if(++Num_Index == 10) Num_Index = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>uchar code Table_OF_Digits[]&#x3D;<br>{</p><pre><code>0x00,0x7E,0x81,0x81,0x81,0x81,0x7E,0x00,/*&#39;0&#39;*/0x00,0x00,0x43,0xFF,0xFF,0x03,0x00,0x00,/*&#39;1&#39;*/0x00,0x00,0x43,0xFF,0xFF,0x03,0x00,0x00,/*&#39;2&#39;*/0x00,0x99,0x99,0x99,0x99,0xFF,0xFF,0x00,/*&#39;3&#39;*/0x00,0x0c,0x14,0x24,0x7f,0x04,0x00,0x00,0x00,0x72,0x51,0x51,0x51,0x4e,0x00,0x00,0x00,0x3e,0x49,0x49,0x49,0x26,0x00,0x00,0x00,0x40,0x40,0x40,0x4f,0x70,0x00,0x00,0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,0x00,0x32,0x49,0x49,0x49,0x3e,0x00,0x00,</code></pre><p>};<br>uchar i&#x3D;0,t&#x3D;0,Num_Index &#x3D; 0;</p><p>void main()<br>{<br>     P3 &#x3D; 0x80;<br>    Num_Index &#x3D; 0;<br>    TMOD &#x3D; 0x00;<br>    TH0 &#x3D; (8192-2000)&#x2F;32;<br>    TL0 &#x3D; (8192-2000)%32;<br>    TR0 &#x3D; 1;<br>    IE &#x3D; 0x82;<br>    while(1);<br>}</p><p>void LED_Screen_Display() interrupt 1<br>{<br>     TH0 &#x3D; (8192-2000)&#x2F;32;<br>    TL0 &#x3D; (8192-2000)%32;<br>    P3 &#x3D; <em>crol</em>(P3,1);<br>    P0 &#x3D; ~Table_OF_Digits[Num_Index * 8 +i];<br>    if(++i &#x3D;&#x3D; 8) i &#x3D; 0;<br>    if(++t &#x3D;&#x3D; 250)<br>    {<br>     t &#x3D; 0x00;<br>        if(++Num_Index &#x3D;&#x3D; 10) Num_Index &#x3D; 0;<br>    }<br>}&#96;</p><h4 id="仿真资源和程序代码（包含取模工具）"><a href="#仿真资源和程序代码（包含取模工具）" class="headerlink" title="仿真资源和程序代码（包含取模工具）"></a>仿真资源和程序代码（包含取模工具）</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1zmGaHUnvJ38W8MtaFht4ig </span><br><span class="line">提取码：nvax</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1zmGaHUnvJ38W8MtaFht4ig  提取码：nvax</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】8位数码管动态扫描显示变化数据</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F8%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F%E6%98%BE%E7%A4%BA%E5%8F%98%E5%8C%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F8%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F%E6%98%BE%E7%A4%BA%E5%8F%98%E5%8C%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】8位数码管动态扫描显示变化数据"><a href="#【Proteus仿真】8位数码管动态扫描显示变化数据" class="headerlink" title="【Proteus仿真】8位数码管动态扫描显示变化数据"></a>【Proteus仿真】8位数码管动态扫描显示变化数据</h1><h3 id="【Proteus仿真】8位数码管动态扫描显示变化数据-1"><a href="#【Proteus仿真】8位数码管动态扫描显示变化数据-1" class="headerlink" title="【Proteus仿真】8位数码管动态扫描显示变化数据"></a>【Proteus仿真】8位数码管动态扫描显示变化数据</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/682d94e0dcc14e218f0e6129af163586.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/*-----------------------------------------------</span><br><span class="line">  名称：8位数码管动态扫描显示变化数据</span><br><span class="line">  内容：8位数码管分别显示不同数字，这种扫描显示方式称为动态扫描，并不停变化赋值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line"></span><br><span class="line">#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换</span><br><span class="line">sbit LATCH1=P2^2;//定义锁存使能端口 段锁存</span><br><span class="line">sbit LATCH2=P2^3;//                 位锁存</span><br><span class="line"></span><br><span class="line">unsigned char code DuanMa[10]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 显示段码值0~9</span><br><span class="line">unsigned char code WeiMa[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;//分别对应相应的数码管点亮,即位码</span><br><span class="line">unsigned char TempData[8]; //存储显示值的全局变量</span><br><span class="line">void Delay(unsigned int t); //函数声明</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num);</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> unsigned int numA=999,numB=0;</span><br><span class="line"> unsigned int j;</span><br><span class="line"> while(1)</span><br><span class="line">      &#123;</span><br><span class="line">   j++;</span><br><span class="line">   if(j==10)  //检测当前数值显示了一小段时间后，</span><br><span class="line">            //需要显示的数值-1，实现数据显示的变化</span><br><span class="line">     &#123;</span><br><span class="line">  j=0;</span><br><span class="line">  numB++;</span><br><span class="line">  if(numA&gt;0)//用于显示0~999</span><br><span class="line">    numA--;</span><br><span class="line">  else</span><br><span class="line">    numA=999;</span><br><span class="line">          if(numB==1000)</span><br><span class="line">    numB=0;</span><br><span class="line"> &#125;</span><br><span class="line">   //递减的三位数码管，带消隐</span><br><span class="line">       if(numA&lt;100)</span><br><span class="line">         TempData[0]=0;</span><br><span class="line">   else</span><br><span class="line">    TempData[0]=DuanMa[numA/100];//分解显示信息，</span><br><span class="line">                          //如要显示68，则68/10=6  68%10=8  </span><br><span class="line">   if(numA&lt;10)</span><br><span class="line">     TempData[1]=0;</span><br><span class="line">   else</span><br><span class="line">     TempData[1]=DuanMa[(numA%100)/10];</span><br><span class="line">   TempData[2]=DuanMa[(numA%100)%10];</span><br><span class="line">       //中间2位数码管不显示，赋值0</span><br><span class="line">       TempData[3]=0; </span><br><span class="line">   TempData[4]=0; </span><br><span class="line">       //递增的三位数码管，带消隐</span><br><span class="line">   if(numB&lt;100)</span><br><span class="line">         TempData[5]=0;</span><br><span class="line">   else</span><br><span class="line">    TempData[5]=DuanMa[numB/100];//分解显示信息，</span><br><span class="line">                          //如要显示68，则68/10=6  68%10=8  </span><br><span class="line">   if(numB&lt;10)</span><br><span class="line">     TempData[6]=0;</span><br><span class="line">   else</span><br><span class="line">     TempData[6]=DuanMa[(numB%100)/10];</span><br><span class="line">   TempData[7]=DuanMa[(numB%100)%10];</span><br><span class="line"></span><br><span class="line">   Display(0,8);//从第一位显示，共显示8位</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 延时函数，含有输入参数 unsigned int t，无返回值</span><br><span class="line"> unsigned int 是定义无符号整形变量，其值的范围是</span><br><span class="line"> 0~65535</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Delay(unsigned int t)</span><br><span class="line">&#123;</span><br><span class="line"> while(--t);</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 显示函数，用于动态扫描数码管</span><br><span class="line"> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示</span><br><span class="line"> 从第三个数码管开始显示</span><br><span class="line"> 如输入0表示从第一个显示。</span><br><span class="line"> Num表示需要显示的位数，如需要显示99两位数值则该值输入2</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num)</span><br><span class="line">&#123;</span><br><span class="line">      unsigned char i;</span><br><span class="line">  </span><br><span class="line">  for(i=0;i&lt;Num;i++)</span><br><span class="line">   &#123; </span><br><span class="line">   DataPort=0;   //清空数据，防止有交替重影</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line"></span><br><span class="line">       DataPort = WeiMa[i+FirstBit]; //取位码 </span><br><span class="line">       LATCH2=1;     //位锁存</span><br><span class="line">       LATCH2=0;</span><br><span class="line"></span><br><span class="line">       DataPort = TempData[i]; //取显示数据，段码</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line">       </span><br><span class="line">   Delay(200); // 扫描间隙延时，时间太长会闪烁，</span><br><span class="line">                   //太短会造成重影</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>———————————————–<br>  名称：8位数码管动态扫描显示变化数据<br>  内容：8位数码管分别显示不同数字，这种扫描显示方式称为动态扫描，并不停变化赋值<br>————————————————</em>&#x2F;<br>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</p><p>#define DataPort P0 &#x2F;&#x2F;定义数据端口 程序中遇到DataPort 则用P0 替换<br>sbit LATCH1&#x3D;P2^2;&#x2F;&#x2F;定义锁存使能端口 段锁存<br>sbit LATCH2&#x3D;P2^3;&#x2F;&#x2F;                 位锁存</p><p>unsigned char code DuanMa[10]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F; 显示段码值0<del>9<br>unsigned char code WeiMa[]&#x3D;{0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};&#x2F;&#x2F;分别对应相应的数码管点亮,即位码<br>unsigned char TempData[8]; &#x2F;&#x2F;存储显示值的全局变量<br>void Delay(unsigned int t); &#x2F;&#x2F;函数声明<br>void Display(unsigned char FirstBit,unsigned char Num);<br>&#x2F;<em>————————————————<br>                    主函数<br>————————————————</em>&#x2F;<br>void main()<br>{<br> unsigned int numA&#x3D;999,numB&#x3D;0;<br> unsigned int j;<br> while(1)<br>      {<br>       j++;<br>       if(j&#x3D;&#x3D;10)  &#x2F;&#x2F;检测当前数值显示了一小段时间后，<br>            &#x2F;&#x2F;需要显示的数值-1，实现数据显示的变化<br>         {<br>          j&#x3D;0;<br>          numB++;<br>          if(numA&gt;0)&#x2F;&#x2F;用于显示0</del>999<br>            numA–;<br>          else<br>            numA&#x3D;999;<br>          if(numB&#x3D;&#x3D;1000)<br>            numB&#x3D;0;<br>         }<br>       &#x2F;&#x2F;递减的三位数码管，带消隐<br>       if(numA&lt;100)<br>         TempData[0]&#x3D;0;<br>       else<br>        TempData[0]&#x3D;DuanMa[numA&#x2F;100];&#x2F;&#x2F;分解显示信息，<br>                          &#x2F;&#x2F;如要显示68，则68&#x2F;10&#x3D;6  68%10&#x3D;8<br>       if(numA&lt;10)<br>         TempData[1]&#x3D;0;<br>       else<br>         TempData[1]&#x3D;DuanMa[(numA%100)&#x2F;10];<br>       TempData[2]&#x3D;DuanMa[(numA%100)%10];<br>       &#x2F;&#x2F;中间2位数码管不显示，赋值0<br>       TempData[3]&#x3D;0;<br>       TempData[4]&#x3D;0;<br>       &#x2F;&#x2F;递增的三位数码管，带消隐<br>       if(numB&lt;100)<br>         TempData[5]&#x3D;0;<br>       else<br>        TempData[5]&#x3D;DuanMa[numB&#x2F;100];&#x2F;&#x2F;分解显示信息，<br>                          &#x2F;&#x2F;如要显示68，则68&#x2F;10&#x3D;6  68%10&#x3D;8<br>       if(numB&lt;10)<br>         TempData[6]&#x3D;0;<br>       else<br>         TempData[6]&#x3D;DuanMa[(numB%100)&#x2F;10];<br>       TempData[7]&#x3D;DuanMa[(numB%100)%10];</p><pre><code>   Display(0,8);//从第一位显示，共显示8位  &#125;</code></pre><p>}<br>&#x2F;<em>————————————————<br> 延时函数，含有输入参数 unsigned int t，无返回值<br> unsigned int 是定义无符号整形变量，其值的范围是<br> 0~65535<br>————————————————</em>&#x2F;<br>void Delay(unsigned int t)<br>{<br> while(–t);<br>}<br>&#x2F;<em>————————————————<br> 显示函数，用于动态扫描数码管<br> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示<br> 从第三个数码管开始显示<br> 如输入0表示从第一个显示。<br> Num表示需要显示的位数，如需要显示99两位数值则该值输入2<br>————————————————</em>&#x2F;<br>void Display(unsigned char FirstBit,unsigned char Num)<br>{<br>      unsigned char i;</p><pre><code>  for(i=0;i&lt;Num;i++)   &#123;    DataPort=0;   //清空数据，防止有交替重影   LATCH1=1;     //段锁存   LATCH1=0;   DataPort = WeiMa[i+FirstBit]; //取位码    LATCH2=1;     //位锁存   LATCH2=0;   DataPort = TempData[i]; //取显示数据，段码   LATCH1=1;     //段锁存   LATCH1=0;      Delay(200); // 扫描间隙延时，时间太长会闪烁，               //太短会造成重影   &#125;</code></pre><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1mYSBwXnhikrhhotaSFAOEA </span><br><span class="line">提取码：rg39</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1mYSBwXnhikrhhotaSFAOEA  提取码：rg39</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】8位端口检测8独立按键</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F8%E4%BD%8D%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B8%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F8%E4%BD%8D%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B8%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】8位端口检测8独立按键"><a href="#【Proteus仿真】8位端口检测8独立按键" class="headerlink" title="【Proteus仿真】8位端口检测8独立按键"></a>【Proteus仿真】8位端口检测8独立按键</h1><h3 id="【Proteus仿真】8位端口检测8独立按键-1"><a href="#【Proteus仿真】8位端口检测8独立按键-1" class="headerlink" title="【Proteus仿真】8位端口检测8独立按键"></a>【Proteus仿真】8位端口检测8独立按键</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/fa5ace87a4844cac9a67516b7a935d73.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周三 6月 29 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line">/*-----------------------------------------------</span><br><span class="line">  名称：单个独立按键依次输入控制</span><br><span class="line">  内容：如计算器输入数据形式相同 从左往右 利用整个端口扫描读取按键值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line"></span><br><span class="line">#define KeyPort P1</span><br><span class="line">#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换</span><br><span class="line"></span><br><span class="line">sbit LATCH1=P2^2;//定义锁存使能端口 段锁存</span><br><span class="line">sbit LATCH2=P2^3;//                 位锁存</span><br><span class="line"></span><br><span class="line">unsigned char code DuanMa[10]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 显示段码值0~9</span><br><span class="line">unsigned char code WeiMa[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;//分别对应相应的数码管点亮,即位码</span><br><span class="line">unsigned char TempData[10]; //存储显示值的全局变量</span><br><span class="line"></span><br><span class="line">void DelayUs2x(unsigned char t);//us级延时函数声明 </span><br><span class="line">void DelayMs(unsigned char t); //ms级延时</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num);//数码管显示函数</span><br><span class="line">unsigned char KeyScan(void);//键盘扫描</span><br><span class="line">void Init_Timer0(void);//定时器初始化</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main (void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char num,i,j;                  </span><br><span class="line"></span><br><span class="line">Init_Timer0();</span><br><span class="line"></span><br><span class="line">while (1)         //主循环</span><br><span class="line">  &#123;</span><br><span class="line"> num=KeyScan();</span><br><span class="line"> if(num)</span><br><span class="line">   &#123;</span><br><span class="line">   if(i&lt;8)</span><br><span class="line">     TempData[i]= DuanMa[num];</span><br><span class="line">i++;</span><br><span class="line">if(i==9)//多出一个按键输入为了清屏 原本应该为8</span><br><span class="line">  &#123;</span><br><span class="line">  i=0;</span><br><span class="line">      for(j=0;j&lt;8;j++)//清屏</span><br><span class="line">         TempData[j]=0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  //Display(0,8); //显示全部8位</span><br><span class="line">     //主循环中添加其他需要一直工作的程序</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> uS延时函数，含有输入参数 unsigned char t，无返回值</span><br><span class="line"> unsigned char 是定义无符号字符变量，其值的范围是</span><br><span class="line"> 0~255 这里使用晶振12M，精确延时请使用汇编,大致延时</span><br><span class="line"> 长度如下 T=tx2+5 uS </span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void DelayUs2x(unsigned char t)</span><br><span class="line">&#123;   </span><br><span class="line"> while(--t);</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> mS延时函数，含有输入参数 unsigned char t，无返回值</span><br><span class="line"> unsigned char 是定义无符号字符变量，其值的范围是</span><br><span class="line"> 0~255 这里使用晶振12M，精确延时请使用汇编</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void DelayMs(unsigned char t)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line"> while(t--)</span><br><span class="line"> &#123;</span><br><span class="line">     //大致延时1mS</span><br><span class="line">     DelayUs2x(245);</span><br><span class="line"> DelayUs2x(245);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 显示函数，用于动态扫描数码管</span><br><span class="line"> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示</span><br><span class="line"> 如输入0表示从第一个显示。</span><br><span class="line"> Num表示需要显示的位数，如需要显示99两位数值则该值输入2</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num)</span><br><span class="line">&#123;</span><br><span class="line">      static unsigned char i=0;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">   DataPort=0;   //清空数据，防止有交替重影</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line"></span><br><span class="line">       DataPort= WeiMa[i+FirstBit]; //取位码 </span><br><span class="line">       LATCH2=1;     //位锁存</span><br><span class="line">       LATCH2=0;</span><br><span class="line"></span><br><span class="line">       DataPort=TempData[i]; //取显示数据，段码</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line">       </span><br><span class="line">   i++;</span><br><span class="line">       if(i==Num)</span><br><span class="line">      i=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    定时器初始化子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_Timer0(void)</span><br><span class="line">&#123;</span><br><span class="line"> TMOD |= 0x01;  //使用模式1，16位定时器，使用&quot;|&quot;符号可以在使用多个定时器时不受影响     </span><br><span class="line"> //TH0=0x00;      //给定初值</span><br><span class="line"> //TL0=0x00;</span><br><span class="line"> EA=1;            //总中断打开</span><br><span class="line"> ET0=1;           //定时器中断打开</span><br><span class="line"> TR0=1;           //定时器开关打开</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 定时器中断子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Timer0_isr(void) interrupt 1 </span><br><span class="line">&#123;</span><br><span class="line"> TH0=(65536-2000)/256;  //重新赋值 2ms</span><br><span class="line"> TL0=(65536-2000)%256;</span><br><span class="line"> </span><br><span class="line"> Display(0,8);       // 调用数码管扫描</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">          按键扫描函数，返回扫描键值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">unsigned char KeyScan(void)</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char keyvalue;</span><br><span class="line"> if(KeyPort!=0xff)</span><br><span class="line">   &#123;</span><br><span class="line">    DelayMs(10);</span><br><span class="line">    if(KeyPort!=0xff)</span><br><span class="line">   &#123;</span><br><span class="line">    keyvalue=KeyPort;</span><br><span class="line">    while(KeyPort!=0xff);</span><br><span class="line">switch(keyvalue)</span><br><span class="line">&#123;</span><br><span class="line"> case 0xfe:return 1;break;</span><br><span class="line"> case 0xfd:return 2;break;</span><br><span class="line"> case 0xfb:return 3;break;</span><br><span class="line"> case 0xf7:return 4;break;</span><br><span class="line"> case 0xef:return 5;break;</span><br><span class="line"> case 0xdf:return 6;break;</span><br><span class="line"> case 0xbf:return 7;break;</span><br><span class="line"> case 0x7f:return 8;break;</span><br><span class="line"> default:return 0;break;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周三 6月 29 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> <em>&#x2F;<br>&#x2F;</em>———————————————–</li></ul><p>  名称：单个独立按键依次输入控制<br>  内容：如计算器输入数据形式相同 从左往右 利用整个端口扫描读取按键值<br>————————————————*&#x2F;<br>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</p><p>#define KeyPort P1<br>#define DataPort P0 &#x2F;&#x2F;定义数据端口 程序中遇到DataPort 则用P0 替换</p><p>sbit LATCH1&#x3D;P2^2;&#x2F;&#x2F;定义锁存使能端口 段锁存<br>sbit LATCH2&#x3D;P2^3;&#x2F;&#x2F;                 位锁存</p><p>unsigned char code DuanMa[10]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F; 显示段码值0~9<br>unsigned char code WeiMa[]&#x3D;{0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};&#x2F;&#x2F;分别对应相应的数码管点亮,即位码<br>unsigned char TempData[10]; &#x2F;&#x2F;存储显示值的全局变量</p><p>void DelayUs2x(unsigned char t);&#x2F;&#x2F;us级延时函数声明<br>void DelayMs(unsigned char t); &#x2F;&#x2F;ms级延时<br>void Display(unsigned char FirstBit,unsigned char Num);&#x2F;&#x2F;数码管显示函数<br>unsigned char KeyScan(void);&#x2F;&#x2F;键盘扫描<br>void Init_Timer0(void);&#x2F;&#x2F;定时器初始化<br>&#x2F;<em>————————————————<br>                    主函数<br>————————————————</em>&#x2F;<br>void main (void)<br>{<br>unsigned char num,i,j;                  </p><p>Init_Timer0();</p><p>while (1)         &#x2F;&#x2F;主循环<br>  {<br> num&#x3D;KeyScan();<br> if(num)<br>   {<br>   if(i&lt;8)<br>     TempData[i]&#x3D; DuanMa[num];<br>    i++;<br>    if(i&#x3D;&#x3D;9)&#x2F;&#x2F;多出一个按键输入为了清屏 原本应该为8<br>      {<br>      i&#x3D;0;<br>      for(j&#x3D;0;j&lt;8;j++)&#x2F;&#x2F;清屏<br>         TempData[j]&#x3D;0;<br>       }<br>   }<br>  &#x2F;&#x2F;Display(0,8); &#x2F;&#x2F;显示全部8位<br>     &#x2F;&#x2F;主循环中添加其他需要一直工作的程序</p><p>  }<br>}<br>&#x2F;<em>————————————————<br> uS延时函数，含有输入参数 unsigned char t，无返回值<br> unsigned char 是定义无符号字符变量，其值的范围是<br> 0~255 这里使用晶振12M，精确延时请使用汇编,大致延时<br> 长度如下 T&#x3D;tx2+5 uS<br>————————————————</em>&#x2F;<br>void DelayUs2x(unsigned char t)<br>{<br> while(–t);<br>}<br>&#x2F;<em>————————————————<br> mS延时函数，含有输入参数 unsigned char t，无返回值<br> unsigned char 是定义无符号字符变量，其值的范围是<br> 0~255 这里使用晶振12M，精确延时请使用汇编<br>————————————————</em>&#x2F;<br>void DelayMs(unsigned char t)<br>{</p><p> while(t–)<br> {<br>     &#x2F;&#x2F;大致延时1mS<br>     DelayUs2x(245);<br>     DelayUs2x(245);<br> }<br>}<br>&#x2F;<em>————————————————<br> 显示函数，用于动态扫描数码管<br> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示<br> 如输入0表示从第一个显示。<br> Num表示需要显示的位数，如需要显示99两位数值则该值输入2<br>————————————————</em>&#x2F;<br>void Display(unsigned char FirstBit,unsigned char Num)<br>{<br>      static unsigned char i&#x3D;0;</p><pre><code>   DataPort=0;   //清空数据，防止有交替重影   LATCH1=1;     //段锁存   LATCH1=0;   DataPort= WeiMa[i+FirstBit]; //取位码    LATCH2=1;     //位锁存   LATCH2=0;   DataPort=TempData[i]; //取显示数据，段码   LATCH1=1;     //段锁存   LATCH1=0;      i++;   if(i==Num)      i=0;</code></pre><p>}<br>&#x2F;<em>————————————————<br>                    定时器初始化子程序<br>————————————————</em>&#x2F;<br>void Init_Timer0(void)<br>{<br> TMOD |&#x3D; 0x01;  &#x2F;&#x2F;使用模式1，16位定时器，使用”|”符号可以在使用多个定时器时不受影响<br> &#x2F;&#x2F;TH0&#x3D;0x00;      &#x2F;&#x2F;给定初值<br> &#x2F;&#x2F;TL0&#x3D;0x00;<br> EA&#x3D;1;            &#x2F;&#x2F;总中断打开<br> ET0&#x3D;1;           &#x2F;&#x2F;定时器中断打开<br> TR0&#x3D;1;           &#x2F;&#x2F;定时器开关打开<br>}<br>&#x2F;<em>————————————————<br>                 定时器中断子程序<br>————————————————</em>&#x2F;<br>void Timer0_isr(void) interrupt 1<br>{<br> TH0&#x3D;(65536-2000)&#x2F;256;  &#x2F;&#x2F;重新赋值 2ms<br> TL0&#x3D;(65536-2000)%256;</p><p> Display(0,8);       &#x2F;&#x2F; 调用数码管扫描</p><p>}</p><p>&#x2F;<em>————————————————<br>          按键扫描函数，返回扫描键值<br>————————————————</em>&#x2F;<br>unsigned char KeyScan(void)<br>{<br> unsigned char keyvalue;<br> if(KeyPort!&#x3D;0xff)<br>   {<br>    DelayMs(10);<br>    if(KeyPort!&#x3D;0xff)<br>       {<br>        keyvalue&#x3D;KeyPort;<br>        while(KeyPort!&#x3D;0xff);<br>        switch(keyvalue)<br>        {<br>         case 0xfe:return 1;break;<br>         case 0xfd:return 2;break;<br>         case 0xfb:return 3;break;<br>         case 0xf7:return 4;break;<br>         case 0xef:return 5;break;<br>         case 0xdf:return 6;break;<br>         case 0xbf:return 7;break;<br>         case 0x7f:return 8;break;<br>         default:return 0;break;<br>        }<br>      }<br>   }<br>   return 0;<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/18-s5W6zMmE5WO21AulUPfA </span><br><span class="line">提取码：gknh</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/18-s5W6zMmE5WO21AulUPfA  提取码：gknh</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】AT24C02数据读写+LCD1602显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FAT24C02%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99LCD1602%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FAT24C02%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99LCD1602%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】AT24C02数据读写-LCD1602显示"><a href="#【Proteus仿真】AT24C02数据读写-LCD1602显示" class="headerlink" title="【Proteus仿真】AT24C02数据读写+LCD1602显示"></a>【Proteus仿真】AT24C02数据读写+LCD1602显示</h1><h3 id="【Proteus仿真】AT24C02数据读写-LCD1602显示-1"><a href="#【Proteus仿真】AT24C02数据读写-LCD1602显示-1" class="headerlink" title="【Proteus仿真】AT24C02数据读写+LCD1602显示"></a>【Proteus仿真】AT24C02数据读写+LCD1602显示</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/e75def69e4af4f55a957cd9f72c16312.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><ol><li>AT24C02采用的IIC通讯，SCK:P20;SDA:P21</li><li>按键K1-K4分别接到P30-P33引脚上。</li></ol><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include &quot;LCD1602.h&quot;</span><br><span class="line">#include &quot;Key.h&quot;</span><br><span class="line">#include &quot;AT24C02.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line"></span><br><span class="line">unsigned char KeyNum;</span><br><span class="line">unsigned int Num;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">LCD_Init();</span><br><span class="line">LCD_ShowNum(1,1,Num,5);</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum=Key();</span><br><span class="line">if(KeyNum==1)//K1按键，Num自增P3_1</span><br><span class="line">&#123;</span><br><span class="line">Num++;</span><br><span class="line">LCD_ShowNum(1,1,Num,5);</span><br><span class="line">&#125;</span><br><span class="line">if(KeyNum==2)//K2按键，Num自减P3_0</span><br><span class="line">&#123;</span><br><span class="line">Num--;</span><br><span class="line">LCD_ShowNum(1,1,Num,5);</span><br><span class="line">&#125;</span><br><span class="line">if(KeyNum==3)//K3按键，向AT24C02写入数据P3_2</span><br><span class="line">&#123;</span><br><span class="line">AT24C02_WriteByte(0,Num%256);</span><br><span class="line">Delay(5);</span><br><span class="line">AT24C02_WriteByte(1,Num/256);</span><br><span class="line">Delay(5);</span><br><span class="line">LCD_ShowString(2,1,&quot;Write OK&quot;);</span><br><span class="line">Delay(1000);</span><br><span class="line">LCD_ShowString(2,1,&quot;        &quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(KeyNum==4)//K4按键，从AT24C02读取数据P3_4</span><br><span class="line">&#123;</span><br><span class="line">Num=AT24C02_ReadByte(0);</span><br><span class="line">Num|=AT24C02_ReadByte(1)&lt;&lt;8;</span><br><span class="line">LCD_ShowNum(1,1,Num,5);</span><br><span class="line">LCD_ShowString(2,1,&quot;Read OK &quot;);</span><br><span class="line">Delay(1000);</span><br><span class="line">LCD_ShowString(2,1,&quot;        &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;REGX52.H&gt;<br>#include “LCD1602.h”<br>#include “Key.h”<br>#include “AT24C02.h”<br>#include “Delay.h”</p><p>unsigned char KeyNum;<br>unsigned int Num;</p><p>void main()<br>{<br>    LCD_Init();<br>    LCD_ShowNum(1,1,Num,5);<br>    while(1)<br>    {<br>        KeyNum&#x3D;Key();<br>        if(KeyNum&#x3D;&#x3D;1)&#x2F;&#x2F;K1按键，Num自增P3_1<br>        {<br>            Num++;<br>            LCD_ShowNum(1,1,Num,5);<br>        }<br>        if(KeyNum&#x3D;&#x3D;2)&#x2F;&#x2F;K2按键，Num自减P3_0<br>        {<br>            Num–;<br>            LCD_ShowNum(1,1,Num,5);<br>        }<br>        if(KeyNum&#x3D;&#x3D;3)&#x2F;&#x2F;K3按键，向AT24C02写入数据P3_2<br>        {<br>            AT24C02_WriteByte(0,Num%256);<br>            Delay(5);<br>            AT24C02_WriteByte(1,Num&#x2F;256);<br>            Delay(5);<br>            LCD_ShowString(2,1,”Write OK”);<br>            Delay(1000);<br>            LCD_ShowString(2,1,”        “);<br>        }<br>        if(KeyNum&#x3D;&#x3D;4)&#x2F;&#x2F;K4按键，从AT24C02读取数据P3_4<br>        {<br>            Num&#x3D;AT24C02_ReadByte(0);<br>            Num|&#x3D;AT24C02_ReadByte(1)&lt;&lt;8;<br>            LCD_ShowNum(1,1,Num,5);<br>            LCD_ShowString(2,1,”Read OK “);<br>            Delay(1000);<br>            LCD_ShowString(2,1,”        “);<br>        }<br>    }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.9SP2平台</p><p><code>Proteus8.9SP2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1dt-wxFNmulZdwDDSQ2Y-Qw </span><br><span class="line">提取码：i6rs</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1dt-wxFNmulZdwDDSQ2Y-Qw  提取码：i6rs</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】BME280温湿度气压传感器数据串口输出</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FBME280%E6%B8%A9%E6%B9%BF%E5%BA%A6%E6%B0%94%E5%8E%8B%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%87%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FBME280%E6%B8%A9%E6%B9%BF%E5%BA%A6%E6%B0%94%E5%8E%8B%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】BME280温湿度气压传感器数据串口输出"><a href="#【Proteus仿真】BME280温湿度气压传感器数据串口输出" class="headerlink" title="【Proteus仿真】BME280温湿度气压传感器数据串口输出"></a>【Proteus仿真】BME280温湿度气压传感器数据串口输出</h1><h3 id="【Proteus仿真】BME280温湿度气压传感器数据串口输出-1"><a href="#【Proteus仿真】BME280温湿度气压传感器数据串口输出-1" class="headerlink" title="【Proteus仿真】BME280温湿度气压传感器数据串口输出"></a>【Proteus仿真】BME280温湿度气压传感器数据串口输出</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/582bb0b20e3a44c0b0b632b48a0aa746.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="BMP280资料下载链接："><a href="#BMP280资料下载链接：" class="headerlink" title="BMP280资料下载链接："></a>BMP280资料下载链接：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/s/1TyQGJQ6R30hntzGr1SaSNg </span><br><span class="line">提取码：8888</span><br></pre></td></tr></table></figure><p><code>https://pan.baidu.com/s/1TyQGJQ6R30hntzGr1SaSNg  提取码：8888</code></p><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><ul><li>I2C接口</li><li>SPI接口</li></ul><p><img src="https://img-blog.csdnimg.cn/b1b64f29b6f54163962bb7f58c3bf740.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/75d2a34dd8764917bed11f0300b089d9.png" alt="在这里插入图片描述"></p><h4 id="所需库"><a href="#所需库" class="headerlink" title="所需库"></a>所需库</h4><ul><li>Adafruit_Unified_Sensor</li><li>Adafruit_BME280</li><li>Adafruit_BusIO</li></ul><p>具体版本信息可以参考下面的编译信息。</p><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Wire.h&gt;</span><br><span class="line">#include &lt;SPI.h&gt;</span><br><span class="line">#include &lt;Adafruit_Sensor.h&gt;//点击这里会自动打开管理库页面: http://librarymanager/All#Adafruit_Sensor</span><br><span class="line">#include &lt;Adafruit_BME280.h&gt;//点击这里会自动打开管理库页面: http://librarymanager/All#Adafruit_BME280</span><br><span class="line"></span><br><span class="line">#define BME_SCK 13</span><br><span class="line">#define BME_MISO 12</span><br><span class="line">#define BME_MOSI 11</span><br><span class="line">#define BME_CS 10</span><br><span class="line"></span><br><span class="line">#define SEALEVELPRESSURE_HPA (1013.25)</span><br><span class="line"></span><br><span class="line">//Adafruit_BME280 bme; // I2C</span><br><span class="line">Adafruit_BME280 bme(BME_CS); // hardware SPI</span><br><span class="line">//Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK); // software SPI</span><br><span class="line"></span><br><span class="line">unsigned long delayTime;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  Serial.println(F(&quot;BME280 test&quot;));</span><br><span class="line"></span><br><span class="line">  bool status;</span><br><span class="line">  </span><br><span class="line">  // default settings</span><br><span class="line">  // (you can also pass in a Wire library object like &amp;Wire2)</span><br><span class="line">  status = bme.begin();  </span><br><span class="line">  if (!status) &#123;</span><br><span class="line">    Serial.println(&quot;Could not find a valid BME280 sensor, check wiring!&quot;);</span><br><span class="line">    while (1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Serial.println(&quot;-- Default Test --&quot;);</span><br><span class="line">  delayTime = 1000;</span><br><span class="line"></span><br><span class="line">  Serial.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void loop() &#123; </span><br><span class="line">  printValues();</span><br><span class="line">  delay(delayTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void printValues() &#123;</span><br><span class="line">  Serial.print(&quot;Temperature = &quot;);</span><br><span class="line">  Serial.print(bme.readTemperature());</span><br><span class="line">  Serial.println(&quot; *C&quot;);</span><br><span class="line">  </span><br><span class="line">  // Convert temperature to Fahrenheit</span><br><span class="line">  /*Serial.print(&quot;Temperature = &quot;);</span><br><span class="line">  Serial.print(1.8 * bme.readTemperature() + 32);</span><br><span class="line">  Serial.println(&quot; *F&quot;);*/</span><br><span class="line">  </span><br><span class="line">  Serial.print(&quot;Pressure = &quot;);</span><br><span class="line">  Serial.print(bme.readPressure() / 100.0F);</span><br><span class="line">  Serial.println(&quot; hPa&quot;);</span><br><span class="line">  </span><br><span class="line">  Serial.print(&quot;Approx. Altitude = &quot;);</span><br><span class="line">  Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));</span><br><span class="line">  Serial.println(&quot; m&quot;);</span><br><span class="line">  </span><br><span class="line">  Serial.print(&quot;Humidity = &quot;);</span><br><span class="line">  Serial.print(bme.readHumidity());</span><br><span class="line">  Serial.println(&quot; %&quot;);</span><br><span class="line">  </span><br><span class="line">  Serial.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;Wire.h&gt;<br>#include &lt;SPI.h&gt;<br>#include &lt;Adafruit_Sensor.h&gt;&#x2F;&#x2F;点击这里会自动打开管理库页面: <a href="http://librarymanager/All#Adafruit_Sensor">http://librarymanager/All#Adafruit_Sensor</a><br>#include &lt;Adafruit_BME280.h&gt;&#x2F;&#x2F;点击这里会自动打开管理库页面: <a href="http://librarymanager/All#Adafruit_BME280">http://librarymanager/All#Adafruit_BME280</a></p><p>#define BME_SCK 13<br>#define BME_MISO 12<br>#define BME_MOSI 11<br>#define BME_CS 10</p><p>#define SEALEVELPRESSURE_HPA (1013.25)</p><p>&#x2F;&#x2F;Adafruit_BME280 bme; &#x2F;&#x2F; I2C<br>Adafruit_BME280 bme(BME_CS); &#x2F;&#x2F; hardware SPI<br>&#x2F;&#x2F;Adafruit_BME280 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK); &#x2F;&#x2F; software SPI</p><p>unsigned long delayTime;</p><p>void setup() {<br>  Serial.begin(9600);<br>  Serial.println(F(“BME280 test”));</p><p>  bool status;</p><p>  &#x2F;&#x2F; default settings<br>  &#x2F;&#x2F; (you can also pass in a Wire library object like &amp;Wire2)<br>  status &#x3D; bme.begin();<br>  if (!status) {<br>    Serial.println(“Could not find a valid BME280 sensor, check wiring!”);<br>    while (1);<br>  }</p><p>  Serial.println(“– Default Test –”);<br>  delayTime &#x3D; 1000;</p><p>  Serial.println();<br>}</p><p>void loop() {<br>  printValues();<br>  delay(delayTime);<br>}</p><p>void printValues() {<br>  Serial.print(“Temperature &#x3D; “);<br>  Serial.print(bme.readTemperature());<br>  Serial.println(“ *C”);</p><p>  &#x2F;&#x2F; Convert temperature to Fahrenheit<br>  &#x2F;*Serial.print(“Temperature &#x3D; “);<br>  Serial.print(1.8 * bme.readTemperature() + 32);<br>  Serial.println(“ <em>F”);</em>&#x2F;</p><p>  Serial.print(“Pressure &#x3D; “);<br>  Serial.print(bme.readPressure() &#x2F; 100.0F);<br>  Serial.println(“ hPa”);</p><p>  Serial.print(“Approx. Altitude &#x3D; “);<br>  Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));<br>  Serial.println(“ m”);</p><p>  Serial.print(“Humidity &#x3D; “);<br>  Serial.print(bme.readHumidity());<br>  Serial.println(“ %”);</p><p>  Serial.println();<br>}&#96;</p><ul><li>编译信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_BusIO</span><br><span class="line">使用 1.0  版本的库 Wire 在文件夹： C:\Users\Administrator\AppData\Local\Arduino15\packages\arduino\hardware\avr\1.8.4\libraries\Wire </span><br><span class="line">使用 1.0  版本的库 SPI 在文件夹： C:\Users\Administrator\AppData\Local\Arduino15\packages\arduino\hardware\avr\1.8.4\libraries\SPI </span><br><span class="line">使用 1.1.4  版本的库 Adafruit_Unified_Sensor 在文件夹： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_Unified_Sensor </span><br><span class="line">使用 2.2.1  版本的库 Adafruit_BME280_Library 在文件夹： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_BME280_Library </span><br><span class="line">使用 1.9.8  版本的库 Adafruit_BusIO 在文件夹： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_BusIO </span><br><span class="line">&quot;C:\\Users\\Administrator\\AppData\\Local\\Arduino15\\packages\\arduino\\tools\\avr-gcc\\7.3.0-atmel3.6.1-arduino7/bin/avr-size&quot; -A &quot;d:\\arduino\\MyHexDir/bme280test.ino.elf&quot;</span><br><span class="line">项目使用了 13814 字节，占用了 (42%) 程序存储空间。最大为 32256 字节。</span><br><span class="line">全局变量使用了636字节，(31%)的动态内存，余留1412字节局部变量。最大为2048字节。</span><br></pre></td></tr></table></figure><p><code>使用： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_BusIO 使用 1.0  版本的库 Wire 在文件夹： C:\Users\Administrator\AppData\Local\Arduino15\packages\arduino\hardware\avr\1.8.4\libraries\Wire  使用 1.0  版本的库 SPI 在文件夹： C:\Users\Administrator\AppData\Local\Arduino15\packages\arduino\hardware\avr\1.8.4\libraries\SPI  使用 1.1.4  版本的库 Adafruit_Unified_Sensor 在文件夹： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_Unified_Sensor  使用 2.2.1  版本的库 Adafruit_BME280_Library 在文件夹： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_BME280_Library  使用 1.9.8  版本的库 Adafruit_BusIO 在文件夹： C:\Users\Administrator\Documents\Arduino\libraries\Adafruit_BusIO  &quot;C:\\Users\\Administrator\\AppData\\Local\\Arduino15\\packages\\arduino\\tools\\avr-gcc\\7.3.0-atmel3.6.1-arduino7/bin/avr-size&quot; -A &quot;d:\\arduino\\MyHexDir/bme280test.ino.elf&quot; 项目使用了 13814 字节，占用了 (42%) 程序存储空间。最大为 32256 字节。 全局变量使用了636字节，(31%)的动态内存，余留1412字节局部变量。最大为2048字节。</code></p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/10M_d51nd2jFMpm1RuORLLA </span><br><span class="line">提取码：reo8</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/10M_d51nd2jFMpm1RuORLLA  提取码：reo8</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】DS18B20+报警温度可调+LM016显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FDS18B20%E6%8A%A5%E8%AD%A6%E6%B8%A9%E5%BA%A6%E5%8F%AF%E8%B0%83LM016%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FDS18B20%E6%8A%A5%E8%AD%A6%E6%B8%A9%E5%BA%A6%E5%8F%AF%E8%B0%83LM016%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】DS18B20-报警温度可调-LM016显示"><a href="#【Proteus仿真】DS18B20-报警温度可调-LM016显示" class="headerlink" title="【Proteus仿真】DS18B20+报警温度可调+LM016显示"></a>【Proteus仿真】DS18B20+报警温度可调+LM016显示</h1><h3 id="【Proteus仿真】DS18B20-报警温度可调-LM016显示-1"><a href="#【Proteus仿真】DS18B20-报警温度可调-LM016显示-1" class="headerlink" title="【Proteus仿真】DS18B20+报警温度可调+LM016显示"></a>【Proteus仿真】DS18B20+报警温度可调+LM016显示</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/e50c6dbbb6504e079a26a311362910ba.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include&lt;1602.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">sbit ds   = P2^2;//ds18b20</span><br><span class="line">sbit beep = P2^3;//蜂鸣器报警</span><br><span class="line">sbit rd = P3^7;</span><br><span class="line">bit flag;</span><br><span class="line">uchar ds_rom[8];</span><br><span class="line">uchar H,L,Key_value;</span><br><span class="line">void TempDelay(uchar us)</span><br><span class="line">&#123;</span><br><span class="line">while(us--); //6.51us</span><br><span class="line">&#125;</span><br><span class="line">void ds_reset()</span><br><span class="line">&#123;</span><br><span class="line">ds=1;</span><br><span class="line">_nop_();</span><br><span class="line">ds=0;</span><br><span class="line">TempDelay(80);//520us</span><br><span class="line">ds=1;</span><br><span class="line">TempDelay(5);</span><br><span class="line">if(ds==0)</span><br><span class="line">flag=1;</span><br><span class="line">else</span><br><span class="line">flag=0;</span><br><span class="line">TempDelay(20);</span><br><span class="line">ds=1;</span><br><span class="line">&#125;</span><br><span class="line">bit ds_read_bit()</span><br><span class="line">&#123;</span><br><span class="line">bit dat;</span><br><span class="line">ds=0;</span><br><span class="line">_nop_();</span><br><span class="line">_nop_();</span><br><span class="line">ds=1;</span><br><span class="line">_nop_();</span><br><span class="line">dat=ds;</span><br><span class="line">TempDelay(12);</span><br><span class="line">return dat;</span><br><span class="line">&#125;</span><br><span class="line">uchar ds_read_byte()</span><br><span class="line">&#123;</span><br><span class="line">uchar i,j,value;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=ds_read_bit();</span><br><span class="line">value=(j&lt;&lt;7)|(value&gt;&gt;1);</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">void ds_write_byte(uchar dat)</span><br><span class="line">&#123;</span><br><span class="line">uchar i,onebit;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">onebit=dat&amp;0x01;</span><br><span class="line">if(onebit)   //д1</span><br><span class="line">&#123;</span><br><span class="line">ds=0;</span><br><span class="line">TempDelay(1);</span><br><span class="line">ds=1;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line">else  //д0</span><br><span class="line">&#123;</span><br><span class="line">ds=0;</span><br><span class="line">TempDelay(11);</span><br><span class="line">ds=1;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;</span><br><span class="line">dat&gt;&gt;=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ds_change()</span><br><span class="line">&#123;</span><br><span class="line">ds_reset();</span><br><span class="line">ds_write_byte(0xcc);</span><br><span class="line">ds_write_byte(0x44);</span><br><span class="line">&#125;</span><br><span class="line">uchar get_temperature()</span><br><span class="line">&#123;</span><br><span class="line">uint temp;</span><br><span class="line">uchar a,b,c;</span><br><span class="line">ds_reset();</span><br><span class="line">ds_write_byte(0xcc);</span><br><span class="line">ds_write_byte(0xbe);</span><br><span class="line">a=ds_read_byte();</span><br><span class="line">b=ds_read_byte();</span><br><span class="line">temp=b;</span><br><span class="line">temp&lt;&lt;=8;</span><br><span class="line">temp|=a;</span><br><span class="line">c = temp*0.0625;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void key()</span><br><span class="line">&#123;</span><br><span class="line">Key_value = P3;</span><br><span class="line">Key_value = Key_value &amp; 0x0f;</span><br><span class="line">if ( Key_value != 0x0f )</span><br><span class="line">&#123;</span><br><span class="line">delay(120);</span><br><span class="line">if(Key_value != 0x0f )&#123;</span><br><span class="line"></span><br><span class="line">switch(Key_value)</span><br><span class="line">&#123;</span><br><span class="line">case 0x0e: H++; break;//P30</span><br><span class="line">case 0x0d: H--; break;//P31</span><br><span class="line">case 0x0b: L++; break;//P32</span><br><span class="line">case 0x07: L--; break;//P33</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">rd = 0;</span><br><span class="line">init_1602();</span><br><span class="line"></span><br><span class="line">write_com( 0x80 + 0 + 3);</span><br><span class="line">write_data( &#x27;H&#x27; );</span><br><span class="line">write_com( 0x80 + 0 + 8);</span><br><span class="line">write_data( &#x27;L&#x27; );</span><br><span class="line"></span><br><span class="line">lcd_distostr(1,1,0);</span><br><span class="line"></span><br><span class="line">H = 40;</span><br><span class="line">L = 10;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">ds_change();</span><br><span class="line">i = get_temperature();</span><br><span class="line">lcd_dis( 1,14,uchartostr( i ) );</span><br><span class="line">lcd_dis( 0,5,uchartostr( H ) );</span><br><span class="line">lcd_dis( 0,10,uchartostr( L ) );</span><br><span class="line">if ( i &gt;= H || i &lt;= L)</span><br><span class="line">&#123;</span><br><span class="line"> beep = 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"> beep = 1;</span><br><span class="line">&#125;</span><br><span class="line">key(); </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include&lt;reg52.h&gt;<br>#include&lt;1602.h&gt;<br>#include&lt;intrins.h&gt;<br>sbit ds   &#x3D; P2^2;&#x2F;&#x2F;ds18b20<br>sbit beep &#x3D; P2^3;&#x2F;&#x2F;蜂鸣器报警<br>sbit rd &#x3D; P3^7;<br>bit flag;<br>uchar ds_rom[8];<br>uchar H,L,Key_value;<br>void TempDelay(uchar us)<br>{<br>    while(us–); &#x2F;&#x2F;6.51us<br>}<br>void ds_reset()<br>{<br>    ds&#x3D;1;<br>    <em>nop</em>();<br>    ds&#x3D;0;<br>    TempDelay(80);&#x2F;&#x2F;520us<br>    ds&#x3D;1;<br>    TempDelay(5);<br>    if(ds&#x3D;&#x3D;0)<br>        flag&#x3D;1;<br>    else<br>        flag&#x3D;0;<br>    TempDelay(20);<br>    ds&#x3D;1;<br>}<br>bit ds_read_bit()<br>{<br>    bit dat;<br>    ds&#x3D;0;<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    ds&#x3D;1;<br>    <em>nop</em>();<br>    dat&#x3D;ds;<br>    TempDelay(12);<br>    return dat;<br>}<br>uchar ds_read_byte()<br>{<br>    uchar i,j,value;<br>    for(i&#x3D;0;i&lt;8;i++)<br>    {<br>        j&#x3D;ds_read_bit();<br>        value&#x3D;(j&lt;&lt;7)|(value&gt;&gt;1);<br>    }<br>    return value;<br>}<br>void ds_write_byte(uchar dat)<br>{<br>    uchar i,onebit;<br>    for(i&#x3D;0;i&lt;8;i++)<br>    {<br>        onebit&#x3D;dat&0x01;<br>        if(onebit)   &#x2F;&#x2F;д1<br>        {<br>            ds&#x3D;0;<br>            TempDelay(1);<br>            ds&#x3D;1;<br>            _nop_();<br>        }<br>        else  &#x2F;&#x2F;д0<br>        {<br>            ds&#x3D;0;<br>            TempDelay(11);<br>            ds&#x3D;1;<br>            _nop_();<br>        }<br>        dat&gt;&gt;&#x3D;1;<br>    }<br>}</p><p>void ds_change()<br>{<br>    ds_reset();<br>    ds_write_byte(0xcc);<br>    ds_write_byte(0x44);<br>}<br>uchar get_temperature()<br>{<br>    uint temp;<br>    uchar a,b,c;<br>    ds_reset();<br>    ds_write_byte(0xcc);<br>    ds_write_byte(0xbe);<br>    a&#x3D;ds_read_byte();<br>    b&#x3D;ds_read_byte();<br>    temp&#x3D;b;<br>    temp&lt;&lt;&#x3D;8;<br>    temp|&#x3D;a;<br>    c &#x3D; temp*0.0625;<br>    return c;<br>}</p><p>void key()<br>{<br>    Key_value &#x3D; P3;<br>    Key_value &#x3D; Key_value &amp; 0x0f;<br>    if ( Key_value !&#x3D; 0x0f )<br>    {<br>        delay(120);<br>        if(Key_value !&#x3D; 0x0f ){</p><pre><code>        switch(Key_value)        &#123;            case 0x0e: H++; break;//P30            case 0x0d: H--; break;//P31            case 0x0b: L++; break;//P32            case 0x07: L--; break;//P33        &#125;    &#125;&#125;</code></pre><p>}</p><p>void main()<br>{<br>    uchar i;<br>    rd &#x3D; 0;<br>    init_1602();</p><pre><code>write_com( 0x80 + 0 + 3);write_data( &#39;H&#39; );write_com( 0x80 + 0 + 8);write_data( &#39;L&#39; );lcd_distostr(1,1,0);H = 40;L = 10;while(1)&#123;    ds_change();    i = get_temperature();    lcd_dis( 1,14,uchartostr( i ) );    lcd_dis( 0,5,uchartostr( H ) );    lcd_dis( 0,10,uchartostr( L ) );    if ( i &gt;= H || i &lt;= L)    &#123;     beep = 0;    &#125;    else    &#123;     beep = 1;    &#125;    key(); &#125;  </code></pre><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1cNOvEdcso85SK95N7-QrSA </span><br><span class="line">提取码：okxs</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1cNOvEdcso85SK95N7-QrSA  提取码：okxs</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】INT0和INT1中断计数</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FINT0%E5%92%8CINT1%E4%B8%AD%E6%96%AD%E8%AE%A1%E6%95%B0/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FINT0%E5%92%8CINT1%E4%B8%AD%E6%96%AD%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】INT0和INT1中断计数"><a href="#【Proteus仿真】INT0和INT1中断计数" class="headerlink" title="【Proteus仿真】INT0和INT1中断计数"></a>【Proteus仿真】INT0和INT1中断计数</h1><h3 id="【Proteus仿真】INT0和INT1中断计数-1"><a href="#【Proteus仿真】INT0和INT1中断计数-1" class="headerlink" title="【Proteus仿真】INT0和INT1中断计数"></a>【Proteus仿真】INT0和INT1中断计数</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/5ca54bf90a4f49538b45cadab6822c1d.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="中断相关寄存器"><a href="#中断相关寄存器" class="headerlink" title="中断相关寄存器"></a>中断相关寄存器</h4><ul><li>IE</li><li>IP</li><li>PS：串行口中断优先级控制位。</li><li>PT1：T1中断优先级控制位。</li><li>PX1：外部中断1优先级控制位。</li><li>PT0：T0中断优先级控制位。</li><li>PX0：外部中断0优先级控制位。</li></ul><p><img src="https://img-blog.csdnimg.cn/be9b149135074270b5e44676cbab58d6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/c392e47b3bc04bc6bbc8890e6970f372.png" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line">sbit k3 = P3^4;</span><br><span class="line">sbit k4 = P3^5;</span><br><span class="line"></span><br><span class="line">uchar code DSY_CODE[]=</span><br><span class="line">&#123;</span><br><span class="line"> 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff</span><br><span class="line">&#125;;//共阳段码</span><br><span class="line"></span><br><span class="line">uchar code Scan_BITs[]=</span><br><span class="line">&#123;</span><br><span class="line">  0x20,0x10,0x08,0x04,0x02,0x01</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar data Buffer_Counts[]=&#123;0,0,0,0,0,0&#125;;</span><br><span class="line">uint Count_A=0;</span><br><span class="line">uint Count_B=0;</span><br><span class="line"></span><br><span class="line">void DelayMS(uint x)</span><br><span class="line">&#123;</span><br><span class="line"> uchar t;</span><br><span class="line">while(x--)</span><br><span class="line">&#123;</span><br><span class="line"> for(t=0;t&lt;120;t++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Show_Counts()</span><br><span class="line">&#123;</span><br><span class="line"> uint i;</span><br><span class="line">Buffer_Counts[2] = Count_A / 100;</span><br><span class="line">Buffer_Counts[1] = Count_A % 100 /10;</span><br><span class="line">Buffer_Counts[0] = Count_A % 10;</span><br><span class="line">if(Buffer_Counts[2]==0)</span><br><span class="line">&#123;</span><br><span class="line"> Buffer_Counts[2] = 0x0a;</span><br><span class="line">if(Buffer_Counts[1]==0)</span><br><span class="line">&#123;</span><br><span class="line"> Buffer_Counts[1]=0x0a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Buffer_Counts[5] = Count_B / 100;</span><br><span class="line">Buffer_Counts[4] = Count_B % 100 /10;</span><br><span class="line">Buffer_Counts[3] = Count_B % 10;</span><br><span class="line">if(Buffer_Counts[5]==0)</span><br><span class="line">&#123;</span><br><span class="line"> Buffer_Counts[5] = 0x0a;</span><br><span class="line">if(Buffer_Counts[4]==0)</span><br><span class="line">&#123;</span><br><span class="line"> Buffer_Counts[4]=0x0a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;6;i++)</span><br><span class="line">&#123;</span><br><span class="line"> P2 = Scan_BITs[i];</span><br><span class="line">P1 = DSY_CODE[Buffer_Counts[i]];</span><br><span class="line">DelayMS(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> IT0 = 1;//启用外部中断0</span><br><span class="line">IT1 = 1;//启用外部中断1</span><br><span class="line">PX0 = 1;//设定外部中断0为最高优先级中断</span><br><span class="line">IE  = 0x85;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> if(k3 == 0) Count_A = 0;</span><br><span class="line">if(k4 == 0) Count_B = 0;</span><br><span class="line">Show_Counts();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*外部中断0函数*/</span><br><span class="line">void EX_INT0() interrupt 0</span><br><span class="line">&#123;</span><br><span class="line"> Count_A++;</span><br><span class="line">&#125;</span><br><span class="line">/*外部中断1函数*/</span><br><span class="line">void EX_INT1() interrupt 2</span><br><span class="line">&#123;</span><br><span class="line"> Count_B++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>sbit k3 &#x3D; P3^4;<br>sbit k4 &#x3D; P3^5;</p><p>uchar code DSY_CODE[]&#x3D;<br>{<br>     0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff<br>};&#x2F;&#x2F;共阳段码</p><p>uchar code Scan_BITs[]&#x3D;<br>{<br>      0x20,0x10,0x08,0x04,0x02,0x01<br>};</p><p>uchar data Buffer_Counts[]&#x3D;{0,0,0,0,0,0};<br>uint Count_A&#x3D;0;<br>uint Count_B&#x3D;0;</p><p>void DelayMS(uint x)<br>{<br>     uchar t;<br>    while(x–)<br>    {<br>     for(t&#x3D;0;t&lt;120;t++);<br>    }<br>}</p><p>void Show_Counts()<br>{<br>     uint i;<br>    Buffer_Counts[2] &#x3D; Count_A &#x2F; 100;<br>    Buffer_Counts[1] &#x3D; Count_A % 100 &#x2F;10;<br>    Buffer_Counts[0] &#x3D; Count_A % 10;<br>    if(Buffer_Counts[2]&#x3D;&#x3D;0)<br>    {<br>     Buffer_Counts[2] &#x3D; 0x0a;<br>        if(Buffer_Counts[1]&#x3D;&#x3D;0)<br>        {<br>         Buffer_Counts[1]&#x3D;0x0a;<br>        }<br>    }</p><pre><code>Buffer_Counts[5] = Count_B / 100;Buffer_Counts[4] = Count_B % 100 /10;Buffer_Counts[3] = Count_B % 10;if(Buffer_Counts[5]==0)&#123; Buffer_Counts[5] = 0x0a;    if(Buffer_Counts[4]==0)    &#123;     Buffer_Counts[4]=0x0a;    &#125;&#125;for(i=0;i&lt;6;i++)&#123; P2 = Scan_BITs[i];    P1 = DSY_CODE[Buffer_Counts[i]];    DelayMS(1);&#125;</code></pre><p>}</p><p>void main()<br>{<br>     IT0 &#x3D; 1;&#x2F;&#x2F;启用外部中断0<br>    IT1 &#x3D; 1;&#x2F;&#x2F;启用外部中断1<br>    PX0 &#x3D; 1;&#x2F;&#x2F;设定外部中断0为最高优先级中断<br>    IE  &#x3D; 0x85;<br>    while(1)<br>    {<br>     if(k3 &#x3D;&#x3D; 0) Count_A &#x3D; 0;<br>        if(k4 &#x3D;&#x3D; 0) Count_B &#x3D; 0;<br>        Show_Counts();<br>    }<br>}<br>&#x2F;<em>外部中断0函数</em>&#x2F;<br>void EX_INT0() interrupt 0<br>{<br>     Count_A++;<br>}<br>&#x2F;<em>外部中断1函数</em>&#x2F;<br>void EX_INT1() interrupt 2<br>{<br>     Count_B++;<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里插入代码片</span><br></pre></td></tr></table></figure><p><code>在这里插入代码片</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】HC-SRF04超声波测距传感器数码管显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FHCSRF04%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FHCSRF04%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】HC-SRF04超声波测距传感器数码管显示"><a href="#【Proteus仿真】HC-SRF04超声波测距传感器数码管显示" class="headerlink" title="【Proteus仿真】HC-SRF04超声波测距传感器数码管显示"></a>【Proteus仿真】HC-SRF04超声波测距传感器数码管显示</h1><h3 id="【Proteus仿真】HC-SRF04超声波测距传感器数码管显示-1"><a href="#【Proteus仿真】HC-SRF04超声波测距传感器数码管显示-1" class="headerlink" title="【Proteus仿真】HC-SRF04超声波测距传感器数码管显示"></a>【Proteus仿真】HC-SRF04超声波测距传感器数码管显示</h3><ul><li>VSM Studio Proteus仿真演示</li><li>实验基于VSM Studio代码编译和仿真一体，可以不依赖外部导入Hex文件进行仿真，本实验同时保留Keil工程。</li></ul><p><img src="https://img-blog.csdnimg.cn/b796012f7bd044e6bd0c9c505ca49365.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef unsigned char uchar;</span><br><span class="line">typedef unsigned int  uint;</span><br><span class="line"> </span><br><span class="line">sbit Tr=P1^0;//触发信号</span><br><span class="line">sbit Ec=P1^1;//回响信号</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void Delay10us(void);//10us延时函数</span><br><span class="line">void Delayms(unsigned int z);//ms延时函数</span><br><span class="line">uint Read_value(void);//读值函数</span><br><span class="line">void InitTimer0(void);//定时器0初始化</span><br><span class="line">void show(uint Out);//显示函数</span><br><span class="line"> </span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">Tr=0;//出发引脚首先拉低</span><br><span class="line">InitTimer0();//初始化定时器0</span><br><span class="line">while(1)&#123;</span><br><span class="line">show(Read_value());//显示距离</span><br><span class="line">Delayms(5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/********************读值函数***********************/</span><br><span class="line">uint Read_value()</span><br><span class="line">&#123;</span><br><span class="line">uint result;</span><br><span class="line">Tr=1;//触发引脚发出11us的触发信号（至少10us）</span><br><span class="line">Delay10us();</span><br><span class="line">Tr=0;</span><br><span class="line">while(!Ec);//度过回响信号的低电平</span><br><span class="line">TR0=1;//开启定时器0</span><br><span class="line">while(Ec);//度过回响信号高电平</span><br><span class="line">TR0=0;//关闭定时器0</span><br><span class="line">result=((TH0*256+TL0)*0.034)/2;// 距离cm=（时间us * 速度cm/us）/2</span><br><span class="line">return result + 1;//+1修正补偿</span><br><span class="line">&#125;</span><br><span class="line">/***********************10us延时函数*****************************/</span><br><span class="line">void Delay10us()</span><br><span class="line">&#123;</span><br><span class="line">TL0=0xF6;</span><br><span class="line">TH0=0xFF;</span><br><span class="line">TR0=1;</span><br><span class="line">while (TF0==0);</span><br><span class="line">TR0=0;</span><br><span class="line">TF0=0;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">/***********************ms延时函数*****************************/</span><br><span class="line">void Delayms(unsigned int z)   </span><br><span class="line">&#123;</span><br><span class="line">uint i,j;</span><br><span class="line">for(i=0;i&lt;z;i++)</span><br><span class="line">for(j=0;j&lt;112;j++);</span><br><span class="line">//延时函数</span><br><span class="line">&#125;</span><br><span class="line">/************************定时器0初始化*****************************/</span><br><span class="line">void InitTimer0(void)</span><br><span class="line">&#123;// 选择定时器0，并且确定是工作方式1（为了超声波模块测量距离计时用的）</span><br><span class="line">    TMOD = 0x01;</span><br><span class="line">    TH0 = 0x00;</span><br><span class="line">    TL0 = 0x00;</span><br><span class="line">    TR0 = 0;//先关闭定时器0</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**********************显示函数*************************************/</span><br><span class="line">void Show(uint Out)</span><br><span class="line">&#123;</span><br><span class="line">char duan[10]=&#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90&#125;;//段码</span><br><span class="line">P2=0x01;//第四位（个位）</span><br><span class="line">Delay10us();</span><br><span class="line">P0=duan[Out%1000%100%10];</span><br><span class="line">Delayms(1);</span><br><span class="line">P0=0xff;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">P2=0x02;//第三位（十位）</span><br><span class="line">Delay10us();</span><br><span class="line">P0=duan[Out%1000%100/10];</span><br><span class="line">Delayms(1);</span><br><span class="line">P0=0xff;</span><br><span class="line"> </span><br><span class="line">P2=0x04;//第二位（百位）</span><br><span class="line">Delay10us();</span><br><span class="line">P0=duan[Out%1000/100];</span><br><span class="line">Delayms(1);</span><br><span class="line">P0=0xff;</span><br><span class="line"> </span><br><span class="line">P2=0x08;//第一位（千位）</span><br><span class="line">Delay10us();</span><br><span class="line">P0=duan[Out/1000];</span><br><span class="line">Delayms(1);</span><br><span class="line">P0=0xff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include&lt;reg52.h&gt;<br>#include&lt;intrins.h&gt;</p><p>typedef unsigned char uchar;<br>typedef unsigned int  uint;</p><p>sbit Tr&#x3D;P1^0;&#x2F;&#x2F;触发信号<br>sbit Ec&#x3D;P1^1;&#x2F;&#x2F;回响信号</p><p>void Delay10us(void);&#x2F;&#x2F;10us延时函数<br>void Delayms(unsigned int z);&#x2F;&#x2F;ms延时函数<br>uint Read_value(void);&#x2F;&#x2F;读值函数<br>void InitTimer0(void);&#x2F;&#x2F;定时器0初始化<br>void show(uint Out);&#x2F;&#x2F;显示函数</p><p>void main()<br>{<br>    Tr&#x3D;0;&#x2F;&#x2F;出发引脚首先拉低<br>    InitTimer0();&#x2F;&#x2F;初始化定时器0<br>    while(1){<br>    show(Read_value());&#x2F;&#x2F;显示距离<br>        Delayms(5);<br>    }<br>}</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>读值函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><em>**&#x2F;<br>uint Read_value()<br>{<br>    uint result;<br>    Tr&#x3D;1;&#x2F;&#x2F;触发引脚发出11us的触发信号（至少10us）<br>    Delay10us();<br>    Tr&#x3D;0;<br>    while(!Ec);&#x2F;&#x2F;度过回响信号的低电平<br>    TR0&#x3D;1;&#x2F;&#x2F;开启定时器0<br>    while(Ec);&#x2F;&#x2F;度过回响信号高电平<br>    TR0&#x3D;0;&#x2F;&#x2F;关闭定时器0<br>    result&#x3D;((TH0<em>256+TL0)<em>0.034)&#x2F;2;&#x2F;&#x2F; 距离cm&#x3D;（时间us * 速度cm&#x2F;us）&#x2F;2<br>    return result + 1;&#x2F;&#x2F;+1修正补偿<br>}<br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>10us延时函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em></em></em></em>***&#x2F;<br>void Delay10us()<br>{<br>    TL0&#x3D;0xF6;<br>    TH0&#x3D;0xFF;<br>    TR0&#x3D;1;<br>    while (TF0&#x3D;&#x3D;0);<br>    TR0&#x3D;0;<br>    TF0&#x3D;0;</p><p>}<br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>ms延时函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>******&#x2F;<br>void Delayms(unsigned int z)<br>{<br>    uint i,j;<br>    for(i&#x3D;0;i&lt;z;i++)<br>        for(j&#x3D;0;j&lt;112;j++);<br>    &#x2F;&#x2F;延时函数<br>}<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>定时器0初始化</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*****&#x2F;<br>void InitTimer0(void)<br>{&#x2F;&#x2F; 选择定时器0，并且确定是工作方式1（为了超声波模块测量距离计时用的）<br>    TMOD &#x3D; 0x01;<br>    TH0 &#x3D; 0x00;<br>    TL0 &#x3D; 0x00;<br>    TR0 &#x3D; 0;&#x2F;&#x2F;先关闭定时器0<br>}</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>显示函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>***************&#x2F;<br>void Show(uint Out)<br>{<br>    char duan[10]&#x3D;{0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};&#x2F;&#x2F;段码<br>        P2&#x3D;0x01;&#x2F;&#x2F;第四位（个位）<br>        Delay10us();<br>        P0&#x3D;duan[Out%1000%100%10];<br>        Delayms(1);<br>        P0&#x3D;0xff;</p><pre><code>    P2=0x02;//第三位（十位）    Delay10us();    P0=duan[Out%1000%100/10];    Delayms(1);    P0=0xff;    P2=0x04;//第二位（百位）    Delay10us();    P0=duan[Out%1000/100];    Delayms(1);    P0=0xff;    P2=0x08;//第一位（千位）    Delay10us();    P0=duan[Out/1000];    Delayms(1);    P0=0xff;</code></pre><p>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1kc54kzA6tlY83FIPMqALmg </span><br><span class="line">提取码：ujr2</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1kc54kzA6tlY83FIPMqALmg  提取码：ujr2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】LCD1602字符滚动显示示例</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FLCD1602%E5%AD%97%E7%AC%A6%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA%E7%A4%BA%E4%BE%8B/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FLCD1602%E5%AD%97%E7%AC%A6%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】LCD1602字符滚动显示示例"><a href="#【Proteus仿真】LCD1602字符滚动显示示例" class="headerlink" title="【Proteus仿真】LCD1602字符滚动显示示例"></a>【Proteus仿真】LCD1602字符滚动显示示例</h1><h3 id="【Proteus仿真】LCD1602字符滚动显示示例-1"><a href="#【Proteus仿真】LCD1602字符滚动显示示例-1" class="headerlink" title="【Proteus仿真】LCD1602字符滚动显示示例"></a>【Proteus仿真】LCD1602字符滚动显示示例</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/eb0d77650dd74378818c62a5778685ca.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**************************************************************************************</span><br><span class="line"></span><br><span class="line">示例名称：LCD1602滚动显示</span><br><span class="line">  </span><br><span class="line">***************************************************************************************/</span><br><span class="line">#include &quot;public.h&quot;</span><br><span class="line">#include &quot;lcd1602.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern void lcd1602_write_cmd(u8 cmd);</span><br><span class="line">extern void lcd1602_write_data(u8 dat); </span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名       : main</span><br><span class="line">* 函数功能 : 主函数</span><br><span class="line">* 输    入       : 无</span><br><span class="line">* 输    出     : 无</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">u8 i=0;</span><br><span class="line">code u8 gshowbufa[]=&quot; LCD1602 scroll... &quot;;</span><br><span class="line">code u8 gshowbufb[]=&quot;perseverance51&quot;;</span><br><span class="line"></span><br><span class="line">lcd1602_init();</span><br><span class="line">lcd1602_show_string(0,0,gshowbufa);</span><br><span class="line">lcd1602_show_string(0,1,gshowbufb);</span><br><span class="line">lcd1602_write_cmd(0x07);//每写一个数据屏幕就要右移一位，就相对于数据来说就是左移了</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">lcd1602_write_cmd(0x80);</span><br><span class="line">for(i=0;i&lt;16;i++)</span><br><span class="line">&#123;</span><br><span class="line">lcd1602_write_data(gshowbufa[i]);</span><br><span class="line">delay_ms(300);//滚动时速度调节</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;**************************************************************************************</p><p>示例名称：LCD1602滚动显示</p><p>***************************************************************************************&#x2F;<br>#include “public.h”<br>#include “lcd1602.h”</p><p>extern void lcd1602_write_cmd(u8 cmd);<br>extern void lcd1602_write_data(u8 dat);<br>&#x2F;*******************************************************************************</p><ul><li><p>函 数 名       : main</p></li><li><p>函数功能 : 主函数</p></li><li><p>输    入       : 无</p></li><li><p>输    出     : 无<br>*******************************************************************************&#x2F;<br>void main()<br>{<br>  u8 i&#x3D;0;<br>code u8 gshowbufa[]&#x3D;” LCD1602 scroll… “;<br>code u8 gshowbufb[]&#x3D;”perseverance51”;</p><p>  lcd1602_init();<br>  lcd1602_show_string(0,0,gshowbufa);<br>  lcd1602_show_string(0,1,gshowbufb);<br>  lcd1602_write_cmd(0x07);&#x2F;&#x2F;每写一个数据屏幕就要右移一位，就相对于数据来说就是左移了<br>  while(1)<br>  {<br>  lcd1602_write_cmd(0x80);<br>  for(i&#x3D;0;i&lt;16;i++)<br>  {<br>      lcd1602_write_data(gshowbufa[i]);<br>      delay_ms(300);&#x2F;&#x2F;滚动时速度调节<br>  }<br>  }</p></li></ul><p>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1raps-9mhwa66XO_n0CjMcQ </span><br><span class="line">提取码：wblz</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1raps-9mhwa66XO_n0CjMcQ  提取码：wblz</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】L297驱动步进电机</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FL297%E9%A9%B1%E5%8A%A8%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FL297%E9%A9%B1%E5%8A%A8%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】L297驱动步进电机"><a href="#【Proteus仿真】L297驱动步进电机" class="headerlink" title="【Proteus仿真】L297驱动步进电机"></a>【Proteus仿真】L297驱动步进电机</h1><h3 id="【Proteus仿真】L297驱动步进电机-1"><a href="#【Proteus仿真】L297驱动步进电机-1" class="headerlink" title="【Proteus仿真】L297驱动步进电机"></a>【Proteus仿真】L297驱动步进电机</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/e94a412ae3b34aceb851ede765e5824f.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="L297引脚功能简介"><a href="#L297引脚功能简介" class="headerlink" title="L297引脚功能简介"></a>L297引脚功能简介</h4><p><img src="https://img-blog.csdnimg.cn/74c9d74ebc014ad5a45fdd0196161c6a.png" alt="在这里插入图片描述"></p><ul><li><p>1 脚(SYNG)——斩波器输出端。如多个 297 同步控制，所有的 SYNC 端都要连在一起，共用一套振荡元件。如果使用外部时钟源，则时钟信号接到此引脚上。</p></li><li><p>2 脚(GND)——接地端。</p></li><li><p>3 脚(HOME)——集电极开路输出端。当 L297 在初始状态(ABCD&#x3D;0101)时，此端有指示。当此引脚有效时，晶体管开路。</p></li><li><p>4 脚(A)——A 相驱动信号。</p></li><li><p>5 脚(  </p><pre><code>     INH1             ‾              \overline&#123;\text&#123;INH1&#125;&#125;    </code></pre><p>   INH1)——控制 A 相和 B 相的驱动极。当此引脚为低电平时，A 相、B 相驱动控制被禁止；当线圈级断电时，双极性桥用这个信号使负载电源快速衰减。若 CONTROL 端输入是低电平时，用斩波器调节负载电流。</p></li><li><p>6 脚(B)——B 相驱动信号。</p></li><li><p>7 脚©——C 相驱动信号。</p></li><li><p>8 脚(  </p><pre><code>     INH2             ‾              \overline&#123;\text&#123;INH2&#125;&#125;    </code></pre><p>   INH2)——控制 C 相和 D 相的驱动级。作用同 INH1 相同。</p></li><li><p>9 脚(D)——D 相驱动信号。</p></li><li><p>10 脚(ENABLE)——L297 的使能输入端。当它为低电平时，INH1，INH2，A，B，C，D 都为低电平。当系统被复位时用来阻止电机驱动。</p></li><li><p>11 脚(CONTROL)——斩波器功能控制端。低电平时使INH1和INH2起作用，高电平时使 A，B，C，D 起作用。</p></li><li><p>12 脚(Vcc)——+5V 电源输入端。</p></li><li><p>13 脚(SENS2)——C 相、D 相绕组电流检测电压反馈输入端。</p></li><li><p>14 脚(SENS1)——A 相、B 相绕组电流检测电压反馈输入端。</p></li><li><p>15 脚(Vref )——斩波器基准电压输入端。加到此引脚的电压决定绕组电流的峰值。</p></li><li><p>16 脚(OSC)——斩波器频率输入端。一个 RC 网络接至此引角以决定斩波器频率，在多个 L297 同步工作时其中一个接到 RC 网络，其余的此引角接地，各个器件的脚 I (SYNC)应连接到一起这样可杂波的引入问题如图 5 所示。</p></li><li><p>17 脚(CW&#x2F;  </p><pre><code>     CCW             ‾              \overline&#123;\text&#123;CCW&#125;&#125;    </code></pre><p>   CCW)—方向控制端。步进电机实际旋转方向由绕组的连接方法决定。当改变此引脚的电平状态时，步进电机反向旋转。</p></li><li><p>18 脚(CLOCK)——步进时钟输入端。该引脚输入负脉冲时步进电机向前步进一个增量，该步进是在信号 的上升沿产生。</p></li><li><p>19 脚(HALF&#x2F;  </p><pre><code>     FULL             ‾              \overline&#123;\text&#123;FULL&#125;&#125;    </code></pre><p>   FULL)——半步、全步方式 选择端。此引脚输入高电平时为半步方式(四相八拍)，低电平时为全步方式。如选择全步方式时变换器在奇数状态，会得到单相工作方式(单四拍)。</p></li><li><p>20 脚(  </p><pre><code>     RESET             ‾              \overline&#123;\text&#123;RESET&#125;&#125;    </code></pre><p>   RESET)——复位输入端。此引脚输入负脉冲时，变换器恢复初始状态 (ABCD&#x3D;0101)。</p></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>L297 驱动相序的产生</li></ul><p>L297 能产生单四拍、双四拍和四相八拍工作所需的适当相序。3 种方式的驱动相序都可以很容易地根据变换器输出的格雷码的顺序产生，格雷码的顺序直接与四八拍(半步方式)相符合 ，只要在脚 19 输入一高电平即可得到.</p><ul><li>通过交替跳过在八步顺序中的状态就可以得到全步工作方式，此时需在脚 19 接一低电平，前已述及根据变换器的状态可得到四拍或双四拍 2 种工作模式</li></ul><h4 id="仿真说明"><a href="#仿真说明" class="headerlink" title="仿真说明"></a>仿真说明</h4><p>注意L297的输出引脚接步进电机的相序，与其他的驱动相序有所差异，如果相序不是按照此接法，仿真时，电机是正反一定角度的摆动效果，而不是做圆周运动的效果。</p><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/********************************************************************</span><br><span class="line"> L297驱动步进电机</span><br><span class="line">*********************************************************************/</span><br><span class="line">#include&lt;reg52.h&gt; </span><br><span class="line"></span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> 控制位定义</span><br><span class="line">********************************************************/</span><br><span class="line"></span><br><span class="line">sbit shi_neng=P2^0;  //使能控制位</span><br><span class="line">sbit fang_shi=P2^1;  //工作方式控制位，半步、全步方式 选择端。此引脚输入高电平时为半步方式(四相八拍)，</span><br><span class="line">//低电平时为全步方式。如选择全步方式时变换器在奇数状态，会得到单相工作方式(单四拍)。</span><br><span class="line">sbit fang_xiang=P2^2;//旋转方向控制位</span><br><span class="line">sbit mai_chong=P2^3; // 脉冲控制位</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> 延时函数</span><br><span class="line">********************************************************/</span><br><span class="line">void delay(uint i)//延时函数</span><br><span class="line">&#123;</span><br><span class="line">uchar j,k;</span><br><span class="line">for(j=0;j&lt;i;j++)</span><br><span class="line">for(k=0;k&lt;250;k++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************************************************</span><br><span class="line"> 延时函数</span><br><span class="line">********************************************************/</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">shi_neng=1;  //使能控制位</span><br><span class="line">fang_shi=0;  //工作方式控制位,高电平时为半步方式(四相八拍)，低电平时为全步方式</span><br><span class="line">fang_xiang=1;//旋转方向控制位</span><br><span class="line">mai_chong=1; // 脉冲控制位</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">mai_chong=~mai_chong; //输出时钟脉冲</span><br><span class="line">delay(15);  //延时  (括号内数值越小，电机转动速度越快)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;********************************************************************<br> L297驱动步进电机<br>*********************************************************************&#x2F;<br>#include&lt;reg52.h&gt; </p><p>#define uchar unsigned char<br>#define uint unsigned int</p><p>&#x2F;********************************************************<br>                         控制位定义<br>********************************************************&#x2F;</p><p>sbit shi_neng&#x3D;P2^0;  &#x2F;&#x2F;使能控制位<br>sbit fang_shi&#x3D;P2^1;  &#x2F;&#x2F;工作方式控制位，半步、全步方式 选择端。此引脚输入高电平时为半步方式(四相八拍)，<br>&#x2F;&#x2F;低电平时为全步方式。如选择全步方式时变换器在奇数状态，会得到单相工作方式(单四拍)。<br>sbit fang_xiang&#x3D;P2^2;&#x2F;&#x2F;旋转方向控制位<br>sbit mai_chong&#x3D;P2^3; &#x2F;&#x2F; 脉冲控制位</p><p>&#x2F;********************************************************<br>                         延时函数<br>********************************************************&#x2F;<br>void delay(uint i)&#x2F;&#x2F;延时函数<br>{<br>    uchar j,k;<br>    for(j&#x3D;0;j&lt;i;j++)<br>    for(k&#x3D;0;k&lt;250;k++);<br>}</p><p>&#x2F;********************************************************<br>                         延时函数<br>********************************************************&#x2F;</p><p>void main()<br>{<br>    shi_neng&#x3D;1;  &#x2F;&#x2F;使能控制位<br>    fang_shi&#x3D;0;  &#x2F;&#x2F;工作方式控制位,高电平时为半步方式(四相八拍)，低电平时为全步方式<br>    fang_xiang&#x3D;1;&#x2F;&#x2F;旋转方向控制位<br>    mai_chong&#x3D;1; &#x2F;&#x2F; 脉冲控制位</p><pre><code>while(1)&#123;    mai_chong=~mai_chong; //输出时钟脉冲    delay(15);  //延时  (括号内数值越小，电机转动速度越快)&#125;</code></pre><p>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1-EAthEFP_O7cM3xziU1MUg </span><br><span class="line">提取码：mnlm</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1-EAthEFP_O7cM3xziU1MUg  提取码：mnlm</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】NE555延时电路</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FNE555%E5%BB%B6%E6%97%B6%E7%94%B5%E8%B7%AF/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FNE555%E5%BB%B6%E6%97%B6%E7%94%B5%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】NE555延时电路"><a href="#【Proteus仿真】NE555延时电路" class="headerlink" title="【Proteus仿真】NE555延时电路"></a>【Proteus仿真】NE555延时电路</h1><h3 id="【Proteus仿真】NE555延时电路-1"><a href="#【Proteus仿真】NE555延时电路-1" class="headerlink" title="【Proteus仿真】NE555延时电路"></a>【Proteus仿真】NE555延时电路</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/a75e4a3b436147d8af48eb344e85f936.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">sbit Signal = P1^0;</span><br><span class="line">sbit BEEP = P3^7;//蜂鸣器</span><br><span class="line"></span><br><span class="line">void Delay(uint x)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">while(x--)</span><br><span class="line">&#123;</span><br><span class="line"> for(i=0;i&lt;80;i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line">&#123;</span><br><span class="line"> if(Signal)</span><br><span class="line">&#123;</span><br><span class="line">BEEP=~BEEP;</span><br><span class="line">Delay(4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char</p><p>sbit Signal &#x3D; P1^0;<br>sbit BEEP &#x3D; P3^7;&#x2F;&#x2F;蜂鸣器</p><p>void Delay(uint x)<br>{<br>     uchar i;<br>    while(x–)<br>    {<br>     for(i&#x3D;0;i&lt;80;i++);<br>    }<br>}</p><p>void main()<br>{<br>     while(1)<br>    {<br>     if(Signal)<br>        {<br>            BEEP&#x3D;~BEEP;<br>            Delay(4);<br>        }<br>    }<br>}&#96;</p><h4 id="仿真资源和程序"><a href="#仿真资源和程序" class="headerlink" title="仿真资源和程序"></a>仿真资源和程序</h4><p>本示例基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1dJKss-03T9zR-w4M2o0gjw </span><br><span class="line">提取码：qgsg</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1dJKss-03T9zR-w4M2o0gjw  提取码：qgsg</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FT6963C%E9%A9%B1%E5%8A%A8PG12864%E7%A4%BA%E4%BE%8B%E5%B8%A6%E4%B8%AD%E8%8B%B1%E6%96%87%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FT6963C%E9%A9%B1%E5%8A%A8PG12864%E7%A4%BA%E4%BE%8B%E5%B8%A6%E4%B8%AD%E8%8B%B1%E6%96%87%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）"><a href="#【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）" class="headerlink" title="【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）"></a>【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）</h1><h3 id="【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）-1"><a href="#【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）-1" class="headerlink" title="【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）"></a>【Proteus仿真】T6963C驱动PG12864示例（带中英文显示）</h3><ul><li>Proteus仿真演示</li><li>屏幕为T6963C驱动控制的</li></ul><p><img src="https://img-blog.csdnimg.cn/25617256699f470fbd1c0f767d498026.gif#pic_center" alt="在这里插入图片描述"></p><p><code>T6963C</code></p><p><img src="https://img-blog.csdnimg.cn/43a3e1e6b8d94a3fa734deba3dd0fb60.png" alt="在这里插入图片描述"></p><h4 id="汉字取模工具和方式"><a href="#汉字取模工具和方式" class="headerlink" title="汉字取模工具和方式"></a>汉字取模工具和方式</h4><ul><li>取模软件：PCtoLCD2002</li><li>取模方式;阴码、行列式、顺向、C51格式</li><li>取模方式;阴码、行列式、顺向、C51格式</li><li>仿真以及相关说明</li></ul><p><code>PCtoLCD2002</code></p><ul><li>取模方式;阴码、行列式、顺向、C51格式</li></ul><p><img src="https://img-blog.csdnimg.cn/a0fcb71a1c244d01936c7b0bd33e7e50.png" alt="在这里插入图片描述"></p><p>如果P0接入了上拉电阻，则启动运行仿真时，显示比较慢大概等待15秒左右，.在实际项目开发过程中尽量放弃使用这种屏幕，主要是因为这个屏幕价格太贵，资料太少。不推崇使用，这里仅仅是仿真演示使用。</p><ul><li>P0口作为总线扩展用时，不用加上拉,在仿真时如果没有加上拉，启动运行仿真，显示画面很快就可以显示出来。</li></ul><p><code>P0</code></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//附录 B 文本方式显示汉字程序</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line">#include&lt;T6963C.h&gt;</span><br><span class="line">#include&lt;DATA.h&gt;</span><br><span class="line">#define lcmcom XBYTE[0x3fff] /*T6963C 写命令口地址，读数据口地址*/</span><br><span class="line">#define lcmdata XBYTE[0x3eff] /*T6963C 写数据口地址*/</span><br><span class="line"></span><br><span class="line">void DelayMs(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char j;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">for(j=0;j&lt;113;j++)</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">init_lcm(); //LCM 初始化</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">clear_lcm(); //LCM 清屏</span><br><span class="line">display_c(0,1,0,5);//从table[0]，从第0行的1位置开始显示，显示5个汉字(16X16)</span><br><span class="line">display_c(5,1,1,5);//数字8X16，显示:0-9</span><br><span class="line">display_c(9,0,2,8);//DATA.H字模与上面的最后两个重叠,显示：89abc..</span><br><span class="line">display_c(17,0,3,5);</span><br><span class="line">DelayMs(2000);</span><br><span class="line">clear_lcm(); //LCM 清屏</span><br><span class="line">display_c(22,0,1,8);</span><br><span class="line">display_c(30,0,2,7);</span><br><span class="line">DelayMs(2000);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;&#x2F;附录 B 文本方式显示汉字程序<br>#include&lt;intrins.h&gt;<br>#include&lt;reg52.h&gt;<br>#include&lt;T6963C.h&gt;<br>#include&lt;DATA.h&gt;<br>#define lcmcom XBYTE[0x3fff] &#x2F;<em>T6963C 写命令口地址，读数据口地址</em>&#x2F;<br>#define lcmdata XBYTE[0x3eff] &#x2F;<em>T6963C 写数据口地址</em>&#x2F;</p><p>void DelayMs(unsigned int n)<br>{<br>    unsigned char j;<br>    while(n–)<br>    {<br>        for(j&#x3D;0;j&lt;113;j++)<br>        ;<br>    }</p><p>}</p><p>void main()<br>{<br>    init_lcm(); &#x2F;&#x2F;LCM 初始化</p><pre><code>while(1)&#123;    clear_lcm(); //LCM 清屏    display_c(0,1,0,5);//从table[0]，从第0行的1位置开始显示，显示5个汉字(16X16)    display_c(5,1,1,5);//数字8X16，显示:0-9    display_c(9,0,2,8);//DATA.H字模与上面的最后两个重叠,显示：89abc..    display_c(17,0,3,5);    DelayMs(2000);    clear_lcm(); //LCM 清屏    display_c(22,0,1,8);    display_c(30,0,2,7);    DelayMs(2000);&#125;</code></pre><p> }&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1T-M-ZU4HG9XAPJXMXtT2JA </span><br><span class="line">提取码：4rah</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1T-M-ZU4HG9XAPJXMXtT2JA  提取码：4rah</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】三极管组成的H桥驱动直流电机+按键正反转控制</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E4%B8%89%E6%9E%81%E7%AE%A1%E7%BB%84%E6%88%90%E7%9A%84H%E6%A1%A5%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%8C%89%E9%94%AE%E6%AD%A3%E5%8F%8D%E8%BD%AC%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E4%B8%89%E6%9E%81%E7%AE%A1%E7%BB%84%E6%88%90%E7%9A%84H%E6%A1%A5%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%8C%89%E9%94%AE%E6%AD%A3%E5%8F%8D%E8%BD%AC%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】三极管组成的H桥驱动直流电机-按键正反转控制"><a href="#【Proteus仿真】三极管组成的H桥驱动直流电机-按键正反转控制" class="headerlink" title="【Proteus仿真】三极管组成的H桥驱动直流电机+按键正反转控制"></a>【Proteus仿真】三极管组成的H桥驱动直流电机+按键正反转控制</h1><h3 id="【Proteus仿真】三极管组成的H桥驱动直流电机-按键正反转控制-1"><a href="#【Proteus仿真】三极管组成的H桥驱动直流电机-按键正反转控制-1" class="headerlink" title="【Proteus仿真】三极管组成的H桥驱动直流电机+按键正反转控制"></a>【Proteus仿真】三极管组成的H桥驱动直流电机+按键正反转控制</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/28f361b10a27484da2f1d1bd1c46321c.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">sbit K1   = P3^0;//正转</span><br><span class="line">sbit K2   = P3^1;//反转</span><br><span class="line">sbit K3   = P3^2;//停止</span><br><span class="line">sbit LED1 = P0^0;//正转指示灯</span><br><span class="line">sbit LED2 = P0^1;//反转指示灯</span><br><span class="line">sbit LED3 = P0^2;//停止指示灯</span><br><span class="line">sbit MA   = P1^0;//电机驱动引脚</span><br><span class="line">sbit MB   = P1^1;//电机驱动引脚</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">LED1 = 1;</span><br><span class="line">LED2 = 1;</span><br><span class="line">LED3 = 0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> if(K1 == 0)</span><br><span class="line">&#123;</span><br><span class="line"> while(K1 == 0);</span><br><span class="line">LED1 = 0;</span><br><span class="line">LED2 = 1;</span><br><span class="line">LED3 = 1;</span><br><span class="line">MA   = 0;</span><br><span class="line">MB   = 1;</span><br><span class="line">&#125;</span><br><span class="line">if(K2 == 0)</span><br><span class="line">&#123;</span><br><span class="line"> while(K1 == 0);</span><br><span class="line">LED1 = 1;</span><br><span class="line">LED2 = 0;</span><br><span class="line">LED3 = 1;</span><br><span class="line">MA   = 1;</span><br><span class="line">MB   = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(K3 == 0)</span><br><span class="line">&#123;</span><br><span class="line"> while(K1 == 0);</span><br><span class="line">LED1 = 1;</span><br><span class="line">LED2 = 1;</span><br><span class="line">LED3 = 0;</span><br><span class="line">MA   = 0;</span><br><span class="line">MB   = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uint unsigned int<br>#define uchar unsigned char<br>sbit K1   &#x3D; P3^0;&#x2F;&#x2F;正转<br>sbit K2   &#x3D; P3^1;&#x2F;&#x2F;反转<br>sbit K3   &#x3D; P3^2;&#x2F;&#x2F;停止<br>sbit LED1 &#x3D; P0^0;&#x2F;&#x2F;正转指示灯<br>sbit LED2 &#x3D; P0^1;&#x2F;&#x2F;反转指示灯<br>sbit LED3 &#x3D; P0^2;&#x2F;&#x2F;停止指示灯<br>sbit MA   &#x3D; P1^0;&#x2F;&#x2F;电机驱动引脚<br>sbit MB   &#x3D; P1^1;&#x2F;&#x2F;电机驱动引脚</p><p>void main(void)<br>{<br>    LED1 &#x3D; 1;<br>    LED2 &#x3D; 1;<br>    LED3 &#x3D; 0;<br>    while(1)<br>    {<br>     if(K1 &#x3D;&#x3D; 0)<br>        {<br>         while(K1 &#x3D;&#x3D; 0);<br>            LED1 &#x3D; 0;<br>            LED2 &#x3D; 1;<br>            LED3 &#x3D; 1;<br>            MA   &#x3D; 0;<br>            MB   &#x3D; 1;<br>        }<br>        if(K2 &#x3D;&#x3D; 0)<br>        {<br>         while(K1 &#x3D;&#x3D; 0);<br>            LED1 &#x3D; 1;<br>            LED2 &#x3D; 0;<br>            LED3 &#x3D; 1;<br>            MA   &#x3D; 1;<br>            MB   &#x3D; 0;<br>        }<br>        if(K3 &#x3D;&#x3D; 0)<br>        {<br>         while(K1 &#x3D;&#x3D; 0);<br>            LED1 &#x3D; 1;<br>            LED2 &#x3D; 1;<br>            LED3 &#x3D; 0;<br>            MA   &#x3D; 0;<br>            MB   &#x3D; 0;<br>        }<br>    }<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1hXPC5K-YvIjtYsLc98CzeQ </span><br><span class="line">提取码：po90</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1hXPC5K-YvIjtYsLc98CzeQ  提取码：po90</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】利用加法计数器74XX160的级联实现2位计数</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%88%A9%E7%94%A8%E5%8A%A0%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A874XX160%E7%9A%84%E7%BA%A7%E8%81%94%E5%AE%9E%E7%8E%B02%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%88%A9%E7%94%A8%E5%8A%A0%E6%B3%95%E8%AE%A1%E6%95%B0%E5%99%A874XX160%E7%9A%84%E7%BA%A7%E8%81%94%E5%AE%9E%E7%8E%B02%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】利用加法计数器74XX160的级联实现2位计数"><a href="#【Proteus仿真】利用加法计数器74XX160的级联实现2位计数" class="headerlink" title="【Proteus仿真】利用加法计数器74XX160的级联实现2位计数"></a>【Proteus仿真】利用加法计数器74XX160的级联实现2位计数</h1><h3 id="【Proteus仿真】利用加法计数器74XX160的级联实现2位计数-1"><a href="#【Proteus仿真】利用加法计数器74XX160的级联实现2位计数-1" class="headerlink" title="【Proteus仿真】利用加法计数器74XX160的级联实现2位计数"></a>【Proteus仿真】利用加法计数器74XX160的级联实现2位计数</h3><ul><li>Proteus仿真</li></ul><p>计数到24归零</p><p><img src="https://img-blog.csdnimg.cn/9824cba916b04d3380d9dffff3b1b832.gif#pic_center" alt="在这里插入图片描述"></p><ul><li>自己搭建电路注意个CLK引脚一个买哦脉冲信号。</li></ul><p><img src="https://img-blog.csdnimg.cn/0d5c97e17e3c41a4a36dad95bb1294fc.png" alt="在这里插入图片描述"></p><h4 id="电路零件清单"><a href="#电路零件清单" class="headerlink" title="电路零件清单"></a>电路零件清单</h4><p><img src="https://img-blog.csdnimg.cn/d627ee8d5ef44f12bd4343f4376f3297.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/eb707e64fa6f4191bd28d35910151aa1.png" alt="在这里插入图片描述"></p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.9平台</p><p><code>Proteus8.9</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1wDLiKBCxrmEW9rWTRJAPDQ </span><br><span class="line">提取码：e3st</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1wDLiKBCxrmEW9rWTRJAPDQ  提取码：e3st</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%9C%A8AT24C04%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%9C%B0%E5%9D%80%E4%B8%AD%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%9C%A8AT24C04%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%9C%B0%E5%9D%80%E4%B8%AD%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取"><a href="#【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取" class="headerlink" title="【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取"></a>【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取</h1><h3 id="【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取-1"><a href="#【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取-1" class="headerlink" title="【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取"></a>【Proteus仿真】在AT24C04的连续地址中写入数据并循环读取</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/67c4f7d734484634ad0cc67215f0b461.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h4><p>在AT24C04的地址0-9中分别写入数据，然后在while循环里面循环从AT24C04的地址0-9读取数据，并通过数码管显示数出来，来验证数据的写入和读取是否成功。</p><p><code>while</code></p><ul><li>本示例是展示如何将数据写入到AT24C04当中，并读取数据，可以用于移植到有需要的相关项目当中。</li></ul><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define NOP4() &#123;_nop_();_nop_();_nop_();_nop_();&#125;</span><br><span class="line"></span><br><span class="line">sbit SCL = P1^0;</span><br><span class="line">sbit SDA = P1^1;</span><br><span class="line"></span><br><span class="line">uchar code DSY_CODE[]=</span><br><span class="line">&#123;</span><br><span class="line"> 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uchar DISP_Buffer[]=&#123;0,0,0&#125;;</span><br><span class="line">uchar Count = 0;</span><br><span class="line"></span><br><span class="line">void DelayMS(uint x)</span><br><span class="line">&#123;</span><br><span class="line">uchar t;</span><br><span class="line">while(x--)</span><br><span class="line">&#123;</span><br><span class="line"> for(t=120;t&gt;0;t--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line"> SDA=1;SCL=1;NOP4();SDA=0;NOP4();SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stop()</span><br><span class="line">&#123;</span><br><span class="line"> SDA=0;SCL=0;NOP4();SCL=1;NOP4();SDA=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RACK()</span><br><span class="line">&#123;</span><br><span class="line"> SDA=1;NOP4();SCL=1;NOP4();SCL=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NO_ACK()</span><br><span class="line">&#123;</span><br><span class="line"> SDA=1;SCL=1;NOP4();SCL=0;SDA=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Write_A_Byte(uchar b)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line"> b&lt;&lt;=1;SDA=CY;_nop_();SCL=1;NOP4();SCL=0;</span><br><span class="line">&#125;</span><br><span class="line">RACK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar Receive_A_Byte()</span><br><span class="line">&#123;</span><br><span class="line"> uchar i,d;</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line"> SCL=1;d&lt;&lt;=1;d|=SDA;SCL=0;</span><br><span class="line">&#125;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br><span class="line">/*地址位写数据*/</span><br><span class="line">void Write_Random_Address_Byte(uchar add,uchar dat)</span><br><span class="line">&#123;</span><br><span class="line"> Start();</span><br><span class="line">Write_A_Byte(0xa0);</span><br><span class="line">Write_A_Byte(add);</span><br><span class="line">Write_A_Byte(dat);</span><br><span class="line">Stop();</span><br><span class="line">DelayMS(10);</span><br><span class="line">&#125;</span><br><span class="line">/*读数据*/</span><br><span class="line">uchar Read_Current_Address_Data()</span><br><span class="line">&#123;</span><br><span class="line"> uchar d;</span><br><span class="line">Start();</span><br><span class="line">Write_A_Byte(0xa1);</span><br><span class="line">d=Receive_A_Byte();</span><br><span class="line">NO_ACK();</span><br><span class="line">Stop();</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br><span class="line">/*地址位读数据*/</span><br><span class="line">uchar Random_Read(uchar addr)</span><br><span class="line">&#123;</span><br><span class="line"> Start();</span><br><span class="line">Write_A_Byte(0xa0);</span><br><span class="line">Write_A_Byte(addr);</span><br><span class="line">Stop();</span><br><span class="line">return Read_Current_Address_Data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Convert_And_Display()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">unsigned char k =0,j=0,z=0;</span><br><span class="line">for(z=0;z&lt;10;z++)&#123;</span><br><span class="line">for(j=0;j&lt;120;j++)&#123;</span><br><span class="line">Count = Random_Read(k);//从AT24C04中读数据</span><br><span class="line"> DISP_Buffer[2] = Count/100;</span><br><span class="line">DISP_Buffer[1] = Count%100/10;</span><br><span class="line">DISP_Buffer[0] = Count%100%10;</span><br><span class="line">//if(DISP_Buffer[2] == 0)</span><br><span class="line">//&#123;</span><br><span class="line">// DISP_Buffer[2] = 10;</span><br><span class="line">//if(DISP_Buffer[1] == 0)</span><br><span class="line">//&#123;</span><br><span class="line">// DISP_Buffer[1] = 10;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">P2 = 0x80;</span><br><span class="line">P0 = DSY_CODE[DISP_Buffer[0]];</span><br><span class="line">DelayMS(2);</span><br><span class="line">P2 = 0x40;</span><br><span class="line">P0 = DSY_CODE[DISP_Buffer[1]];</span><br><span class="line">DelayMS(2);</span><br><span class="line">P2 = 0x20;</span><br><span class="line">P0 = DSY_CODE[DISP_Buffer[2]];</span><br><span class="line">DelayMS(2); </span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i=0;</span><br><span class="line"> //Count = Random_Read(0x00) + 1;</span><br><span class="line">//Write_Random_Address_Byte(0x00,Count);</span><br><span class="line">for(i=0;i&lt;10;i++)&#123;</span><br><span class="line">Write_Random_Address_Byte(i,111+i);//指定地址写数据</span><br><span class="line">&#125;</span><br><span class="line">while(1)&#123;</span><br><span class="line">Convert_And_Display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>#define NOP4() {<em>nop</em>();<em>nop</em>();<em>nop</em>();<em>nop</em>();}</p><p>sbit SCL &#x3D; P1^0;<br>sbit SDA &#x3D; P1^1;</p><p>uchar code DSY_CODE[]&#x3D;<br>{<br>     0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90<br>};</p><p>uchar DISP_Buffer[]&#x3D;{0,0,0};<br>uchar Count &#x3D; 0;</p><p>void DelayMS(uint x)<br>{<br>    uchar t;<br>    while(x–)<br>    {<br>     for(t&#x3D;120;t&gt;0;t–);<br>    }<br>}</p><p>void Start()<br>{<br>     SDA&#x3D;1;SCL&#x3D;1;NOP4();SDA&#x3D;0;NOP4();SCL&#x3D;0;<br>}</p><p>void Stop()<br>{<br>     SDA&#x3D;0;SCL&#x3D;0;NOP4();SCL&#x3D;1;NOP4();SDA&#x3D;1;<br>}</p><p>void RACK()<br>{<br>     SDA&#x3D;1;NOP4();SCL&#x3D;1;NOP4();SCL&#x3D;0;<br>}</p><p>void NO_ACK()<br>{<br>     SDA&#x3D;1;SCL&#x3D;1;NOP4();SCL&#x3D;0;SDA&#x3D;0;<br>}</p><p>void Write_A_Byte(uchar b)<br>{<br>     uchar i;<br>    for(i&#x3D;0;i&lt;8;i++)<br>    {<br>     b&lt;&lt;&#x3D;1;SDA&#x3D;CY;<em>nop</em>();SCL&#x3D;1;NOP4();SCL&#x3D;0;<br>    }<br>    RACK();<br>}</p><p>uchar Receive_A_Byte()<br>{<br>     uchar i,d;<br>    for(i&#x3D;0;i&lt;8;i++)<br>    {<br>     SCL&#x3D;1;d&lt;&lt;&#x3D;1;d|&#x3D;SDA;SCL&#x3D;0;<br>    }<br>    return d;<br>}<br>&#x2F;<em>地址位写数据</em>&#x2F;<br>void Write_Random_Address_Byte(uchar add,uchar dat)<br>{<br>     Start();<br>    Write_A_Byte(0xa0);<br>    Write_A_Byte(add);<br>    Write_A_Byte(dat);<br>    Stop();<br>    DelayMS(10);<br>}<br>&#x2F;<em>读数据</em>&#x2F;<br>uchar Read_Current_Address_Data()<br>{<br>     uchar d;<br>    Start();<br>    Write_A_Byte(0xa1);<br>    d&#x3D;Receive_A_Byte();<br>    NO_ACK();<br>    Stop();<br>    return d;<br>}<br>&#x2F;<em>地址位读数据</em>&#x2F;<br>uchar Random_Read(uchar addr)<br>{<br>     Start();<br>    Write_A_Byte(0xa0);<br>    Write_A_Byte(addr);<br>    Stop();<br>    return Read_Current_Address_Data();<br>}</p><p>void Convert_And_Display()<br>{</p><pre><code>unsigned char k =0,j=0,z=0;for(z=0;z&lt;10;z++)&#123;        for(j=0;j&lt;120;j++)&#123;Count = Random_Read(k);//从AT24C04中读数据 DISP_Buffer[2] = Count/100;DISP_Buffer[1] = Count%100/10;DISP_Buffer[0] = Count%100%10;</code></pre><p>&#x2F;&#x2F;if(DISP_Buffer[2] &#x3D;&#x3D; 0)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F; DISP_Buffer[2] &#x3D; 10;<br>&#x2F;&#x2F;if(DISP_Buffer[1] &#x3D;&#x3D; 0)<br>&#x2F;&#x2F;{<br>&#x2F;&#x2F; DISP_Buffer[1] &#x3D; 10;<br>&#x2F;&#x2F;}<br>&#x2F;&#x2F;}<br>    P2 &#x3D; 0x80;<br>    P0 &#x3D; DSY_CODE[DISP_Buffer[0]];<br>    DelayMS(2);<br>    P2 &#x3D; 0x40;<br>    P0 &#x3D; DSY_CODE[DISP_Buffer[1]];<br>    DelayMS(2);<br>    P2 &#x3D; 0x20;<br>    P0 &#x3D; DSY_CODE[DISP_Buffer[2]];<br>    DelayMS(2);<br>}<br>                    k++;<br>    }<br>}</p><p>void main()<br>{<br>    unsigned char i&#x3D;0;<br> &#x2F;&#x2F;Count &#x3D; Random_Read(0x00) + 1;<br>&#x2F;&#x2F;Write_Random_Address_Byte(0x00,Count);<br>    for(i&#x3D;0;i&lt;10;i++){<br>        Write_Random_Address_Byte(i,111+i);&#x2F;&#x2F;指定地址写数据<br>    }<br>    while(1){<br>        Convert_And_Display();<br>    }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1TCEXVLOZqa_KnJ-1tiTKAw </span><br><span class="line">提取码：k0kq</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1TCEXVLOZqa_KnJ-1tiTKAw  提取码：k0kq</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】基于74LS148+74LS279+74LS48的四路抢答器</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%9F%BA%E4%BA%8E74LS14874LS27974LS48%E7%9A%84%E5%9B%9B%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%9F%BA%E4%BA%8E74LS14874LS27974LS48%E7%9A%84%E5%9B%9B%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】基于74LS148-74LS279-74LS48的四路抢答器"><a href="#【Proteus仿真】基于74LS148-74LS279-74LS48的四路抢答器" class="headerlink" title="【Proteus仿真】基于74LS148+74LS279+74LS48的四路抢答器"></a>【Proteus仿真】基于74LS148+74LS279+74LS48的四路抢答器</h1><h3 id="【Proteus仿真】基于74LS148-74LS279-74LS48的四路抢答器-1"><a href="#【Proteus仿真】基于74LS148-74LS279-74LS48的四路抢答器-1" class="headerlink" title="【Proteus仿真】基于74LS148+74LS279+74LS48的四路抢答器"></a>【Proteus仿真】基于74LS148+74LS279+74LS48的四路抢答器</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/7658dc5b65c448d3a3709ae09fec93d3.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="74LS148"><a href="#74LS148" class="headerlink" title="74LS148"></a>74LS148</h4><p>74LS148 是8 线－3 线优先编码器，共有 54&#x2F;74148 和 54&#x2F;74LS148 两种线路结构型式，将 8 条数据线（0－7）进行 3 线(4-2-1)二进制（八进制）优先编码，即对最高位数据线进行译码。利用选通端（EI）和输出选通端（EO）可进行八进制扩展。</p><h4 id="74LS279"><a href="#74LS279" class="headerlink" title="74LS279"></a>74LS279</h4><p>74LS279 是 4路R-S 触发器。</p><h4 id="74LS48"><a href="#74LS48" class="headerlink" title="74LS48"></a>74LS48</h4><p>七段共阴数码管译码器驱动器.</p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/18WtXijHmoeCg1kKb9DrVbA </span><br><span class="line">提取码：i8zn</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/18WtXijHmoeCg1kKb9DrVbA  提取码：i8zn</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】定时器0作为16位计数器使用示例</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A80%E4%BD%9C%E4%B8%BA16%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A80%E4%BD%9C%E4%B8%BA16%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】定时器0作为16位计数器使用示例"><a href="#【Proteus仿真】定时器0作为16位计数器使用示例" class="headerlink" title="【Proteus仿真】定时器0作为16位计数器使用示例"></a>【Proteus仿真】定时器0作为16位计数器使用示例</h1><h3 id="【Proteus仿真】定时器0作为外部16位计数器使用示例"><a href="#【Proteus仿真】定时器0作为外部16位计数器使用示例" class="headerlink" title="【Proteus仿真】定时器0作为外部16位计数器使用示例"></a>【Proteus仿真】定时器0作为外部16位计数器使用示例</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/ff2659d9bd9b4c33a3a7e162895a7f19.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>将定时器0作为外部16位计数器使用，当外部引脚P34引脚触发时，计数器0寄存器+1，然后，通过串口将定时器0寄存器值（TH0，TH0）打印出来.（平时一般用作定时器功能比较多。）</p><ul><li>示例代码来源Keil官方示例“8051 Counter 0 Example Program”修改得来：<a href="https://www.keil.com/download/list/c51.htm">https://www.keil.com/download/list/c51.htm</a></li></ul><p><code>Keil</code></p><p><a href="https://www.keil.com/download/list/c51.htm">https://www.keil.com/download/list/c51.htm</a></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周五 6月 24 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;reg51.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">static volatile unsigned char cnt=0;</span><br><span class="line">sbit led = P1^0;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">MAIN C function</span><br><span class="line">b,h,l来对输入字节宽的设置</span><br><span class="line">一个单字节变量时要使用%bd</span><br><span class="line">1.b八位</span><br><span class="line">2.h十六位</span><br><span class="line">3.l三十二位</span><br><span class="line">%d两个字节变量int</span><br><span class="line">%bd单字节变量char</span><br><span class="line">%ld四字节变量long int</span><br><span class="line">%x   unsigned int</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main (void)</span><br><span class="line">&#123;</span><br><span class="line">/*--------------------------------------</span><br><span class="line">Set serial port for 9600 baud at</span><br><span class="line">11.0592 MHz.  Note that we use Timer 1</span><br><span class="line">for the baud rate generator.</span><br><span class="line">--------------------------------------*/</span><br><span class="line">SCON  = 0x50;</span><br><span class="line">TMOD |= 0x20;</span><br><span class="line">TH1   = 0xFA;</span><br><span class="line">TR1   = 1;</span><br><span class="line">TI    = 1;</span><br><span class="line"></span><br><span class="line">PCON |= 0x80;</span><br><span class="line"></span><br><span class="line">printf (&quot;\r\nCounter 0 Example Program\r\n&quot;);</span><br><span class="line">printf (&quot;\r\nStart toggling P3.4 (T0 input)\r\n\r\n&quot;);</span><br><span class="line"></span><br><span class="line">/*--------------------------------------</span><br><span class="line">Set Timer0 for 16-bit counter mode.</span><br><span class="line">Set the Timer0 Run control bit.</span><br><span class="line">--------------------------------------*/</span><br><span class="line">TMOD = (TMOD &amp; 0xF0) | 0x05;</span><br><span class="line">TR0 = 1;</span><br><span class="line"></span><br><span class="line">/*--------------------------------------</span><br><span class="line">Output the value of the counter.  As you</span><br><span class="line">toggle P3.4, the timer/counter 0 value</span><br><span class="line">will increase.</span><br><span class="line">--------------------------------------*/</span><br><span class="line">while (1)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">if(cnt != TL0)</span><br><span class="line">&#123;</span><br><span class="line"> printf (&quot;\rCounter 0 = %2.2bX%2.2bXh&quot;, TH0, TL0);//Counter 0 = 0000h</span><br><span class="line">led = ! led  ;    //work LED flash</span><br><span class="line">cnt = TL0;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周五 6月 24 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;reg51.h&gt;<br>#include &lt;stdio.h&gt;<br>static volatile unsigned char cnt&#x3D;0;<br>sbit led &#x3D; P1^0;</p><p>&#x2F;<em>————————————————<br>MAIN C function<br>b,h,l来对输入字节宽的设置<br>一个单字节变量时要使用%bd<br>1.b八位<br>2.h十六位<br>3.l三十二位<br>%d两个字节变量int<br>%bd单字节变量char<br>%ld四字节变量long int<br>%x   unsigned int<br>————————————————</em>&#x2F;<br>void main (void)<br>{<br>&#x2F;<em>————————————–<br>Set serial port for 9600 baud at<br>11.0592 MHz.  Note that we use Timer 1<br>for the baud rate generator.<br>————————————–</em>&#x2F;<br>SCON  &#x3D; 0x50;<br>TMOD |&#x3D; 0x20;<br>TH1   &#x3D; 0xFA;<br>TR1   &#x3D; 1;<br>TI    &#x3D; 1;</p><p>PCON |&#x3D; 0x80;</p><p>printf (“\r\nCounter 0 Example Program\r\n”);<br>printf (“\r\nStart toggling P3.4 (T0 input)\r\n\r\n”);</p><p>&#x2F;<em>————————————–<br>Set Timer0 for 16-bit counter mode.<br>Set the Timer0 Run control bit.<br>————————————–</em>&#x2F;<br>TMOD &#x3D; (TMOD &amp; 0xF0) | 0x05;<br>TR0 &#x3D; 1;</p><p>&#x2F;<em>————————————–<br>Output the value of the counter.  As you<br>toggle P3.4, the timer&#x2F;counter 0 value<br>will increase.<br>————————————–</em>&#x2F;<br>while (1)<br>  {</p><p>if(cnt !&#x3D; TL0)<br>{<br>         printf (“\rCounter 0 &#x3D; %2.2bX%2.2bXh”, TH0, TL0);&#x2F;&#x2F;Counter 0 &#x3D; 0000h<br>            led &#x3D; ! led  ;    &#x2F;&#x2F;work LED flash<br>            cnt &#x3D; TL0;<br>}<br>  }<br>}&#96;</p><h4 id="示例代码和仿真资源"><a href="#示例代码和仿真资源" class="headerlink" title="示例代码和仿真资源"></a>示例代码和仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1xNy0uIOxpSA-d-W1rZXWbA </span><br><span class="line">提取码：diqn</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1xNy0uIOxpSA-d-W1rZXWbA  提取码：diqn</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】定时器1外部计数中断</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A81%E5%A4%96%E9%83%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E6%96%AD/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%AE%9A%E6%97%B6%E5%99%A81%E5%A4%96%E9%83%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】定时器1外部计数中断"><a href="#【Proteus仿真】定时器1外部计数中断" class="headerlink" title="【Proteus仿真】定时器1外部计数中断"></a>【Proteus仿真】定时器1外部计数中断</h1><h3 id="【Proteus仿真】定时器1外部计数中断-1"><a href="#【Proteus仿真】定时器1外部计数中断-1" class="headerlink" title="【Proteus仿真】定时器1外部计数中断"></a>【Proteus仿真】定时器1外部计数中断</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/689dfde1400c4996937d0480006c94ea.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周一 6月 27 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line"></span><br><span class="line">sbit LED=P1^2;    //定义LED端口</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    定时器初始化子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_Timer1(void)</span><br><span class="line">&#123;</span><br><span class="line"> TMOD |= 0x10 | 0x40;  //使用模式1，16位计数器，使用&quot;|&quot;符号可以在使用多个定时器时不受影响     </span><br><span class="line"> TH1=0xFF;      //给定初值</span><br><span class="line"> TL1=252;         //从245计数到255 </span><br><span class="line"> EA=1;            //总中断打开</span><br><span class="line"> ET1=1;           //定时器中断打开</span><br><span class="line"> TR1=1;           //定时器开关打开</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> Init_Timer1();</span><br><span class="line"> while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 定时器中断子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Timer1_isr(void) interrupt 3 </span><br><span class="line">&#123;</span><br><span class="line"> TH1=0xFF;      //重新给定初值</span><br><span class="line"> TL1=252; </span><br><span class="line"> LED=~LED;        //指示灯反相，可以看到闪烁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周一 6月 27 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</p><p>sbit LED&#x3D;P1^2;    &#x2F;&#x2F;定义LED端口</p><p>&#x2F;<em>————————————————<br>                    定时器初始化子程序<br>————————————————</em>&#x2F;<br>void Init_Timer1(void)<br>{<br> TMOD |&#x3D; 0x10 | 0x40;  &#x2F;&#x2F;使用模式1，16位计数器，使用”|”符号可以在使用多个定时器时不受影响<br> TH1&#x3D;0xFF;      &#x2F;&#x2F;给定初值<br> TL1&#x3D;252;         &#x2F;&#x2F;从245计数到255<br> EA&#x3D;1;            &#x2F;&#x2F;总中断打开<br> ET1&#x3D;1;           &#x2F;&#x2F;定时器中断打开<br> TR1&#x3D;1;           &#x2F;&#x2F;定时器开关打开<br>}<br>&#x2F;<em>————————————————<br>                    主程序<br>————————————————</em>&#x2F;<br>void main()<br>{<br> Init_Timer1();<br> while(1);<br>}</p><p>&#x2F;<em>————————————————<br>                 定时器中断子程序<br>————————————————</em>&#x2F;<br>void Timer1_isr(void) interrupt 3<br>{<br> TH1&#x3D;0xFF;      &#x2F;&#x2F;重新给定初值<br> TL1&#x3D;252;<br> LED&#x3D;~LED;        &#x2F;&#x2F;指示灯反相，可以看到闪烁<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1sp9LLXfxGzN5c7i4JGUqRw </span><br><span class="line">提取码：einh</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1sp9LLXfxGzN5c7i4JGUqRw  提取码：einh</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】数码管+4x4键盘矩阵按键简易计算器</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%95%B0%E7%A0%81%E7%AE%A14x4%E9%94%AE%E7%9B%98%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%95%B0%E7%A0%81%E7%AE%A14x4%E9%94%AE%E7%9B%98%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】数码管-4x4键盘矩阵按键简易计算器"><a href="#【Proteus仿真】数码管-4x4键盘矩阵按键简易计算器" class="headerlink" title="【Proteus仿真】数码管+4x4键盘矩阵按键简易计算器"></a>【Proteus仿真】数码管+4x4键盘矩阵按键简易计算器</h1><h3 id="【Proteus仿真】数码管-4x4键盘矩阵按键简易计算器-1"><a href="#【Proteus仿真】数码管-4x4键盘矩阵按键简易计算器-1" class="headerlink" title="【Proteus仿真】数码管+4x4键盘矩阵按键简易计算器"></a>【Proteus仿真】数码管+4x4键盘矩阵按键简易计算器</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/1e56bce4ea044fd98e709dfd80b88f6e.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="仿真器件"><a href="#仿真器件" class="headerlink" title="仿真器件"></a>仿真器件</h4><ul><li>74HC573数据缓冲器</li><li>8位共阴数码管</li></ul><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/*-----------------------------------------------</span><br><span class="line">4x4键盘矩阵按键简易计算器</span><br><span class="line">  内容：整数之间运算，没有小数所有除法得出的结果不正确，有负号运算，</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&quot;display.h&quot;</span><br><span class="line">#include&quot;delay.h&quot;</span><br><span class="line">#include&quot;keyboard.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char num,i,sign;                   </span><br><span class="line"> unsigned char temp[8];        //最大输入8个</span><br><span class="line"> bit firstflag;</span><br><span class="line"> int a=0,b=0;</span><br><span class="line"> unsigned char s;</span><br><span class="line"></span><br><span class="line"> Init_Timer0();   //初始化定时器0</span><br><span class="line">while (1)         //主循环</span><br><span class="line">  &#123;</span><br><span class="line"> num=KeyPro();  //扫描键盘</span><br><span class="line"> if(num!=0xff)  //如果扫描是按键有效值则进行处理</span><br><span class="line">   &#123; </span><br><span class="line">    if(i==0)    //输入是第一个字符的时候需要把改行清空，方便观看</span><br><span class="line">  &#123;</span><br><span class="line">  for(s=0;s&lt;8;s++) //赋值完成后把缓冲区清零，防止下次输入影响结果</span><br><span class="line">  TempData[s]=0;</span><br><span class="line">  &#125;</span><br><span class="line">if((&#x27;+&#x27;==num)|| (i==8) || (&#x27;-&#x27;==num) || (&#x27;x&#x27;==num)|| (&#x27;/&#x27;==num) || (&#x27;=&#x27;==num))//输入数字最大值8，输入符号表示输入结束</span><br><span class="line">  &#123;</span><br><span class="line">  i=0;  //计数器复位</span><br><span class="line"></span><br><span class="line"> if(firstflag==0)  //如果是输入的第一个数据，赋值给a，并把标志位置1，到下一个数据输入时可以跳转赋值给b</span><br><span class="line">     &#123;</span><br><span class="line">     sscanf(temp,&quot;%d&quot;,&amp;a);//从一个字符串输入到变量</span><br><span class="line">         firstflag=1;</span><br><span class="line"> &#125;</span><br><span class="line">  else  </span><br><span class="line">     sscanf(temp,&quot;%d&quot;,&amp;b);</span><br><span class="line">  for(s=0;s&lt;8;s++) //赋值完成后把缓冲区清零，防止下次输入影响结果</span><br><span class="line">    temp[s]=0;</span><br><span class="line">      </span><br><span class="line">  if(num!=&#x27;=&#x27;)      //判断当前符号位并做相应处理</span><br><span class="line">     sign=num;      //如果不是等号记下标志位</span><br><span class="line">  else</span><br><span class="line">     &#123;  </span><br><span class="line"> firstflag=0;   //检测到输入=号，判断上次读入的符合</span><br><span class="line">         switch(sign)</span><br><span class="line">       &#123;</span><br><span class="line">    case &#x27;+&#x27;:a=a+b;</span><br><span class="line">break;</span><br><span class="line">case &#x27;-&#x27;:a=a-b;</span><br><span class="line">break;</span><br><span class="line">case &#x27;x&#x27;:a=a*b;</span><br><span class="line">break;</span><br><span class="line">case &#x27;/&#x27;:a=a/b;</span><br><span class="line">break;</span><br><span class="line">default:break;</span><br><span class="line">   &#125;</span><br><span class="line"> sprintf(temp,&quot;%d&quot;,a);  //打印十进制到临时缓冲区</span><br><span class="line">  for(s=0;s&lt;8;s++)       //由于打印的是ASCII码值</span><br><span class="line">    &#123; </span><br><span class="line">if(temp[s]==0)      //所以需要转换，如果为0表示null 数码管上则不能显示，所以赋值0</span><br><span class="line">                TempData[s]=0;</span><br><span class="line">else if(temp[s]==0x2d)//表示负号，数码管显示负号 0x40</span><br><span class="line">     TempData[s]=0x40;</span><br><span class="line">    else </span><br><span class="line">         TempData[s]=dofly_DuanMa[temp[s]-&#x27;0&#x27;];//其他0-9负号则进行ASCII 到 数字处理，如当前是&#x27;3&#x27;，用&#x27;3&#x27;-&#x27;0&#x27;=3</span><br><span class="line">                                       //&#x27;3&#x27;的16进制是0x33,&#x27;0&#x27;的16进制是0x30     </span><br><span class="line">&#125;</span><br><span class="line"> sign=0;a=b=0;            //用完后所有数据清零</span><br><span class="line"> for(s=0;s&lt;8;s++)</span><br><span class="line">    temp[s]=0;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   elseif(i&lt;16)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">         temp[i]=num+&#x27;0&#x27;; </span><br><span class="line">         TempData[i]=dofly_DuanMa[num];//输出数据</span><br><span class="line">     i++;   //输入数值累加</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>———————————————–<br>    4x4键盘矩阵按键简易计算器<br>  内容：整数之间运算，没有小数所有除法得出的结果不正确，有负号运算，<br>————————————————</em>&#x2F;<br>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义<br>#include&lt;stdio.h&gt;<br>#include”display.h”<br>#include”delay.h”<br>#include”keyboard.h”</p><p>&#x2F;<em>————————————————<br>                    主程序<br>————————————————</em>&#x2F;<br>void main()<br>{<br> unsigned char num,i,sign;<br> unsigned char temp[8];        &#x2F;&#x2F;最大输入8个<br> bit firstflag;<br> int a&#x3D;0,b&#x3D;0;<br> unsigned char s;</p><p> Init_Timer0();   &#x2F;&#x2F;初始化定时器0<br>while (1)         &#x2F;&#x2F;主循环<br>  {<br> num&#x3D;KeyPro();  &#x2F;&#x2F;扫描键盘<br> if(num!&#x3D;0xff)  &#x2F;&#x2F;如果扫描是按键有效值则进行处理<br>   {<br>    if(i&#x3D;&#x3D;0)    &#x2F;&#x2F;输入是第一个字符的时候需要把改行清空，方便观看<br>      {<br>      for(s&#x3D;0;s&lt;8;s++) &#x2F;&#x2F;赋值完成后把缓冲区清零，防止下次输入影响结果<br>          TempData[s]&#x3D;0;<br>      }<br>    if((‘+’&#x3D;&#x3D;num)|| (i&#x3D;&#x3D;8) || (‘-‘&#x3D;&#x3D;num) || (‘x’&#x3D;&#x3D;num)|| (‘&#x2F;‘&#x3D;&#x3D;num) || (‘&#x3D;’&#x3D;&#x3D;num))&#x2F;&#x2F;输入数字最大值8，输入符号表示输入结束<br>      {<br>      i&#x3D;0;  &#x2F;&#x2F;计数器复位</p><pre><code> if(firstflag==0)  //如果是输入的第一个数据，赋值给a，并把标志位置1，到下一个数据输入时可以跳转赋值给b     &#123;     sscanf(temp,&quot;%d&quot;,&amp;a);//从一个字符串输入到变量     firstflag=1;     &#125;  else       sscanf(temp,&quot;%d&quot;,&amp;b);  for(s=0;s&lt;8;s++) //赋值完成后把缓冲区清零，防止下次输入影响结果        temp[s]=0;    if(num!=&#39;=&#39;)      //判断当前符号位并做相应处理     sign=num;      //如果不是等号记下标志位  else     &#123;       firstflag=0;   //检测到输入=号，判断上次读入的符合     switch(sign)       &#123;        case &#39;+&#39;:a=a+b;        break;        case &#39;-&#39;:a=a-b;        break;        case &#39;x&#39;:a=a*b;        break;        case &#39;/&#39;:a=a/b;        break;        default:break;       &#125;     sprintf(temp,&quot;%d&quot;,a);  //打印十进制到临时缓冲区      for(s=0;s&lt;8;s++)       //由于打印的是ASCII码值        &#123;         if(temp[s]==0)      //所以需要转换，如果为0表示null 数码管上则不能显示，所以赋值0            TempData[s]=0;        else if(temp[s]==0x2d)//表示负号，数码管显示负号 0x40             TempData[s]=0x40;    else              TempData[s]=dofly_DuanMa[temp[s]-&#39;0&#39;];//其他0-9负号则进行ASCII 到 数字处理，如当前是&#39;3&#39;，用&#39;3&#39;-&#39;0&#39;=3                                                   //&#39;3&#39;的16进制是0x33,&#39;0&#39;的16进制是0x30             &#125;     sign=0;a=b=0;            //用完后所有数据清零     for(s=0;s&lt;8;s++)        temp[s]=0;     &#125;  &#125;</code></pre><p>   elseif(i&lt;16)<br>      {</p><pre><code>     temp[i]=num+&#39;0&#39;;      TempData[i]=dofly_DuanMa[num];//输出数据     i++;   //输入数值累加   &#125;&#125;</code></pre><p>  }<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1GUj3y7ChSbSJMaSFNhp4cQ </span><br><span class="line">提取码：3p1t</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1GUj3y7ChSbSJMaSFNhp4cQ  提取码：3p1t</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】数码管递加/递减带闪烁消隐显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%95%B0%E7%A0%81%E7%AE%A1%E9%80%92%E5%8A%A0%E9%80%92%E5%87%8F%E5%B8%A6%E9%97%AA%E7%83%81%E6%B6%88%E9%9A%90%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%95%B0%E7%A0%81%E7%AE%A1%E9%80%92%E5%8A%A0%E9%80%92%E5%87%8F%E5%B8%A6%E9%97%AA%E7%83%81%E6%B6%88%E9%9A%90%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】数码管递加-递减带闪烁消隐显示"><a href="#【Proteus仿真】数码管递加-递减带闪烁消隐显示" class="headerlink" title="【Proteus仿真】数码管递加&#x2F;递减带闪烁消隐显示"></a>【Proteus仿真】数码管递加&#x2F;递减带闪烁消隐显示</h1><h3 id="【Proteus仿真】数码管递加-递减带闪烁消隐显示-1"><a href="#【Proteus仿真】数码管递加-递减带闪烁消隐显示-1" class="headerlink" title="【Proteus仿真】数码管递加&#x2F;递减带闪烁消隐显示"></a>【Proteus仿真】数码管递加&#x2F;递减带闪烁消隐显示</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/f12ed9caa6df4ceb95583df3f45188a4.gif#pic_center" alt="在这里插入图片描述"></p><p>数码管一段递增显示，另一端递减显示，中间两段闪烁。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/*-----------------------------------------------</span><br><span class="line">  名称：多位数码管动态扫描显示变化数据</span><br><span class="line">  内容：多位数码管分别显示不同数字，这种扫描显示方式成为动态扫描，并不停变化赋值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line"></span><br><span class="line">#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换</span><br><span class="line">sbit LATCH1=P2^2;//定义锁存使能端口 段锁存</span><br><span class="line">sbit LATCH2=P2^3;//                 位锁存</span><br><span class="line"></span><br><span class="line">unsigned char code DuanMa[10]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 显示段码值0~9</span><br><span class="line">unsigned char code WeiMa[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;//分别对应相应的数码管点亮,即位码</span><br><span class="line">unsigned char TempData[8]; //存储显示值的全局变量</span><br><span class="line">void Delay(unsigned int t); //函数声明</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num);</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> unsigned int numA=999,numB=0;</span><br><span class="line"> unsigned int j;</span><br><span class="line"> bit FlashFlag;</span><br><span class="line"> while(1)</span><br><span class="line">      &#123;</span><br><span class="line">   j++;</span><br><span class="line">   if(j==20)  //检测当前数值显示了一小段时间后，</span><br><span class="line">              //需要显示的数值，实现数据显示的变化</span><br><span class="line">     &#123;</span><br><span class="line">  j=0;</span><br><span class="line">  FlashFlag=!FlashFlag;</span><br><span class="line">  numB++;</span><br><span class="line">  if(numA&gt;0)//用于显示0~999</span><br><span class="line">    numA--;</span><br><span class="line">  else</span><br><span class="line">    numA=999;</span><br><span class="line">          if(numB==1000)</span><br><span class="line">    numB=0;</span><br><span class="line"> &#125;</span><br><span class="line">   //递减的三位数码管，带消隐</span><br><span class="line">       //分解显示信息，如要显示68，则68/10=6  68%10=8  </span><br><span class="line">    TempData[0] = DuanMa[numA/100];</span><br><span class="line">     TempData[1] = DuanMa[(numA%100)/10];</span><br><span class="line">     TempData[2] = DuanMa[(numA%100)%10];</span><br><span class="line">       //中间2位数码管不显示，赋值0</span><br><span class="line">  if(FlashFlag)</span><br><span class="line">    &#123;</span><br><span class="line">         TempData[3]=0x40; //显示&quot;-&quot;</span><br><span class="line">     TempData[4]=0x40; </span><br><span class="line"> &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">     TempData[3]=0; </span><br><span class="line">     TempData[4]=0; </span><br><span class="line">    &#125;</span><br><span class="line">       //递增的三位数码管，带消隐</span><br><span class="line">   //分解显示信息，如要显示68，则68/10=6  68%10=8</span><br><span class="line">    TempData[5]= DuanMa[numB/100];  </span><br><span class="line">     TempData[6]= DuanMa[(numB%100)/10];</span><br><span class="line">     TempData[7]= DuanMa[(numB%100)%10];</span><br><span class="line"></span><br><span class="line">   Display(0,8);//从第一位显示，共显示8位</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 延时函数，含有输入参数 unsigned int t，无返回值</span><br><span class="line"> unsigned int 是定义无符号整形变量，其值的范围是</span><br><span class="line"> 0~65535</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Delay(unsigned int t)</span><br><span class="line">&#123;</span><br><span class="line"> while(--t);</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 显示函数，用于动态扫描数码管</span><br><span class="line"> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示</span><br><span class="line"> 如输入0表示从第一个显示。</span><br><span class="line"> Num表示需要显示的位数，如需要显示99两位数值则该值输入2</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num)</span><br><span class="line">&#123;</span><br><span class="line">      unsigned char i;</span><br><span class="line">  </span><br><span class="line">  for(i=0;i&lt;Num;i++)</span><br><span class="line">   &#123; </span><br><span class="line">   DataPort=0;   //清空数据，防止有交替重影</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line"></span><br><span class="line">       DataPort= WeiMa[i+FirstBit]; //取位码 </span><br><span class="line">       LATCH2=1;     //位锁存</span><br><span class="line">       LATCH2=0;</span><br><span class="line"></span><br><span class="line">       DataPort=TempData[i]; //取显示数据，段码</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line">       </span><br><span class="line">   Delay(200); // 扫描间隙延时，时间太长会闪烁，太短会造成重影</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>———————————————–<br>  名称：多位数码管动态扫描显示变化数据<br>  内容：多位数码管分别显示不同数字，这种扫描显示方式成为动态扫描，并不停变化赋值<br>————————————————</em>&#x2F;<br>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</p><p>#define DataPort P0 &#x2F;&#x2F;定义数据端口 程序中遇到DataPort 则用P0 替换<br>sbit LATCH1&#x3D;P2^2;&#x2F;&#x2F;定义锁存使能端口 段锁存<br>sbit LATCH2&#x3D;P2^3;&#x2F;&#x2F;                 位锁存</p><p>unsigned char code DuanMa[10]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F; 显示段码值0<del>9<br>unsigned char code WeiMa[]&#x3D;{0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};&#x2F;&#x2F;分别对应相应的数码管点亮,即位码<br>unsigned char TempData[8]; &#x2F;&#x2F;存储显示值的全局变量<br>void Delay(unsigned int t); &#x2F;&#x2F;函数声明<br>void Display(unsigned char FirstBit,unsigned char Num);<br>&#x2F;<em>————————————————<br>                    主函数<br>————————————————</em>&#x2F;<br>void main()<br>{<br> unsigned int numA&#x3D;999,numB&#x3D;0;<br> unsigned int j;<br> bit FlashFlag;<br> while(1)<br>      {<br>       j++;<br>       if(j&#x3D;&#x3D;20)  &#x2F;&#x2F;检测当前数值显示了一小段时间后，<br>              &#x2F;&#x2F;需要显示的数值，实现数据显示的变化<br>         {<br>          j&#x3D;0;<br>          FlashFlag&#x3D;!FlashFlag;<br>          numB++;<br>          if(numA&gt;0)&#x2F;&#x2F;用于显示0</del>999<br>            numA–;<br>          else<br>            numA&#x3D;999;<br>          if(numB&#x3D;&#x3D;1000)<br>            numB&#x3D;0;<br>         }<br>       &#x2F;&#x2F;递减的三位数码管，带消隐<br>       &#x2F;&#x2F;分解显示信息，如要显示68，则68&#x2F;10&#x3D;6  68%10&#x3D;8<br>        TempData[0] &#x3D; DuanMa[numA&#x2F;100];<br>         TempData[1] &#x3D; DuanMa[(numA%100)&#x2F;10];<br>         TempData[2] &#x3D; DuanMa[(numA%100)%10];<br>       &#x2F;&#x2F;中间2位数码管不显示，赋值0<br>      if(FlashFlag)<br>        {<br>         TempData[3]&#x3D;0x40; &#x2F;&#x2F;显示”-“<br>         TempData[4]&#x3D;0x40;<br>         }<br>      else<br>        {<br>         TempData[3]&#x3D;0;<br>         TempData[4]&#x3D;0;<br>        }<br>       &#x2F;&#x2F;递增的三位数码管，带消隐<br>       &#x2F;&#x2F;分解显示信息，如要显示68，则68&#x2F;10&#x3D;6  68%10&#x3D;8<br>        TempData[5]&#x3D; DuanMa[numB&#x2F;100];<br>         TempData[6]&#x3D; DuanMa[(numB%100)&#x2F;10];<br>         TempData[7]&#x3D; DuanMa[(numB%100)%10];</p><pre><code>   Display(0,8);//从第一位显示，共显示8位  &#125;</code></pre><p>}<br>&#x2F;<em>————————————————<br> 延时函数，含有输入参数 unsigned int t，无返回值<br> unsigned int 是定义无符号整形变量，其值的范围是<br> 0~65535<br>————————————————</em>&#x2F;<br>void Delay(unsigned int t)<br>{<br> while(–t);<br>}<br>&#x2F;<em>————————————————<br> 显示函数，用于动态扫描数码管<br> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示<br> 如输入0表示从第一个显示。<br> Num表示需要显示的位数，如需要显示99两位数值则该值输入2<br>————————————————</em>&#x2F;<br>void Display(unsigned char FirstBit,unsigned char Num)<br>{<br>      unsigned char i;</p><pre><code>  for(i=0;i&lt;Num;i++)   &#123;    DataPort=0;   //清空数据，防止有交替重影   LATCH1=1;     //段锁存   LATCH1=0;   DataPort= WeiMa[i+FirstBit]; //取位码    LATCH2=1;     //位锁存   LATCH2=0;   DataPort=TempData[i]; //取显示数据，段码   LATCH1=1;     //段锁存   LATCH1=0;      Delay(200); // 扫描间隙延时，时间太长会闪烁，太短会造成重影   &#125;</code></pre><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台。可以基于VSM Studio独立仿真，不依赖Keil工程编译的hex文件。</p><p><code>Proteus8.12</code></p><p><code>VSM Studio</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1kpJpGytctmI1n7jNZK5rsQ </span><br><span class="line">提取码：yy90</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1kpJpGytctmI1n7jNZK5rsQ  提取码：yy90</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】步进电机转速数码管显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E8%BD%AC%E9%80%9F%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E8%BD%AC%E9%80%9F%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】步进电机转速数码管显示"><a href="#【Proteus仿真】步进电机转速数码管显示" class="headerlink" title="【Proteus仿真】步进电机转速数码管显示"></a>【Proteus仿真】步进电机转速数码管显示</h1><h3 id="【Proteus仿真】步进电机转速数码管显示-1"><a href="#【Proteus仿真】步进电机转速数码管显示-1" class="headerlink" title="【Proteus仿真】步进电机转速数码管显示"></a>【Proteus仿真】步进电机转速数码管显示</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/714d62cca1814549a6f0a802c8c9bb1e.gif#pic_center" alt="在这里插入图片描述"></p><p>采用4相8拍,数码管显示 40-90速度等级，数字越大，速度越慢。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周二 6月 28 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line">/*-----------------------------------------------</span><br><span class="line">  名称：步进电机</span><br><span class="line">  内容：本程序用于测试4相步进电机常规驱动 </span><br><span class="line">        使用1-2相励磁</span><br><span class="line">        1-2相激励功率增倍，步进角度减半，抖动减少</span><br><span class="line">        顺序如下 a-ab-b-bc-c-cd-d-da   又称4相8拍</span><br><span class="line">数码管显示 40-90速度等级，数字越大，速度越慢</span><br><span class="line"> ------------------------------------------------*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">typedef unsigned char   uchar;</span><br><span class="line">typedef unsigned int    uint;</span><br><span class="line">#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换</span><br><span class="line">#define out_port  (P1)</span><br><span class="line">sbit LATCH1=P2^2;//定义锁存使能端口 段锁存</span><br><span class="line">sbit LATCH2=P2^3;//                 位锁存</span><br><span class="line">uchar const sequence[8] = &#123;0x02,0x06,0x04,0x0c,0x08,0x09,0x01,0x03&#125;;</span><br><span class="line">unsigned char code  DuanMa[10]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 显示段码值0~9</span><br><span class="line">unsigned char code  WeiMa[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;//分别对应相应的数码管点亮,即位码</span><br><span class="line">unsigned char TempData[8]; //存储显示值的全局变量</span><br><span class="line"></span><br><span class="line">sbit A1=P1^0; //定义步进电机连接端口</span><br><span class="line">sbit B1=P1^1;</span><br><span class="line">sbit C1=P1^2;</span><br><span class="line">sbit D1=P1^3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned char Speed;</span><br><span class="line"></span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num);</span><br><span class="line">void Init_Timer0(void);</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> mS延时函数，含有输入参数 unsigned char t，无返回值</span><br><span class="line"> unsigned char 是定义无符号字符变量，其值的范围是</span><br><span class="line"> 0~255 这里使用晶振12M，精确延时请使用汇编</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void DelayMs(uint j)</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">   for(; j&gt;0; j--)</span><br><span class="line">    &#123; i = 120;</span><br><span class="line">      while (i--);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main()</span><br><span class="line">&#123;uchar i;</span><br><span class="line"> Init_Timer0();</span><br><span class="line"> EA=1;          //全局中断开</span><br><span class="line"> EX0=1;         //外部中断0开</span><br><span class="line"> IT0=1;         //1表示边沿触发</span><br><span class="line"></span><br><span class="line"> Speed=40;</span><br><span class="line"> TempData[0]= DuanMa[Speed/10];//分解显示信息，如要显示68， </span><br><span class="line"> TempData[1]= DuanMa[Speed%10];//则68/10=6  68%10=8 </span><br><span class="line">  out_port = 0x03;</span><br><span class="line">   while(1)</span><br><span class="line">    &#123; </span><br><span class="line">i = i&lt;8 ? i+1 : 0;</span><br><span class="line">     out_port = sequence[i];    </span><br><span class="line">     DelayMs(Speed);         //改变这个参数可以调整电机转速 ,</span><br><span class="line">                             //数字越小，转速越大,力矩越小</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 外部中断程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void ISR_INT0(void) interrupt 0 </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"> if(!INT0)</span><br><span class="line">   &#123;</span><br><span class="line">   DelayMs(10);//在此处可以添加去抖动程序，防止按键抖动造成错误</span><br><span class="line">   if(!INT0)</span><br><span class="line">   //while(!INT1);//等待按键释放</span><br><span class="line">     &#123;</span><br><span class="line">     Speed +=10;   </span><br><span class="line"> if(Speed==100)</span><br><span class="line">   Speed=40;</span><br><span class="line">    TempData[0]= DuanMa[Speed/10];//分解显示信息，如要显示68，  </span><br><span class="line"> TempData[1]= DuanMa[Speed%10];//则68/10=6  68%10=8</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 显示函数，用于动态扫描数码管</span><br><span class="line"> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示</span><br><span class="line"> 如输入0表示从第一个显示。</span><br><span class="line"> Num表示需要显示的位数，如需要显示99两位数值则该值输入2</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num)</span><br><span class="line">&#123;</span><br><span class="line">      static unsigned char i=0;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">   DataPort=0;   //清空数据，防止有交替重影</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line"></span><br><span class="line">       DataPort= WeiMa[i+FirstBit]; //取位码 </span><br><span class="line">       LATCH2=1;     //位锁存</span><br><span class="line">       LATCH2=0;</span><br><span class="line"></span><br><span class="line">       DataPort=TempData[i]; //取显示数据，段码</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line">       </span><br><span class="line">   i++;</span><br><span class="line">       if(i==Num)</span><br><span class="line">      i=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    定时器初始化子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_Timer0(void)</span><br><span class="line">&#123;</span><br><span class="line"> TMOD |= 0x01;  //使用模式1，16位定时器，使用&quot;|&quot;符号可以在使用多个定时器时不受影响     </span><br><span class="line"> //TH0=0x00;      //给定初值</span><br><span class="line"> //TL0=0x00;</span><br><span class="line"> EA=1;            //总中断打开</span><br><span class="line"> ET0=1;           //定时器中断打开</span><br><span class="line"> TR0=1;           //定时器开关打开</span><br><span class="line"> PT0=1;           //优先级打开</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 定时器中断子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Timer0_isr(void) interrupt 1 </span><br><span class="line">&#123;</span><br><span class="line"> TH0=(65536-2000)/256;  //重新赋值 2ms</span><br><span class="line"> TL0=(65536-2000)%256;</span><br><span class="line"> </span><br><span class="line"> Display(0,8);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周二 6月 28 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> <em>&#x2F;<br>&#x2F;</em>———————————————–</li></ul><p>  名称：步进电机<br>  内容：本程序用于测试4相步进电机常规驱动<br>        使用1-2相励磁<br>        1-2相激励功率增倍，步进角度减半，抖动减少<br>        顺序如下 a-ab-b-bc-c-cd-d-da   又称4相8拍<br>        数码管显示 40-90速度等级，数字越大，速度越慢<br> ————————————————*&#x2F;</p><p>#include &lt;reg52.h&gt;<br>typedef unsigned char   uchar;<br>typedef unsigned int    uint;<br>#define DataPort P0 &#x2F;&#x2F;定义数据端口 程序中遇到DataPort 则用P0 替换<br>#define out_port  (P1)<br>sbit LATCH1&#x3D;P2^2;&#x2F;&#x2F;定义锁存使能端口 段锁存<br>sbit LATCH2&#x3D;P2^3;&#x2F;&#x2F;                 位锁存<br>uchar const sequence[8] &#x3D; {0x02,0x06,0x04,0x0c,0x08,0x09,0x01,0x03};<br>unsigned char code  DuanMa[10]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F; 显示段码值0~9<br>unsigned char code  WeiMa[]&#x3D;{0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};&#x2F;&#x2F;分别对应相应的数码管点亮,即位码<br>unsigned char TempData[8]; &#x2F;&#x2F;存储显示值的全局变量</p><p>sbit A1&#x3D;P1^0; &#x2F;&#x2F;定义步进电机连接端口<br>sbit B1&#x3D;P1^1;<br>sbit C1&#x3D;P1^2;<br>sbit D1&#x3D;P1^3;</p><p>unsigned char Speed;</p><p>void Display(unsigned char FirstBit,unsigned char Num);<br>void Init_Timer0(void);</p><p>&#x2F;<em>————————————————<br> mS延时函数，含有输入参数 unsigned char t，无返回值<br> unsigned char 是定义无符号字符变量，其值的范围是<br> 0~255 这里使用晶振12M，精确延时请使用汇编<br>————————————————</em>&#x2F;<br>void DelayMs(uint j)<br>{<br>    uchar i;<br>   for(; j&gt;0; j–)<br>    { i &#x3D; 120;<br>      while (i–);<br>    }<br>}<br>&#x2F;<em>————————————————<br>                    主函数<br>————————————————</em>&#x2F;<br>void main()<br>{uchar i;<br> Init_Timer0();<br> EA&#x3D;1;          &#x2F;&#x2F;全局中断开<br> EX0&#x3D;1;         &#x2F;&#x2F;外部中断0开<br> IT0&#x3D;1;         &#x2F;&#x2F;1表示边沿触发</p><p> Speed&#x3D;40;<br> TempData[0]&#x3D; DuanMa[Speed&#x2F;10];&#x2F;&#x2F;分解显示信息，如要显示68，<br> TempData[1]&#x3D; DuanMa[Speed%10];&#x2F;&#x2F;则68&#x2F;10&#x3D;6  68%10&#x3D;8<br>  out_port &#x3D; 0x03;<br>   while(1)<br>    {<br>    i &#x3D; i&lt;8 ? i+1 : 0;<br>     out_port &#x3D; sequence[i];<br>     DelayMs(Speed);         &#x2F;&#x2F;改变这个参数可以调整电机转速 ,<br>                             &#x2F;&#x2F;数字越小，转速越大,力矩越小<br>  }<br>}</p><p>&#x2F;<em>————————————————<br>                 外部中断程序<br>————————————————</em>&#x2F;<br>void ISR_INT0(void) interrupt 0<br>{</p><p> if(!INT0)<br>   {<br>   DelayMs(10);&#x2F;&#x2F;在此处可以添加去抖动程序，防止按键抖动造成错误<br>   if(!INT0)<br>   &#x2F;&#x2F;while(!INT1);&#x2F;&#x2F;等待按键释放<br>     {<br>     Speed +&#x3D;10;<br>     if(Speed&#x3D;&#x3D;100)<br>       Speed&#x3D;40;<br>        TempData[0]&#x3D; DuanMa[Speed&#x2F;10];&#x2F;&#x2F;分解显示信息，如要显示68，<br>     TempData[1]&#x3D; DuanMa[Speed%10];&#x2F;&#x2F;则68&#x2F;10&#x3D;6  68%10&#x3D;8<br>     }<br>   }<br>}<br>&#x2F;<em>————————————————<br> 显示函数，用于动态扫描数码管<br> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示<br> 如输入0表示从第一个显示。<br> Num表示需要显示的位数，如需要显示99两位数值则该值输入2<br>————————————————</em>&#x2F;<br>void Display(unsigned char FirstBit,unsigned char Num)<br>{<br>      static unsigned char i&#x3D;0;</p><pre><code>   DataPort=0;   //清空数据，防止有交替重影   LATCH1=1;     //段锁存   LATCH1=0;   DataPort= WeiMa[i+FirstBit]; //取位码    LATCH2=1;     //位锁存   LATCH2=0;   DataPort=TempData[i]; //取显示数据，段码   LATCH1=1;     //段锁存   LATCH1=0;      i++;   if(i==Num)      i=0;</code></pre><p>}<br>&#x2F;<em>————————————————<br>                    定时器初始化子程序<br>————————————————</em>&#x2F;<br>void Init_Timer0(void)<br>{<br> TMOD |&#x3D; 0x01;  &#x2F;&#x2F;使用模式1，16位定时器，使用”|”符号可以在使用多个定时器时不受影响<br> &#x2F;&#x2F;TH0&#x3D;0x00;      &#x2F;&#x2F;给定初值<br> &#x2F;&#x2F;TL0&#x3D;0x00;<br> EA&#x3D;1;            &#x2F;&#x2F;总中断打开<br> ET0&#x3D;1;           &#x2F;&#x2F;定时器中断打开<br> TR0&#x3D;1;           &#x2F;&#x2F;定时器开关打开<br> PT0&#x3D;1;           &#x2F;&#x2F;优先级打开<br>}<br>&#x2F;<em>————————————————<br>                 定时器中断子程序<br>————————————————</em>&#x2F;<br>void Timer0_isr(void) interrupt 1<br>{<br> TH0&#x3D;(65536-2000)&#x2F;256;  &#x2F;&#x2F;重新赋值 2ms<br> TL0&#x3D;(65536-2000)%256;</p><p> Display(0,8);</p><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1weDjea_J5ZyeEZ4IbRBP9Q </span><br><span class="line">提取码：24d3</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1weDjea_J5ZyeEZ4IbRBP9Q  提取码：24d3</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】直流电机方向和速度按键控制</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%96%B9%E5%90%91%E5%92%8C%E9%80%9F%E5%BA%A6%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E6%96%B9%E5%90%91%E5%92%8C%E9%80%9F%E5%BA%A6%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】直流电机方向和速度按键控制"><a href="#【Proteus仿真】直流电机方向和速度按键控制" class="headerlink" title="【Proteus仿真】直流电机方向和速度按键控制"></a>【Proteus仿真】直流电机方向和速度按键控制</h1><h3 id="【Proteus仿真】直流电机方向和速度按键控制-1"><a href="#【Proteus仿真】直流电机方向和速度按键控制-1" class="headerlink" title="【Proteus仿真】直流电机方向和速度按键控制"></a>【Proteus仿真】直流电机方向和速度按键控制</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/3383bc098acf4c49beb438c31912354e.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">//*************************************************************************************************</span><br><span class="line">//*************************************************************************************************</span><br><span class="line">//**&lt;程序名&gt;：键盘控制直流电机运转。  **</span><br><span class="line">//**&lt;功能&gt;：通过按键控制直流电机运转并在LCD上显示运行状态。 **</span><br><span class="line">//*************************************************************************************************</span><br><span class="line">//*************************************************************************************************</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;includes.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define TIME0H 0xFF</span><br><span class="line">#define TIME0L 0x9C//定时器0溢出时间：0.1ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define TIME1H 0x3C</span><br><span class="line">#define TIME1L 0xB0//定时器1溢出时间：50ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;PWM调制计数&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">unsigned char uc_MoCount=0;</span><br><span class="line">unsigned char uc_MoChange=128;</span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;防抖动标志&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">bit b_KeyShock=0;  //键盘防抖动标志位。</span><br><span class="line">//当按键中断产生时，首先判断此位。</span><br><span class="line">//0--执行键盘扫描及键码处理程序；1--不执行。</span><br><span class="line"></span><br><span class="line">bit b_KillShock=0;//防抖标志清除位：0--不清除；1--清除。</span><br><span class="line"></span><br><span class="line">unsigned char uc_KillCount=1;//抖动标志清除计数，使用定时器1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;键盘扫描开启标志&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">bit b_KeyScan=0;//0--不扫描；</span><br><span class="line">//1--扫描。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">vdInitialize();</span><br><span class="line"></span><br><span class="line">vWriteCMD(0x80);</span><br><span class="line">vShowChar(&quot;Motor Run Status&quot;);</span><br><span class="line">vWriteCMD(0xC4);</span><br><span class="line">vShowChar(&quot;Stop&quot;);</span><br><span class="line">vWriteCMD(0xCC);</span><br><span class="line">vShowNumber(uc_MoChange);</span><br><span class="line"></span><br><span class="line">SCANPORT=0x0F;</span><br><span class="line"></span><br><span class="line">MOTORPORT=MO_STOP;</span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;外部中断0，用于开启键盘扫描及键码处理标志&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">IT0=1; //中断方式：下降沿。</span><br><span class="line">EX0=1; //开启外部中断。</span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;定时器0，定时器0中断，用于PWM调制计数 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TMOD=0x11;</span><br><span class="line"></span><br><span class="line">TH0=TIME0H;</span><br><span class="line">TL0=TIME0L;</span><br><span class="line">TR0=1;</span><br><span class="line">ET0=1;</span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;定时器1，用于防抖动标志清除 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TH1=TIME1H;</span><br><span class="line">TL1=TIME1L;</span><br><span class="line">TR1=1; //开启定时器1</span><br><span class="line">ET1=1; //开定时器1中断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EA=1;</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">if(b_KeyScan==1)   //如果有按键按下，则进行按键扫描和键码处理。</span><br><span class="line">&#123;</span><br><span class="line">b_KeyScan=0;</span><br><span class="line">vKeyProcess(ucKeyScan());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//*************************************************************************************************</span><br><span class="line">//*  *</span><br><span class="line">//*******************************外部中断0，用于开启键盘扫描及键码处理******************  *</span><br><span class="line">//*  *</span><br><span class="line">//*************************************************************************************************</span><br><span class="line">void vINT0(void) interrupt 0</span><br><span class="line">&#123;</span><br><span class="line">if(b_KeyShock==0)</span><br><span class="line">&#123;</span><br><span class="line">b_KeyScan=1;//开启键盘扫描标志。</span><br><span class="line">b_KeyShock=1;//设置防抖动标志。</span><br><span class="line">&#125;</span><br><span class="line">else b_KeyShock=0;//如果有抖动则不执行键扫描，恢复防抖动标志。</span><br><span class="line"></span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;设置防抖动清除标志位 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">if(b_KeyShock==1)</span><br><span class="line">b_KillShock=1;//如果防抖动标志位开启则开启防抖动标志清除位，</span><br><span class="line">//300ms后清除防抖动标志。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//*************************************************************************************************</span><br><span class="line">//*  *</span><br><span class="line">//*****************************定时器0中断，用于PWM调制计数****************************  *</span><br><span class="line">//*  *</span><br><span class="line">//*************************************************************************************************</span><br><span class="line">void vTimer0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(uc_MoChange&gt;128)  //正向。</span><br><span class="line">&#123;</span><br><span class="line">if(uc_MoCount&lt;uc_MoChange)</span><br><span class="line">MOTORPORT=MO_COMMON;</span><br><span class="line">else</span><br><span class="line">MOTORPORT=MO_CUTOFF;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(uc_MoChange&lt;127) //反向。</span><br><span class="line">&#123;</span><br><span class="line">if(uc_MoCount&gt;uc_MoChange)</span><br><span class="line">MOTORPORT=MO_OPPOSE;</span><br><span class="line">else</span><br><span class="line">MOTORPORT=MO_CUTOFF;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">MOTORPORT=MO_STOP;//停止</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(uc_MoCount&lt;255)</span><br><span class="line">uc_MoCount++;</span><br><span class="line">else</span><br><span class="line">uc_MoCount=0;</span><br><span class="line"></span><br><span class="line">TH0=TIME0H;</span><br><span class="line">TL0=TIME0L;</span><br><span class="line">&#125;</span><br><span class="line">//*************************************************************************************************</span><br><span class="line">//*  *</span><br><span class="line">//*****************定时器1中断，用于计时功能和防抖动标志清除以及显示报告****************  *</span><br><span class="line">//*  *</span><br><span class="line">//*************************************************************************************************</span><br><span class="line">void vTimer1(void) interrupt 3</span><br><span class="line">&#123;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;防抖动标志清除&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">if(b_KillShock==1)</span><br><span class="line">&#123;</span><br><span class="line">if(uc_KillCount==5) //当防抖动标志位为1时，计时300ms后清除抖动标志位。</span><br><span class="line">&#123;</span><br><span class="line">b_KeyShock=0;</span><br><span class="line">b_KillShock=0;</span><br><span class="line">uc_KillCount=1;</span><br><span class="line">&#125;</span><br><span class="line">else uc_KillCount++;</span><br><span class="line">&#125;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;恢复定时器1溢出时间&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TH1=TIME1H;</span><br><span class="line">TL1=TIME1L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;&#x2F;*************************************************************************************************<br>&#x2F;&#x2F;*************************************************************************************************<br>&#x2F;&#x2F;<strong>&lt;程序名&gt;：键盘控制直流电机运转。  **<br>&#x2F;&#x2F;</strong>&lt;功能&gt;：通过按键控制直流电机运转并在LCD上显示运行状态。 **<br>&#x2F;&#x2F;*************************************************************************************************<br>&#x2F;&#x2F;*************************************************************************************************</p><p>#include “includes.h”</p><p>#define TIME0H 0xFF<br>#define TIME0L 0x9C&#x2F;&#x2F;定时器0溢出时间：0.1ms</p><p>#define TIME1H 0x3C<br>#define TIME1L 0xB0&#x2F;&#x2F;定时器1溢出时间：50ms</p><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;PWM调制计数&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>unsigned char uc_MoCount&#x3D;0;<br>unsigned char uc_MoChange&#x3D;128;</p><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;防抖动标志&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>bit b_KeyShock&#x3D;0;  &#x2F;&#x2F;键盘防抖动标志位。<br>                                    &#x2F;&#x2F;当按键中断产生时，首先判断此位。<br>                                    &#x2F;&#x2F;0–执行键盘扫描及键码处理程序；1–不执行。</p><p>bit b_KillShock&#x3D;0;&#x2F;&#x2F;防抖标志清除位：0–不清除；1–清除。</p><p>unsigned char uc_KillCount&#x3D;1;&#x2F;&#x2F;抖动标志清除计数，使用定时器1。</p><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;键盘扫描开启标志&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>bit b_KeyScan&#x3D;0;&#x2F;&#x2F;0–不扫描；<br>                                    &#x2F;&#x2F;1–扫描。</p><p>void main()<br>{<br>    vdInitialize();</p><pre><code>vWriteCMD(0x80);vShowChar(&quot;Motor Run Status&quot;);vWriteCMD(0xC4);vShowChar(&quot;Stop&quot;);vWriteCMD(0xCC);vShowNumber(uc_MoChange);SCANPORT=0x0F;MOTORPORT=MO_STOP;</code></pre><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;外部中断0，用于开启键盘扫描及键码处理标志&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    IT0&#x3D;1; &#x2F;&#x2F;中断方式：下降沿。<br>    EX0&#x3D;1; &#x2F;&#x2F;开启外部中断。</p><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;定时器0，定时器0中断，用于PWM调制计数 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    TMOD&#x3D;0x11;</p><pre><code>TH0=TIME0H;TL0=TIME0L;TR0=1;ET0=1;</code></pre><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;定时器1，用于防抖动标志清除 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    TH1&#x3D;TIME1H;<br>    TL1&#x3D;TIME1L;<br>    TR1&#x3D;1; &#x2F;&#x2F;开启定时器1<br>    ET1&#x3D;1; &#x2F;&#x2F;开定时器1中断</p><pre><code>EA=1;while(1)&#123;if(b_KeyScan==1)   //如果有按键按下，则进行按键扫描和键码处理。    &#123;    b_KeyScan=0;    vKeyProcess(ucKeyScan());    &#125;&#125;</code></pre><p>}</p><p>&#x2F;&#x2F;*************************************************************************************************<br>&#x2F;&#x2F;*  *<br>&#x2F;&#x2F;*<em><strong><strong><strong><strong><strong><em><strong><strong><strong><strong><strong><strong><strong><strong><strong>外部中断0，用于开启键盘扫描及键码处理</strong></strong></strong></strong></strong></strong></strong></strong></strong>  *<br>&#x2F;&#x2F;</em>  *<br>&#x2F;&#x2F;</strong></strong></strong></strong></strong></em>**************************************************************************************<br>void vINT0(void) interrupt 0<br>{<br>    if(b_KeyShock&#x3D;&#x3D;0)<br>        {<br>            b_KeyScan&#x3D;1;&#x2F;&#x2F;开启键盘扫描标志。<br>            b_KeyShock&#x3D;1;&#x2F;&#x2F;设置防抖动标志。<br>        }<br>    else b_KeyShock&#x3D;0;&#x2F;&#x2F;如果有抖动则不执行键扫描，恢复防抖动标志。</p><p>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;设置防抖动清除标志位 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    if(b_KeyShock&#x3D;&#x3D;1)<br>        b_KillShock&#x3D;1;&#x2F;&#x2F;如果防抖动标志位开启则开启防抖动标志清除位，<br>                                    &#x2F;&#x2F;300ms后清除防抖动标志。</p><p>}</p><p>&#x2F;&#x2F;*************************************************************************************************<br>&#x2F;&#x2F;*  *<br>&#x2F;&#x2F;*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>定时器0中断，用于PWM调制计数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>  *<br>&#x2F;&#x2F;*  *<br>&#x2F;&#x2F;*************************************************************************************************<br>void vTimer0() interrupt 1<br>{</p><pre><code>if(uc_MoChange&gt;128)  //正向。    &#123;    if(uc_MoCount&lt;uc_MoChange)        MOTORPORT=MO_COMMON;    else        MOTORPORT=MO_CUTOFF;    &#125;else    &#123;    if(uc_MoChange&lt;127) //反向。        &#123;        if(uc_MoCount&gt;uc_MoChange)            MOTORPORT=MO_OPPOSE;        else            MOTORPORT=MO_CUTOFF;        &#125;    else        MOTORPORT=MO_STOP;//停止    &#125;if(uc_MoCount&lt;255)    uc_MoCount++;else    uc_MoCount=0;TH0=TIME0H;TL0=TIME0L;</code></pre><p>}<br>&#x2F;&#x2F;*************************************************************************************************<br>&#x2F;&#x2F;*  *<br>&#x2F;&#x2F;*<strong><strong><strong><strong><strong><strong><strong><strong>定时器1中断，用于计时功能和防抖动标志清除以及显示报告</strong></strong></strong></strong></strong></strong></strong></strong>  *<br>&#x2F;&#x2F;*  *<br>&#x2F;&#x2F;*************************************************************************************************<br>void vTimer1(void) interrupt 3<br>{<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;防抖动标志清除&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    if(b_KillShock&#x3D;&#x3D;1)<br>        {<br>        if(uc_KillCount&#x3D;&#x3D;5) &#x2F;&#x2F;当防抖动标志位为1时，计时300ms后清除抖动标志位。<br>            {<br>            b_KeyShock&#x3D;0;<br>            b_KillShock&#x3D;0;<br>            uc_KillCount&#x3D;1;<br>            }<br>        else uc_KillCount++;<br>        }<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;恢复定时器1溢出时间&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&#x2F;&#x2F;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>    TH1&#x3D;TIME1H;<br>    TL1&#x3D;TIME1L;<br>}&#96;</p><ul><li>工程架构</li><li>添加头文件方法</li></ul><p><img src="https://img-blog.csdnimg.cn/3c2b75c654a84649a77e7f5fed526f52.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2bf5d110ff294ca2aa09186645420b11.png" alt="在这里插入图片描述"></p><h4 id="程序代码和仿真资源"><a href="#程序代码和仿真资源" class="headerlink" title="程序代码和仿真资源"></a>程序代码和仿真资源</h4><p>本实验基于Proteus8.9SP2平台</p><p><code>Proteus8.9SP2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1NLJJy2qP8ErFIc42lbsxJQ </span><br><span class="line">提取码：aeyl</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1NLJJy2qP8ErFIc42lbsxJQ  提取码：aeyl</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】矩阵键盘中断扫描</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E6%89%AB%E6%8F%8F/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】矩阵键盘中断扫描"><a href="#【Proteus仿真】矩阵键盘中断扫描" class="headerlink" title="【Proteus仿真】矩阵键盘中断扫描"></a>【Proteus仿真】矩阵键盘中断扫描</h1><h3 id="【Proteus仿真】矩阵键盘中断扫描-1"><a href="#【Proteus仿真】矩阵键盘中断扫描-1" class="headerlink" title="【Proteus仿真】矩阵键盘中断扫描"></a>【Proteus仿真】矩阵键盘中断扫描</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/58392d855c71424c829ad420358af437.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">/*-----------------------------------------------</span><br><span class="line">  名称：矩阵键盘依次输入控制 使用行列逐级扫描 中断方式</span><br><span class="line">  内容：如计算器输入数据形式相同 从右至左 使用行列扫描方法</span><br><span class="line">        中断方式可以有效提供cpu工作效率，在有按键动作时才扫描，平时不进行扫描工作</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换</span><br><span class="line">#define KeyPort  P1</span><br><span class="line"></span><br><span class="line">sbit LATCH1=P2^2;//定义锁存使能端口 段锁存</span><br><span class="line">sbit LATCH2=P2^3;//                 位锁存</span><br><span class="line"></span><br><span class="line">bit KeyPressFlag;//定义按键标志位</span><br><span class="line"></span><br><span class="line">unsigned char code DuanMa[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,</span><br><span class="line">                           0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;// 显示段码值0~F</span><br><span class="line">unsigned char code WeiMa[]=&#123;0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;//分别对应相应的数码管点亮,即位码</span><br><span class="line">unsigned char TempData[10]; //存储显示值的全局变量</span><br><span class="line"></span><br><span class="line">void DelayUs2x(unsigned char t);//us级延时函数声明 </span><br><span class="line">void DelayMs(unsigned char t); //ms级延时</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num);//数码管显示函数</span><br><span class="line">unsigned char KeyScan(void);//键盘扫描</span><br><span class="line">unsigned char KeyPro(void);</span><br><span class="line">void Init_Timer0(void);//定时器初始化</span><br><span class="line">void Init_INT0(void);  //外部中断0初始化和</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main (void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char num,i,j;                  </span><br><span class="line">unsigned char temp[8];</span><br><span class="line">Init_Timer0();</span><br><span class="line">Init_INT0();</span><br><span class="line">while (1)         //主循环</span><br><span class="line">  &#123;</span><br><span class="line">  KeyPort=0xf0;// 赋值用于中断检测</span><br><span class="line"> if(KeyPressFlag==1)</span><br><span class="line"> &#123;</span><br><span class="line">  KeyPressFlag=0;  //按键标志清零，以便下次检测</span><br><span class="line">  num=KeyPro();    </span><br><span class="line">  if(num!=0xff)</span><br><span class="line">   &#123;</span><br><span class="line">    if(i&lt;8)</span><br><span class="line">      &#123;</span><br><span class="line">       temp[i]=DuanMa[num];</span><br><span class="line">   for(j=0;j&lt;=i;j++)</span><br><span class="line">          TempData[7-i+j]=temp[j];</span><br><span class="line">       &#125;</span><br><span class="line">i++;</span><br><span class="line">if(i==9)//多出一个按键输入为了清屏 原本应该为8</span><br><span class="line">      &#123;</span><br><span class="line">  i=0;</span><br><span class="line">      for(j=0;j&lt;8;j++)//清屏</span><br><span class="line">         TempData[j]=0;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> uS延时函数，含有输入参数 unsigned char t，无返回值</span><br><span class="line"> unsigned char 是定义无符号字符变量，其值的范围是</span><br><span class="line"> 0~255 这里使用晶振12M，精确延时请使用汇编,大致延时</span><br><span class="line"> 长度如下 T=tx2+5 uS </span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void DelayUs2x(unsigned char t)</span><br><span class="line">&#123;   </span><br><span class="line"> while(--t);</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> mS延时函数，含有输入参数 unsigned char t，无返回值</span><br><span class="line"> unsigned char 是定义无符号字符变量，其值的范围是</span><br><span class="line"> 0~255 这里使用晶振12M，精确延时请使用汇编</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void DelayMs(unsigned char t)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line"> while(t--)</span><br><span class="line"> &#123;</span><br><span class="line">     //大致延时1mS</span><br><span class="line">     DelayUs2x(245);</span><br><span class="line"> DelayUs2x(245);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> 显示函数，用于动态扫描数码管</span><br><span class="line"> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示</span><br><span class="line"> 如输入0表示从第一个显示。</span><br><span class="line"> Num表示需要显示的位数，如需要显示99两位数值则该值输入2</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Display(unsigned char FirstBit,unsigned char Num)</span><br><span class="line">&#123;</span><br><span class="line">      static unsigned char i=0;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">   DataPort=0;   //清空数据，防止有交替重影</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line"></span><br><span class="line">       DataPort = WeiMa[i+FirstBit]; //取位码 </span><br><span class="line">       LATCH2=1;     //位锁存</span><br><span class="line">       LATCH2=0;</span><br><span class="line"></span><br><span class="line">       DataPort=TempData[i]; //取显示数据，段码</span><br><span class="line">       LATCH1=1;     //段锁存</span><br><span class="line">       LATCH1=0;</span><br><span class="line">       </span><br><span class="line">   i++;</span><br><span class="line">       if(i==Num)</span><br><span class="line">      i=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    定时器初始化子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_Timer0(void)</span><br><span class="line">&#123;</span><br><span class="line"> TMOD |= 0x01;  //使用模式1，16位定时器，使用&quot;|&quot;符号可以在使用多个定时器时不受影响     </span><br><span class="line"> //TH0=0x00;      //给定初值</span><br><span class="line"> //TL0=0x00;</span><br><span class="line"> EA=1;            //总中断打开</span><br><span class="line"> ET0=1;           //定时器中断打开</span><br><span class="line"> TR0=1;           //定时器开关打开</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 定时器中断子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Timer0_isr(void) interrupt 1 </span><br><span class="line">&#123;</span><br><span class="line"> TH0=(65536-2000)/256;  //重新赋值 2ms</span><br><span class="line"> TL0=(65536-2000)%256;</span><br><span class="line"> </span><br><span class="line"> Display(0,8);       // 调用数码管扫描</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">按键扫描函数，返回扫描键值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">unsigned char KeyScan(void)  //键盘扫描函数，使用行列逐级扫描法</span><br><span class="line">&#123;</span><br><span class="line"> unsigned char Val;</span><br><span class="line"> KeyPort=0xf0;//高四位置高，低四位拉低</span><br><span class="line"> if(KeyPort!=0xf0)//表示有按键按下</span><br><span class="line">   &#123;</span><br><span class="line">    DelayMs(10);  //去抖</span><br><span class="line">if(KeyPort!=0xf0)</span><br><span class="line">  &#123;           //表示有按键按下</span><br><span class="line">    KeyPort=0xfe; //检测第一行</span><br><span class="line">if(KeyPort!=0xfe)</span><br><span class="line">  &#123;</span><br><span class="line">  Val=KeyPort&amp;0xf0;</span><br><span class="line">        Val+=0x0e;</span><br><span class="line">    while(KeyPort!=0xfe);</span><br><span class="line">  DelayMs(10); //去抖</span><br><span class="line">  while(KeyPort!=0xfe);</span><br><span class="line">       return Val;</span><br><span class="line">        &#125;</span><br><span class="line">        KeyPort=0xfd; //检测第二行</span><br><span class="line">if(KeyPort!=0xfd)</span><br><span class="line">  &#123;</span><br><span class="line">  Val=KeyPort&amp;0xf0;</span><br><span class="line">        Val+=0x0d;</span><br><span class="line">    while(KeyPort!=0xfd);</span><br><span class="line">  DelayMs(10); //去抖</span><br><span class="line">  while(KeyPort!=0xfd);</span><br><span class="line">       return Val;</span><br><span class="line">        &#125;</span><br><span class="line">    KeyPort=0xfb; //检测第三行</span><br><span class="line">if(KeyPort!=0xfb)</span><br><span class="line">  &#123;</span><br><span class="line">  Val=KeyPort&amp;0xf0;</span><br><span class="line">        Val+=0x0b;</span><br><span class="line">    while(KeyPort!=0xfb);</span><br><span class="line">  DelayMs(10); //去抖</span><br><span class="line">  while(KeyPort!=0xfb);</span><br><span class="line">       return Val;</span><br><span class="line">        &#125;</span><br><span class="line">    KeyPort=0xf7; //检测第四行</span><br><span class="line">if(KeyPort!=0xf7)</span><br><span class="line">  &#123;</span><br><span class="line">  Val=KeyPort&amp;0xf0;</span><br><span class="line">        Val+=0x07;</span><br><span class="line">    while(KeyPort!=0xf7);</span><br><span class="line">  DelayMs(10); //去抖</span><br><span class="line">  while(KeyPort!=0xf7);</span><br><span class="line">       return Val;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  return 0xff;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">按键值处理函数，返回扫键值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">unsigned char KeyPro(void)</span><br><span class="line">&#123;</span><br><span class="line"> switch(KeyScan())</span><br><span class="line"> &#123;</span><br><span class="line">  case 0x7e:return 0;break;//0 按下相应的键显示相对应的码值</span><br><span class="line">  case 0x7d:return 1;break;//1</span><br><span class="line">  case 0x7b:return 2;break;//2</span><br><span class="line">  case 0x77:return 3;break;//3</span><br><span class="line">  case 0xbe:return 4;break;//4</span><br><span class="line">  case 0xbd:return 5;break;//5</span><br><span class="line">  case 0xbb:return 6;break;//6</span><br><span class="line">  case 0xb7:return 7;break;//7</span><br><span class="line">  case 0xde:return 8;break;//8</span><br><span class="line">  case 0xdd:return 9;break;//9</span><br><span class="line">  case 0xdb:return 10;break;//a</span><br><span class="line">  case 0xd7:return 11;break;//b</span><br><span class="line">  case 0xee:return 12;break;//c</span><br><span class="line">  case 0xed:return 13;break;//d</span><br><span class="line">  case 0xeb:return 14;break;//e</span><br><span class="line">  case 0xe7:return 15;break;//f</span><br><span class="line">  default:return 0xff;break;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">           外部中断0初始化</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_INT0(void)</span><br><span class="line">&#123;</span><br><span class="line">  EA=1;          //全局中断开</span><br><span class="line">  EX0=1;         //外部中断0开</span><br><span class="line">  IT0=1;         //边沿触发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 外部中断0程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void ISR_INT0(void) interrupt 0 </span><br><span class="line">&#123;</span><br><span class="line"> KeyPressFlag=1;   //表明按键有动作，可以进行按键扫描</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;<em>———————————————–<br>  名称：矩阵键盘依次输入控制 使用行列逐级扫描 中断方式<br>  内容：如计算器输入数据形式相同 从右至左 使用行列扫描方法<br>        中断方式可以有效提供cpu工作效率，在有按键动作时才扫描，平时不进行扫描工作<br>————————————————</em>&#x2F;<br>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</p><p>#define DataPort P0 &#x2F;&#x2F;定义数据端口 程序中遇到DataPort 则用P0 替换<br>#define KeyPort  P1</p><p>sbit LATCH1&#x3D;P2^2;&#x2F;&#x2F;定义锁存使能端口 段锁存<br>sbit LATCH2&#x3D;P2^3;&#x2F;&#x2F;                 位锁存</p><p>bit KeyPressFlag;&#x2F;&#x2F;定义按键标志位</p><p>unsigned char code DuanMa[]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,<br>                                   0x77,0x7c,0x39,0x5e,0x79,0x71};&#x2F;&#x2F; 显示段码值0~F<br>unsigned char code WeiMa[]&#x3D;{0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};&#x2F;&#x2F;分别对应相应的数码管点亮,即位码<br>unsigned char TempData[10]; &#x2F;&#x2F;存储显示值的全局变量</p><p>void DelayUs2x(unsigned char t);&#x2F;&#x2F;us级延时函数声明<br>void DelayMs(unsigned char t); &#x2F;&#x2F;ms级延时<br>void Display(unsigned char FirstBit,unsigned char Num);&#x2F;&#x2F;数码管显示函数<br>unsigned char KeyScan(void);&#x2F;&#x2F;键盘扫描<br>unsigned char KeyPro(void);<br>void Init_Timer0(void);&#x2F;&#x2F;定时器初始化<br>void Init_INT0(void);  &#x2F;&#x2F;外部中断0初始化和<br>&#x2F;<em>————————————————<br>                    主函数<br>————————————————</em>&#x2F;<br>void main (void)<br>{<br>unsigned char num,i,j;<br>unsigned char temp[8];<br>Init_Timer0();<br>Init_INT0();<br>while (1)         &#x2F;&#x2F;主循环<br>  {<br>  KeyPort&#x3D;0xf0;&#x2F;&#x2F; 赋值用于中断检测<br> if(KeyPressFlag&#x3D;&#x3D;1)<br> {<br>  KeyPressFlag&#x3D;0;  &#x2F;&#x2F;按键标志清零，以便下次检测<br>  num&#x3D;KeyPro();<br>  if(num!&#x3D;0xff)<br>   {<br>    if(i&lt;8)<br>      {<br>       temp[i]&#x3D;DuanMa[num];<br>       for(j&#x3D;0;j&lt;&#x3D;i;j++)<br>          TempData[7-i+j]&#x3D;temp[j];<br>       }<br>    i++;<br>    if(i&#x3D;&#x3D;9)&#x2F;&#x2F;多出一个按键输入为了清屏 原本应该为8<br>      {<br>      i&#x3D;0;<br>      for(j&#x3D;0;j&lt;8;j++)&#x2F;&#x2F;清屏<br>         TempData[j]&#x3D;0;<br>       }<br>     }<br>    }<br> }<br>}<br>&#x2F;<em>————————————————<br> uS延时函数，含有输入参数 unsigned char t，无返回值<br> unsigned char 是定义无符号字符变量，其值的范围是<br> 0~255 这里使用晶振12M，精确延时请使用汇编,大致延时<br> 长度如下 T&#x3D;tx2+5 uS<br>————————————————</em>&#x2F;<br>void DelayUs2x(unsigned char t)<br>{<br> while(–t);<br>}<br>&#x2F;<em>————————————————<br> mS延时函数，含有输入参数 unsigned char t，无返回值<br> unsigned char 是定义无符号字符变量，其值的范围是<br> 0~255 这里使用晶振12M，精确延时请使用汇编<br>————————————————</em>&#x2F;<br>void DelayMs(unsigned char t)<br>{</p><p> while(t–)<br> {<br>     &#x2F;&#x2F;大致延时1mS<br>     DelayUs2x(245);<br>     DelayUs2x(245);<br> }<br>}<br>&#x2F;<em>————————————————<br> 显示函数，用于动态扫描数码管<br> 输入参数 FirstBit 表示需要显示的第一位，如赋值2表示从第三个数码管开始显示<br> 如输入0表示从第一个显示。<br> Num表示需要显示的位数，如需要显示99两位数值则该值输入2<br>————————————————</em>&#x2F;<br>void Display(unsigned char FirstBit,unsigned char Num)<br>{<br>      static unsigned char i&#x3D;0;</p><pre><code>   DataPort=0;   //清空数据，防止有交替重影   LATCH1=1;     //段锁存   LATCH1=0;   DataPort = WeiMa[i+FirstBit]; //取位码    LATCH2=1;     //位锁存   LATCH2=0;   DataPort=TempData[i]; //取显示数据，段码   LATCH1=1;     //段锁存   LATCH1=0;      i++;   if(i==Num)      i=0;</code></pre><p>}<br>&#x2F;<em>————————————————<br>                    定时器初始化子程序<br>————————————————</em>&#x2F;<br>void Init_Timer0(void)<br>{<br> TMOD |&#x3D; 0x01;  &#x2F;&#x2F;使用模式1，16位定时器，使用”|”符号可以在使用多个定时器时不受影响<br> &#x2F;&#x2F;TH0&#x3D;0x00;      &#x2F;&#x2F;给定初值<br> &#x2F;&#x2F;TL0&#x3D;0x00;<br> EA&#x3D;1;            &#x2F;&#x2F;总中断打开<br> ET0&#x3D;1;           &#x2F;&#x2F;定时器中断打开<br> TR0&#x3D;1;           &#x2F;&#x2F;定时器开关打开<br>}<br>&#x2F;<em>————————————————<br>                 定时器中断子程序<br>————————————————</em>&#x2F;<br>void Timer0_isr(void) interrupt 1<br>{<br> TH0&#x3D;(65536-2000)&#x2F;256;  &#x2F;&#x2F;重新赋值 2ms<br> TL0&#x3D;(65536-2000)%256;</p><p> Display(0,8);       &#x2F;&#x2F; 调用数码管扫描</p><p>}</p><p>&#x2F;<em>————————————————<br>按键扫描函数，返回扫描键值<br>————————————————</em>&#x2F;<br>unsigned char KeyScan(void)  &#x2F;&#x2F;键盘扫描函数，使用行列逐级扫描法<br>{<br> unsigned char Val;<br> KeyPort&#x3D;0xf0;&#x2F;&#x2F;高四位置高，低四位拉低<br> if(KeyPort!&#x3D;0xf0)&#x2F;&#x2F;表示有按键按下<br>   {<br>    DelayMs(10);  &#x2F;&#x2F;去抖<br>    if(KeyPort!&#x3D;0xf0)<br>      {           &#x2F;&#x2F;表示有按键按下<br>        KeyPort&#x3D;0xfe; &#x2F;&#x2F;检测第一行<br>        if(KeyPort!&#x3D;0xfe)<br>      {<br>              Val&#x3D;KeyPort&0xf0;<br>            Val+&#x3D;0x0e;<br>        while(KeyPort!&#x3D;0xfe);<br>              DelayMs(10); &#x2F;&#x2F;去抖<br>              while(KeyPort!&#x3D;0xfe);<br>           return Val;<br>            }<br>        KeyPort&#x3D;0xfd; &#x2F;&#x2F;检测第二行<br>        if(KeyPort!&#x3D;0xfd)<br>      {<br>              Val&#x3D;KeyPort&0xf0;<br>            Val+&#x3D;0x0d;<br>        while(KeyPort!&#x3D;0xfd);<br>              DelayMs(10); &#x2F;&#x2F;去抖<br>              while(KeyPort!&#x3D;0xfd);<br>           return Val;<br>            }<br>        KeyPort&#x3D;0xfb; &#x2F;&#x2F;检测第三行<br>        if(KeyPort!&#x3D;0xfb)<br>      {<br>              Val&#x3D;KeyPort&0xf0;<br>            Val+&#x3D;0x0b;<br>        while(KeyPort!&#x3D;0xfb);<br>              DelayMs(10); &#x2F;&#x2F;去抖<br>              while(KeyPort!&#x3D;0xfb);<br>           return Val;<br>            }<br>        KeyPort&#x3D;0xf7; &#x2F;&#x2F;检测第四行<br>        if(KeyPort!&#x3D;0xf7)<br>      {<br>              Val&#x3D;KeyPort&0xf0;<br>            Val+&#x3D;0x07;<br>        while(KeyPort!&#x3D;0xf7);<br>              DelayMs(10); &#x2F;&#x2F;去抖<br>              while(KeyPort!&#x3D;0xf7);<br>           return Val;<br>            }<br>     }<br>   }<br>  return 0xff;<br>}<br>&#x2F;<em>————————————————<br>按键值处理函数，返回扫键值<br>————————————————</em>&#x2F;<br>unsigned char KeyPro(void)<br>{<br> switch(KeyScan())<br> {<br>  case 0x7e:return 0;break;&#x2F;&#x2F;0 按下相应的键显示相对应的码值<br>  case 0x7d:return 1;break;&#x2F;&#x2F;1<br>  case 0x7b:return 2;break;&#x2F;&#x2F;2<br>  case 0x77:return 3;break;&#x2F;&#x2F;3<br>  case 0xbe:return 4;break;&#x2F;&#x2F;4<br>  case 0xbd:return 5;break;&#x2F;&#x2F;5<br>  case 0xbb:return 6;break;&#x2F;&#x2F;6<br>  case 0xb7:return 7;break;&#x2F;&#x2F;7<br>  case 0xde:return 8;break;&#x2F;&#x2F;8<br>  case 0xdd:return 9;break;&#x2F;&#x2F;9<br>  case 0xdb:return 10;break;&#x2F;&#x2F;a<br>  case 0xd7:return 11;break;&#x2F;&#x2F;b<br>  case 0xee:return 12;break;&#x2F;&#x2F;c<br>  case 0xed:return 13;break;&#x2F;&#x2F;d<br>  case 0xeb:return 14;break;&#x2F;&#x2F;e<br>  case 0xe7:return 15;break;&#x2F;&#x2F;f<br>  default:return 0xff;break;<br> }<br>}<br>&#x2F;<em>————————————————<br>           外部中断0初始化<br>————————————————</em>&#x2F;<br>void Init_INT0(void)<br>{<br>  EA&#x3D;1;          &#x2F;&#x2F;全局中断开<br>  EX0&#x3D;1;         &#x2F;&#x2F;外部中断0开<br>  IT0&#x3D;1;         &#x2F;&#x2F;边沿触发<br>}</p><p>&#x2F;<em>————————————————<br>                 外部中断0程序<br>————————————————</em>&#x2F;<br>void ISR_INT0(void) interrupt 0<br>{<br> KeyPressFlag&#x3D;1;   &#x2F;&#x2F;表明按键有动作，可以进行按键扫描<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台。可以基于VSM Studio独立仿真，不依赖Keil工程编译的hex文件。</p><p><code>Proteus8.12</code></p><p><code>VSM Studio</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1vcQSNOkXymwkWJ3DnRH2VQ </span><br><span class="line">提取码：jlo8</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1vcQSNOkXymwkWJ3DnRH2VQ  提取码：jlo8</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】简易数码管定时器时钟</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%AE%80%E6%98%93%E6%95%B0%E7%A0%81%E7%AE%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%AE%80%E6%98%93%E6%95%B0%E7%A0%81%E7%AE%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】简易数码管定时器时钟"><a href="#【Proteus仿真】简易数码管定时器时钟" class="headerlink" title="【Proteus仿真】简易数码管定时器时钟"></a>【Proteus仿真】简易数码管定时器时钟</h1><h3 id="【Proteus仿真】简易数码管定时器时钟-1"><a href="#【Proteus仿真】简易数码管定时器时钟-1" class="headerlink" title="【Proteus仿真】简易数码管定时器时钟"></a>【Proteus仿真】简易数码管定时器时钟</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/2737283b158344c0a2fc311de5af3401.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**************************************************************************************</span><br><span class="line"></span><br><span class="line">实验名称：计时器（数码管显示）</span><br><span class="line">接线说明：</span><br><span class="line">实验现象：下载程序后，按下K1键开始计时，再次按下K1键停止计时，按下K2键清零</span><br><span class="line">注意事项：  </span><br><span class="line">***************************************************************************************/</span><br><span class="line">#include &quot;public.h&quot;</span><br><span class="line">#include &quot;key.h&quot;</span><br><span class="line">#include &quot;beep.h&quot;</span><br><span class="line">#include &quot;smg.h&quot;</span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">* 函 数 名       : main</span><br><span class="line">* 函数功能 : 主函数</span><br><span class="line">* 输    入       : 无</span><br><span class="line">* 输    出     : 无</span><br><span class="line">*******************************************************************************/</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">u8 key=0;</span><br><span class="line">u8 time_buf[8];</span><br><span class="line">u8 time_flag=0;</span><br><span class="line"></span><br><span class="line">time0_init();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">key=key_scan(0);</span><br><span class="line">if(key==KEY1_PRESS)//开始和停止计时</span><br><span class="line">&#123;</span><br><span class="line">time_flag=!time_flag;</span><br><span class="line">beep_alarm(1000,25);//短暂提示音</span><br><span class="line">&#125;</span><br><span class="line">else if(key==KEY2_PRESS)//清除计时</span><br><span class="line">&#123;</span><br><span class="line">time0_stop();</span><br><span class="line">time_flag=0;</span><br><span class="line">gmin=0;</span><br><span class="line">gsec=0;</span><br><span class="line">gmsec=0;</span><br><span class="line">beep_alarm(1000,25);//短暂提示音</span><br><span class="line">&#125;</span><br><span class="line">if(time_flag)</span><br><span class="line">time0_start();//开始计时</span><br><span class="line">else</span><br><span class="line">time0_stop();//停止计时</span><br><span class="line"></span><br><span class="line">time_buf[0]=gsmg_code[gmin/10];</span><br><span class="line">time_buf[1]=gsmg_code[gmin%10];//分</span><br><span class="line">time_buf[2]=0x40;//-</span><br><span class="line">time_buf[3]=gsmg_code[gsec/10];</span><br><span class="line">time_buf[4]=gsmg_code[gsec%10];//秒</span><br><span class="line">time_buf[5]=0x40;//-</span><br><span class="line">time_buf[6]=gsmg_code[gmsec/10];</span><br><span class="line">time_buf[7]=gsmg_code[gmsec%10];//毫秒</span><br><span class="line">smg_display(time_buf,1);//显示</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;**************************************************************************************</p><p>实验名称：计时器（数码管显示）<br>接线说明：<br>实验现象：下载程序后，按下K1键开始计时，再次按下K1键停止计时，按下K2键清零<br>注意事项：<br>***************************************************************************************&#x2F;<br>#include “public.h”<br>#include “key.h”<br>#include “beep.h”<br>#include “smg.h”<br>#include “time.h”</p><p>&#x2F;*******************************************************************************</p><ul><li><p>函 数 名       : main</p></li><li><p>函数功能 : 主函数</p></li><li><p>输    入       : 无</p></li><li><p>输    出     : 无<br>*******************************************************************************&#x2F;<br>void main()<br>{<br>  u8 key&#x3D;0;<br>  u8 time_buf[8];<br>  u8 time_flag&#x3D;0;</p><p>  time0_init();<br>  while(1)<br>  {<br>  key&#x3D;key_scan(0);<br>  if(key&#x3D;&#x3D;KEY1_PRESS)&#x2F;&#x2F;开始和停止计时<br>  {<br>      time_flag&#x3D;!time_flag;<br>      beep_alarm(1000,25);&#x2F;&#x2F;短暂提示音<br>  }<br>  else if(key&#x3D;&#x3D;KEY2_PRESS)&#x2F;&#x2F;清除计时<br>  {<br>      time0_stop();<br>      time_flag&#x3D;0;<br>      gmin&#x3D;0;<br>      gsec&#x3D;0;<br>      gmsec&#x3D;0;<br>      beep_alarm(1000,25);&#x2F;&#x2F;短暂提示音<br>  }<br>  if(time_flag)<br>      time0_start();&#x2F;&#x2F;开始计时<br>  else<br>      time0_stop();&#x2F;&#x2F;停止计时<br><br>  time_buf[0]&#x3D;gsmg_code[gmin&#x2F;10];<br>  time_buf[1]&#x3D;gsmg_code[gmin%10];&#x2F;&#x2F;分<br>  time_buf[2]&#x3D;0x40;&#x2F;&#x2F;-<br>  time_buf[3]&#x3D;gsmg_code[gsec&#x2F;10];<br>  time_buf[4]&#x3D;gsmg_code[gsec%10];&#x2F;&#x2F;秒<br>  time_buf[5]&#x3D;0x40;&#x2F;&#x2F;-<br>  time_buf[6]&#x3D;gsmg_code[gmsec&#x2F;10];<br>  time_buf[7]&#x3D;gsmg_code[gmsec%10];&#x2F;&#x2F;毫秒<br>  smg_display(time_buf,1);&#x2F;&#x2F;显示<br>  }</p></li></ul><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1R9WzkThUx-z4CB-HVJFByQ </span><br><span class="line">提取码：ujzg</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1R9WzkThUx-z4CB-HVJFByQ  提取码：ujzg</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】计数逻辑组成的数字钟</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E8%AE%A1%E6%95%B0%E9%80%BB%E8%BE%91%E7%BB%84%E6%88%90%E7%9A%84%E6%95%B0%E5%AD%97%E9%92%9F/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E8%AE%A1%E6%95%B0%E9%80%BB%E8%BE%91%E7%BB%84%E6%88%90%E7%9A%84%E6%95%B0%E5%AD%97%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】计数逻辑组成的数字钟"><a href="#【Proteus仿真】计数逻辑组成的数字钟" class="headerlink" title="【Proteus仿真】计数逻辑组成的数字钟"></a>【Proteus仿真】计数逻辑组成的数字钟</h1><h3 id="【Proteus仿真】计数逻辑组成的数字钟-1"><a href="#【Proteus仿真】计数逻辑组成的数字钟-1" class="headerlink" title="【Proteus仿真】计数逻辑组成的数字钟"></a>【Proteus仿真】计数逻辑组成的数字钟</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/5ddd238af3c04c1e995773f0d138e13f.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="器件清单"><a href="#器件清单" class="headerlink" title="器件清单"></a>器件清单</h4><p><img src="https://img-blog.csdnimg.cn/4775f6cb23034a1689bd7ece6d856366.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/218f3cc8448349debe98537c309f97d1.png" alt="在这里插入图片描述"></p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>实验基于Proteus8.9SP2平台</p><p><code>Proteus8.9SP2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1sCZfKC0vTYA-KmtERpxpfQ </span><br><span class="line">提取码：qotn</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1sCZfKC0vTYA-KmtERpxpfQ  提取码：qotn</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】超声波模块HC-SR04测距</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97HCSR04%E6%B5%8B%E8%B7%9D/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97HCSR04%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】超声波模块HC-SR04测距"><a href="#【Proteus仿真】超声波模块HC-SR04测距" class="headerlink" title="【Proteus仿真】超声波模块HC-SR04测距"></a>【Proteus仿真】超声波模块HC-SR04测距</h1><h3 id="【Proteus仿真】超声波模块HC-SR04测距-1"><a href="#【Proteus仿真】超声波模块HC-SR04测距-1" class="headerlink" title="【Proteus仿真】超声波模块HC-SR04测距"></a>【Proteus仿真】超声波模块HC-SR04测距</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/77c33a512d37419bbad8894a1de76dd2.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="测距实现代码"><a href="#测距实现代码" class="headerlink" title="测距实现代码"></a>测距实现代码</h4><ul><li>触发引脚间隔时间10us,很关键。</li></ul><p><code>10us</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/********************读值函数***********************/</span><br><span class="line">unsigned int Read_value()</span><br><span class="line">&#123;</span><br><span class="line">uint result;</span><br><span class="line">Tr=1;//触发引脚发出11us的触发信号（至少10us）</span><br><span class="line">Delay10us();</span><br><span class="line">Tr=0;</span><br><span class="line">while(!Ec);//度过回响信号的低电平</span><br><span class="line">TR0=1;//开启定时器0</span><br><span class="line">while(Ec);//度过回响信号高电平</span><br><span class="line">TR0=0;//关闭定时器0</span><br><span class="line">result=((TH0*256+TL0)*0.034)/2;// 距离cm=（时间us * 速度cm/us）/2</span><br><span class="line">return result + 2;//+2修正补偿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/********************读值函数***********************/ unsigned int Read_value() &#123;     uint result;     Tr=1;//触发引脚发出11us的触发信号（至少10us）     Delay10us();     Tr=0;     while(!Ec);//度过回响信号的低电平     TR0=1;//开启定时器0     while(Ec);//度过回响信号高电平     TR0=0;//关闭定时器0     result=((TH0*256+TL0)*0.034)/2;// 距离cm=（时间us * 速度cm/us）/2     return result + 2;//+2修正补偿 &#125;</code></p><h4 id="仿真设置"><a href="#仿真设置" class="headerlink" title="仿真设置"></a>仿真设置</h4><ul><li>主控频率选择12MHz</li><li>VSM Studio中包含代码，可以不依赖启动Keil工程来编译生成Hex文件，在VSM Studio界面直接点击仿真启动按钮会直接编译并运行代码。(前提是安装了Keil编译器)</li><li>工程设置</li></ul><p><img src="https://img-blog.csdnimg.cn/e7c243585dee4a6091cfae88ac955b85.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a1f97debf68b418ea2ae8774c3bb0a61.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/adeea7d1a7fa40fc911444fe4723bd3b.png" alt="在这里插入图片描述"></p><h4 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STC89C5xRC.H&gt;</span><br><span class="line">#include &quot;LCD1602.h&quot;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">typedef unsigned char uchar;</span><br><span class="line">typedef unsigned int  uint;</span><br><span class="line"></span><br><span class="line">sbit Tr=P1^0;//触发信号</span><br><span class="line">sbit Ec=P1^1;//回响信号</span><br><span class="line">unsigned char  ge,shi,bai;  //自定义寄存器</span><br><span class="line">unsigned int distance,tmp;</span><br><span class="line">void Delay10us(void);//10us延时函数</span><br><span class="line">void Delayms(unsigned int z) ;//ms延时函数</span><br><span class="line">unsigned int Read_value(void);//读值函数</span><br><span class="line">void InitTimer0(void);//定时器0初始化</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Tr=0;//出发引脚首先拉低</span><br><span class="line">InitTimer0();//初始化定时器0</span><br><span class="line">    LCD1602_Init();//初始化LCD1602</span><br><span class="line">    LCD1602_delay_ms(1);</span><br><span class="line">    LCD1602_set_position(0,4);//指针设置到第一行第4列</span><br><span class="line">    LCD1602_prints(&quot;Distance:&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">tmp = Read_value();//读值</span><br><span class="line">LCD1602_set_position(1,4);</span><br><span class="line">LcdPrintNum(tmp);</span><br><span class="line">Delayms(800) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********************读值函数***********************/</span><br><span class="line">unsigned int Read_value()</span><br><span class="line">&#123;</span><br><span class="line">uint result;</span><br><span class="line">Tr=1;//触发引脚发出11us的触发信号（至少10us）</span><br><span class="line">Delay10us();</span><br><span class="line">//Delayms(1);</span><br><span class="line">Tr=0;</span><br><span class="line">while(!Ec);//度过回响信号的低电平</span><br><span class="line">TR0=1;//开启定时器0</span><br><span class="line">while(Ec);//度过回响信号高电平</span><br><span class="line">TR0=0;//关闭定时器0</span><br><span class="line">result=((TH0*256+TL0)*0.034)/2;// 距离cm=（时间us * 速度cm/us）/2</span><br><span class="line">return result + 2;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/***********************10us延时函数*****************************/</span><br><span class="line">void Delay10us()</span><br><span class="line">&#123;</span><br><span class="line">TL0=0xF5;</span><br><span class="line">TH0=0xFF;</span><br><span class="line">TR0=1;</span><br><span class="line">while (TF0==0);</span><br><span class="line">TR0=0;</span><br><span class="line">TF0=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***********************1ms延时函数*****************************/</span><br><span class="line">void Delayms(unsigned int z)   //误差 0us</span><br><span class="line">&#123;</span><br><span class="line">uint i,j;</span><br><span class="line">for(i=0;i&lt;z;i++)</span><br><span class="line">for(j=0;j&lt;112;j++);</span><br><span class="line">//延时函数</span><br><span class="line">&#125;</span><br><span class="line">/************************定时器0初始化*****************************/</span><br><span class="line">void InitTimer0(void)</span><br><span class="line">&#123;</span><br><span class="line">    TMOD = 0x01;</span><br><span class="line">    TH0 = 0x00;</span><br><span class="line">    TL0 = 0x00;</span><br><span class="line">    TR0 = 0;//先关闭定时器0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;STC89C5xRC.H&gt;<br>#include “LCD1602.h”<br>#include&lt;intrins.h&gt;<br>typedef unsigned char uchar;<br>typedef unsigned int  uint;</p><p>sbit Tr&#x3D;P1^0;&#x2F;&#x2F;触发信号<br>sbit Ec&#x3D;P1^1;&#x2F;&#x2F;回响信号<br>unsigned char  ge,shi,bai;  &#x2F;&#x2F;自定义寄存器<br>unsigned int distance,tmp;<br>void Delay10us(void);&#x2F;&#x2F;10us延时函数<br>void Delayms(unsigned int z) ;&#x2F;&#x2F;ms延时函数<br>unsigned int Read_value(void);&#x2F;&#x2F;读值函数<br>void InitTimer0(void);&#x2F;&#x2F;定时器0初始化</p><p>void main()<br>{</p><pre><code>Tr=0;//出发引脚首先拉低InitTimer0();//初始化定时器0LCD1602_Init();//初始化LCD1602LCD1602_delay_ms(1);LCD1602_set_position(0,4);//指针设置到第一行第4列LCD1602_prints(&quot;Distance:&quot;);while(1)&#123;    tmp = Read_value();//读值    LCD1602_set_position(1,4);    LcdPrintNum(tmp);        Delayms(800) ;&#125;</code></pre><p>}</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>读值函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>***&#x2F;<br>unsigned int Read_value()<br>{<br>    uint result;<br>    Tr&#x3D;1;&#x2F;&#x2F;触发引脚发出11us的触发信号（至少10us）<br>    Delay10us();<br>    &#x2F;&#x2F;Delayms(1);<br>    Tr&#x3D;0;<br>    while(!Ec);&#x2F;&#x2F;度过回响信号的低电平<br>    TR0&#x3D;1;&#x2F;&#x2F;开启定时器0<br>    while(Ec);&#x2F;&#x2F;度过回响信号高电平<br>    TR0&#x3D;0;&#x2F;&#x2F;关闭定时器0<br>    result&#x3D;((TH0*256+TL0)*0.034)&#x2F;2;&#x2F;&#x2F; 距离cm&#x3D;（时间us * 速度cm&#x2F;us）&#x2F;2<br>    return result + 2;</p><p>}<br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>10us延时函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>******&#x2F;<br>void Delay10us()<br>{<br>    TL0&#x3D;0xF5;<br>    TH0&#x3D;0xFF;<br>    TR0&#x3D;1;<br>    while (TF0&#x3D;&#x3D;0);<br>    TR0&#x3D;0;<br>    TF0&#x3D;0;<br>}</p><p>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>1ms延时函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>******&#x2F;<br>void Delayms(unsigned int z)   &#x2F;&#x2F;误差 0us<br>{<br>    uint i,j;<br>    for(i&#x3D;0;i&lt;z;i++)<br>        for(j&#x3D;0;j&lt;112;j++);<br>    &#x2F;&#x2F;延时函数<br>}<br>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>定时器0初始化</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*****&#x2F;<br>void InitTimer0(void)<br>{<br>    TMOD &#x3D; 0x01;<br>    TH0 &#x3D; 0x00;<br>    TL0 &#x3D; 0x00;<br>    TR0 &#x3D; 0;&#x2F;&#x2F;先关闭定时器0<br>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1SmpqBhbqrFPM_jwih-_kFw </span><br><span class="line">提取码：o7c2</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1SmpqBhbqrFPM_jwih-_kFw  提取码：o7c2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】键盘矩阵扫描+LCD128x64显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E9%94%AE%E7%9B%98%E7%9F%A9%E9%98%B5%E6%89%AB%E6%8F%8FLCD128x64%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E9%94%AE%E7%9B%98%E7%9F%A9%E9%98%B5%E6%89%AB%E6%8F%8FLCD128x64%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】键盘矩阵扫描-LCD128x64显示"><a href="#【Proteus仿真】键盘矩阵扫描-LCD128x64显示" class="headerlink" title="【Proteus仿真】键盘矩阵扫描+LCD128x64显示"></a>【Proteus仿真】键盘矩阵扫描+LCD128x64显示</h1><h3 id="【Proteus仿真】键盘矩阵扫描-LCD128x64显示-1"><a href="#【Proteus仿真】键盘矩阵扫描-LCD128x64显示-1" class="headerlink" title="【Proteus仿真】键盘矩阵扫描+LCD128x64显示"></a>【Proteus仿真】键盘矩阵扫描+LCD128x64显示</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/ceff7fbd59464103bc37c47b0df1fbf8.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="汉字取模工具和取模方式"><a href="#汉字取模工具和取模方式" class="headerlink" title="汉字取模工具和取模方式"></a>汉字取模工具和取模方式</h4><ul><li>取模工具：PCtoLCD2002</li><li>取模方式：阴码、逆向、列行式、C51格式、</li></ul><p><code>PCtoLCD2002</code></p><p><img src="https://img-blog.csdnimg.cn/086058426d0b4503953c888b443edb69.png" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg51.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#include &quot;LCD_12864.H&quot;</span><br><span class="line">#include &quot;KeyPad.H&quot;</span><br><span class="line">#include &quot;DotMatri.H&quot;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line"></span><br><span class="line">//键盘扫描开启标志其值由外部中断 0 控制</span><br><span class="line">bit KeyPressDown = 0;</span><br><span class="line">uchar T_Count = 0;</span><br><span class="line">sbit SPK = P3^7;</span><br><span class="line">//Keybord_Chars 中数字与符号编码与键盘按键对照表</span><br><span class="line">uchar code KeyPosTable[]=</span><br><span class="line">&#123;</span><br><span class="line">    7,8,9,10,</span><br><span class="line">    4,5,6,11,</span><br><span class="line">    1,2,3,12,</span><br><span class="line">    15,0,14,13</span><br><span class="line">&#125;;</span><br><span class="line">//蜂鸣器发声</span><br><span class="line">void Beep()</span><br><span class="line">&#123;</span><br><span class="line">    uchar i,x=20;</span><br><span class="line">    while (x--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=0; i&lt;120; i++);</span><br><span class="line">        SPK=~SPK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//主程序</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    uchar i;</span><br><span class="line">    LCD_Initialize(); //初始化 LCD</span><br><span class="line">    for (i=0; i&lt;7; i++) //从第一页开始左边距 16 点显示 7 个 16*16 点阵的中文提示信息</span><br><span class="line">    Display_A_WORD_String (1,16*(i+1),1,Word_String[i]);</span><br><span class="line">    P1=0x0f;</span><br><span class="line">    IE=0x83; //允许外部 0 和定时器 0 中断</span><br><span class="line">    IT0=1; //设为下降沿中断方式外部中断 0 用于启停键盘</span><br><span class="line">    TH0=(65536-5000)/256;//50ms 定时</span><br><span class="line">    TL0=(65536-5000)%256;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">//如果有按键按下则处理按键</span><br><span class="line">        if(KeyPressDown==1)</span><br><span class="line">        &#123;//扫描处理</span><br><span class="line">            Beep();</span><br><span class="line">            KeyPressDown=0;</span><br><span class="line">            Display_A_char(4,55,Keyboard_Chars[KeyPosTable[KeyScan()] ]);</span><br><span class="line">            TR0=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//外部中断 0 控制消抖延时</span><br><span class="line">void EX0_INT() interrupt 0</span><br><span class="line">&#123;</span><br><span class="line">    TR0=1;//开启定时器 0延时 300ms 消抖</span><br><span class="line">&#125;</span><br><span class="line">//定时器用于消抖并确认有键按下启动主程序中的按键扫描</span><br><span class="line">void T0_INT() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    if(++T_Count==6) //50*6=300ms 延时抖动</span><br><span class="line">    &#123;</span><br><span class="line">        T_Count=0;</span><br><span class="line">        KeyPressDown=1; //确定有键按下</span><br><span class="line">    &#125;</span><br><span class="line">    TH0=(65526-50000)/256; //50ms 定时</span><br><span class="line">    TL0=(65526-50000)%256;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg51.h&gt;<br>#include &lt;intrins.h&gt;<br>#include “LCD_12864.H”<br>#include “KeyPad.H”<br>#include “DotMatri.H”<br>#define uchar unsigned char<br>#define uint unsigned int</p><p>&#x2F;&#x2F;键盘扫描开启标志其值由外部中断 0 控制<br>bit KeyPressDown &#x3D; 0;<br>uchar T_Count &#x3D; 0;<br>sbit SPK &#x3D; P3^7;<br>&#x2F;&#x2F;Keybord_Chars 中数字与符号编码与键盘按键对照表<br>uchar code KeyPosTable[]&#x3D;<br>{<br>    7,8,9,10,<br>    4,5,6,11,<br>    1,2,3,12,<br>    15,0,14,13<br>};<br>&#x2F;&#x2F;蜂鸣器发声<br>void Beep()<br>{<br>    uchar i,x&#x3D;20;<br>    while (x–)<br>    {<br>        for(i&#x3D;0; i&lt;120; i++);<br>        SPK&#x3D;~SPK;<br>    }<br>}<br>&#x2F;&#x2F;主程序<br>void main()<br>{<br>    uchar i;<br>    LCD_Initialize(); &#x2F;&#x2F;初始化 LCD<br>    for (i&#x3D;0; i&lt;7; i++) &#x2F;&#x2F;从第一页开始左边距 16 点显示 7 个 16<em>16 点阵的中文提示信息<br>    Display_A_WORD_String (1,16</em>(i+1),1,Word_String[i]);<br>    P1&#x3D;0x0f;<br>    IE&#x3D;0x83; &#x2F;&#x2F;允许外部 0 和定时器 0 中断<br>    IT0&#x3D;1; &#x2F;&#x2F;设为下降沿中断方式外部中断 0 用于启停键盘<br>    TH0&#x3D;(65536-5000)&#x2F;256;&#x2F;&#x2F;50ms 定时<br>    TL0&#x3D;(65536-5000)%256;<br>    while(1)<br>    {<br>&#x2F;&#x2F;如果有按键按下则处理按键<br>        if(KeyPressDown&#x3D;&#x3D;1)<br>        {&#x2F;&#x2F;扫描处理<br>            Beep();<br>            KeyPressDown&#x3D;0;<br>            Display_A_char(4,55,Keyboard_Chars[KeyPosTable[KeyScan()] ]);<br>            TR0&#x3D;0;<br>        }<br>    }<br>}<br>&#x2F;&#x2F;外部中断 0 控制消抖延时<br>void EX0_INT() interrupt 0<br>{<br>    TR0&#x3D;1;&#x2F;&#x2F;开启定时器 0延时 300ms 消抖<br>}<br>&#x2F;&#x2F;定时器用于消抖并确认有键按下启动主程序中的按键扫描<br>void T0_INT() interrupt 1<br>{<br>    if(++T_Count&#x3D;&#x3D;6) &#x2F;&#x2F;50*6&#x3D;300ms 延时抖动<br>    {<br>        T_Count&#x3D;0;<br>        KeyPressDown&#x3D;1; &#x2F;&#x2F;确定有键按下<br>    }<br>    TH0&#x3D;(65526-50000)&#x2F;256; &#x2F;&#x2F;50ms 定时<br>    TL0&#x3D;(65526-50000)%256;<br>}&#96;</p><ul><li>工程架构以及编译信息</li></ul><p><img src="https://img-blog.csdnimg.cn/625ea24d0e8f41a7a43b33bde7383709.png" alt="在这里插入图片描述"></p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本示例基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1qdwGTMi5dLT55ZdDuTKYjA </span><br><span class="line">提取码：4vtv</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1qdwGTMi5dLT55ZdDuTKYjA  提取码：4vtv</code></p><p><img src="https://img-blog.csdnimg.cn/cc0fc833ca8c4f63a7d2c6dd8c889293.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus】基于VSM Studio驱动LM016驱动模板</title>
      <link href="/2024/03/Proteus-Proteus%E5%9F%BA%E4%BA%8EVSM-Studio%E9%A9%B1%E5%8A%A8LM016%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/03/Proteus-Proteus%E5%9F%BA%E4%BA%8EVSM-Studio%E9%A9%B1%E5%8A%A8LM016%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus】基于VSM-Studio驱动LM016驱动模板"><a href="#【Proteus】基于VSM-Studio驱动LM016驱动模板" class="headerlink" title="【Proteus】基于VSM Studio驱动LM016驱动模板"></a>【Proteus】基于VSM Studio驱动LM016驱动模板</h1><h3 id="【Proteus】基于VSM-Studio驱动LM016驱动模板-1"><a href="#【Proteus】基于VSM-Studio驱动LM016驱动模板-1" class="headerlink" title="【Proteus】基于VSM Studio驱动LM016驱动模板"></a>【Proteus】基于VSM Studio驱动LM016驱动模板</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/76561b22418a4832b752850119ff857f.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="主程序代码"><a href="#主程序代码" class="headerlink" title="主程序代码"></a>主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周日 6月 5 2022</span><br><span class="line"> * Processor: AT89C52</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">//#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;LCD1602driver.h&quot;</span><br><span class="line">unsigned int Result=0;</span><br><span class="line">void main(void)</span><br><span class="line"> &#123; </span><br><span class="line"></span><br><span class="line">LCD_Init();</span><br><span class="line">   while (1)&#123;</span><br><span class="line">Result++;</span><br><span class="line">Delay(800);</span><br><span class="line">LCD_ShowNum(1,1,Result,3);//显示3位计数</span><br><span class="line">LCD_ShowString(1,5,&quot;Perseverance&quot;);//显示字符串</span><br><span class="line">LCD_ShowSignedNum(2,1,9527,4);// 显示4位整型数</span><br><span class="line">LCD_ShowChar(2,6,0XDF);//显示‘ °’</span><br><span class="line">LCD_ShowChar(2,7,&#x27;C&#x27;);//显示‘C’</span><br><span class="line">LCD_ShowHexNum(2,9,255,2);//显示&#x27;FF&#x27;</span><br><span class="line">LCD_ShowBinNum(2,12,15,4);//显示‘1111’</span><br><span class="line"></span><br><span class="line">//LCD_WriteCommand(0x01);//光标复位，清屏</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周日 6月 5 2022</li><li>Processor: AT89C52</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;reg52.h&gt;<br>&#x2F;&#x2F;#include &lt;stdio.h&gt;<br>#include “LCD1602driver.h”<br>unsigned int Result&#x3D;0;<br>void main(void)<br> { </p><pre><code>LCD_Init();</code></pre><p>   while (1){<br>        Result++;<br>        Delay(800);<br>        LCD_ShowNum(1,1,Result,3);&#x2F;&#x2F;显示3位计数<br>        LCD_ShowString(1,5,”Perseverance”);&#x2F;&#x2F;显示字符串<br>        LCD_ShowSignedNum(2,1,9527,4);&#x2F;&#x2F; 显示4位整型数<br>        LCD_ShowChar(2,6,0XDF);&#x2F;&#x2F;显示‘ °’<br>        LCD_ShowChar(2,7,’C’);&#x2F;&#x2F;显示‘C’<br>        LCD_ShowHexNum(2,9,255,2);&#x2F;&#x2F;显示’FF’<br>        LCD_ShowBinNum(2,12,15,4);&#x2F;&#x2F;显示‘1111’</p><p>&#x2F;&#x2F;LCD_WriteCommand(0x01);&#x2F;&#x2F;光标复位，清屏<br>}<br> }&#96;</p><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1w1o8fhwLRJSHTfBD_JniNQ </span><br><span class="line">提取码：0ohu</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1w1o8fhwLRJSHTfBD_JniNQ  提取码：0ohu</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制</title>
      <link href="/2024/03/VSM-VSM-Studio-uln2003%E9%A9%B1%E5%8A%A8%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%8D%95%E6%8C%89%E9%94%AE%E5%90%AF%E4%BF%9D%E5%81%9C%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%85%AB%E6%8B%8D%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/03/VSM-VSM-Studio-uln2003%E9%A9%B1%E5%8A%A8%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%8D%95%E6%8C%89%E9%94%AE%E5%90%AF%E4%BF%9D%E5%81%9C%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%85%AB%E6%8B%8D%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="VSM-Studio-uln2003驱动步进电机-单按键启保停正反转八拍控制"><a href="#VSM-Studio-uln2003驱动步进电机-单按键启保停正反转八拍控制" class="headerlink" title="VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制"></a>VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制</h1><h3 id="VSM-Studio-uln2003驱动步进电机-单按键启保停正反转八拍控制-1"><a href="#VSM-Studio-uln2003驱动步进电机-单按键启保停正反转八拍控制-1" class="headerlink" title="VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制"></a>VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/a67509c804d444f0bc97a75b8f5cfe44.gif#pic_center" alt="在这里插入图片描述"></p><h5 id="基于51单片机，步进电机采用8节拍控制"><a href="#基于51单片机，步进电机采用8节拍控制" class="headerlink" title="基于51单片机，步进电机采用8节拍控制"></a>基于51单片机，步进电机采用8节拍控制</h5><h4 id="VSM-Studio代码"><a href="#VSM-Studio代码" class="headerlink" title="VSM Studio代码"></a>VSM Studio代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周二 6月 7 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">typedef unsigned char   uchar;</span><br><span class="line">typedef unsigned int    uint;</span><br><span class="line">sbit LED = P1^0;</span><br><span class="line">uchar const sequence[8] = &#123;0x02,0x06,0x04,0x0c,0x08,0x09,0x01,0x03&#125;;//8拍控制</span><br><span class="line">#define out_port  (P2)</span><br><span class="line">sbit  interruptPin = P3^2;</span><br><span class="line">#define HIGH  (1)</span><br><span class="line">#define LOW (0)</span><br><span class="line">#define  Speed 120//速度</span><br><span class="line">#define FOSC 12000000L</span><br><span class="line">#define T1MS (65536-FOSC/12/1000)   //1ms timer calculation method in 12T mode</span><br><span class="line">static volatile unsigned char keyFlag = 0  ;//按键状态</span><br><span class="line">void fanzhuan();</span><br><span class="line">void zhengzhuan();</span><br><span class="line">void Stop();</span><br><span class="line"></span><br><span class="line">void exint0() interrupt 0           //(location at 0003H)</span><br><span class="line">&#123;</span><br><span class="line">     keyFlag++;</span><br><span class="line">keyFlag%=3;</span><br><span class="line">&#125;</span><br><span class="line">/* Timer0 延时 */</span><br><span class="line">void delay(unsigned int t)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int count = 0;</span><br><span class="line">  TMOD |= 0x01;</span><br><span class="line">  TH0 = 0xFC;</span><br><span class="line">  TL0 = 0x66;</span><br><span class="line">  TR0 = 1;</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    if (TF0 == 1)</span><br><span class="line">    &#123;</span><br><span class="line">      count++;</span><br><span class="line">      TF0 = 0;</span><br><span class="line">      TH0 = 0xFC;</span><br><span class="line">      TL0 = 0x66;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &gt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> IT0 = 1;                        //set INT0 int type (1:Falling 0:Low level)</span><br><span class="line">    EX0 = 1;                        //enable INT0 interrupt</span><br><span class="line">    EA = 1;                         //open global interrupt switch</span><br><span class="line">   out_port = 0x03;</span><br><span class="line">while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(keyFlag)keyFlag==1? zhengzhuan():fanzhuan(); else  Stop();</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stop()&#123;</span><br><span class="line">  //这里可以填写其他控制代码</span><br><span class="line">     out_port = 0X0f;</span><br><span class="line">     LED= LOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">void zhengzhuan()&#123; </span><br><span class="line">static unsigned char i=0;</span><br><span class="line">i = i&lt;8 ? i+1 : 0;</span><br><span class="line">         out_port = sequence[i];</span><br><span class="line">LED = !LED;</span><br><span class="line">delay(Speed);//此数值必须大于100，否则仿真的时候会抖动 .</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">void fanzhuan()&#123;</span><br><span class="line">static unsigned char k=0;</span><br><span class="line">k = k&gt;0 ? k-1 : 7;</span><br><span class="line">   out_port = sequence[k];</span><br><span class="line">     LED= !LED;</span><br><span class="line">delay(Speed);//此数值必须大于100，否则仿真的时候会抖动 .</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周二 6月 7 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;REGX52.H&gt;<br>typedef unsigned char   uchar;<br>typedef unsigned int    uint;<br>sbit LED &#x3D; P1^0;<br>uchar const sequence[8] &#x3D; {0x02,0x06,0x04,0x0c,0x08,0x09,0x01,0x03};&#x2F;&#x2F;8拍控制<br>#define out_port  (P2)<br>sbit  interruptPin &#x3D; P3^2;<br>#define HIGH  (1)<br>#define LOW (0)<br>#define  Speed 120&#x2F;&#x2F;速度<br>#define FOSC 12000000L<br>#define T1MS (65536-FOSC&#x2F;12&#x2F;1000)   &#x2F;&#x2F;1ms timer calculation method in 12T mode<br>static volatile unsigned char keyFlag &#x3D; 0  ;&#x2F;&#x2F;按键状态<br>void fanzhuan();<br>void zhengzhuan();<br>void Stop();</p><p>void exint0() interrupt 0           &#x2F;&#x2F;(location at 0003H)<br>{<br>     keyFlag++;<br>        keyFlag%&#x3D;3;<br>}<br>&#x2F;* Timer0 延时 *&#x2F;<br>void delay(unsigned int t)<br>{<br>  unsigned int count &#x3D; 0;<br>  TMOD |&#x3D; 0x01;<br>  TH0 &#x3D; 0xFC;<br>  TL0 &#x3D; 0x66;<br>  TR0 &#x3D; 1;<br>  while (1)<br>  {<br>    if (TF0 &#x3D;&#x3D; 1)<br>    {<br>      count++;<br>      TF0 &#x3D; 0;<br>      TH0 &#x3D; 0xFC;<br>      TL0 &#x3D; 0x66;<br>    }<br>    if (count &gt;&#x3D; t)<br>    {<br>      break;<br>    }<br>  }<br>}</p><p>void main() {<br>     IT0 &#x3D; 1;                        &#x2F;&#x2F;set INT0 int type (1:Falling 0:Low level)<br>    EX0 &#x3D; 1;                        &#x2F;&#x2F;enable INT0 interrupt<br>    EA &#x3D; 1;                         &#x2F;&#x2F;open global interrupt switch<br>       out_port &#x3D; 0x03;<br>    while(1)<br> {<br>     if(keyFlag)keyFlag&#x3D;&#x3D;1? zhengzhuan():fanzhuan(); else  Stop();<br> }<br>}</p><p>void Stop(){<br>  &#x2F;&#x2F;这里可以填写其他控制代码<br>     out_port &#x3D; 0X0f;<br>     LED&#x3D; LOW;<br>  }</p><p>void zhengzhuan(){<br>                    static unsigned char i&#x3D;0;<br>                i &#x3D; i&lt;8 ? i+1 : 0;<br>         out_port &#x3D; sequence[i];<br>                    LED &#x3D; !LED;<br>delay(Speed);&#x2F;&#x2F;此数值必须大于100，否则仿真的时候会抖动 .</p><pre><code>  &#125;</code></pre><p>void fanzhuan(){<br>    static unsigned char k&#x3D;0;<br>    k &#x3D; k&gt;0 ? k-1 : 7;<br>       out_port &#x3D; sequence[k];<br>     LED&#x3D; !LED;<br>delay(Speed);&#x2F;&#x2F;此数值必须大于100，否则仿真的时候会抖动 .</p><pre><code> &#125;`</code></pre><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1lNtEvPjskcgceoOEQsCiHw </span><br><span class="line">提取码：nwpt</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1lNtEvPjskcgceoOEQsCiHw  提取码：nwpt</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSM Studio uln2003驱动步进电机+单按键启保停正反转四拍控制</title>
      <link href="/2024/03/VSM-VSM-Studio-uln2003%E9%A9%B1%E5%8A%A8%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%8D%95%E6%8C%89%E9%94%AE%E5%90%AF%E4%BF%9D%E5%81%9C%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%9B%9B%E6%8B%8D%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/03/VSM-VSM-Studio-uln2003%E9%A9%B1%E5%8A%A8%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%8D%95%E6%8C%89%E9%94%AE%E5%90%AF%E4%BF%9D%E5%81%9C%E6%AD%A3%E5%8F%8D%E8%BD%AC%E5%9B%9B%E6%8B%8D%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="VSM-Studio-uln2003驱动步进电机-单按键启保停正反转四拍控制"><a href="#VSM-Studio-uln2003驱动步进电机-单按键启保停正反转四拍控制" class="headerlink" title="VSM Studio uln2003驱动步进电机+单按键启保停正反转四拍控制"></a>VSM Studio uln2003驱动步进电机+单按键启保停正反转四拍控制</h1><h3 id="VSM-Studio-uln2003驱动步进电机-单按键启保停正反转四拍控制-1"><a href="#VSM-Studio-uln2003驱动步进电机-单按键启保停正反转四拍控制-1" class="headerlink" title="VSM Studio uln2003驱动步进电机+单按键启保停正反转四拍控制"></a>VSM Studio uln2003驱动步进电机+单按键启保停正反转四拍控制</h3><ul><li>相关篇《VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制》</li><li>Proteus仿真演示</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/125171917">VSM Studio uln2003驱动步进电机+单按键启保停正反转八拍控制</a></p><p><img src="https://img-blog.csdnimg.cn/ecba01f0e67443dc9e81e6759d076c95.gif#pic_center" alt="在这里插入图片描述"></p><h5 id="基于51单片机，步进电机采用4节拍控制"><a href="#基于51单片机，步进电机采用4节拍控制" class="headerlink" title="基于51单片机，步进电机采用4节拍控制"></a>基于51单片机，步进电机采用4节拍控制</h5><h4 id="VSM-Studio代码"><a href="#VSM-Studio代码" class="headerlink" title="VSM Studio代码"></a>VSM Studio代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周二 6月 7 2022</span><br><span class="line"> * Processor: AT89C52</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">typedef unsigned char   uchar;</span><br><span class="line">typedef unsigned int    uint;</span><br><span class="line">sbit LED = P1^0;</span><br><span class="line">uchar const sequence[4] = &#123;0x06,0x0c,0x09,0x03&#125;;//4节拍控制</span><br><span class="line">#define out_port  (P2)</span><br><span class="line">sbit  interruptPin = P3^2;</span><br><span class="line">#define HIGH  (1)</span><br><span class="line">#define LOW (0)</span><br><span class="line">#define  Speed 120//速度</span><br><span class="line">static volatile unsigned char keyFlag = 0  ;//按键状态</span><br><span class="line"></span><br><span class="line">void fanzhuan();</span><br><span class="line">void zhengzhuan();</span><br><span class="line">void Stop();</span><br><span class="line">void delay(unsigned int t);</span><br><span class="line"></span><br><span class="line">void exint0() interrupt 0           //(location at 0003H)</span><br><span class="line">&#123;</span><br><span class="line">     keyFlag++;</span><br><span class="line"> keyFlag%=3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delay(unsigned int t)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int count = 0;</span><br><span class="line">  TMOD |= 0x01;</span><br><span class="line">  TH0 = 0xFC;</span><br><span class="line">  TL0 = 0x66;</span><br><span class="line">  TR0 = 1;</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    if (TF0 == 1)</span><br><span class="line">    &#123;</span><br><span class="line">      count++;</span><br><span class="line">      TF0 = 0;</span><br><span class="line">      TH0 = 0xFC;</span><br><span class="line">      TL0 = 0x66;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &gt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line"> IT0 = 1;                        //set INT0 int type (1:Falling 0:Low level)</span><br><span class="line">    EX0 = 1;                        //enable INT0 interrupt</span><br><span class="line">    EA = 1;                         //open global interrupt switch</span><br><span class="line">out_port = 0x03;</span><br><span class="line">while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(keyFlag)keyFlag==1? zhengzhuan():fanzhuan(); else  Stop();</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stop()&#123;</span><br><span class="line">  //这里可以填写其他控制代码</span><br><span class="line">     out_port = 0X0f;</span><br><span class="line">     LED= LOW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">void zhengzhuan()&#123; </span><br><span class="line">static unsigned char i=0;</span><br><span class="line">i = i&lt;8 ? i+1 : 0;</span><br><span class="line">         out_port = sequence[i];</span><br><span class="line">LED = !LED;</span><br><span class="line">delay(Speed);//此数值必须大于100，否则仿真的时候会抖动 .</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">void fanzhuan()&#123;</span><br><span class="line">static unsigned char k=0;</span><br><span class="line">k = k&gt;0 ? k-1 : 7;</span><br><span class="line">   out_port = sequence[k];</span><br><span class="line">     LED= !LED;</span><br><span class="line">delay(Speed);//此数值必须大于100，否则仿真的时候会抖动 .</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周二 6月 7 2022</li><li>Processor: AT89C52</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;REGX52.H&gt;<br>#include &lt;intrins.h&gt;<br>typedef unsigned char   uchar;<br>typedef unsigned int    uint;<br>sbit LED &#x3D; P1^0;<br>uchar const sequence[4] &#x3D; {0x06,0x0c,0x09,0x03};&#x2F;&#x2F;4节拍控制<br>#define out_port  (P2)<br>sbit  interruptPin &#x3D; P3^2;<br>#define HIGH  (1)<br>#define LOW (0)<br>#define  Speed 120&#x2F;&#x2F;速度<br>static volatile unsigned char keyFlag &#x3D; 0  ;&#x2F;&#x2F;按键状态</p><p>void fanzhuan();<br>void zhengzhuan();<br>void Stop();<br>void delay(unsigned int t);</p><p>void exint0() interrupt 0           &#x2F;&#x2F;(location at 0003H)<br>{<br>     keyFlag++;<br>     keyFlag%&#x3D;3;<br>}</p><p>void delay(unsigned int t)<br>{<br>  unsigned int count &#x3D; 0;<br>  TMOD |&#x3D; 0x01;<br>  TH0 &#x3D; 0xFC;<br>  TL0 &#x3D; 0x66;<br>  TR0 &#x3D; 1;<br>  while (1)<br>  {<br>    if (TF0 &#x3D;&#x3D; 1)<br>    {<br>      count++;<br>      TF0 &#x3D; 0;<br>      TH0 &#x3D; 0xFC;<br>      TL0 &#x3D; 0x66;<br>    }<br>    if (count &gt;&#x3D; t)<br>    {<br>      break;<br>    }<br>  }<br>}<br>void main() {<br>     IT0 &#x3D; 1;                        &#x2F;&#x2F;set INT0 int type (1:Falling 0:Low level)<br>    EX0 &#x3D; 1;                        &#x2F;&#x2F;enable INT0 interrupt<br>    EA &#x3D; 1;                         &#x2F;&#x2F;open global interrupt switch<br>out_port &#x3D; 0x03;<br>    while(1)<br> {<br>     if(keyFlag)keyFlag&#x3D;&#x3D;1? zhengzhuan():fanzhuan(); else  Stop();<br> }<br>}</p><p>void Stop(){<br>  &#x2F;&#x2F;这里可以填写其他控制代码<br>     out_port &#x3D; 0X0f;<br>     LED&#x3D; LOW;<br>  }</p><p>void zhengzhuan(){<br>        static unsigned char i&#x3D;0;<br>                i &#x3D; i&lt;8 ? i+1 : 0;<br>         out_port &#x3D; sequence[i];<br>                    LED &#x3D; !LED;<br>delay(Speed);&#x2F;&#x2F;此数值必须大于100，否则仿真的时候会抖动 .</p><pre><code>  &#125;</code></pre><p>void fanzhuan(){<br>    static unsigned char k&#x3D;0;<br>    k &#x3D; k&gt;0 ? k-1 : 7;<br>       out_port &#x3D; sequence[k];<br>     LED&#x3D; !LED;<br>delay(Speed);&#x2F;&#x2F;此数值必须大于100，否则仿真的时候会抖动 .</p><pre><code> &#125;`</code></pre><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.12平台.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1g8WmQTIR5M5ynU8NPrpxjg </span><br><span class="line">提取码：r7ri</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1g8WmQTIR5M5ynU8NPrpxjg  提取码：r7ri</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSM Studio 直流电机H桥驱动PWM 单向控制</title>
      <link href="/2024/03/VSM-VSM-Studio-%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BAH%E6%A1%A5%E9%A9%B1%E5%8A%A8PWM-%E5%8D%95%E5%90%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/03/VSM-VSM-Studio-%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BAH%E6%A1%A5%E9%A9%B1%E5%8A%A8PWM-%E5%8D%95%E5%90%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="VSM-Studio-直流电机H桥驱动PWM-单向控制"><a href="#VSM-Studio-直流电机H桥驱动PWM-单向控制" class="headerlink" title="VSM Studio 直流电机H桥驱动PWM 单向控制"></a>VSM Studio 直流电机H桥驱动PWM 单向控制</h1><h3 id="VSM-Studio-直流电机H桥驱动PWM-单向控制-1"><a href="#VSM-Studio-直流电机H桥驱动PWM-单向控制-1" class="headerlink" title="VSM Studio 直流电机H桥驱动PWM 单向控制"></a>VSM Studio 直流电机H桥驱动PWM 单向控制</h3><ul><li>Proteus仿真</li></ul><p><img src="https://img-blog.csdnimg.cn/925eb23e77624a44ba389afff8642565.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="VSM-Studio-代码"><a href="#VSM-Studio-代码" class="headerlink" title="VSM Studio 代码"></a>VSM Studio 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周二 6月 7 2022</span><br><span class="line"> * Processor: AT89C52</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;REGX52.H&gt;</span><br><span class="line">#include &lt;intrins.H&gt;</span><br><span class="line"></span><br><span class="line">// Define P3 pins</span><br><span class="line">sbit Inc =P3^4; </span><br><span class="line">sbit Dec  = P3^5;</span><br><span class="line">sbit Dir =  P3^6 ;</span><br><span class="line">sbit PWM  = P3^7;</span><br><span class="line"></span><br><span class="line">// Define new types</span><br><span class="line">typedef unsigned char   uchar;</span><br><span class="line">typedef unsigned int    uint;</span><br><span class="line"></span><br><span class="line">void delay(uint);</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line"> &#123; </span><br><span class="line"> int speed;</span><br><span class="line">   // Select initial direction and speed.</span><br><span class="line">   Dir = 1;</span><br><span class="line">   if (Dir)</span><br><span class="line">      speed = 400;</span><br><span class="line">   else</span><br><span class="line">      speed = 100;</span><br><span class="line">   while(1)</span><br><span class="line">    &#123; if(!Inc)</span><br><span class="line">      // Increase speed   </span><br><span class="line">         speed = speed &gt; 0 ? speed - 1 : 0;</span><br><span class="line">      if(!Dec)</span><br><span class="line">      // Decrease speed</span><br><span class="line">         speed = speed &lt; 500 ? speed + 1 : 500;</span><br><span class="line">      </span><br><span class="line">      // Drive a PWM signal out. </span><br><span class="line">      PWM=1;</span><br><span class="line">      delay(speed);</span><br><span class="line">      PWM=0;</span><br><span class="line">      delay(500-speed);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void delay(uint j)</span><br><span class="line"> &#123; for(; j&gt;0; j--)</span><br><span class="line">    &#123; </span><br><span class="line">_nop_();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周二 6月 7 2022</li><li>Processor: AT89C52</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;REGX52.H&gt;<br>#include &lt;intrins.H&gt;</p><p>&#x2F;&#x2F; Define P3 pins<br>sbit Inc &#x3D;P3^4;<br>sbit Dec  &#x3D; P3^5;<br>sbit Dir &#x3D;  P3^6 ;<br>sbit PWM  &#x3D; P3^7;</p><p>&#x2F;&#x2F; Define new types<br>typedef unsigned char   uchar;<br>typedef unsigned int    uint;</p><p>void delay(uint);</p><p>void main(void)<br> {<br>     int speed;<br>   &#x2F;&#x2F; Select initial direction and speed.<br>   Dir &#x3D; 1;<br>   if (Dir)<br>      speed &#x3D; 400;<br>   else<br>      speed &#x3D; 100;<br>   while(1)<br>    { if(!Inc)<br>      &#x2F;&#x2F; Increase speed<br>         speed &#x3D; speed &gt; 0 ? speed - 1 : 0;<br>      if(!Dec)<br>      &#x2F;&#x2F; Decrease speed<br>         speed &#x3D; speed &lt; 500 ? speed + 1 : 500;</p><pre><code>  // Drive a PWM signal out.   PWM=1;  delay(speed);  PWM=0;  delay(500-speed);&#125;</code></pre><p> }</p><p>void delay(uint j)<br> { for(; j&gt;0; j–)<br>    {<br>            <em>nop</em>();<br>    }<br> }&#96;</p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1a1oIn0mIsth85X3W7tAbRg </span><br><span class="line">提取码：ukg5</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1a1oIn0mIsth85X3W7tAbRg  提取码：ukg5</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】4X4矩阵按键扫描组成的加减运算</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4X4%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E7%BB%84%E6%88%90%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4X4%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E6%89%AB%E6%8F%8F%E7%BB%84%E6%88%90%E7%9A%84%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】4X4矩阵按键扫描组成的加减运算"><a href="#【Proteus仿真】4X4矩阵按键扫描组成的加减运算" class="headerlink" title="【Proteus仿真】4X4矩阵按键扫描组成的加减运算"></a>【Proteus仿真】4X4矩阵按键扫描组成的加减运算</h1><h3 id="【Proteus仿真】4X4矩阵按键扫描组成的加减运算-1"><a href="#【Proteus仿真】4X4矩阵按键扫描组成的加减运算-1" class="headerlink" title="【Proteus仿真】4X4矩阵按键扫描组成的加减运算"></a>【Proteus仿真】4X4矩阵按键扫描组成的加减运算</h3><ul><li>《【Proteus仿真】4X4矩阵按键扫描组成的简易加法器》</li><li>Proteus仿真演示</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/125290001">【Proteus仿真】4X4矩阵按键扫描组成的简易加法器</a></p><p><img src="https://img-blog.csdnimg.cn/345e5b32caaa4bf1a5d27f58a7b34773.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h4><p>支持加和减运算，但不支持连续加减操作。</p><h4 id="VSM-Studio代码"><a href="#VSM-Studio代码" class="headerlink" title="VSM Studio代码"></a>VSM Studio代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^0;</span><br><span class="line">sbit ADDR1 = P1^1;</span><br><span class="line">sbit ADDR2 = P1^2;</span><br><span class="line">sbit ADDR3 = P1^3;</span><br><span class="line">sbit ENLED = P1^4;</span><br><span class="line">sbit KEY_IN_1  = P2^4;</span><br><span class="line">sbit KEY_IN_2  = P2^5;</span><br><span class="line">sbit KEY_IN_3  = P2^6;</span><br><span class="line">sbit KEY_IN_4  = P2^7;</span><br><span class="line">sbit KEY_OUT_1 = P2^3;</span><br><span class="line">sbit KEY_OUT_2 = P2^2;</span><br><span class="line">sbit KEY_OUT_3 = P2^1;</span><br><span class="line">sbit KEY_OUT_4 = P2^0;</span><br><span class="line"></span><br><span class="line">unsigned char code LedChar[] = &#123;  //数码管显示字符转换表</span><br><span class="line">    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,</span><br><span class="line">    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E</span><br><span class="line">&#125;;</span><br><span class="line">unsigned char LedBuff[6] = &#123;  //数码管显示缓冲区</span><br><span class="line">    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF</span><br><span class="line">&#125;;</span><br><span class="line">unsigned char code KeyCodeMap[4][4] = &#123; //矩阵按键编号到标准键盘键码的映射表</span><br><span class="line">    &#123; 0x31, 0x32, 0x33, 0x26 &#125;, //数字键1、数字键2、数字键3、向上键</span><br><span class="line">    &#123; 0x34, 0x35, 0x36, 0x25 &#125;, //数字键4、数字键5、数字键6、向左键</span><br><span class="line">    &#123; 0x37, 0x38, 0x39, 0x28 &#125;, //数字键7、数字键8、数字键9、向下键</span><br><span class="line">    &#123; 0x30, 0x1B, 0x0D, 0x27 &#125;  //数字键0、ESC键、  回车键、 向右键</span><br><span class="line">&#125;;</span><br><span class="line">unsigned char KeySta[4][4] = &#123;  //全部矩阵按键的当前状态</span><br><span class="line">    &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void KeyDriver();</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    EA = 1;       //使能总中断</span><br><span class="line">    ENLED = 0;    //选择数码管进行显示</span><br><span class="line">    ADDR3 = 1;</span><br><span class="line">    TMOD = 0x01;  //设置T0为模式1</span><br><span class="line">    TH0  = 0xFC;  //为T0赋初值0xFC67，定时1ms</span><br><span class="line">    TL0  = 0x67;</span><br><span class="line">    ET0  = 1;     //使能T0中断</span><br><span class="line">    TR0  = 1;     //启动T0</span><br><span class="line">    LedBuff[0] = LedChar[0];  //上电显示0</span><br><span class="line"></span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyDriver();   //调用按键驱动函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 将一个有符号长整型的数字显示到数码管上，num-待显示数字 */</span><br><span class="line">void ShowNumber(long num)</span><br><span class="line">&#123;</span><br><span class="line">    signed char i;</span><br><span class="line">    unsigned char sign;</span><br><span class="line">    unsigned char buf[6];</span><br><span class="line">    </span><br><span class="line">    if (num &lt; 0)  //首先提取并暂存符号位</span><br><span class="line">    &#123;</span><br><span class="line">        sign = 1;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        sign = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i=0; i&lt;6; i++)   //把长整型数转换为6位十进制的数组</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = num % 10;</span><br><span class="line">        num = num / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i=5; i&gt;=1; i--)  //从最高位起，遇到0转换为空格，遇到非0则退出循环</span><br><span class="line">    &#123;</span><br><span class="line">        if (buf[i] == 0)</span><br><span class="line">            LedBuff[i] = 0xFF;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sign != 0)        //负数时，需在最前面添加负号</span><br><span class="line">    &#123;</span><br><span class="line">        if (i &lt; 5)        //当有效位数小于6位时添加负号，否则显示结果将是错的</span><br><span class="line">        &#123;</span><br><span class="line">            LedBuff[i+1] = 0xBF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for ( ; i&gt;=0; i--)    //剩余低位都如实转换为数码管显示字符</span><br><span class="line">    &#123;</span><br><span class="line">        LedBuff[i] = LedChar[buf[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span><br><span class="line">void KeyAction(unsigned char keycode)</span><br><span class="line">&#123;</span><br><span class="line">    static char oprt = 0;    //用于保存加减运算符</span><br><span class="line">    static long result = 0;  //用于保存运算结果</span><br><span class="line">    static long addend = 0;  //用于保存输入的加数</span><br><span class="line">    </span><br><span class="line">    if ((keycode&gt;=0x30) &amp;&amp; (keycode&lt;=0x39))  //输入0-9的数字</span><br><span class="line">    &#123;</span><br><span class="line">        addend = (addend*10)+(keycode-0x30); //整体十进制左移，新数字进入个位</span><br><span class="line">        ShowNumber(addend);    //运算结果显示到数码管</span><br><span class="line">    &#125;</span><br><span class="line">    else if (keycode == 0x26)  //向上键用作加号</span><br><span class="line">    &#123;</span><br><span class="line">        oprt = 0;              //设置运算符变量</span><br><span class="line">        result = addend;       //运算数存到结果中，准备进行加减</span><br><span class="line">        addend = 0;            //清零运算数，准备接收下一个运算数</span><br><span class="line">        ShowNumber(addend);    //刷新数码管显示</span><br><span class="line">    &#125;</span><br><span class="line">    else if (keycode == 0x28)  //向下键用作减号</span><br><span class="line">    &#123;</span><br><span class="line">        oprt = 1;              //设置运算符变量</span><br><span class="line">        result = addend;       //运算数存到结果中，准备进行加减</span><br><span class="line">        addend = 0;            //清零运算数，准备接收下一个运算数</span><br><span class="line">        ShowNumber(addend);    //刷新数码管显示</span><br><span class="line">    &#125;</span><br><span class="line">    else if (keycode == 0x0D)  //回车键，执行加减运算</span><br><span class="line">    &#123;</span><br><span class="line">        if (oprt == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            result += addend;  //进行加法运算</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            result -= addend;  //进行减法运算</span><br><span class="line">        &#125;</span><br><span class="line">        addend = 0;</span><br><span class="line">        ShowNumber(result);    //运算结果显示到数码管</span><br><span class="line">    &#125;</span><br><span class="line">    else if (keycode == 0x1B)  //Esc键，清零结果</span><br><span class="line">    &#123;</span><br><span class="line">        addend = 0;</span><br><span class="line">        result = 0;</span><br><span class="line">        ShowNumber(addend);    //清零后的加数显示到数码管</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span><br><span class="line">void KeyDriver()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i, j;</span><br><span class="line">    static unsigned char backup[4][4] = &#123;  //按键值备份，保存前一次的值</span><br><span class="line">        &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;,  &#123;1, 1, 1, 1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    for (i=0; i&lt;4; i++)  //循环检测4*4的矩阵按键</span><br><span class="line">    &#123;</span><br><span class="line">        for (j=0; j&lt;4; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (backup[i][j] != KeySta[i][j])    //检测按键动作</span><br><span class="line">            &#123;</span><br><span class="line">                if (backup[i][j] != 0)           //按键按下时执行动作</span><br><span class="line">                &#123;</span><br><span class="line">                    KeyAction(KeyCodeMap[i][j]); //调用按键动作函数</span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = KeySta[i][j];     //刷新前一次的备份值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 按键扫描函数，需在定时中断中调用，推荐调用间隔1ms */</span><br><span class="line">void KeyScan()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i;</span><br><span class="line">    static unsigned char keyout = 0;   //矩阵按键扫描输出索引</span><br><span class="line">    static unsigned char keybuf[4][4] = &#123;  //矩阵按键扫描缓冲区</span><br><span class="line">        &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,  &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,</span><br><span class="line">        &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;,  &#123;0xFF, 0xFF, 0xFF, 0xFF&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //将一行的4个按键值移入缓冲区</span><br><span class="line">    keybuf[keyout][0] = (keybuf[keyout][0] &lt;&lt; 1) | KEY_IN_1;</span><br><span class="line">    keybuf[keyout][1] = (keybuf[keyout][1] &lt;&lt; 1) | KEY_IN_2;</span><br><span class="line">    keybuf[keyout][2] = (keybuf[keyout][2] &lt;&lt; 1) | KEY_IN_3;</span><br><span class="line">    keybuf[keyout][3] = (keybuf[keyout][3] &lt;&lt; 1) | KEY_IN_4;</span><br><span class="line">    //消抖后更新按键状态</span><br><span class="line">    for (i=0; i&lt;4; i++)  //每行4个按键，所以循环4次</span><br><span class="line">    &#123;</span><br><span class="line">        if ((keybuf[keyout][i] &amp; 0x0F) == 0x00)</span><br><span class="line">        &#123;   //连续4次扫描值为0，即4*4ms内都是按下状态时，可认为按键已稳定的按下</span><br><span class="line">            KeySta[keyout][i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((keybuf[keyout][i] &amp; 0x0F) == 0x0F)</span><br><span class="line">        &#123;   //连续4次扫描值为1，即4*4ms内都是弹起状态时，可认为按键已稳定的弹起</span><br><span class="line">            KeySta[keyout][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //执行下一次的扫描输出</span><br><span class="line">    keyout++;                //输出索引递增</span><br><span class="line">    keyout = keyout &amp; 0x03;  //索引值加到4即归零</span><br><span class="line">    switch (keyout)          //根据索引，释放当前输出引脚，拉低下次的输出引脚</span><br><span class="line">    &#123;</span><br><span class="line">        case 0: KEY_OUT_4 = 1; KEY_OUT_1 = 0; break;</span><br><span class="line">        case 1: KEY_OUT_1 = 1; KEY_OUT_2 = 0; break;</span><br><span class="line">        case 2: KEY_OUT_2 = 1; KEY_OUT_3 = 0; break;</span><br><span class="line">        case 3: KEY_OUT_3 = 1; KEY_OUT_4 = 0; break;</span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span><br><span class="line">void LedScan()</span><br><span class="line">&#123;</span><br><span class="line">    static unsigned char i = 0;  //动态扫描的索引</span><br><span class="line">    </span><br><span class="line">    P0 = 0xFF;   //显示消隐</span><br><span class="line">    switch (i)</span><br><span class="line">    &#123;</span><br><span class="line">        case 0: ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; break;</span><br><span class="line">        case 1: ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; break;</span><br><span class="line">        case 2: ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; break;</span><br><span class="line">        case 3: ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; break;</span><br><span class="line">        case 4: ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; break;</span><br><span class="line">        case 5: ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; break;</span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* T0中断服务函数，用于数码管显示扫描与按键扫描 */</span><br><span class="line">void InterruptTimer0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = 0xFC;  //重新加载初值</span><br><span class="line">    TL0 = 0x67;</span><br><span class="line">    LedScan();   //调用数码管显示扫描函数</span><br><span class="line">    KeyScan();   //调用按键扫描函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;reg52.h&gt;</p><p>sbit ADDR0 &#x3D; P1^0;<br>sbit ADDR1 &#x3D; P1^1;<br>sbit ADDR2 &#x3D; P1^2;<br>sbit ADDR3 &#x3D; P1^3;<br>sbit ENLED &#x3D; P1^4;<br>sbit KEY_IN_1  &#x3D; P2^4;<br>sbit KEY_IN_2  &#x3D; P2^5;<br>sbit KEY_IN_3  &#x3D; P2^6;<br>sbit KEY_IN_4  &#x3D; P2^7;<br>sbit KEY_OUT_1 &#x3D; P2^3;<br>sbit KEY_OUT_2 &#x3D; P2^2;<br>sbit KEY_OUT_3 &#x3D; P2^1;<br>sbit KEY_OUT_4 &#x3D; P2^0;</p><p>unsigned char code LedChar[] &#x3D; {  &#x2F;&#x2F;数码管显示字符转换表<br>    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,<br>    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E<br>};<br>unsigned char LedBuff[6] &#x3D; {  &#x2F;&#x2F;数码管显示缓冲区<br>    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF<br>};<br>unsigned char code KeyCodeMap[4][4] &#x3D; { &#x2F;&#x2F;矩阵按键编号到标准键盘键码的映射表<br>    { 0x31, 0x32, 0x33, 0x26 }, &#x2F;&#x2F;数字键1、数字键2、数字键3、向上键<br>    { 0x34, 0x35, 0x36, 0x25 }, &#x2F;&#x2F;数字键4、数字键5、数字键6、向左键<br>    { 0x37, 0x38, 0x39, 0x28 }, &#x2F;&#x2F;数字键7、数字键8、数字键9、向下键<br>    { 0x30, 0x1B, 0x0D, 0x27 }  &#x2F;&#x2F;数字键0、ESC键、  回车键、 向右键<br>};<br>unsigned char KeySta[4][4] &#x3D; {  &#x2F;&#x2F;全部矩阵按键的当前状态<br>    {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1}<br>};</p><p>void KeyDriver();</p><p>void main()<br>{<br>    EA &#x3D; 1;       &#x2F;&#x2F;使能总中断<br>    ENLED &#x3D; 0;    &#x2F;&#x2F;选择数码管进行显示<br>    ADDR3 &#x3D; 1;<br>    TMOD &#x3D; 0x01;  &#x2F;&#x2F;设置T0为模式1<br>    TH0  &#x3D; 0xFC;  &#x2F;&#x2F;为T0赋初值0xFC67，定时1ms<br>    TL0  &#x3D; 0x67;<br>    ET0  &#x3D; 1;     &#x2F;&#x2F;使能T0中断<br>    TR0  &#x3D; 1;     &#x2F;&#x2F;启动T0<br>    LedBuff[0] &#x3D; LedChar[0];  &#x2F;&#x2F;上电显示0</p><pre><code>while (1)&#123;    KeyDriver();   //调用按键驱动函数&#125;</code></pre><p>}<br>&#x2F;* 将一个有符号长整型的数字显示到数码管上，num-待显示数字 *&#x2F;<br>void ShowNumber(long num)<br>{<br>    signed char i;<br>    unsigned char sign;<br>    unsigned char buf[6];</p><pre><code>if (num &lt; 0)  //首先提取并暂存符号位&#123;    sign = 1;    num = -num;&#125;else&#123;    sign = 0;&#125;for (i=0; i&lt;6; i++)   //把长整型数转换为6位十进制的数组&#123;    buf[i] = num % 10;    num = num / 10;&#125;for (i=5; i&gt;=1; i--)  //从最高位起，遇到0转换为空格，遇到非0则退出循环&#123;    if (buf[i] == 0)        LedBuff[i] = 0xFF;    else        break;&#125;if (sign != 0)        //负数时，需在最前面添加负号&#123;    if (i &lt; 5)        //当有效位数小于6位时添加负号，否则显示结果将是错的    &#123;        LedBuff[i+1] = 0xBF;    &#125;&#125;for ( ; i&gt;=0; i--)    //剩余低位都如实转换为数码管显示字符&#123;    LedBuff[i] = LedChar[buf[i]];&#125;</code></pre><p>}<br>&#x2F;* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 *&#x2F;<br>void KeyAction(unsigned char keycode)<br>{<br>    static char oprt &#x3D; 0;    &#x2F;&#x2F;用于保存加减运算符<br>    static long result &#x3D; 0;  &#x2F;&#x2F;用于保存运算结果<br>    static long addend &#x3D; 0;  &#x2F;&#x2F;用于保存输入的加数</p><pre><code>if ((keycode&gt;=0x30) &amp;&amp; (keycode&lt;=0x39))  //输入0-9的数字&#123;    addend = (addend*10)+(keycode-0x30); //整体十进制左移，新数字进入个位    ShowNumber(addend);    //运算结果显示到数码管&#125;else if (keycode == 0x26)  //向上键用作加号&#123;    oprt = 0;              //设置运算符变量    result = addend;       //运算数存到结果中，准备进行加减    addend = 0;            //清零运算数，准备接收下一个运算数    ShowNumber(addend);    //刷新数码管显示&#125;else if (keycode == 0x28)  //向下键用作减号&#123;    oprt = 1;              //设置运算符变量    result = addend;       //运算数存到结果中，准备进行加减    addend = 0;            //清零运算数，准备接收下一个运算数    ShowNumber(addend);    //刷新数码管显示&#125;else if (keycode == 0x0D)  //回车键，执行加减运算&#123;    if (oprt == 0)    &#123;        result += addend;  //进行加法运算    &#125;    else    &#123;        result -= addend;  //进行减法运算    &#125;    addend = 0;    ShowNumber(result);    //运算结果显示到数码管&#125;else if (keycode == 0x1B)  //Esc键，清零结果&#123;    addend = 0;    result = 0;    ShowNumber(addend);    //清零后的加数显示到数码管&#125;</code></pre><p>}<br>&#x2F;* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 *&#x2F;<br>void KeyDriver()<br>{<br>    unsigned char i, j;<br>    static unsigned char backup[4][4] &#x3D; {  &#x2F;&#x2F;按键值备份，保存前一次的值<br>        {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1},  {1, 1, 1, 1}<br>    };</p><pre><code>for (i=0; i&lt;4; i++)  //循环检测4*4的矩阵按键&#123;    for (j=0; j&lt;4; j++)    &#123;        if (backup[i][j] != KeySta[i][j])    //检测按键动作        &#123;            if (backup[i][j] != 0)           //按键按下时执行动作            &#123;                KeyAction(KeyCodeMap[i][j]); //调用按键动作函数            &#125;            backup[i][j] = KeySta[i][j];     //刷新前一次的备份值        &#125;    &#125;&#125;</code></pre><p>}<br>&#x2F;* 按键扫描函数，需在定时中断中调用，推荐调用间隔1ms *&#x2F;<br>void KeyScan()<br>{<br>    unsigned char i;<br>    static unsigned char keyout &#x3D; 0;   &#x2F;&#x2F;矩阵按键扫描输出索引<br>    static unsigned char keybuf[4][4] &#x3D; {  &#x2F;&#x2F;矩阵按键扫描缓冲区<br>        {0xFF, 0xFF, 0xFF, 0xFF},  {0xFF, 0xFF, 0xFF, 0xFF},<br>        {0xFF, 0xFF, 0xFF, 0xFF},  {0xFF, 0xFF, 0xFF, 0xFF}<br>    };</p><pre><code>//将一行的4个按键值移入缓冲区keybuf[keyout][0] = (keybuf[keyout][0] &lt;&lt; 1) | KEY_IN_1;keybuf[keyout][1] = (keybuf[keyout][1] &lt;&lt; 1) | KEY_IN_2;keybuf[keyout][2] = (keybuf[keyout][2] &lt;&lt; 1) | KEY_IN_3;keybuf[keyout][3] = (keybuf[keyout][3] &lt;&lt; 1) | KEY_IN_4;//消抖后更新按键状态for (i=0; i&lt;4; i++)  //每行4个按键，所以循环4次&#123;    if ((keybuf[keyout][i] &amp; 0x0F) == 0x00)    &#123;   //连续4次扫描值为0，即4*4ms内都是按下状态时，可认为按键已稳定的按下        KeySta[keyout][i] = 0;    &#125;    else if ((keybuf[keyout][i] &amp; 0x0F) == 0x0F)    &#123;   //连续4次扫描值为1，即4*4ms内都是弹起状态时，可认为按键已稳定的弹起        KeySta[keyout][i] = 1;    &#125;&#125;//执行下一次的扫描输出keyout++;                //输出索引递增keyout = keyout &amp; 0x03;  //索引值加到4即归零switch (keyout)          //根据索引，释放当前输出引脚，拉低下次的输出引脚&#123;    case 0: KEY_OUT_4 = 1; KEY_OUT_1 = 0; break;    case 1: KEY_OUT_1 = 1; KEY_OUT_2 = 0; break;    case 2: KEY_OUT_2 = 1; KEY_OUT_3 = 0; break;    case 3: KEY_OUT_3 = 1; KEY_OUT_4 = 0; break;    default: break;&#125;</code></pre><p>}<br>&#x2F;* 数码管动态扫描刷新函数，需在定时中断中调用 *&#x2F;<br>void LedScan()<br>{<br>    static unsigned char i &#x3D; 0;  &#x2F;&#x2F;动态扫描的索引</p><pre><code>P0 = 0xFF;   //显示消隐switch (i)&#123;    case 0: ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; break;    case 1: ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; break;    case 2: ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; break;    case 3: ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; break;    case 4: ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; break;    case 5: ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; break;    default: break;&#125;</code></pre><p>}<br>&#x2F;* T0中断服务函数，用于数码管显示扫描与按键扫描 *&#x2F;<br>void InterruptTimer0() interrupt 1<br>{<br>    TH0 &#x3D; 0xFC;  &#x2F;&#x2F;重新加载初值<br>    TL0 &#x3D; 0x67;<br>    LedScan();   &#x2F;&#x2F;调用数码管显示扫描函数<br>    KeyScan();   &#x2F;&#x2F;调用按键扫描函数<br>}&#96;</p><ul><li>VSM Studio</li></ul><p><img src="https://img-blog.csdnimg.cn/3d41f07dc2214f468b813cca03422f46.png" alt="在这里插入图片描述"></p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本实验基于Proteus8.12平台。本示例只有基于VSM Studio代码，没有Keil工程。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1yKxiRrMpyy75w81WzB4iPA </span><br><span class="line">提取码：0wcd</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1yKxiRrMpyy75w81WzB4iPA  提取码：0wcd</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】LCD1602+DS1307按键设置简易时钟</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FLCD1602DS1307%E6%8C%89%E9%94%AE%E8%AE%BE%E7%BD%AE%E7%AE%80%E6%98%93%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FLCD1602DS1307%E6%8C%89%E9%94%AE%E8%AE%BE%E7%BD%AE%E7%AE%80%E6%98%93%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】LCD1602-DS1307按键设置简易时钟"><a href="#【Proteus仿真】LCD1602-DS1307按键设置简易时钟" class="headerlink" title="【Proteus仿真】LCD1602+DS1307按键设置简易时钟"></a>【Proteus仿真】LCD1602+DS1307按键设置简易时钟</h1><h3 id="【Proteus仿真】LCD1602-DS1307按键设置简易时钟-1"><a href="#【Proteus仿真】LCD1602-DS1307按键设置简易时钟-1" class="headerlink" title="【Proteus仿真】LCD1602+DS1307按键设置简易时钟"></a>【Proteus仿真】LCD1602+DS1307按键设置简易时钟</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/1618556297e24526ab5d0c31b7fa670b.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>通过按键设置当前时间，按键调整时间只实现了对时分秒的设置，年月日以及星期是程序代码写入的，按键不能进行调整，功能需自行完善。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周四 6月 23 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/****************************************************</span><br><span class="line"></span><br><span class="line">电路图说明：</span><br><span class="line">将单片机P2.7和P1.0分别与RTC（实时时钟）的时钟信号SCL端</span><br><span class="line">和数据信号SDA端相连， RTC的sout引脚与单片机P3.2相连，RTC的</span><br><span class="line">地址是11010000(0xD0)独立键盘k0~K3接P1.1~P1.3</span><br><span class="line">程序功能：</span><br><span class="line">  使用时钟芯片ds1307制作一个实时时钟</span><br><span class="line">******************************************************/</span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">//实时时钟两信号线</span><br><span class="line">sbit scl=P2^7;</span><br><span class="line">sbit sda=P1^0;</span><br><span class="line">//独立键盘扫描位</span><br><span class="line">sbit k0=P1^1;</span><br><span class="line">sbit k1=P1^2;</span><br><span class="line">sbit k2=P1^3;</span><br><span class="line">//液晶显示器控制位</span><br><span class="line">sbit lcd_rs=P3^4;</span><br><span class="line">sbit lcd_e=P3^5;</span><br><span class="line">void init();//初始化IIC总线，使总线处于备用状态,</span><br><span class="line">//初始化lcd并显示上面table1和table2的值，初始化定时器0，初始化变量时分秒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/****************IIC总线控制函数***************************/</span><br><span class="line">void IIC_start();//IIC通信开始信号</span><br><span class="line">void IIC_stop();//IIC通信停止信号</span><br><span class="line">void IIC_un_ack();//单片机发送非应答位</span><br><span class="line">//void IIC_ack();//单片机发送应答位</span><br><span class="line">void IIC_check_ack();//单片机检查应答位</span><br><span class="line">void IIC_write_byte(uchar);//发送一字节数据</span><br><span class="line">uchar IIC_read_byte();//接收一字节数据</span><br><span class="line">void nop();//5us空操作延迟</span><br><span class="line">/**********************************/</span><br><span class="line">/**********ds1307读写函数*******************/</span><br><span class="line">void ds1307_write_date(uchar ,uchar ,uchar);//向指定器件写一字节数据</span><br><span class="line">//参数1器件地址，参数2要存的数据存放位置8位地址</span><br><span class="line">//参数3要写的数据</span><br><span class="line"></span><br><span class="line">uchar ds1307_read_date(uchar ,uchar );//从指定器件读一字节数据，</span><br><span class="line">//参数1被通信器件地址，参数2要读的数据存放位置8位地址</span><br><span class="line">//函数返回读取的数据。</span><br><span class="line">void delay(uint);//基数1ms延迟程序</span><br><span class="line">/***********************************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**************LCD操作函数**************************/</span><br><span class="line"></span><br><span class="line">uchar hour,minute,second,k0_num;//时分秒变量，菜单键k0第几次按下计数，ds1307跟新标志</span><br><span class="line">//时钟初显示</span><br><span class="line">uchar code table1[]=&quot;2022-06-23 Thu&quot;;</span><br><span class="line">uchar code table2[]=&quot;    16:31:15 &quot;;//2022年6月23日16:31:15</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void lcd_write_com(uchar);//向液晶显示器写指令设置其显示的格式</span><br><span class="line">void lcd_write_date(uchar);//向液晶显示器写显示的数据</span><br><span class="line"></span><br><span class="line">/**********************************************/</span><br><span class="line"></span><br><span class="line">/**************时钟函数*******************/</span><br><span class="line">void lcd_write_second(uchar);//向lcd写秒</span><br><span class="line">void lcd_write_minute(uchar);//向lcd写分</span><br><span class="line">void lcd_write_hour(uchar);//向lcd写时</span><br><span class="line">void run_time();//时钟走动显示</span><br><span class="line">void keyscan();//菜单键扫描</span><br><span class="line">/****************************************/</span><br><span class="line"></span><br><span class="line">/*********十进值与BCD码之间互换**********/</span><br><span class="line">uchar b_second,b_minute,b_hour;</span><br><span class="line">uchar dectobcd(uchar);//十进值转bcd码</span><br><span class="line">uchar bcdtodec(uchar);//bcd码转十进值</span><br><span class="line">/****************************************/</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">keyscan();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void nop()</span><br><span class="line">&#123;</span><br><span class="line">_nop_();_nop_();_nop_();</span><br><span class="line">_nop_();_nop_();_nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">//将数据线和时钟线拉高，处于备用状态即非忙</span><br><span class="line">sda=1;</span><br><span class="line">nop();</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line"></span><br><span class="line">//初始化写入LCD的时分秒</span><br><span class="line">        second=16;</span><br><span class="line">        minute=23;</span><br><span class="line">        hour=16;</span><br><span class="line">//初始化ds1307</span><br><span class="line">ds1307_write_date(0xd0,0x07,0x10);//初始化1307的控制字，使其SOUT引脚输出1Hz的方波。</span><br><span class="line">//初始化1307的时间</span><br><span class="line">ds1307_write_date(0xd0,6,0x14); </span><br><span class="line">ds1307_write_date(0xd0,5,0x06);   </span><br><span class="line">ds1307_write_date(0xd0,4,0x09);</span><br><span class="line">ds1307_write_date(0xd0,3,0x00);</span><br><span class="line">ds1307_write_date(0xd0,2,0x23);</span><br><span class="line">ds1307_write_date(0xd0,1,0x59);</span><br><span class="line">ds1307_write_date(0xd0,0,0x55);</span><br><span class="line"></span><br><span class="line">//初始化液晶显示器</span><br><span class="line">lcd_write_com(0x38);//设置16*2行，5*7点阵，8位数据接口</span><br><span class="line">lcd_write_com(0x06);//写字符指针和光标自动向右移动</span><br><span class="line">lcd_write_com(0x0c);//开显示，不显示光标，光标不闪烁</span><br><span class="line">lcd_write_com(0x01);//显示清屏</span><br><span class="line">for(i=0;i&lt;15;i++)</span><br><span class="line">&#123;</span><br><span class="line">lcd_write_date(table1[i]);</span><br><span class="line">&#125;</span><br><span class="line">lcd_write_com(0x80+0x40);</span><br><span class="line">for(i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">lcd_write_date(table2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开启外部中断0</span><br><span class="line">EA=1;</span><br><span class="line">EX0=1;</span><br><span class="line">IT0=1;</span><br><span class="line">&#125;</span><br><span class="line">void IIC_start()</span><br><span class="line">&#123;</span><br><span class="line">//在时钟信号有效scl=1时，数据线负跳变</span><br><span class="line">sda=1;</span><br><span class="line">nop();</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line">sda=0;</span><br><span class="line">nop();</span><br><span class="line">scl=0;//拉低为下个时钟数据作准备</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">void IIC_stop()</span><br><span class="line">&#123;</span><br><span class="line">//在时钟信号有效scl=1时，数据线正跳变，释放总线,使总线处于备用状态即非忙</span><br><span class="line">sda=0;</span><br><span class="line">nop();</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line">sda=1;</span><br><span class="line">nop();</span><br><span class="line">nop();</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">void IIC_un_ack()</span><br><span class="line">&#123;</span><br><span class="line">//时钟信号有效时，sda给1，给出非应答</span><br><span class="line">sda=1;</span><br><span class="line">nop();</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line">scl=0;//拉低为下个时钟数据作准备</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">void IIC_ack()</span><br><span class="line">&#123;</span><br><span class="line">//时钟信号有效时，sda给0，给出应答</span><br><span class="line">sda=0;</span><br><span class="line">nop();</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line">scl=0;//拉低为下个时钟数据作准备</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">void IIC_check_ack()</span><br><span class="line">&#123;</span><br><span class="line">//uchar i;</span><br><span class="line">//时钟信号有效时，检测数据信号sda是否为0，给0说明有应答信号</span><br><span class="line">scl=1;</span><br><span class="line">//while((sda==1)&amp;&amp;(i&lt;255)) i++;</span><br><span class="line">nop();</span><br><span class="line">scl=0;//拉低为下个时钟数据作准备</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">uchar IIC_read_byte( )</span><br><span class="line">&#123;</span><br><span class="line">uchar i,temp;//temp用于存放从数据线读到的数据</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;8;i++)//从数据线读取一个字节（8位）</span><br><span class="line">&#123;</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line">temp=(temp&lt;&lt;1)|sda;//temp左移，腾出第0位，然后将数据线上的一位数用或</span><br><span class="line"> //运算存放到temp的第0位</span><br><span class="line">scl=0;//拉低为下个时钟数据作准备</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IIC_write_byte(uchar byte)</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">for(i=0;i&lt;8;i++)//向数据线写一个字节（8位）</span><br><span class="line">&#123;</span><br><span class="line">byte=byte&lt;&lt;1;//左移位，将byte第7位移到PSW中的进位标志位CY中</span><br><span class="line">sda=CY;</span><br><span class="line">nop();</span><br><span class="line">scl=1;</span><br><span class="line">nop();</span><br><span class="line">scl=0;//拉低为下个时钟数据作准备</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line">sda=1;//释放总线，准备接收被控设备应答信号</span><br><span class="line">nop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ds1307_write_date(uchar d_address,uchar r_address,uchar date)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">IIC_start();</span><br><span class="line">IIC_write_byte(d_address &amp; (~0x01));//写器件地址,方向是写,所以或上0x00</span><br><span class="line">IIC_check_ack();//等待应答</span><br><span class="line">IIC_write_byte(r_address);//写存储器数据存放的8位地址</span><br><span class="line">IIC_check_ack();//等待应答</span><br><span class="line">IIC_write_byte(date);//写一字节数据</span><br><span class="line">IIC_check_ack();//等待应答</span><br><span class="line">IIC_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar ds1307_read_date(uchar d_address,uchar r_address)</span><br><span class="line">&#123;</span><br><span class="line">uchar r;</span><br><span class="line">IIC_start();</span><br><span class="line">IIC_write_byte(d_address &amp; (~0x01));//写器件地址，方向是写</span><br><span class="line">IIC_check_ack();//等待应答</span><br><span class="line">IIC_write_byte(r_address);//写存储器数据存放的8位地址</span><br><span class="line">IIC_check_ack();//等待应答</span><br><span class="line"></span><br><span class="line">//换方向</span><br><span class="line">IIC_start();</span><br><span class="line">IIC_write_byte(d_address|0x01);//写器件地址，方向是读，所以或上1</span><br><span class="line">    IIC_check_ack();</span><br><span class="line">r=IIC_read_byte();//读取一个字节数据</span><br><span class="line">IIC_un_ack();</span><br><span class="line">IIC_stop();</span><br><span class="line">return r;//将读到的数据返回</span><br><span class="line">&#125;</span><br><span class="line">void delay(uint z)//晶振频率12MHz时，z=1时延迟1ms</span><br><span class="line">&#123;</span><br><span class="line">uint a,b;</span><br><span class="line">for(a=z;a&gt;0;a--)</span><br><span class="line">for(b=110;b&gt;0;b--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void lcd_write_com(uchar com)//lcd写指令函数定义</span><br><span class="line">&#123;</span><br><span class="line">lcd_rs=0;</span><br><span class="line">P0=com;</span><br><span class="line">delay(1);</span><br><span class="line">lcd_e=1;</span><br><span class="line">lcd_e=0;</span><br><span class="line">delay(2);</span><br><span class="line">&#125;</span><br><span class="line">void lcd_write_date(uchar date)//lcd写数据函数定义</span><br><span class="line">&#123;</span><br><span class="line">lcd_rs=1;</span><br><span class="line">P0=date;</span><br><span class="line">delay(1);</span><br><span class="line">lcd_e=1;</span><br><span class="line">lcd_e=0;</span><br><span class="line">delay(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void lcd_write_second(uchar sec)//向lcd写秒</span><br><span class="line">&#123;</span><br><span class="line">uchar h,l;</span><br><span class="line">h=sec/10;</span><br><span class="line">l=sec%10;</span><br><span class="line">lcd_write_com(0x80+0x40+10);</span><br><span class="line">lcd_write_date(0x30+h);</span><br><span class="line">lcd_write_date(0x30+l);</span><br><span class="line">&#125;</span><br><span class="line">void lcd_write_minute(uchar min)//向lcd写分</span><br><span class="line">&#123;</span><br><span class="line">uchar h,l;</span><br><span class="line">h=min/10;</span><br><span class="line">l=min%10;</span><br><span class="line">lcd_write_com(0x80+0x40+7);</span><br><span class="line">lcd_write_date(0x30+h);</span><br><span class="line">lcd_write_date(0x30+l);</span><br><span class="line">&#125;</span><br><span class="line">void lcd_write_hour(uchar hou)//向lcd写时</span><br><span class="line">&#123;</span><br><span class="line">uchar h,l;</span><br><span class="line">h=hou/10;</span><br><span class="line">l=hou%10;</span><br><span class="line">lcd_write_com(0x80+0x40+4);</span><br><span class="line">lcd_write_date(0x30+h);</span><br><span class="line">lcd_write_date(0x30+l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void inter0()interrupt 0</span><br><span class="line">&#123;</span><br><span class="line">run_time();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run_time()//时钟走动函数定义</span><br><span class="line">&#123;</span><br><span class="line">//从1307中读出时间</span><br><span class="line">b_second=ds1307_read_date(0xd0,0);//返回函数r值秒</span><br><span class="line">b_minute=ds1307_read_date(0xd0,1);</span><br><span class="line">b_hour=ds1307_read_date(0xd0,2);</span><br><span class="line">//将读出的时间转换成十进值</span><br><span class="line">second=bcdtodec(b_second);</span><br><span class="line">minute=bcdtodec(b_minute);</span><br><span class="line">hour=bcdtodec(b_hour);</span><br><span class="line">//更新lcd显示时间</span><br><span class="line">lcd_write_second(second);</span><br><span class="line">lcd_write_minute(minute);</span><br><span class="line">lcd_write_hour(hour);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar dectobcd(uchar dec)//十进值到BCD码</span><br><span class="line">&#123;</span><br><span class="line">uchar x,y;</span><br><span class="line">x=dec/10;//得到bcd的十位数</span><br><span class="line">y=dec%10;//得到bcd的个位数</span><br><span class="line">y=(x&lt;&lt;4)|y;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br><span class="line">uchar bcdtodec(uchar bcd)//bcd码转十进值</span><br><span class="line">&#123;</span><br><span class="line">uchar x,y;</span><br><span class="line">y=bcd/16;//得到十进制的十位数</span><br><span class="line">x=bcd%16;//得到十进制的个位数</span><br><span class="line">y=y*10+x;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void keyscan()//菜单键按下扫描函数定义</span><br><span class="line">&#123;</span><br><span class="line">k0=1;</span><br><span class="line">k1=1;</span><br><span class="line">k2=1;</span><br><span class="line">//判断菜单键k0是否按下</span><br><span class="line">if(k0==0)</span><br><span class="line">&#123;</span><br><span class="line">delay(5);</span><br><span class="line">if(k0==0)</span><br><span class="line">&#123;</span><br><span class="line">while(!k0);//松手检测</span><br><span class="line">k0_num++;//记录菜单键k0是第几次按下，而判断是调节秒、分还是时。</span><br><span class="line">if(k0_num==1)//指示调节秒</span><br><span class="line">&#123;</span><br><span class="line">EX0=0;//关闭外部中断0，使时间走动停止，准备调时间</span><br><span class="line">ds1307_write_date(0xd0,0,0x80|b_second);</span><br><span class="line">lcd_write_com(0x80+0x40+11);//数据指针和光标移动秒出</span><br><span class="line">lcd_write_com(0x0f);//使光标显示，并光标处字符格符闪烁，用来提示用户此时可以调节</span><br><span class="line"> //什么？是秒，是分还是时。</span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==2)//指示调节分</span><br><span class="line">&#123;</span><br><span class="line">lcd_write_com(0x80+0x40+8);//数据指针和光标移动分出</span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==3)//指示调节时</span><br><span class="line">&#123;</span><br><span class="line">lcd_write_com(0x80+0x40+5);//数据指针和光标移动时出</span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==4)//退出时间调节菜单</span><br><span class="line">&#123;</span><br><span class="line">k0_num=0;//菜单键k0按下清零</span><br><span class="line">lcd_write_com(0x0c);//恢复到时钟走动状态，即光标不显示，不闪烁</span><br><span class="line">//将所调的时间转换成bcd码</span><br><span class="line">b_second=dectobcd(second);</span><br><span class="line">b_minute=dectobcd(minute);</span><br><span class="line">b_hour=dectobcd(hour);</span><br><span class="line">//将所调的时间向时钟写入</span><br><span class="line">ds1307_write_date(0xd0,2,b_hour);</span><br><span class="line">ds1307_write_date(0xd0,1,b_minute);</span><br><span class="line">ds1307_write_date(0xd0,0,b_second);</span><br><span class="line"></span><br><span class="line">EX0=1;//开外部中断0，时间开始继续走动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否按下过时间调节菜单键k0,而处于需要调节时间状态</span><br><span class="line">if(k0_num)</span><br><span class="line">&#123;</span><br><span class="line">//判断是否是上调键k1按下</span><br><span class="line">if(k1==0)</span><br><span class="line">&#123;</span><br><span class="line">delay(5);</span><br><span class="line">if(k1==0)</span><br><span class="line">&#123;</span><br><span class="line">while(!k1);//松手检测</span><br><span class="line">if(k0_num==1)//上调秒</span><br><span class="line">&#123;</span><br><span class="line">second++;</span><br><span class="line">if(second==60)</span><br><span class="line">second=0;</span><br><span class="line">lcd_write_second(second);//向lcd写入被修改的时间</span><br><span class="line">lcd_write_com(0x80+0x40+11);//光标位置重定位到所要调的时间处</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==2)//上调分</span><br><span class="line">&#123;</span><br><span class="line">minute++;</span><br><span class="line">if(minute==60)</span><br><span class="line">minute=0;</span><br><span class="line">lcd_write_minute(minute);</span><br><span class="line">lcd_write_com(0x80+0x40+8);</span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==3)//上调时</span><br><span class="line">&#123;</span><br><span class="line">hour++;</span><br><span class="line">if(hour==24)</span><br><span class="line">hour=0;</span><br><span class="line">lcd_write_hour(hour);</span><br><span class="line">lcd_write_com(0x80+0x40+5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//判断是否是下调键k2按下</span><br><span class="line">if(k2==0)</span><br><span class="line">&#123;</span><br><span class="line">delay(5);</span><br><span class="line">if(k2==0)</span><br><span class="line">&#123;</span><br><span class="line">while(!k2);</span><br><span class="line">if(k0_num==1)//下调节秒</span><br><span class="line">&#123;</span><br><span class="line">second--;</span><br><span class="line">if(second==255)</span><br><span class="line">second=59;</span><br><span class="line">lcd_write_second(second);</span><br><span class="line">lcd_write_com(0x80+0x40+11);</span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==2)//下调节分</span><br><span class="line">&#123;</span><br><span class="line">minute--;</span><br><span class="line">if(minute==255)</span><br><span class="line">minute=59;</span><br><span class="line">lcd_write_minute(minute);</span><br><span class="line">lcd_write_com(0x80+0x40+8);</span><br><span class="line">&#125;</span><br><span class="line">if(k0_num==3)//下调节时</span><br><span class="line">&#123;</span><br><span class="line">hour--;</span><br><span class="line">if(hour==255)</span><br><span class="line">hour=23;</span><br><span class="line">lcd_write_hour(hour);</span><br><span class="line">lcd_write_com(0x80+0x40+5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周四 6月 23 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>&#x2F;****************************************************</p><p>电路图说明：<br>    将单片机P2.7和P1.0分别与RTC（实时时钟）的时钟信号SCL端<br>和数据信号SDA端相连， RTC的sout引脚与单片机P3.2相连，RTC的<br>地址是11010000(0xD0)独立键盘k0<del>K3接P1.1</del>P1.3<br>程序功能：<br>      使用时钟芯片ds1307制作一个实时时钟<br>******************************************************&#x2F;<br>#include &lt;reg52.h&gt;<br>#include&lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>&#x2F;&#x2F;实时时钟两信号线<br>sbit scl&#x3D;P2^7;<br>sbit sda&#x3D;P1^0;<br>&#x2F;&#x2F;独立键盘扫描位<br>sbit k0&#x3D;P1^1;<br>sbit k1&#x3D;P1^2;<br>sbit k2&#x3D;P1^3;<br>&#x2F;&#x2F;液晶显示器控制位<br>sbit lcd_rs&#x3D;P3^4;<br>sbit lcd_e&#x3D;P3^5;<br>void init();&#x2F;&#x2F;初始化IIC总线，使总线处于备用状态,<br>            &#x2F;&#x2F;初始化lcd并显示上面table1和table2的值，初始化定时器0，初始化变量时分秒</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong>IIC总线控制函数</strong></strong></strong></strong></strong></strong></strong></strong>***********&#x2F;<br>void IIC_start();&#x2F;&#x2F;IIC通信开始信号<br>void IIC_stop();&#x2F;&#x2F;IIC通信停止信号<br>void IIC_un_ack();&#x2F;&#x2F;单片机发送非应答位<br>&#x2F;&#x2F;void IIC_ack();&#x2F;&#x2F;单片机发送应答位<br>void IIC_check_ack();&#x2F;&#x2F;单片机检查应答位<br>void IIC_write_byte(uchar);&#x2F;&#x2F;发送一字节数据<br>uchar IIC_read_byte();&#x2F;&#x2F;接收一字节数据<br>void nop();&#x2F;&#x2F;5us空操作延迟<br>&#x2F;**********************************&#x2F;<br>&#x2F;<strong><strong><strong><strong><strong>ds1307读写函数</strong></strong></strong></strong></strong>*********&#x2F;<br>void ds1307_write_date(uchar ,uchar ,uchar);&#x2F;&#x2F;向指定器件写一字节数据<br>                                    &#x2F;&#x2F;参数1器件地址，参数2要存的数据存放位置8位地址<br>                                    &#x2F;&#x2F;参数3要写的数据</p><p>uchar ds1307_read_date(uchar ,uchar );&#x2F;&#x2F;从指定器件读一字节数据，<br>                                &#x2F;&#x2F;参数1被通信器件地址，参数2要读的数据存放位置8位地址<br>                                &#x2F;&#x2F;函数返回读取的数据。<br>void delay(uint);&#x2F;&#x2F;基数1ms延迟程序<br>&#x2F;***********************************&#x2F;</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong>LCD操作函数</strong></strong></strong></strong></strong></strong></strong>************&#x2F;</p><p>uchar hour,minute,second,k0_num;&#x2F;&#x2F;时分秒变量，菜单键k0第几次按下计数，ds1307跟新标志<br>&#x2F;&#x2F;时钟初显示<br>uchar code table1[]&#x3D;”2022-06-23 Thu”;<br>uchar code table2[]&#x3D;”    16:31:15 “;&#x2F;&#x2F;2022年6月23日16:31:15</p><p>void lcd_write_com(uchar);&#x2F;&#x2F;向液晶显示器写指令设置其显示的格式<br>void lcd_write_date(uchar);&#x2F;&#x2F;向液晶显示器写显示的数据</p><p>&#x2F;**********************************************&#x2F;</p><p>&#x2F;<strong><strong><strong><strong><strong><strong><strong>时钟函数</strong></strong></strong></strong></strong></strong></strong>*****&#x2F;<br>void lcd_write_second(uchar);&#x2F;&#x2F;向lcd写秒<br>void lcd_write_minute(uchar);&#x2F;&#x2F;向lcd写分<br>void lcd_write_hour(uchar);&#x2F;&#x2F;向lcd写时<br>void run_time();&#x2F;&#x2F;时钟走动显示<br>void keyscan();&#x2F;&#x2F;菜单键扫描<br>&#x2F;****************************************&#x2F;</p><p>&#x2F;<em><strong><strong><strong><strong>十进值与BCD码之间互换</strong></strong></strong></strong></em><em>&#x2F;<br>uchar b_second,b_minute,b_hour;<br>uchar dectobcd(uchar);&#x2F;&#x2F;十进值转bcd码<br>uchar bcdtodec(uchar);&#x2F;&#x2F;bcd码转十进值<br>&#x2F;</em>***************************************&#x2F;</p><p>void main()<br>{<br>    init();<br>    while(1)<br>    {<br>        keyscan();<br>    }<br>}</p><p>void nop()<br>{<br>    <em>nop</em>();<em>nop</em>();<em>nop</em>();<br>    <em>nop</em>();<em>nop</em>();<em>nop</em>();<br>}</p><p>void init()<br>{<br>    uchar i;<br>    &#x2F;&#x2F;将数据线和时钟线拉高，处于备用状态即非忙<br>    sda&#x3D;1;<br>    nop();<br>    scl&#x3D;1;<br>    nop();</p><pre><code>//初始化写入LCD的时分秒    second=16;    minute=23;    hour=16;//初始化ds1307ds1307_write_date(0xd0,0x07,0x10);//初始化1307的控制字，使其SOUT引脚输出1Hz的方波。//初始化1307的时间ds1307_write_date(0xd0,6,0x14); ds1307_write_date(0xd0,5,0x06);   ds1307_write_date(0xd0,4,0x09);ds1307_write_date(0xd0,3,0x00);ds1307_write_date(0xd0,2,0x23);ds1307_write_date(0xd0,1,0x59);ds1307_write_date(0xd0,0,0x55);//初始化液晶显示器lcd_write_com(0x38);//设置16*2行，5*7点阵，8位数据接口lcd_write_com(0x06);//写字符指针和光标自动向右移动lcd_write_com(0x0c);//开显示，不显示光标，光标不闪烁lcd_write_com(0x01);//显示清屏for(i=0;i&lt;15;i++)&#123;    lcd_write_date(table1[i]);&#125;lcd_write_com(0x80+0x40);for(i=0;i&lt;10;i++)&#123;    lcd_write_date(table2[i]);&#125;</code></pre><p>&#x2F;&#x2F;开启外部中断0<br>    EA&#x3D;1;<br>    EX0&#x3D;1;<br>    IT0&#x3D;1;<br>}<br>void IIC_start()<br>{<br>    &#x2F;&#x2F;在时钟信号有效scl&#x3D;1时，数据线负跳变<br>    sda&#x3D;1;<br>    nop();<br>    scl&#x3D;1;<br>    nop();<br>    sda&#x3D;0;<br>    nop();<br>    scl&#x3D;0;&#x2F;&#x2F;拉低为下个时钟数据作准备<br>    nop();<br>}<br>void IIC_stop()<br>{<br>    &#x2F;&#x2F;在时钟信号有效scl&#x3D;1时，数据线正跳变，释放总线,使总线处于备用状态即非忙<br>    sda&#x3D;0;<br>    nop();<br>    scl&#x3D;1;<br>    nop();<br>    sda&#x3D;1;<br>    nop();<br>    nop();<br>    nop();<br>}<br>void IIC_un_ack()<br>{<br>    &#x2F;&#x2F;时钟信号有效时，sda给1，给出非应答<br>    sda&#x3D;1;<br>    nop();<br>    scl&#x3D;1;<br>    nop();<br>    scl&#x3D;0;&#x2F;&#x2F;拉低为下个时钟数据作准备<br>    nop();<br>}<br>&#x2F;*<br>void IIC_ack()<br>{<br>    &#x2F;&#x2F;时钟信号有效时，sda给0，给出应答<br>    sda&#x3D;0;<br>    nop();<br>    scl&#x3D;1;<br>    nop();<br>    scl&#x3D;0;&#x2F;&#x2F;拉低为下个时钟数据作准备<br>    nop();<br>}<br>*&#x2F;<br>void IIC_check_ack()<br>{<br>    &#x2F;&#x2F;uchar i;<br>    &#x2F;&#x2F;时钟信号有效时，检测数据信号sda是否为0，给0说明有应答信号<br>    scl&#x3D;1;<br>    &#x2F;&#x2F;while((sda&#x3D;&#x3D;1)&amp;&amp;(i&lt;255)) i++;<br>    nop();<br>    scl&#x3D;0;&#x2F;&#x2F;拉低为下个时钟数据作准备<br>    nop();<br>}<br>uchar IIC_read_byte( )<br>{<br>    uchar i,temp;&#x2F;&#x2F;temp用于存放从数据线读到的数据</p><pre><code>for(i=0;i&lt;8;i++)//从数据线读取一个字节（8位）&#123;    scl=1;    nop();    temp=(temp&lt;&lt;1)|sda;//temp左移，腾出第0位，然后将数据线上的一位数用或                             //运算存放到temp的第0位    scl=0;//拉低为下个时钟数据作准备    nop();&#125;return temp;</code></pre><p>}</p><p>void IIC_write_byte(uchar byte)<br>{<br>    uchar i;<br>    for(i&#x3D;0;i&lt;8;i++)&#x2F;&#x2F;向数据线写一个字节（8位）<br>    {<br>        byte&#x3D;byte&lt;&lt;1;&#x2F;&#x2F;左移位，将byte第7位移到PSW中的进位标志位CY中<br>        sda&#x3D;CY;<br>        nop();<br>        scl&#x3D;1;<br>        nop();<br>        scl&#x3D;0;&#x2F;&#x2F;拉低为下个时钟数据作准备<br>        nop();<br>    }<br>    sda&#x3D;1;&#x2F;&#x2F;释放总线，准备接收被控设备应答信号<br>    nop();<br>}</p><p>void ds1307_write_date(uchar d_address,uchar r_address,uchar date)<br>{</p><pre><code>IIC_start();IIC_write_byte(d_address &amp; (~0x01));//写器件地址,方向是写,所以或上0x00IIC_check_ack();//等待应答IIC_write_byte(r_address);//写存储器数据存放的8位地址IIC_check_ack();//等待应答IIC_write_byte(date);//写一字节数据IIC_check_ack();//等待应答IIC_stop();</code></pre><p>}</p><p>uchar ds1307_read_date(uchar d_address,uchar r_address)<br>{<br>    uchar r;<br>    IIC_start();<br>    IIC_write_byte(d_address &amp; (~0x01));&#x2F;&#x2F;写器件地址，方向是写<br>    IIC_check_ack();&#x2F;&#x2F;等待应答<br>    IIC_write_byte(r_address);&#x2F;&#x2F;写存储器数据存放的8位地址<br>    IIC_check_ack();&#x2F;&#x2F;等待应答</p><pre><code>//换方向IIC_start();IIC_write_byte(d_address|0x01);//写器件地址，方向是读，所以或上1IIC_check_ack();r=IIC_read_byte();//读取一个字节数据IIC_un_ack();IIC_stop();return r;//将读到的数据返回</code></pre><p>}<br>void delay(uint z)&#x2F;&#x2F;晶振频率12MHz时，z&#x3D;1时延迟1ms<br>{<br>    uint a,b;<br>    for(a&#x3D;z;a&gt;0;a–)<br>        for(b&#x3D;110;b&gt;0;b–);<br>}</p><p>void lcd_write_com(uchar com)&#x2F;&#x2F;lcd写指令函数定义<br>{<br>    lcd_rs&#x3D;0;<br>    P0&#x3D;com;<br>    delay(1);<br>    lcd_e&#x3D;1;<br>    lcd_e&#x3D;0;<br>    delay(2);<br>}<br>void lcd_write_date(uchar date)&#x2F;&#x2F;lcd写数据函数定义<br>{<br>    lcd_rs&#x3D;1;<br>    P0&#x3D;date;<br>    delay(1);<br>    lcd_e&#x3D;1;<br>    lcd_e&#x3D;0;<br>    delay(2);<br>}</p><p>void lcd_write_second(uchar sec)&#x2F;&#x2F;向lcd写秒<br>{<br>    uchar h,l;<br>    h&#x3D;sec&#x2F;10;<br>    l&#x3D;sec%10;<br>    lcd_write_com(0x80+0x40+10);<br>    lcd_write_date(0x30+h);<br>    lcd_write_date(0x30+l);<br>}<br>void lcd_write_minute(uchar min)&#x2F;&#x2F;向lcd写分<br>{<br>    uchar h,l;<br>    h&#x3D;min&#x2F;10;<br>    l&#x3D;min%10;<br>    lcd_write_com(0x80+0x40+7);<br>    lcd_write_date(0x30+h);<br>    lcd_write_date(0x30+l);<br>}<br>void lcd_write_hour(uchar hou)&#x2F;&#x2F;向lcd写时<br>{<br>    uchar h,l;<br>    h&#x3D;hou&#x2F;10;<br>    l&#x3D;hou%10;<br>    lcd_write_com(0x80+0x40+4);<br>    lcd_write_date(0x30+h);<br>    lcd_write_date(0x30+l);<br>}</p><p>void inter0()interrupt 0<br>{<br>    run_time();<br>}</p><p>void run_time()&#x2F;&#x2F;时钟走动函数定义<br>{<br>    &#x2F;&#x2F;从1307中读出时间<br>    b_second&#x3D;ds1307_read_date(0xd0,0);&#x2F;&#x2F;返回函数r值秒<br>    b_minute&#x3D;ds1307_read_date(0xd0,1);<br>    b_hour&#x3D;ds1307_read_date(0xd0,2);<br>    &#x2F;&#x2F;将读出的时间转换成十进值<br>    second&#x3D;bcdtodec(b_second);<br>    minute&#x3D;bcdtodec(b_minute);<br>    hour&#x3D;bcdtodec(b_hour);<br>    &#x2F;&#x2F;更新lcd显示时间<br>    lcd_write_second(second);<br>    lcd_write_minute(minute);<br>    lcd_write_hour(hour);<br>}</p><p>uchar dectobcd(uchar dec)&#x2F;&#x2F;十进值到BCD码<br>{<br>    uchar x,y;<br>    x&#x3D;dec&#x2F;10;&#x2F;&#x2F;得到bcd的十位数<br>    y&#x3D;dec%10;&#x2F;&#x2F;得到bcd的个位数<br>    y&#x3D;(x&lt;&lt;4)|y;<br>    return y;<br>}<br>uchar bcdtodec(uchar bcd)&#x2F;&#x2F;bcd码转十进值<br>{<br>    uchar x,y;<br>    y&#x3D;bcd&#x2F;16;&#x2F;&#x2F;得到十进制的十位数<br>    x&#x3D;bcd%16;&#x2F;&#x2F;得到十进制的个位数<br>    y&#x3D;y*10+x;<br>    return y;<br>}</p><p>void keyscan()&#x2F;&#x2F;菜单键按下扫描函数定义<br>{<br>    k0&#x3D;1;<br>    k1&#x3D;1;<br>    k2&#x3D;1;<br>    &#x2F;&#x2F;判断菜单键k0是否按下<br>    if(k0&#x3D;&#x3D;0)<br>    {<br>        delay(5);<br>        if(k0&#x3D;&#x3D;0)<br>        {<br>            while(!k0);&#x2F;&#x2F;松手检测<br>            k0_num++;&#x2F;&#x2F;记录菜单键k0是第几次按下，而判断是调节秒、分还是时。<br>            if(k0_num&#x3D;&#x3D;1)&#x2F;&#x2F;指示调节秒<br>            {<br>                EX0&#x3D;0;&#x2F;&#x2F;关闭外部中断0，使时间走动停止，准备调时间<br>                ds1307_write_date(0xd0,0,0x80|b_second);<br>                lcd_write_com(0x80+0x40+11);&#x2F;&#x2F;数据指针和光标移动秒出<br>                lcd_write_com(0x0f);&#x2F;&#x2F;使光标显示，并光标处字符格符闪烁，用来提示用户此时可以调节<br>                                     &#x2F;&#x2F;什么？是秒，是分还是时。<br>            }<br>            if(k0_num&#x3D;&#x3D;2)&#x2F;&#x2F;指示调节分<br>            {<br>                lcd_write_com(0x80+0x40+8);&#x2F;&#x2F;数据指针和光标移动分出<br>            }<br>            if(k0_num&#x3D;&#x3D;3)&#x2F;&#x2F;指示调节时<br>            {<br>                lcd_write_com(0x80+0x40+5);&#x2F;&#x2F;数据指针和光标移动时出<br>            }<br>            if(k0_num&#x3D;&#x3D;4)&#x2F;&#x2F;退出时间调节菜单<br>            {<br>                k0_num&#x3D;0;&#x2F;&#x2F;菜单键k0按下清零<br>                lcd_write_com(0x0c);&#x2F;&#x2F;恢复到时钟走动状态，即光标不显示，不闪烁<br>                &#x2F;&#x2F;将所调的时间转换成bcd码<br>                b_second&#x3D;dectobcd(second);<br>                b_minute&#x3D;dectobcd(minute);<br>                b_hour&#x3D;dectobcd(hour);<br>                &#x2F;&#x2F;将所调的时间向时钟写入<br>                ds1307_write_date(0xd0,2,b_hour);<br>                ds1307_write_date(0xd0,1,b_minute);<br>                ds1307_write_date(0xd0,0,b_second);</p><pre><code>            EX0=1;//开外部中断0，时间开始继续走动        &#125;            &#125;&#125;//判断是否按下过时间调节菜单键k0,而处于需要调节时间状态if(k0_num)&#123;    //判断是否是上调键k1按下    if(k1==0)    &#123;        delay(5);        if(k1==0)        &#123;            while(!k1);//松手检测            if(k0_num==1)//上调秒            &#123;                second++;                if(second==60)                    second=0;                lcd_write_second(second);//向lcd写入被修改的时间                lcd_write_com(0x80+0x40+11);//光标位置重定位到所要调的时间处                            &#125;            if(k0_num==2)//上调分            &#123;                minute++;                if(minute==60)                    minute=0;                lcd_write_minute(minute);                lcd_write_com(0x80+0x40+8);            &#125;            if(k0_num==3)//上调时            &#123;                hour++;                if(hour==24)                    hour=0;                lcd_write_hour(hour);                lcd_write_com(0x80+0x40+5);            &#125;        &#125;    &#125;    //判断是否是下调键k2按下    if(k2==0)    &#123;        delay(5);        if(k2==0)        &#123;            while(!k2);            if(k0_num==1)//下调节秒            &#123;                second--;                if(second==255)                    second=59;                lcd_write_second(second);                lcd_write_com(0x80+0x40+11);            &#125;            if(k0_num==2)//下调节分            &#123;                minute--;                if(minute==255)                    minute=59;                lcd_write_minute(minute);                lcd_write_com(0x80+0x40+8);            &#125;            if(k0_num==3)//下调节时            &#123;                hour--;                if(hour==255)                    hour=23;                lcd_write_hour(hour);                lcd_write_com(0x80+0x40+5);            &#125;        &#125;    &#125;&#125;</code></pre><p>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/15j7vId51clOJlcNxIMkcww </span><br><span class="line">提取码：8z3w</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/15j7vId51clOJlcNxIMkcww  提取码：8z3w</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】4x4矩阵键盘中断方式扫描 +数码管显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4x4%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%89%AB%E6%8F%8F-%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F4x4%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%89%AB%E6%8F%8F-%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】4x4矩阵键盘中断方式扫描-数码管显示"><a href="#【Proteus仿真】4x4矩阵键盘中断方式扫描-数码管显示" class="headerlink" title="【Proteus仿真】4x4矩阵键盘中断方式扫描 +数码管显示"></a>【Proteus仿真】4x4矩阵键盘中断方式扫描 +数码管显示</h1><h3 id="【Proteus仿真】4x4矩阵键盘中断扫描-数码管显示"><a href="#【Proteus仿真】4x4矩阵键盘中断扫描-数码管显示" class="headerlink" title="【Proteus仿真】4x4矩阵键盘中断扫描 +数码管显示"></a>【Proteus仿真】4x4矩阵键盘中断扫描 +数码管显示</h3><ul><li>Proteus仿真演示</li><li>相关篇《【Proteus仿真】键盘矩阵扫描+LCD128x64显示》</li><li>《【Proteus仿真】Arduino UNO+数码管显示4x4键盘矩阵按键》</li><li>《51单片机 数码管显示(0 -F)+4×4键盘矩阵按键输入》</li><li>《51单片机8x9矩阵键盘+数码管+74HC595+Proteus仿真》</li><li>《51单片机8x8矩阵键盘+数码管+74HC595+Proteus仿真》</li></ul><p>Proteus仿真演示</p><p><img src="https://img-blog.csdnimg.cn/7a333bec53ef4e39b22053f43b959fed.gif#pic_center" alt="在这里插入图片描述"></p><p>相关篇《【Proteus仿真】键盘矩阵扫描+LCD128x64显示》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/125348185">【Proteus仿真】键盘矩阵扫描+LCD128x64显示</a></p><p>《【Proteus仿真】Arduino UNO+数码管显示4x4键盘矩阵按键》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/125452871">【Proteus仿真】Arduino UNO+数码管显示4x4键盘矩阵按键</a></p><p>《51单片机 数码管显示(0 -F)+4×4键盘矩阵按键输入》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121007364">51单片机 数码管显示(0 -F)+4×4键盘矩阵按键输入</a></p><p>《51单片机8x9矩阵键盘+数码管+74HC595+Proteus仿真》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120009976">51单片机8x9矩阵键盘+数码管+74HC595+Proteus仿真</a></p><p>《51单片机8x8矩阵键盘+数码管+74HC595+Proteus仿真》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/120007533">51单片机8x8矩阵键盘+数码管+74HC595+Proteus仿真</a></p><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>中断方式可以有效提高cpu工作效率，在有按键动作时才进行扫描，平时不进行扫描工作。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line">/*-----------------------------------------------</span><br><span class="line">  名称：矩阵键盘依次输入控制 使用行列逐级扫描 中断方式</span><br><span class="line"></span><br><span class="line">  内容：如计算器输入数据形式相同 从右至左 使用行列扫描方法</span><br><span class="line">        中断方式可以有效提供cpu工作效率，在有按键动作时才扫描，平时不进行扫描工作</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义</span><br><span class="line">#include&lt;intrins.h&gt; </span><br><span class="line"></span><br><span class="line">#define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换</span><br><span class="line">#define KeyPort  P1</span><br><span class="line">#define MAIN_Fosc12000000uL//定义主时钟</span><br><span class="line">unsigned char T0RH = 0; //T0 重载值的高字节</span><br><span class="line">unsigned char T0RL = 0; //T0 重载值的低字节</span><br><span class="line"></span><br><span class="line">sbit LATCH1=P2^2;//定义锁存使能端口 段锁存</span><br><span class="line">sbit LATCH2=P2^3;//                 位锁存</span><br><span class="line">sbit P32 =P3^2;</span><br><span class="line">bit KeyPressFlag;//定义按键标志位</span><br><span class="line">unsigned char keycode;</span><br><span class="line">unsigned char code DuanMa[]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;// 显示段码值0~9</span><br><span class="line"></span><br><span class="line">void DelayMs(unsigned char t); //ms级延时</span><br><span class="line">void Display();//数码管显示函数</span><br><span class="line">void KeyScan(void);//键盘扫描</span><br><span class="line">unsigned char KeyPro(void);</span><br><span class="line">void Init_Timer0(void);//定时器初始化</span><br><span class="line">void Init_INT0(void);  //外部中断0初始化和</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    主函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void main (void)</span><br><span class="line">&#123;</span><br><span class="line">KeyPort =0xf0;</span><br><span class="line">Init_Timer0();</span><br><span class="line">Init_INT0();</span><br><span class="line">while (1) KeyPort = 0xf0;       //主循环</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line"> mS延时函数</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void delay(unsigned int xms)// 延迟函数</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i,j;</span><br><span class="line">for(i=xms;i&gt;0;i--)</span><br><span class="line">for(j=112;j&gt;0;j--);</span><br><span class="line">&#125;</span><br><span class="line">/*数码管显示函数*/</span><br><span class="line">void Display()</span><br><span class="line">&#123;</span><br><span class="line">      static unsigned char k=0;</span><br><span class="line">   DataPort=0x00;   //清空数据，防止有交替重影</span><br><span class="line">       LATCH1=0;</span><br><span class="line"> LATCH2=1;</span><br><span class="line">       DataPort=DuanMa[keycode/10]; //取位码 </span><br><span class="line">delay(5);</span><br><span class="line">LATCH1=1;//关掉上面显示的十位显示</span><br><span class="line">       LATCH2=1;     //位锁存</span><br><span class="line">       LATCH2=0;//打开个位显示</span><br><span class="line"></span><br><span class="line">   DataPort=0x00;   //清空数据，防止有交替重影</span><br><span class="line">       DataPort=DuanMa[keycode%10];  //取显示数据，段码</span><br><span class="line">delay(5);</span><br><span class="line">k = k&lt;2 ? k+1 : 0;</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                    定时器初始化子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_Timer0(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long tmp; //临时变量</span><br><span class="line"> TMOD |= 0x01;  //使用模式1，16位定时器，使用&quot;|&quot;符号可以在使用多个定时器时不受影响     </span><br><span class="line">    tmp = MAIN_Fosc / 12; //定时器计数频率</span><br><span class="line">    tmp = (tmp * 50) / 1000; //计算所需的计数值50ms</span><br><span class="line">    tmp = 65536 - tmp; //计算定时器重载值</span><br><span class="line">    tmp = tmp + 12; //补偿中断响应延时造成的误差</span><br><span class="line">    T0RH = (unsigned char)(tmp&gt;&gt;8); //定时器重载值拆分为高低字节</span><br><span class="line">    T0RL = (unsigned char)tmp;</span><br><span class="line">    TMOD &amp;= 0xF0; //清零 T0 的控制位</span><br><span class="line">    TMOD |= 0x01; //配置 T0 为模式 1</span><br><span class="line">    TH0 = T0RH; //加载 T0 重载值</span><br><span class="line">    TL0 = T0RL;</span><br><span class="line"></span><br><span class="line"> EA=1;            //总中断打开</span><br><span class="line"> ET0=1;           //定时器中断打开</span><br><span class="line"> TR0=1;           //定时器开关打开</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 定时器中断子程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Timer0_isr(void) interrupt 1 </span><br><span class="line">&#123;</span><br><span class="line"> TH0=(65536-50000)/256;  //重新赋值 50ms</span><br><span class="line"> TL0=(65536-50000)%256;</span><br><span class="line"> Display();       // 调用数码管扫描</span><br><span class="line">&#125;</span><br><span class="line">/*------------------------------------------------</span><br><span class="line">按键扫描函数，返回扫描键值</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void KeyScan(void)  //键盘扫描函数，使用行列逐级扫描法</span><br><span class="line">&#123;</span><br><span class="line">unsigned char t,key;</span><br><span class="line">/**********************第一行矩阵*******************/</span><br><span class="line"></span><br><span class="line">KeyPort = 0xfe;//1111 1110 让P3.0口输出低</span><br><span class="line">t = KeyPort;</span><br><span class="line">t=t&amp;0xf0;// 1111 0000 屏蔽后四位</span><br><span class="line"></span><br><span class="line">if(t != 0xf0) // 说明按键有被按住</span><br><span class="line">&#123;</span><br><span class="line">delay(10);</span><br><span class="line">t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">if( t != 0xf0)</span><br><span class="line">&#123;</span><br><span class="line">t = KeyPort;</span><br><span class="line">switch(t)</span><br><span class="line">&#123;</span><br><span class="line">case 0xee:</span><br><span class="line">key = 1;   // 此时为 1110 1110  S1按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xde:</span><br><span class="line">key = 2;   // 此时为 1101 1110  S2按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xbe:</span><br><span class="line">key = 3;   // 此时为 1011 1110  S3按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0x7e:</span><br><span class="line">key = 4;   // 此时为 0111 1110  S4按键被按下</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">// 判断按键是否被松开</span><br><span class="line">while( t != 0xf0)&#123;</span><br><span class="line"> t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">&#125;</span><br><span class="line">keycode = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********************第二行矩阵*******************/</span><br><span class="line"></span><br><span class="line">KeyPort = 0xfd;//1111 1101 让P3.1口输出低</span><br><span class="line">t = KeyPort;</span><br><span class="line">t=t&amp;0xf0;// 1111 0000 屏蔽后四位</span><br><span class="line">if(t != 0xf0) // 说明按键有被按住</span><br><span class="line">&#123;</span><br><span class="line">delay(10);</span><br><span class="line">t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">if( t != 0xf0)</span><br><span class="line">&#123;</span><br><span class="line">t = KeyPort;</span><br><span class="line">switch(t)</span><br><span class="line">&#123;</span><br><span class="line">case 0xed:</span><br><span class="line">key = 5;   // 此时为 1110 1101  S5按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xdd:</span><br><span class="line">key = 6;   // 此时为 1101 1101  S6按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xbd:</span><br><span class="line">key = 7;   // 此时为 1011 1101  S7按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0x7d:</span><br><span class="line">key = 8;   // 此时为 0111 1101  S8按键被按下</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 判断按键是否被松开</span><br><span class="line">while( t != 0xf0)&#123;</span><br><span class="line"> t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">&#125;</span><br><span class="line">keycode = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********************第三行矩阵*******************/</span><br><span class="line"></span><br><span class="line">KeyPort = 0xfb;//1111 1011 让P3.2口输出低</span><br><span class="line">t = KeyPort;</span><br><span class="line">t=t&amp;0xf0;// 1111 0000 屏蔽后四位</span><br><span class="line"></span><br><span class="line">if(t != 0xf0) // 说明按键有被按住</span><br><span class="line">&#123;</span><br><span class="line">delay(10);</span><br><span class="line">t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">if( t != 0xf0)</span><br><span class="line">&#123;</span><br><span class="line">t = KeyPort;</span><br><span class="line">switch(t)</span><br><span class="line">&#123;</span><br><span class="line">case 0xeb:</span><br><span class="line">key = 9;   // 此时为 1110 1011  S9按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xdb:</span><br><span class="line">key = 10;   // 此时为 1101 1011  S10按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xbb:</span><br><span class="line">key = 11;   // 此时为 1011 1011 S11按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0x7b:</span><br><span class="line">key = 12;   // 此时为 0111 1011  S12按键被按下</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">// 判断按键是否被松开</span><br><span class="line">while( t != 0xf0)&#123;</span><br><span class="line"> t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">&#125;</span><br><span class="line">keycode = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********************第四行矩阵*******************/</span><br><span class="line"></span><br><span class="line">KeyPort = 0xf7;//1111 0111 让P1.3口输出低</span><br><span class="line">t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;// 1111 0000 屏蔽后四位</span><br><span class="line">if(t != 0xf0) // 说明按键有被按住</span><br><span class="line">&#123;</span><br><span class="line">delay(10);</span><br><span class="line">t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">if( t != 0xf0)</span><br><span class="line">&#123;</span><br><span class="line">t = KeyPort;</span><br><span class="line">switch(t)</span><br><span class="line">&#123;</span><br><span class="line">case 0xe7:</span><br><span class="line">key = 13;   // 此时为 1110 0111  S13按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xd7:</span><br><span class="line">key = 14;   // 此时为 1101 0111  S14按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0xb7:</span><br><span class="line">key = 15;   // 此时为 1011 0111  S15按键被按下</span><br><span class="line">break;</span><br><span class="line">case 0x77:</span><br><span class="line">key = 16;   // 此时为 0111 0111  S16按键被按下</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">// 判断按键是否被松开</span><br><span class="line">while( t != 0xf0)&#123;</span><br><span class="line"> t = KeyPort;</span><br><span class="line">t = t&amp;0xf0;</span><br><span class="line">&#125;</span><br><span class="line">keycode = key;//把按键的值发给数组，让其对应的数字打印再数码管上</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">           外部中断0初始化</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void Init_INT0(void)</span><br><span class="line">&#123;</span><br><span class="line">  EA=1;          //全局中断开</span><br><span class="line">  EX0=1;         //外部中断0开</span><br><span class="line">  IT0=1;         //边沿触发</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*------------------------------------------------</span><br><span class="line">                 外部中断0程序</span><br><span class="line">------------------------------------------------*/</span><br><span class="line">void int0() interrupt 0 //在中断服务函数中进行键盘扫描</span><br><span class="line">&#123;</span><br><span class="line"> KeyScan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*———————————————–<br>  名称：矩阵键盘依次输入控制 使用行列逐级扫描 中断方式</p><p>  内容：如计算器输入数据形式相同 从右至左 使用行列扫描方法<br>        中断方式可以有效提供cpu工作效率，在有按键动作时才扫描，平时不进行扫描工作<br>————————————————*&#x2F;<br>#include&lt;reg52.h&gt; &#x2F;&#x2F;包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义<br>#include&lt;intrins.h&gt; </p><p>#define DataPort P0 &#x2F;&#x2F;定义数据端口 程序中遇到DataPort 则用P0 替换<br>#define KeyPort  P1<br>#define MAIN_Fosc12000000uL&#x2F;&#x2F;定义主时钟<br>unsigned char T0RH &#x3D; 0; &#x2F;&#x2F;T0 重载值的高字节<br>unsigned char T0RL &#x3D; 0; &#x2F;&#x2F;T0 重载值的低字节</p><p>sbit LATCH1&#x3D;P2^2;&#x2F;&#x2F;定义锁存使能端口 段锁存<br>sbit LATCH2&#x3D;P2^3;&#x2F;&#x2F;                 位锁存<br>sbit P32 &#x3D;P3^2;<br>bit KeyPressFlag;&#x2F;&#x2F;定义按键标志位<br>unsigned char keycode;<br>unsigned char code DuanMa[]&#x3D;{0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};&#x2F;&#x2F; 显示段码值0~9</p><p>void DelayMs(unsigned char t); &#x2F;&#x2F;ms级延时<br>void Display();&#x2F;&#x2F;数码管显示函数<br>void KeyScan(void);&#x2F;&#x2F;键盘扫描<br>unsigned char KeyPro(void);<br>void Init_Timer0(void);&#x2F;&#x2F;定时器初始化<br>void Init_INT0(void);  &#x2F;&#x2F;外部中断0初始化和<br>&#x2F;<em>————————————————<br>                    主函数<br>————————————————</em>&#x2F;<br>void main (void)<br>{<br>    KeyPort &#x3D;0xf0;<br>    Init_Timer0();<br>    Init_INT0();<br>while (1) KeyPort &#x3D; 0xf0;       &#x2F;&#x2F;主循环<br>}</p><p>&#x2F;<em>————————————————<br> mS延时函数<br>————————————————</em>&#x2F;<br>void delay(unsigned int xms)&#x2F;&#x2F; 延迟函数<br>{<br>    unsigned int i,j;<br>    for(i&#x3D;xms;i&gt;0;i–)<br>        for(j&#x3D;112;j&gt;0;j–);<br>}<br>&#x2F;<em>数码管显示函数</em>&#x2F;<br>void Display()<br>{<br>      static unsigned char k&#x3D;0;<br>       DataPort&#x3D;0x00;   &#x2F;&#x2F;清空数据，防止有交替重影<br>       LATCH1&#x3D;0;<br>             LATCH2&#x3D;1;<br>       DataPort&#x3D;DuanMa[keycode&#x2F;10]; &#x2F;&#x2F;取位码<br>        delay(5);<br>        LATCH1&#x3D;1;&#x2F;&#x2F;关掉上面显示的十位显示<br>       LATCH2&#x3D;1;     &#x2F;&#x2F;位锁存<br>       LATCH2&#x3D;0;&#x2F;&#x2F;打开个位显示</p><pre><code>   DataPort=0x00;   //清空数据，防止有交替重影   DataPort=DuanMa[keycode%10];  //取显示数据，段码        delay(5);    k = k&lt;2 ? k+1 : 0;</code></pre><p>}<br>&#x2F;<em>————————————————<br>                    定时器初始化子程序<br>————————————————</em>&#x2F;<br>void Init_Timer0(void)<br>{<br>    unsigned long tmp; &#x2F;&#x2F;临时变量<br> TMOD |&#x3D; 0x01;  &#x2F;&#x2F;使用模式1，16位定时器，使用”|”符号可以在使用多个定时器时不受影响<br>    tmp &#x3D; MAIN_Fosc &#x2F; 12; &#x2F;&#x2F;定时器计数频率<br>    tmp &#x3D; (tmp * 50) &#x2F; 1000; &#x2F;&#x2F;计算所需的计数值50ms<br>    tmp &#x3D; 65536 - tmp; &#x2F;&#x2F;计算定时器重载值<br>    tmp &#x3D; tmp + 12; &#x2F;&#x2F;补偿中断响应延时造成的误差<br>    T0RH &#x3D; (unsigned char)(tmp&gt;&gt;8); &#x2F;&#x2F;定时器重载值拆分为高低字节<br>    T0RL &#x3D; (unsigned char)tmp;<br>    TMOD &amp;&#x3D; 0xF0; &#x2F;&#x2F;清零 T0 的控制位<br>    TMOD |&#x3D; 0x01; &#x2F;&#x2F;配置 T0 为模式 1<br>    TH0 &#x3D; T0RH; &#x2F;&#x2F;加载 T0 重载值<br>    TL0 &#x3D; T0RL;</p><p> EA&#x3D;1;            &#x2F;&#x2F;总中断打开<br> ET0&#x3D;1;           &#x2F;&#x2F;定时器中断打开<br> TR0&#x3D;1;           &#x2F;&#x2F;定时器开关打开<br>}<br>&#x2F;<em>————————————————<br>                 定时器中断子程序<br>————————————————</em>&#x2F;<br>void Timer0_isr(void) interrupt 1<br>{<br> TH0&#x3D;(65536-50000)&#x2F;256;  &#x2F;&#x2F;重新赋值 50ms<br> TL0&#x3D;(65536-50000)%256;<br> Display();       &#x2F;&#x2F; 调用数码管扫描<br>}<br>&#x2F;<em>————————————————<br>按键扫描函数，返回扫描键值<br>————————————————</em>&#x2F;<br>void KeyScan(void)  &#x2F;&#x2F;键盘扫描函数，使用行列逐级扫描法<br>{<br>        unsigned char t,key;<br>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong>第一行矩阵</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;</p><pre><code>KeyPort = 0xfe;//1111 1110 让P3.0口输出低t = KeyPort;t=t&amp;0xf0;// 1111 0000 屏蔽后四位if(t != 0xf0) // 说明按键有被按住&#123;    delay(10);    t = KeyPort;    t = t&amp;0xf0;    if( t != 0xf0)    &#123;        t = KeyPort;        switch(t)        &#123;            case 0xee:                key = 1;   // 此时为 1110 1110  S1按键被按下                break;            case 0xde:                key = 2;   // 此时为 1101 1110  S2按键被按下                break;            case 0xbe:                key = 3;   // 此时为 1011 1110  S3按键被按下                break;            case 0x7e:                key = 4;   // 此时为 0111 1110  S4按键被按下                break;        &#125;        // 判断按键是否被松开        while( t != 0xf0)&#123;         t = KeyPort;            t = t&amp;0xf0;        &#125;        keycode = key;    &#125;&#125;</code></pre><p>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong>第二行矩阵</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;</p><pre><code>KeyPort = 0xfd;//1111 1101 让P3.1口输出低t = KeyPort;t=t&amp;0xf0;// 1111 0000 屏蔽后四位if(t != 0xf0) // 说明按键有被按住&#123;    delay(10);    t = KeyPort;    t = t&amp;0xf0;    if( t != 0xf0)    &#123;        t = KeyPort;        switch(t)        &#123;            case 0xed:                key = 5;   // 此时为 1110 1101  S5按键被按下                break;            case 0xdd:                key = 6;   // 此时为 1101 1101  S6按键被按下                break;            case 0xbd:                key = 7;   // 此时为 1011 1101  S7按键被按下                break;            case 0x7d:                key = 8;   // 此时为 0111 1101  S8按键被按下                break;            &#125;        // 判断按键是否被松开        while( t != 0xf0)&#123;         t = KeyPort;            t = t&amp;0xf0;        &#125;                    keycode = key;    &#125;&#125;</code></pre><p>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong>第三行矩阵</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;</p><pre><code>KeyPort = 0xfb;//1111 1011 让P3.2口输出低t = KeyPort;t=t&amp;0xf0;// 1111 0000 屏蔽后四位if(t != 0xf0) // 说明按键有被按住&#123;    delay(10);    t = KeyPort;    t = t&amp;0xf0;    if( t != 0xf0)    &#123;        t = KeyPort;        switch(t)        &#123;            case 0xeb:                key = 9;   // 此时为 1110 1011  S9按键被按下                break;            case 0xdb:                key = 10;   // 此时为 1101 1011  S10按键被按下                break;            case 0xbb:                key = 11;   // 此时为 1011 1011 S11按键被按下                break;            case 0x7b:                key = 12;   // 此时为 0111 1011  S12按键被按下                break;        &#125;        // 判断按键是否被松开        while( t != 0xf0)&#123;         t = KeyPort;            t = t&amp;0xf0;        &#125;        keycode = key;    &#125;&#125;</code></pre><p>&#x2F;***<em><strong><strong><strong><strong><strong><strong><strong><strong><strong>第四行矩阵</strong></strong></strong></strong></strong></strong></strong></strong></strong></em>&#x2F;</p><pre><code>KeyPort = 0xf7;//1111 0111 让P1.3口输出低t = KeyPort;t = t&amp;0xf0;// 1111 0000 屏蔽后四位if(t != 0xf0) // 说明按键有被按住&#123;    delay(10);    t = KeyPort;    t = t&amp;0xf0;    if( t != 0xf0)    &#123;        t = KeyPort;        switch(t)        &#123;            case 0xe7:                key = 13;   // 此时为 1110 0111  S13按键被按下                break;            case 0xd7:                key = 14;   // 此时为 1101 0111  S14按键被按下                break;            case 0xb7:                key = 15;   // 此时为 1011 0111  S15按键被按下                break;            case 0x77:                key = 16;   // 此时为 0111 0111  S16按键被按下                break;        &#125;        // 判断按键是否被松开        while( t != 0xf0)&#123;         t = KeyPort;            t = t&amp;0xf0;        &#125;        keycode = key;//把按键的值发给数组，让其对应的数字打印再数码管上    &#125;&#125;</code></pre><p>}</p><p>&#x2F;<em>————————————————<br>           外部中断0初始化<br>————————————————</em>&#x2F;<br>void Init_INT0(void)<br>{<br>  EA&#x3D;1;          &#x2F;&#x2F;全局中断开<br>  EX0&#x3D;1;         &#x2F;&#x2F;外部中断0开<br>  IT0&#x3D;1;         &#x2F;&#x2F;边沿触发<br>}</p><p>&#x2F;<em>————————————————<br>                 外部中断0程序<br>————————————————</em>&#x2F;<br>void int0() interrupt 0 &#x2F;&#x2F;在中断服务函数中进行键盘扫描<br>{<br>     KeyScan();<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1xpMedaf7dpC9EuCFK7I2Tw </span><br><span class="line">提取码：jhb2</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1xpMedaf7dpC9EuCFK7I2Tw  提取码：jhb2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F88LED%E7%82%B9%E9%98%B5%E5%B1%8F%E4%BB%BF%E7%94%B5%E6%A2%AF%E6%95%B0%E5%AD%97%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F88LED%E7%82%B9%E9%98%B5%E5%B1%8F%E4%BB%BF%E7%94%B5%E6%A2%AF%E6%95%B0%E5%AD%97%E6%BB%9A%E5%8A%A8%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示"><a href="#【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示" class="headerlink" title="【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示"></a>【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示</h1><h3 id="【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示-1"><a href="#【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示-1" class="headerlink" title="【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示"></a>【Proteus仿真】8×8LED点阵屏仿电梯数字滚动显示</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/77cded2993784e4289fb0964ce079420.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="8X8点阵取模工具和取模方式（随源码打包）"><a href="#8X8点阵取模工具和取模方式（随源码打包）" class="headerlink" title="8X8点阵取模工具和取模方式（随源码打包）"></a>8X8点阵取模工具和取模方式（随源码打包）</h4><p><img src="https://img-blog.csdnimg.cn/29da13fcf5724ab59c2d28f48b105bdd.png" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">//名称：8×8LED点阵屏仿电梯数字滚动显示</span><br><span class="line">//说明：本例模拟了电梯显示屏上下滚动显示楼层的效果，当目标楼层大于</span><br><span class="line">//当前楼层时，将向上滚动显示，反之则向下滚动显示。</span><br><span class="line">#include &lt;reg51.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">uchar code Table[]=</span><br><span class="line">&#123;</span><br><span class="line">0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,//0</span><br><span class="line">0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,//1</span><br><span class="line">0x00,0x7E,0x02,0x02,0x7E,0x40,0x40,0x7E,//2</span><br><span class="line">0x00,0x7E,0x02,0x02,0x7E,0x02,0x02,0x7E,//3</span><br><span class="line">0x00,0x48,0x48,0x48,0x7E,0x08,0x08,0x08,//4</span><br><span class="line">0x00,0x7E,0x40,0x40,0x7E,0x02,0x02,0x7E,//5</span><br><span class="line">0x00,0x7C,0x40,0x40,0x7C,0x44,0x44,0x7C,//6</span><br><span class="line">0x00,0x7C,0x04,0x04,0x04,0x04,0x04,0x04,//7</span><br><span class="line">0x00,0x7C,0x44,0x44,0x7C,0x44,0x44,0x7C,//8</span><br><span class="line">0x00,0x7E,0x42,0x42,0x7E,0x02,0x02,0x7E,//9</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">uint r= 0;</span><br><span class="line">char offset = 0;</span><br><span class="line">uchar Current_Level = 1,Dest_Level=1,x=0,t =0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> P3 = 0x80;</span><br><span class="line">Current_Level = 1;//从1开始显示</span><br><span class="line">TMOD  = 0x01;//T0工作方式</span><br><span class="line">TH0 = -4000/256;//4ms//每个数字有8字节</span><br><span class="line">TL0 = -4000%256;</span><br><span class="line">TR0=1;</span><br><span class="line">IE = 0x82;</span><br><span class="line">EA =1;</span><br><span class="line">while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Led_Dispaly() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">uchar i;</span><br><span class="line">//在停止滚动时，如果有按键按下，则判断目标楼层</span><br><span class="line">if (P1 != 0xff &amp;&amp; Current_Level == Dest_Level )</span><br><span class="line">&#123;</span><br><span class="line">if (P1 ==0xfe)Dest_Level =5;</span><br><span class="line">if (P1 ==0xfd)Dest_Level =4;</span><br><span class="line">if (P1 ==0xfb)Dest_Level =3;</span><br><span class="line">if (P1 ==0xf7)Dest_Level =2;</span><br><span class="line">if (P1 ==0xef)Dest_Level =1;</span><br><span class="line">&#125;</span><br><span class="line">TH0 = -4000/256;//4ms</span><br><span class="line">TL0 = -4000%256;</span><br><span class="line">P3 =_crol_(P3,1);</span><br><span class="line">i = Current_Level *8 + r + offset;</span><br><span class="line">P0 = ~Table[i];</span><br><span class="line"></span><br><span class="line">//上升显示</span><br><span class="line">if (Current_Level &lt; Dest_Level )</span><br><span class="line">&#123;</span><br><span class="line">if ( ++r ==8)</span><br><span class="line">&#123;//每个数字有8字节</span><br><span class="line">r =0;</span><br><span class="line">if( ++x ==4)</span><br><span class="line">&#123;//每完成x次刷新后后偏</span><br><span class="line">x = 0;</span><br><span class="line">if(++offset ==8)</span><br><span class="line">&#123;</span><br><span class="line">offset = 0;</span><br><span class="line">Current_Level++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//下降显示</span><br><span class="line">else if(Current_Level &gt; Dest_Level )</span><br><span class="line">&#123;</span><br><span class="line">if ( ++r ==8)</span><br><span class="line">&#123;//每个数字有8字节</span><br><span class="line">r =0;</span><br><span class="line">if( ++x ==4)</span><br><span class="line">&#123;//每完成x次刷新后前偏</span><br><span class="line">x = 0;</span><br><span class="line">if(--offset == -8)</span><br><span class="line">&#123;</span><br><span class="line">offset = 0;</span><br><span class="line">Current_Level--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//停止滚动，保持稳定的刷新显示</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if ( ++r ==8) r =0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;&#x2F;名称：8×8LED点阵屏仿电梯数字滚动显示<br>&#x2F;&#x2F;说明：本例模拟了电梯显示屏上下滚动显示楼层的效果，当目标楼层大于<br>&#x2F;&#x2F;当前楼层时，将向上滚动显示，反之则向下滚动显示。<br>#include &lt;reg51.h&gt;<br>#include &lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>uchar code Table[]&#x3D;<br>{<br>    0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,&#x2F;&#x2F;0<br>    0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,&#x2F;&#x2F;1<br>    0x00,0x7E,0x02,0x02,0x7E,0x40,0x40,0x7E,&#x2F;&#x2F;2<br>    0x00,0x7E,0x02,0x02,0x7E,0x02,0x02,0x7E,&#x2F;&#x2F;3<br>    0x00,0x48,0x48,0x48,0x7E,0x08,0x08,0x08,&#x2F;&#x2F;4<br>    0x00,0x7E,0x40,0x40,0x7E,0x02,0x02,0x7E,&#x2F;&#x2F;5<br>    0x00,0x7C,0x40,0x40,0x7C,0x44,0x44,0x7C,&#x2F;&#x2F;6<br>    0x00,0x7C,0x04,0x04,0x04,0x04,0x04,0x04,&#x2F;&#x2F;7<br>    0x00,0x7C,0x44,0x44,0x7C,0x44,0x44,0x7C,&#x2F;&#x2F;8<br>    0x00,0x7E,0x42,0x42,0x7E,0x02,0x02,0x7E,&#x2F;&#x2F;9</p><p>};<br>uint r&#x3D; 0;<br>char offset &#x3D; 0;<br>uchar Current_Level &#x3D; 1,Dest_Level&#x3D;1,x&#x3D;0,t &#x3D;0;</p><p>void main()<br>{<br>     P3 &#x3D; 0x80;<br>    Current_Level &#x3D; 1;&#x2F;&#x2F;从1开始显示<br>    TMOD  &#x3D; 0x01;&#x2F;&#x2F;T0工作方式<br>    TH0 &#x3D; -4000&#x2F;256;&#x2F;&#x2F;4ms&#x2F;&#x2F;每个数字有8字节<br>    TL0 &#x3D; -4000%256;<br>    TR0&#x3D;1;<br>    IE &#x3D; 0x82;<br>    EA &#x3D;1;<br>    while(1);<br>}</p><p>void Led_Dispaly() interrupt 1<br>{<br>    uchar i;<br>    &#x2F;&#x2F;在停止滚动时，如果有按键按下，则判断目标楼层<br>    if (P1 !&#x3D; 0xff &amp;&amp; Current_Level &#x3D;&#x3D; Dest_Level )<br>    {<br>    if (P1 &#x3D;&#x3D;0xfe)Dest_Level &#x3D;5;<br>    if (P1 &#x3D;&#x3D;0xfd)Dest_Level &#x3D;4;<br>    if (P1 &#x3D;&#x3D;0xfb)Dest_Level &#x3D;3;<br>    if (P1 &#x3D;&#x3D;0xf7)Dest_Level &#x3D;2;<br>    if (P1 &#x3D;&#x3D;0xef)Dest_Level &#x3D;1;<br>    }<br>    TH0 &#x3D; -4000&#x2F;256;&#x2F;&#x2F;4ms<br>    TL0 &#x3D; -4000%256;<br>    P3 &#x3D;<em>crol</em>(P3,1);<br>    i &#x3D; Current_Level *8 + r + offset;<br>    P0 &#x3D; ~Table[i];</p><pre><code>//上升显示if (Current_Level &lt; Dest_Level )&#123;    if ( ++r ==8)    &#123;//每个数字有8字节            r =0;        if( ++x ==4)        &#123;//每完成x次刷新后后偏            x = 0;            if(++offset ==8)            &#123;                offset = 0;                Current_Level++;            &#125;                    &#125;    &#125;    &#125;//下降显示else if(Current_Level &gt; Dest_Level )&#123;    if ( ++r ==8)    &#123;//每个数字有8字节        r =0;        if( ++x ==4)        &#123;//每完成x次刷新后前偏            x = 0;            if(--offset == -8)            &#123;                offset = 0;                Current_Level--;            &#125;                    &#125;    &#125;    &#125;//停止滚动，保持稳定的刷新显示else&#123;    if ( ++r ==8) r =0;&#125;</code></pre><p>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本示例基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1nbibyaWHQg8onv-0gfuBeA </span><br><span class="line">提取码：jn53</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1nbibyaWHQg8onv-0gfuBeA  提取码：jn53</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】LCD1602整屏内容信息移动</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FLCD1602%E6%95%B4%E5%B1%8F%E5%86%85%E5%AE%B9%E4%BF%A1%E6%81%AF%E7%A7%BB%E5%8A%A8/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FLCD1602%E6%95%B4%E5%B1%8F%E5%86%85%E5%AE%B9%E4%BF%A1%E6%81%AF%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】LCD1602整屏内容信息移动"><a href="#【Proteus仿真】LCD1602整屏内容信息移动" class="headerlink" title="【Proteus仿真】LCD1602整屏内容信息移动"></a>【Proteus仿真】LCD1602整屏内容信息移动</h1><h3 id="【Proteus仿真】LCD1602整屏内容信息移动-1"><a href="#【Proteus仿真】LCD1602整屏内容信息移动-1" class="headerlink" title="【Proteus仿真】LCD1602整屏内容信息移动"></a>【Proteus仿真】LCD1602整屏内容信息移动</h3><ul><li>Proteus仿真演示(本实例仅做proteus仿真参考)</li></ul><p><img src="https://img-blog.csdnimg.cn/45ca049709f2448388bef57de3b50e25.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="proteus仿真相关设置"><a href="#proteus仿真相关设置" class="headerlink" title="proteus仿真相关设置"></a>proteus仿真相关设置</h4><ul><li>Data Memory map:设置范围：0000-FFFF</li></ul><p><code>Data Memory map</code></p><p><code>0000-FFFF</code></p><p><img src="https://img-blog.csdnimg.cn/f8a570316c1545969204b259e404c363.png" alt="在这里插入图片描述"></p><h4 id="keil编译选项设置"><a href="#keil编译选项设置" class="headerlink" title="keil编译选项设置"></a>keil编译选项设置</h4><p><code>keil</code></p><p><img src="https://img-blog.csdnimg.cn/fc8ac0a12e3249c69100ea5c49e96c69.png" alt="在这里插入图片描述"></p><h4 id="主程序示例代码"><a href="#主程序示例代码" class="headerlink" title="主程序示例代码"></a>主程序示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STC89C5xRC.H&gt;</span><br><span class="line">#include &quot;LCD1602.h&quot;</span><br><span class="line"></span><br><span class="line">bit flag500ms = 0; //500ms 定时标志</span><br><span class="line">unsigned char T0RH = 0; //T0 重载值的高字节</span><br><span class="line">unsigned char T0RL = 0; //T0 重载值的低字节</span><br><span class="line">unsigned char code str1[] = &quot;Perseverance51&quot;;</span><br><span class="line">//待显示的第二行字符串，最好与与第一行字符串等长，较短的行可用空格补齐</span><br><span class="line">unsigned char code str2[] = &quot;Hello &#x27; World&quot;;</span><br><span class="line">/* 配置并启动 T0，ms-T0 定时时间 */</span><br><span class="line">void ConfigTimer0(unsigned int ms)&#123;</span><br><span class="line">    unsigned long tmp; //临时变量</span><br><span class="line">    tmp = 11059200 / 12; //定时器计数频率</span><br><span class="line">    tmp = (tmp * ms) / 1000; //计算所需的计数值</span><br><span class="line">    tmp = 65536 - tmp; //计算定时器重载值</span><br><span class="line">   tmp = tmp + 12; //补偿中断响应延时造成的误差</span><br><span class="line">    T0RH = (unsigned char)(tmp&gt;&gt;8); //定时器重载值拆分为高低字节</span><br><span class="line">    T0RL = (unsigned char)tmp;</span><br><span class="line">    TMOD &amp;= 0xF0; //清零 T0 的控制位</span><br><span class="line">    TMOD |= 0x01; //配置 T0 为模式 1</span><br><span class="line">    TH0 = T0RH; //加载 T0 重载值</span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = 1; //使能 T0 中断</span><br><span class="line">    TR0 = 1; //启动 T0</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i;</span><br><span class="line">    unsigned char index = 0; //移动索引</span><br><span class="line">    unsigned char  bufMove1[16+sizeof(str1)+16]; //移动显示缓冲区 1</span><br><span class="line">    unsigned char  bufMove2[16+sizeof(str2)+16]; //移动显示缓冲区 2</span><br><span class="line">EA = 1; //开总中断</span><br><span class="line"> ConfigTimer0(60); //配置 T0 定时 设置过小会导致Proteus仿真时屏幕有黑块区域，按理这个值不应该超过51ms才行</span><br><span class="line">//实际硬件添加定义：pdata 外部存储区</span><br><span class="line"></span><br><span class="line">    LCD1602_Init();//初始化LCD1602</span><br><span class="line">LCD1602_write_com(0x01);//清屏指令</span><br><span class="line">//缓冲区开头一段填充为空格</span><br><span class="line">    for (i=0; i&lt;16; i++)&#123;</span><br><span class="line">        bufMove1[i] = &#x27; &#x27;;</span><br><span class="line">        bufMove2[i] = &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    //待显示字符串拷贝到缓冲区中间位置</span><br><span class="line">    for (i=0; i&lt;(sizeof(str1)-1); i++)&#123;</span><br><span class="line">        bufMove1[16+i] = str1[i];</span><br><span class="line">        bufMove2[16+i] = str2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //缓冲区结尾一段也填充为空格</span><br><span class="line">    for (i=(16+sizeof(str1)-1); i&lt;sizeof(bufMove1); i++)&#123;</span><br><span class="line">        bufMove1[i] = &#x27; &#x27;;</span><br><span class="line">        bufMove2[i] = &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (flag500ms)&#123; //每 500ms 移动一次屏幕</span><br><span class="line">            flag500ms = 0;</span><br><span class="line">            //从缓冲区抽出需显示的一段字符显示到液晶上</span><br><span class="line">            LcdShowStr(0, 0, bufMove1+index, 16);</span><br><span class="line">            LcdShowStr(1, 0, bufMove2+index, 16);</span><br><span class="line">            //移动索引递增，实现左移</span><br><span class="line">            index++;</span><br><span class="line">            if (index &gt;= (16+sizeof(str1)-1))&#123;</span><br><span class="line">                //起始位置达到字符串尾部后即返回从头开始</span><br><span class="line">                index = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* T0 中断服务函数，定时 500ms */</span><br><span class="line">void InterruptTimer0() interrupt 1&#123;</span><br><span class="line">    static unsigned char tmr500ms = 0;</span><br><span class="line">   </span><br><span class="line">    TH0 = T0RH; //重新加载重载值</span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    tmr500ms++;</span><br><span class="line">    if (tmr500ms &gt;= 10)&#123;</span><br><span class="line">        tmr500ms = 0;</span><br><span class="line">        flag500ms = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;STC89C5xRC.H&gt;<br>#include “LCD1602.h”</p><p>bit flag500ms &#x3D; 0; &#x2F;&#x2F;500ms 定时标志<br>unsigned char T0RH &#x3D; 0; &#x2F;&#x2F;T0 重载值的高字节<br>unsigned char T0RL &#x3D; 0; &#x2F;&#x2F;T0 重载值的低字节<br>unsigned char code str1[] &#x3D; “Perseverance51”;<br>&#x2F;&#x2F;待显示的第二行字符串，最好与与第一行字符串等长，较短的行可用空格补齐<br>unsigned char code str2[] &#x3D; “Hello ‘ World”;<br>&#x2F;* 配置并启动 T0，ms-T0 定时时间 *&#x2F;<br>void ConfigTimer0(unsigned int ms){<br>    unsigned long tmp; &#x2F;&#x2F;临时变量<br>    tmp &#x3D; 11059200 &#x2F; 12; &#x2F;&#x2F;定时器计数频率<br>    tmp &#x3D; (tmp * ms) &#x2F; 1000; &#x2F;&#x2F;计算所需的计数值<br>    tmp &#x3D; 65536 - tmp; &#x2F;&#x2F;计算定时器重载值<br>   tmp &#x3D; tmp + 12; &#x2F;&#x2F;补偿中断响应延时造成的误差<br>    T0RH &#x3D; (unsigned char)(tmp&gt;&gt;8); &#x2F;&#x2F;定时器重载值拆分为高低字节<br>    T0RL &#x3D; (unsigned char)tmp;<br>    TMOD &amp;&#x3D; 0xF0; &#x2F;&#x2F;清零 T0 的控制位<br>    TMOD |&#x3D; 0x01; &#x2F;&#x2F;配置 T0 为模式 1<br>    TH0 &#x3D; T0RH; &#x2F;&#x2F;加载 T0 重载值<br>    TL0 &#x3D; T0RL;<br>    ET0 &#x3D; 1; &#x2F;&#x2F;使能 T0 中断<br>    TR0 &#x3D; 1; &#x2F;&#x2F;启动 T0<br>}<br>void main()<br>{<br>        unsigned char i;<br>    unsigned char index &#x3D; 0; &#x2F;&#x2F;移动索引<br>    unsigned char  bufMove1[16+sizeof(str1)+16]; &#x2F;&#x2F;移动显示缓冲区 1<br>    unsigned char  bufMove2[16+sizeof(str2)+16]; &#x2F;&#x2F;移动显示缓冲区 2<br>    EA &#x3D; 1; &#x2F;&#x2F;开总中断<br>     ConfigTimer0(60); &#x2F;&#x2F;配置 T0 定时 设置过小会导致Proteus仿真时屏幕有黑块区域，按理这个值不应该超过51ms才行<br>    &#x2F;&#x2F;实际硬件添加定义：pdata 外部存储区</p><pre><code>LCD1602_Init();//初始化LCD1602LCD1602_write_com(0x01);//清屏指令//缓冲区开头一段填充为空格for (i=0; i&lt;16; i++)&#123;    bufMove1[i] = &#39; &#39;;    bufMove2[i] = &#39; &#39;;&#125;//待显示字符串拷贝到缓冲区中间位置for (i=0; i&lt;(sizeof(str1)-1); i++)&#123;    bufMove1[16+i] = str1[i];    bufMove2[16+i] = str2[i];&#125;//缓冲区结尾一段也填充为空格for (i=(16+sizeof(str1)-1); i&lt;sizeof(bufMove1); i++)&#123;    bufMove1[i] = &#39; &#39;;    bufMove2[i] = &#39; &#39;;&#125;while(1)&#123;    if (flag500ms)&#123; //每 500ms 移动一次屏幕        flag500ms = 0;        //从缓冲区抽出需显示的一段字符显示到液晶上        LcdShowStr(0, 0, bufMove1+index, 16);        LcdShowStr(1, 0, bufMove2+index, 16);        //移动索引递增，实现左移        index++;        if (index &gt;= (16+sizeof(str1)-1))&#123;            //起始位置达到字符串尾部后即返回从头开始            index = 0;        &#125;    &#125;&#125;</code></pre><p>}</p><p>&#x2F;* T0 中断服务函数，定时 500ms *&#x2F;<br>void InterruptTimer0() interrupt 1{<br>    static unsigned char tmr500ms &#x3D; 0;</p><pre><code>TH0 = T0RH; //重新加载重载值TL0 = T0RL;tmr500ms++;if (tmr500ms &gt;= 10)&#123;    tmr500ms = 0;    flag500ms = 1;&#125;</code></pre><p>}&#96;</p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本示例基于Proteus8.12平台。</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1GFzQSNQW5E0Do0CyvJovlQ </span><br><span class="line">提取码：37jm</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1GFzQSNQW5E0Do0CyvJovlQ  提取码：37jm</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】基于VSM 串口printf调试输出示例</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%9F%BA%E4%BA%8EVSM-%E4%B8%B2%E5%8F%A3printf%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%9F%BA%E4%BA%8EVSM-%E4%B8%B2%E5%8F%A3printf%E8%B0%83%E8%AF%95%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】基于VSM-串口printf调试输出示例"><a href="#【Proteus仿真】基于VSM-串口printf调试输出示例" class="headerlink" title="【Proteus仿真】基于VSM 串口printf调试输出示例"></a>【Proteus仿真】基于VSM 串口printf调试输出示例</h1><h3 id="【Proteus仿真】基于VSM-串口printf调试输出示例-1"><a href="#【Proteus仿真】基于VSM-串口printf调试输出示例-1" class="headerlink" title="【Proteus仿真】基于VSM 串口printf调试输出示例"></a>【Proteus仿真】基于VSM 串口printf调试输出示例</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/f61fd4c550bf461bbfcf54170abe13c4.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>在Proteus里面使用VSM Studio打印浮点数变量编译会出错，这里就没有打印这个类型了。</p><p><code>VSM Studio</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/* Main.c file generated by New Project wizard</span><br><span class="line"> *</span><br><span class="line"> * Created:   周一 7月 4 2022</span><br><span class="line"> * Processor: AT89C51</span><br><span class="line"> * Compiler:  Keil for 8051</span><br><span class="line"> */</span><br><span class="line">#include &lt;reg51.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAIN_Fosc11059200uL//定义主时钟</span><br><span class="line">#define BAUD 9600           //UART baudrate</span><br><span class="line"></span><br><span class="line">void delayms(unsigned int z)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int x,y;</span><br><span class="line">  for(x=z;x&gt;0;x--)</span><br><span class="line">    for(y=112;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tst_printf (void) &#123;</span><br><span class="line">  char a = 1;</span><br><span class="line">  int b  = 12365;</span><br><span class="line">  long c = 0x7FFFFFFF;</span><br><span class="line"></span><br><span class="line">  unsigned char x = &#x27;A&#x27;;</span><br><span class="line">  unsigned int y  = 54321;</span><br><span class="line">  unsigned long z = 0x4A6F6E00;</span><br><span class="line"></span><br><span class="line">//  float f_a = 10.0;</span><br><span class="line">// float f_g = 22.95;</span><br><span class="line"></span><br><span class="line">  char buf [] = &quot;Test String&quot;;//不定长数组</span><br><span class="line">  char *p = buf;</span><br><span class="line"></span><br><span class="line">  printf (&quot;char %bd int %d long %ld\n&quot;,a,b,c);</span><br><span class="line">  printf (&quot;Uchar %bu Uint %u Ulong %lu\n&quot;,x,y,z);</span><br><span class="line">  printf (&quot;xchar %bx xint %x xlong %lx\n&quot;,x,y,z);</span><br><span class="line">  printf (&quot;String %s is at address %p\n&quot;,buf,p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123; </span><br><span class="line">SCON = 0x50; //串口方式1,允许接收 </span><br><span class="line">//PCON=0x80;//波特率倍频，启用时，波特率翻倍</span><br><span class="line">    TMOD &amp;= 0x0F; //清零 T1 的控制位</span><br><span class="line">    TMOD |= 0x20; //定时器1 定时方式2 ,8位自动重装载</span><br><span class="line">TH1 = TL1 =256  -(MAIN_Fosc/12/32/BAUD); //计算 T1 重载值</span><br><span class="line">TI = 1; </span><br><span class="line">TR1 = 1; //启动定时器 </span><br><span class="line">ET1 = 0; //禁止 T1 中断</span><br><span class="line">ES = 1; //使能串口中断</span><br><span class="line">EA =1;</span><br><span class="line">printf(&quot;Hello World!\n&quot;); //显示Hello World </span><br><span class="line">while(1) </span><br><span class="line">&#123; </span><br><span class="line">delayms(3000);</span><br><span class="line">tst_printf();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;* Main.c file generated by New Project wizard<br> *</p><ul><li>Created:   周一 7月 4 2022</li><li>Processor: AT89C51</li><li>Compiler:  Keil for 8051<br> *&#x2F;</li></ul><p>#include &lt;reg51.h&gt;<br>#include &lt;stdio.h&gt;</p><p>#define MAIN_Fosc11059200uL&#x2F;&#x2F;定义主时钟<br>#define BAUD 9600           &#x2F;&#x2F;UART baudrate</p><p>void delayms(unsigned int z)<br>{<br>  unsigned int x,y;<br>  for(x&#x3D;z;x&gt;0;x–)<br>    for(y&#x3D;112;y&gt;0;y–);<br>}</p><p>void tst_printf (void) {<br>  char a &#x3D; 1;<br>  int b  &#x3D; 12365;<br>  long c &#x3D; 0x7FFFFFFF;</p><p>  unsigned char x &#x3D; ‘A’;<br>  unsigned int y  &#x3D; 54321;<br>  unsigned long z &#x3D; 0x4A6F6E00;</p><p>&#x2F;&#x2F;  float f_a &#x3D; 10.0;<br>&#x2F;&#x2F; float f_g &#x3D; 22.95;</p><p>  char buf [] &#x3D; “Test String”;&#x2F;&#x2F;不定长数组<br>  char *p &#x3D; buf;</p><p>  printf (“char %bd int %d long %ld\n”,a,b,c);<br>  printf (“Uchar %bu Uint %u Ulong %lu\n”,x,y,z);<br>  printf (“xchar %bx xint %x xlong %lx\n”,x,y,z);<br>  printf (“String %s is at address %p\n”,buf,p);</p><p>}</p><p>void main(void)<br>{<br>    SCON &#x3D; 0x50; &#x2F;&#x2F;串口方式1,允许接收<br>&#x2F;&#x2F;PCON&#x3D;0x80;&#x2F;&#x2F;波特率倍频，启用时，波特率翻倍<br>    TMOD &amp;&#x3D; 0x0F; &#x2F;&#x2F;清零 T1 的控制位<br>    TMOD |&#x3D; 0x20; &#x2F;&#x2F;定时器1 定时方式2 ,8位自动重装载<br>    TH1 &#x3D; TL1 &#x3D;256  -(MAIN_Fosc&#x2F;12&#x2F;32&#x2F;BAUD); &#x2F;&#x2F;计算 T1 重载值<br>    TI &#x3D; 1;<br>    TR1 &#x3D; 1; &#x2F;&#x2F;启动定时器<br>    ET1 &#x3D; 0; &#x2F;&#x2F;禁止 T1 中断<br>    ES &#x3D; 1; &#x2F;&#x2F;使能串口中断<br>    EA &#x3D;1;<br>printf(“Hello World!\n”); &#x2F;&#x2F;显示Hello World<br>    while(1)<br>    {<br>    delayms(3000);<br>    tst_printf();<br>    }<br>}&#96;</p><ul><li>在VSM Studio界面选中main.c文件后，点击运行仿真，然后暂停可以看到代码运行位置。</li></ul><p><code>main.c</code></p><p><img src="https://img-blog.csdnimg.cn/979de1e46dc7441ca78957d8e940ca74.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/01b9451e3aa24940a0984de50b08973a.png" alt="在这里插入图片描述"></p><h4 id="仿真资源"><a href="#仿真资源" class="headerlink" title="仿真资源"></a>仿真资源</h4><p>本示例基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1INRLd18hGqulVlpr3gyQ_g </span><br><span class="line">提取码：jkvt</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1INRLd18hGqulVlpr3gyQ_g  提取码：jkvt</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】多路非阻塞延时流水灯演示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%A4%9A%E8%B7%AF%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BB%B6%E6%97%B6%E6%B5%81%E6%B0%B4%E7%81%AF%E6%BC%94%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E5%A4%9A%E8%B7%AF%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BB%B6%E6%97%B6%E6%B5%81%E6%B0%B4%E7%81%AF%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】多路非阻塞延时流水灯演示"><a href="#【Proteus仿真】多路非阻塞延时流水灯演示" class="headerlink" title="【Proteus仿真】多路非阻塞延时流水灯演示"></a>【Proteus仿真】多路非阻塞延时流水灯演示</h1><h3 id="【Proteus仿真】多路非阻塞延时流水灯演示-1"><a href="#【Proteus仿真】多路非阻塞延时流水灯演示-1" class="headerlink" title="【Proteus仿真】多路非阻塞延时流水灯演示"></a>【Proteus仿真】多路非阻塞延时流水灯演示</h3><ul><li>🌻Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/c3c3641c6c9e4096bbf4287c3c82015a.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="🌼功能说明"><a href="#🌼功能说明" class="headerlink" title="🌼功能说明"></a>🌼功能说明</h4><h5 id="📜51单片机利用定时器轮询设置2路不同长度的延时时间，跑流水灯。"><a href="#📜51单片机利用定时器轮询设置2路不同长度的延时时间，跑流水灯。" class="headerlink" title="📜51单片机利用定时器轮询设置2路不同长度的延时时间，跑流水灯。"></a>📜51单片机利用定时器轮询设置2路不同长度的延时时间，跑流水灯。</h5><h4 id="📓实现方法"><a href="#📓实现方法" class="headerlink" title="📓实现方法"></a>📓实现方法</h4><h5 id="📑利用定时器中断，创建一个以1毫秒为时基的定时器中断函数。在需要不同时间的定时长度时，就设置一个定时的标量，当使能这个被定义的标量后，定时器每隔1毫秒就进入中断服务函数里面查询并累加计数，当累计计数达到标量值时就将对应的标量标志位置1，然后只要在主循环中查询该标量标志位是否值1从而实现非阻塞定时的功能。"><a href="#📑利用定时器中断，创建一个以1毫秒为时基的定时器中断函数。在需要不同时间的定时长度时，就设置一个定时的标量，当使能这个被定义的标量后，定时器每隔1毫秒就进入中断服务函数里面查询并累加计数，当累计计数达到标量值时就将对应的标量标志位置1，然后只要在主循环中查询该标量标志位是否值1从而实现非阻塞定时的功能。" class="headerlink" title="📑利用定时器中断，创建一个以1毫秒为时基的定时器中断函数。在需要不同时间的定时长度时，就设置一个定时的标量，当使能这个被定义的标量后，定时器每隔1毫秒就进入中断服务函数里面查询并累加计数，当累计计数达到标量值时就将对应的标量标志位置1，然后只要在主循环中查询该标量标志位是否值1从而实现非阻塞定时的功能。"></a>📑利用定时器中断，创建一个以1毫秒为时基的定时器中断函数。在需要不同时间的定时长度时，就设置一个定时的标量，当使能这个被定义的标量后，定时器每隔1毫秒就进入中断服务函数里面查询并累加计数，当累计计数达到标量值时就将对应的标量标志位置1，然后只要在主循环中查询该标量标志位是否值1从而实现非阻塞定时的功能。</h5><ul><li>✅定时器中断服务函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void time0_isr() interrupt  1 using  0</span><br><span class="line">&#123;</span><br><span class="line">TR0 = 0 ;</span><br><span class="line">if(time_enable)//计数器使能</span><br><span class="line">&#123;</span><br><span class="line">cnt --;</span><br><span class="line">if(!cnt)time_flag = 1;//计数时间到</span><br><span class="line">&#125;</span><br><span class="line">if(time_enable2)//计数器使能</span><br><span class="line">&#123;</span><br><span class="line">cnt2 --;</span><br><span class="line">if(!cnt2)time_flag2 = 1;//计数时间到</span><br><span class="line">&#125;</span><br><span class="line">TL0 = 0x18;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">TR0 = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;void time0_isr() interrupt  1 using  0<br>{<br>    TR0 &#x3D; 0 ;<br>    if(time_enable)&#x2F;&#x2F;计数器使能<br>    {<br>        cnt –;<br>        if(!cnt)time_flag &#x3D; 1;&#x2F;&#x2F;计数时间到<br>    }<br>    if(time_enable2)&#x2F;&#x2F;计数器使能<br>    {<br>        cnt2 –;<br>        if(!cnt2)time_flag2 &#x3D; 1;&#x2F;&#x2F;计数时间到<br>    }<br>    TL0 &#x3D; 0x18;&#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0xFC;&#x2F;&#x2F;设置定时初始值<br>    TR0 &#x3D; 1;</p><p>}&#96;</p><h5 id="✨当然也可以直接在定时器中断服务函数里面直接进行标志位查询，以减少定义的变量多，但是这样的运算会降低精度。"><a href="#✨当然也可以直接在定时器中断服务函数里面直接进行标志位查询，以减少定义的变量多，但是这样的运算会降低精度。" class="headerlink" title="✨当然也可以直接在定时器中断服务函数里面直接进行标志位查询，以减少定义的变量多，但是这样的运算会降低精度。"></a>✨当然也可以直接在定时器中断服务函数里面直接进行标志位查询，以减少定义的变量多，但是这样的运算会降低精度。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void time0_isr() interrupt  1 using  0</span><br><span class="line">&#123;</span><br><span class="line">TR0 = 0 ;</span><br><span class="line">cnt++;</span><br><span class="line">if(cnt%20000==0) flag1=1;</span><br><span class="line">if(cnt%500==0) flag2=1;</span><br><span class="line">TL0 = 0x18;//设置定时初始值</span><br><span class="line">TH0 = 0xFC;//设置定时初始值</span><br><span class="line">TR0 = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;void time0_isr() interrupt  1 using  0<br>{<br>    TR0 &#x3D; 0 ;<br>    cnt++;<br>    if(cnt%20000&#x3D;&#x3D;0) flag1&#x3D;1;<br>    if(cnt%500&#x3D;&#x3D;0) flag2&#x3D;1;<br>    TL0 &#x3D; 0x18;&#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0xFC;&#x2F;&#x2F;设置定时初始值<br>    TR0 &#x3D; 1;</p><p>}&#96;</p><h4 id="📝主函数代码"><a href="#📝主函数代码" class="headerlink" title="📝主函数代码"></a>📝主函数代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">#define led_shine_time 2000</span><br><span class="line">#define led_shine_time2 500</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char temp = 0x80;</span><br><span class="line">unsigned char temp2 = 0x01;</span><br><span class="line">unsigned char i,j;</span><br><span class="line">cnt = led_shine_time;</span><br><span class="line">cnt2 = led_shine_time2;</span><br><span class="line">time_enable = 1;//使能1路定时器</span><br><span class="line">time_enable2 = 1;//使能2路定时器</span><br><span class="line">Timer0Init();</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> if(time_flag)//查询定时器计数是否达到设定值</span><br><span class="line"> &#123;</span><br><span class="line"> time_flag = 0;</span><br><span class="line"> P1 = ~(temp&gt;&gt;i);</span><br><span class="line"> cnt = led_shine_time;//重新装载</span><br><span class="line"> i++;</span><br><span class="line"> i %=8;</span><br><span class="line"> &#125;</span><br><span class="line">  if(time_flag2)//查询定时器计数是否达到设定值</span><br><span class="line"> &#123;</span><br><span class="line"> time_flag2 = 0;</span><br><span class="line"> P2 = ~(temp&gt;&gt;j);</span><br><span class="line"> cnt2 = led_shine_time2;//重新装载</span><br><span class="line"> j++;</span><br><span class="line"> j %=8;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “time.h”</p><p>#define led_shine_time 2000<br>#define led_shine_time2 500</p><p>void main()<br>{<br>    unsigned char temp &#x3D; 0x80;<br>    unsigned char temp2 &#x3D; 0x01;<br>    unsigned char i,j;<br>    cnt &#x3D; led_shine_time;<br>    cnt2 &#x3D; led_shine_time2;<br>    time_enable &#x3D; 1;&#x2F;&#x2F;使能1路定时器<br>    time_enable2 &#x3D; 1;&#x2F;&#x2F;使能2路定时器<br>    Timer0Init();<br>    while(1)<br>    {<br>     if(time_flag)&#x2F;&#x2F;查询定时器计数是否达到设定值<br>     {<br>         time_flag &#x3D; 0;<br>         P1 &#x3D; ~(temp&gt;&gt;i);<br>         cnt &#x3D; led_shine_time;&#x2F;&#x2F;重新装载<br>         i++;<br>         i %&#x3D;8;<br>     }<br>      if(time_flag2)&#x2F;&#x2F;查询定时器计数是否达到设定值<br>     {<br>         time_flag2 &#x3D; 0;<br>         P2 &#x3D; ~(temp&gt;&gt;j);<br>         cnt2 &#x3D; led_shine_time2;&#x2F;&#x2F;重新装载<br>         j++;<br>         j %&#x3D;8;<br>     }<br>    }<br>}&#96;</p><h4 id="📚程序源码和仿真资源"><a href="#📚程序源码和仿真资源" class="headerlink" title="📚程序源码和仿真资源"></a>📚程序源码和仿真资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/19mcG9hdqiuo3FciJAMgnCg </span><br><span class="line">提取码：it5g</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/19mcG9hdqiuo3FciJAMgnCg  提取码：it5g</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】独立按键+数码管显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】独立按键-数码管显示"><a href="#【Proteus仿真】独立按键-数码管显示" class="headerlink" title="【Proteus仿真】独立按键+数码管显示"></a>【Proteus仿真】独立按键+数码管显示</h1><h3 id="【Proteus仿真】独立按键-数码管显示-1"><a href="#【Proteus仿真】独立按键-数码管显示-1" class="headerlink" title="【Proteus仿真】独立按键+数码管显示"></a>【Proteus仿真】独立按键+数码管显示</h3><ul><li>✨Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/a6756cf88ee54c299e046896529a45f6.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="📚功能简介"><a href="#📚功能简介" class="headerlink" title="📚功能简介"></a>📚功能简介</h4><h5 id="📝本文内容上是并无新意，只是将各功能模块分离开来。功能底层实现采用非阻塞式按键扫描，单击或长按都加一的模式，使用定时器定时扫描的方式。"><a href="#📝本文内容上是并无新意，只是将各功能模块分离开来。功能底层实现采用非阻塞式按键扫描，单击或长按都加一的模式，使用定时器定时扫描的方式。" class="headerlink" title="📝本文内容上是并无新意，只是将各功能模块分离开来。功能底层实现采用非阻塞式按键扫描，单击或长按都加一的模式，使用定时器定时扫描的方式。"></a>📝本文内容上是并无新意，只是将各功能模块分离开来。功能底层实现采用非阻塞式按键扫描，单击或长按都加一的模式，使用定时器定时扫描的方式。</h5><h4 id="🛠工程架构"><a href="#🛠工程架构" class="headerlink" title="🛠工程架构"></a>🛠工程架构</h4><p><img src="https://img-blog.csdnimg.cn/8a20933c0ef84487a5e7d7ee12e2c986.png" alt="在这里插入图片描述"></p><h4 id="📓主程序代码"><a href="#📓主程序代码" class="headerlink" title="📓主程序代码"></a>📓主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Key.h&quot;</span><br><span class="line">#include &quot;display.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int NumCnt;</span><br><span class="line"></span><br><span class="line">void Dis_Service();</span><br><span class="line">void Key_Service(); </span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">while(1)&#123;</span><br><span class="line">  Key_Service();</span><br><span class="line">Dis_Service();</span><br><span class="line">Display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> void Key_Service()&#123;</span><br><span class="line">switch(Key_Scan())&#123;</span><br><span class="line">case 0:break;</span><br><span class="line">case 1:NumCnt++;if(NumCnt &gt;9999)NumCnt = 0;break;</span><br><span class="line">case 2:NumCnt--;if(NumCnt &gt; 9999)NumCnt =9999;break;</span><br><span class="line">case 3:NumCnt = 0;break;</span><br><span class="line">case 4: NumCnt= 9527 ;break ;</span><br><span class="line">default :break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Dis_Service()&#123;</span><br><span class="line">LEDBuf[0]=NumCnt/1000;</span><br><span class="line">LEDBuf[1]=NumCnt/100%10;</span><br><span class="line">LEDBuf[2]=NumCnt/10%10;</span><br><span class="line">LEDBuf[3]=NumCnt%10; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “Key.h”<br>#include “display.h”</p><p>unsigned int NumCnt;</p><p>void Dis_Service();<br>void Key_Service(); </p><p>void main(){</p><pre><code>while(1)&#123;  Key_Service();    Dis_Service();    Display();&#125;</code></pre><p>}</p><p> void Key_Service(){<br>    switch(Key_Scan()){<br>    case 0:break;<br>    case 1:NumCnt++;if(NumCnt &gt;9999)NumCnt &#x3D; 0;break;<br>    case 2:NumCnt–;if(NumCnt &gt; 9999)NumCnt &#x3D;9999;break;<br>    case 3:NumCnt &#x3D; 0;break;<br>    case 4: NumCnt&#x3D; 9527 ;break ;<br>    default :break;<br>    }<br>}</p><p>void Dis_Service(){<br>                LEDBuf[0]&#x3D;NumCnt&#x2F;1000;<br>                LEDBuf[1]&#x3D;NumCnt&#x2F;100%10;<br>                LEDBuf[2]&#x3D;NumCnt&#x2F;10%10;<br>                LEDBuf[3]&#x3D;NumCnt%10;<br> }&#96;</p><h4 id="⛳程序源码和仿真资源"><a href="#⛳程序源码和仿真资源" class="headerlink" title="⛳程序源码和仿真资源"></a>⛳程序源码和仿真资源</h4><p>🔖本案例基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1lf1tHxfozh1ITvgS_jQ4Pg </span><br><span class="line">提取码：qbl8</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1lf1tHxfozh1ITvgS_jQ4Pg  提取码：qbl8</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC单片机 NRF24L01通讯实验</title>
      <link href="/2024/03/STC-STC%E5%8D%95%E7%89%87%E6%9C%BA-NRF24L01%E9%80%9A%E8%AE%AF%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/03/STC-STC%E5%8D%95%E7%89%87%E6%9C%BA-NRF24L01%E9%80%9A%E8%AE%AF%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC单片机-NRF24L01通讯实验"><a href="#STC单片机-NRF24L01通讯实验" class="headerlink" title="STC单片机 NRF24L01通讯实验"></a>STC单片机 NRF24L01通讯实验</h1><h3 id="STC单片机-NRF24L01通讯实验-1"><a href="#STC单片机-NRF24L01通讯实验-1" class="headerlink" title="STC单片机 NRF24L01通讯实验"></a>STC单片机 NRF24L01通讯实验</h3><ul><li>🔖验证对象：STC15L2K60S2  📍STC15L2K60S2自制系统板开源地址：<a href="https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban">https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban</a></li><li>⏱时钟频率：11.0592MHz</li><li>🌼NRF24L01模块以及接线说明</li><li>📜接线定义：</li></ul><p>🔖验证对象：STC15L2K60S2  📍STC15L2K60S2自制系统板开源地址：<a href="https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban">https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban</a></p><p><code>STC15L2K60S2</code></p><p><img src="https://img-blog.csdnimg.cn/34e134cf773948e89141bed5e146bce0.png" alt="在这里插入图片描述"></p><p><code>https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban</code></p><p>⏱时钟频率：11.0592MHz</p><p><code>11.0592</code></p><p>🌼NRF24L01模块以及接线说明</p><p><img src="https://img-blog.csdnimg.cn/ce898ab67ac24dbbbb38b36d3c30445d.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/c4015cf214744a7997a0e48317de943a.png" alt="在这里插入图片描述"></p><p>📜接线定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">----------------------</span><br><span class="line">   VCC CSN MOSI IRQ</span><br><span class="line">   GND CE  SCK  MISO</span><br><span class="line">----------------------</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define SCK  P17</span><br><span class="line">#define MISO P16</span><br><span class="line">#define MOSI P15</span><br><span class="line">#define CSN  P13</span><br><span class="line">#define CE   P12</span><br><span class="line">#define IRQ  P14</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="&#96;&#x2F;*"></a>&#96;&#x2F;*</h2><h2 id="VCC-CSN-MOSI-IRQ-GND-CE-SCK-MISO"><a href="#VCC-CSN-MOSI-IRQ-GND-CE-SCK-MISO" class="headerlink" title="   VCC CSN MOSI IRQ   GND CE  SCK  MISO"></a>   VCC CSN MOSI IRQ<br>   GND CE  SCK  MISO</h2><p>*&#x2F;</p><p>#define SCK  P17<br>#define MISO P16<br>#define MOSI P15<br>#define CSN  P13<br>#define CE   P12<br>#define IRQ  P14&#96;</p><ul><li>🔰如果接线错误或nRF24L01有问题会打印如下信息：</li></ul><p><img src="https://img-blog.csdnimg.cn/00aee639d40145e3871a1cedf0513366.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a695df66eaac47d2aa0c44b4ddb9d8e5.png" alt="在这里插入图片描述"></p><h4 id="⛳功能说明和注意事项"><a href="#⛳功能说明和注意事项" class="headerlink" title="⛳功能说明和注意事项"></a>⛳功能说明和注意事项</h4><ol><li>在进行本实验前，需要确保模块正常，接线正确，如果接线错误，打开串口时，会打印初始化失败相关信息提示。</li><li>发射端采用按键控制数据发送，程序默认是当P00引脚电平拉低时发送指定数据。</li><li>串口通讯波特率：115200</li><li>如果采用5V的STC单片机进行本实验，NRF24L01模块为3.3V供电模块，需要注意引脚电平转化，或者串联1K电阻以免损坏通讯模块。</li></ol><p><img src="https://img-blog.csdnimg.cn/5bbaa34356824c31863f1e9255a8ceef.png" alt="在这里插入图片描述"></p><p><code>115200</code></p><h4 id="📝发射端主程序"><a href="#📝发射端主程序" class="headerlink" title="📝发射端主程序"></a>📝发射端主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STC15F2K60S2.H&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;NRF24L01.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">xdata u8 sendbuf[32] = &quot;Hello World!Perseverance9527&quot;;</span><br><span class="line">#define MAIN_Fosc   11059200UL</span><br><span class="line">#define Baudrate    115200L</span><br><span class="line">#define TM          (65536 -(MAIN_Fosc/Baudrate/4))</span><br><span class="line">//配置串口1初始化函数</span><br><span class="line">void UartInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    SCON = (SCON &amp; 0x3f) | 0x40;</span><br><span class="line">    T2L  = TM;</span><br><span class="line">    T2H  = TM &gt;&gt; 8;</span><br><span class="line">    AUXR |= 0x15;</span><br><span class="line">&#125;</span><br><span class="line">//串口单字符输出函数</span><br><span class="line">void UartPutc(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    SBUF = dat;</span><br><span class="line">    while(TI == 0);</span><br><span class="line">    TI = 0;</span><br><span class="line">&#125;</span><br><span class="line">//配置printf函数，需包含stdio.h头文件</span><br><span class="line">char putchar(char c)</span><br><span class="line">&#123;</span><br><span class="line">    UartPutc(c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    P0M1 = 0x00;//配置端口为准双向模式</span><br><span class="line">    P0M0 = 0x00;</span><br><span class="line"></span><br><span class="line">    P1M1 = 0x00;</span><br><span class="line">    P1M0 = 0x00;</span><br><span class="line">    UartInit();//串口初始化</span><br><span class="line">    printf(&quot;STC15L2K60S2 nRF24L01 Send !\r\n&quot;); //UART发送一个字符串</span><br><span class="line"></span><br><span class="line">    if(NRF_CONFIG(NRF_TX))//nrf初始化，配置为发送模式</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;nRF24L01 Send Init error!\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else printf(&quot;nRF24L01 Send Init success!\r\n&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(P00 == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_TxOrRxPack(NRF_TX, sendbuf, 32, 100);//P35按键按下，发送数据</span><br><span class="line">            printf(&quot;Send!\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;STC15F2K60S2.H&gt;</p><p>#include &lt;NRF24L01.h&gt;<br>#include &lt;intrins.h&gt;<br>#include “stdio.h”<br>xdata u8 sendbuf[32] &#x3D; “Hello World!Perseverance9527”;<br>#define MAIN_Fosc   11059200UL<br>#define Baudrate    115200L<br>#define TM          (65536 -(MAIN_Fosc&#x2F;Baudrate&#x2F;4))<br>&#x2F;&#x2F;配置串口1初始化函数<br>void UartInit(void)<br>{<br>    SCON &#x3D; (SCON &amp; 0x3f) | 0x40;<br>    T2L  &#x3D; TM;<br>    T2H  &#x3D; TM &gt;&gt; 8;<br>    AUXR |&#x3D; 0x15;<br>}<br>&#x2F;&#x2F;串口单字符输出函数<br>void UartPutc(unsigned char dat)<br>{<br>    SBUF &#x3D; dat;<br>    while(TI &#x3D;&#x3D; 0);<br>    TI &#x3D; 0;<br>}<br>&#x2F;&#x2F;配置printf函数，需包含stdio.h头文件<br>char putchar(char c)<br>{<br>    UartPutc(c);<br>    return c;<br>}</p><p>void main(void)<br>{</p><pre><code>P0M1 = 0x00;//配置端口为准双向模式P0M0 = 0x00;P1M1 = 0x00;P1M0 = 0x00;UartInit();//串口初始化printf(&quot;STC15L2K60S2 nRF24L01 Send !\r\n&quot;); //UART发送一个字符串if(NRF_CONFIG(NRF_TX))//nrf初始化，配置为发送模式&#123;    printf(&quot;nRF24L01 Send Init error!\r\n&quot;);&#125;else printf(&quot;nRF24L01 Send Init success!\r\n&quot;);while(1)&#123;    if(P00 == 0)    &#123;        NRF_TxOrRxPack(NRF_TX, sendbuf, 32, 100);//P35按键按下，发送数据        printf(&quot;Send!\r\n&quot;);    &#125;&#125;</code></pre><p>}&#96;</p><h4 id="📝接收端主程序"><a href="#📝接收端主程序" class="headerlink" title="📝接收端主程序"></a>📝接收端主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;STC15F2K60S2.H&gt;</span><br><span class="line">#include &lt;NRF24L01.h&gt;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">xdata u8 Rece_buf[32] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">#define MAIN_Fosc   11059200UL</span><br><span class="line">#define Baudrate    115200L</span><br><span class="line">#define TM          (65536 -(MAIN_Fosc/Baudrate/4))</span><br><span class="line">void UartInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    SCON = (SCON &amp; 0x3f) | 0x40;</span><br><span class="line">    T2L  = TM;</span><br><span class="line">    T2H  = TM &gt;&gt; 8;</span><br><span class="line">    AUXR |= 0x15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UartPutc(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    SBUF = dat;</span><br><span class="line">    while(TI == 0);</span><br><span class="line">    TI = 0;</span><br><span class="line">&#125;</span><br><span class="line">char putchar(char c)</span><br><span class="line">&#123;</span><br><span class="line">    UartPutc(c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    P0M1 = 0x00;</span><br><span class="line">    P0M0 = 0x00;</span><br><span class="line"></span><br><span class="line">    P1M1 = 0x00;</span><br><span class="line">    P1M0 = 0x00;</span><br><span class="line">    UartInit();</span><br><span class="line">    printf(&quot;STC15L2K60S2 nRF24L01 Receve !\r\n&quot;); //UART发送一个字符串</span><br><span class="line">    if(NRF_CONFIG(NRF_RX))//检测设备在线</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;nRF24L01 Receve Init error!\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else printf(&quot;nRF24L01 Receve Init success!\r\n&quot;);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(NRF_TxOrRxPack(NRF_RX, Rece_buf, 32, 100) == RX_OK)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;Receve data: %s \r\n&quot;, Rece_buf);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include &lt;STC15F2K60S2.H&gt;<br>#include &lt;NRF24L01.h&gt;<br>#include &lt;intrins.h&gt;<br>#include “stdio.h”<br>xdata u8 Rece_buf[32] &#x3D; {0};</p><p>#define MAIN_Fosc   11059200UL<br>#define Baudrate    115200L<br>#define TM          (65536 -(MAIN_Fosc&#x2F;Baudrate&#x2F;4))<br>void UartInit(void)<br>{<br>    SCON &#x3D; (SCON &amp; 0x3f) | 0x40;<br>    T2L  &#x3D; TM;<br>    T2H  &#x3D; TM &gt;&gt; 8;<br>    AUXR |&#x3D; 0x15;<br>}</p><p>void UartPutc(unsigned char dat)<br>{<br>    SBUF &#x3D; dat;<br>    while(TI &#x3D;&#x3D; 0);<br>    TI &#x3D; 0;<br>}<br>char putchar(char c)<br>{<br>    UartPutc(c);<br>    return c;<br>}<br>void main(void)<br>{</p><pre><code>P0M1 = 0x00;P0M0 = 0x00;P1M1 = 0x00;P1M0 = 0x00;UartInit();printf(&quot;STC15L2K60S2 nRF24L01 Receve !\r\n&quot;); //UART发送一个字符串if(NRF_CONFIG(NRF_RX))//检测设备在线&#123;    printf(&quot;nRF24L01 Receve Init error!\r\n&quot;);&#125;else printf(&quot;nRF24L01 Receve Init success!\r\n&quot;);while(1)&#123;    if(NRF_TxOrRxPack(NRF_RX, Rece_buf, 32, 100) == RX_OK)    &#123;        printf(&quot;Receve data: %s \r\n&quot;, Rece_buf);    &#125;&#125;</code></pre><p>}&#96;</p><h4 id="📚程序源码"><a href="#📚程序源码" class="headerlink" title="📚程序源码"></a>📚程序源码</h4><ul><li>🌿发射端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1F6fqcEtJ6YgzBUVSQpXyxg</span><br><span class="line">提取码: angp</span><br></pre></td></tr></table></figure><p><code>链接: https://pan.baidu.com/s/1F6fqcEtJ6YgzBUVSQpXyxg 提取码: angp</code></p><ul><li>🌿接收端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1xuyyzrzSCkL401JuEYlZ1w</span><br><span class="line">提取码: gsng</span><br></pre></td></tr></table></figure><p><code>链接: https://pan.baidu.com/s/1xuyyzrzSCkL401JuEYlZ1w 提取码: gsng</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC单片机 NRF24L01通讯带状态反馈</title>
      <link href="/2024/03/STC-STC%E5%8D%95%E7%89%87%E6%9C%BA-NRF24L01%E9%80%9A%E8%AE%AF%E5%B8%A6%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88/"/>
      <url>/2024/03/STC-STC%E5%8D%95%E7%89%87%E6%9C%BA-NRF24L01%E9%80%9A%E8%AE%AF%E5%B8%A6%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC单片机-NRF24L01通讯带状态反馈"><a href="#STC单片机-NRF24L01通讯带状态反馈" class="headerlink" title="STC单片机 NRF24L01通讯带状态反馈"></a>STC单片机 NRF24L01通讯带状态反馈</h1><h3 id="STC单片机-NRF24L01通讯带状态反馈-1"><a href="#STC单片机-NRF24L01通讯带状态反馈-1" class="headerlink" title="STC单片机 NRF24L01通讯带状态反馈"></a>STC单片机 NRF24L01通讯带状态反馈</h3><ul><li>📍相关篇《STC单片机 NRF24L01通讯实验》</li><li>🔖验证对象：STC15L2K60S2</li><li>📍STC15L2K60S2自制系统板开源地址：<a href="https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban">https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban</a></li><li>⏱时钟频率：11.0592MHz</li><li>🌼NRF24L01模块以及接线说明</li></ul><p>📍相关篇《STC单片机 NRF24L01通讯实验》</p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/130617473">STC单片机 NRF24L01通讯实验</a></p><p>🔖验证对象：STC15L2K60S2</p><p><code>STC15L2K60S2</code></p><p>📍STC15L2K60S2自制系统板开源地址：<a href="https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban">https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban</a></p><p><code>https://oshwhub.com/perseverance51/stc15l2k60s2-ji-tong-ban</code></p><p>⏱时钟频率：11.0592MHz</p><p><code>11.0592</code></p><p>🌼NRF24L01模块以及接线说明</p><p><img src="https://img-blog.csdnimg.cn/5d5bcb8f8b6d4111853f7bc829f908a4.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/9b324a8c32844043ad60c56258b80fcd.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">----------------------</span><br><span class="line">   VCC CSN MOSI IRQ</span><br><span class="line">   GND CE  SCK  MISO</span><br><span class="line">----------------------</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define SCK  P17</span><br><span class="line">#define MISO P16</span><br><span class="line">#define MOSI P15</span><br><span class="line">#define CSN  P13</span><br><span class="line">#define CE   P12</span><br><span class="line">#define IRQ  P14</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="&#96;&#x2F;*"></a>&#96;&#x2F;*</h2><h2 id="VCC-CSN-MOSI-IRQ-GND-CE-SCK-MISO"><a href="#VCC-CSN-MOSI-IRQ-GND-CE-SCK-MISO" class="headerlink" title="   VCC CSN MOSI IRQ   GND CE  SCK  MISO"></a>   VCC CSN MOSI IRQ<br>   GND CE  SCK  MISO</h2><p>*&#x2F;</p><p>#define SCK  P17<br>#define MISO P16<br>#define MOSI P15<br>#define CSN  P13<br>#define CE   P12<br>#define IRQ  P14&#96;</p><ul><li>✨在上面一篇的基础上增加了接收端状态反馈，如果发射端发送的数据，接收端没有收到信息或由于自身的原因发送失败，在发射端的串口调试信息里面输出对应的相关提示信息。</li></ul><h5 id="✨在上面一篇的基础上增加了接收端状态反馈，如果发射端发送的数据，接收端没有收到信息或由于自身的原因发送失败，在发射端的串口调试信息里面输出对应的相关提示信息。"><a href="#✨在上面一篇的基础上增加了接收端状态反馈，如果发射端发送的数据，接收端没有收到信息或由于自身的原因发送失败，在发射端的串口调试信息里面输出对应的相关提示信息。" class="headerlink" title="✨在上面一篇的基础上增加了接收端状态反馈，如果发射端发送的数据，接收端没有收到信息或由于自身的原因发送失败，在发射端的串口调试信息里面输出对应的相关提示信息。"></a>✨在上面一篇的基础上增加了接收端状态反馈，如果发射端发送的数据，接收端没有收到信息或由于自身的原因发送失败，在发射端的串口调试信息里面输出对应的相关提示信息。</h5><p><img src="https://img-blog.csdnimg.cn/107bd622cc3942ca8c314d5abcfa75a6.png" alt="在这里插入图片描述"></p><ul><li>🍭本例程程序接收端程序值添加检测状态指示灯主要是针对对发射端的程序做了内容新增。</li></ul><h4 id="📝发射端主程序"><a href="#📝发射端主程序" class="headerlink" title="📝发射端主程序"></a>📝发射端主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;NRF24L01.h&quot;</span><br><span class="line">#include &quot;LED.h&quot;</span><br><span class="line">#include &lt;intrins.h&gt;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">xdata u8 sendbuf[32] = &quot;Hello World!Perseverance9527&quot;;</span><br><span class="line">#define MAIN_Fosc   11059200UL</span><br><span class="line">#define Baudrate    115200L</span><br><span class="line">#define TM          (65536 -(MAIN_Fosc/Baudrate/4))</span><br><span class="line">//配置串口1初始化函数</span><br><span class="line">void UartInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    SCON = (SCON &amp; 0x3f) | 0x40;</span><br><span class="line">    T2L  = TM;</span><br><span class="line">    T2H  = TM &gt;&gt; 8;</span><br><span class="line">    AUXR |= 0x15;</span><br><span class="line">&#125;</span><br><span class="line">//串口单字符输出函数</span><br><span class="line">void UartPutc(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    SBUF = dat;</span><br><span class="line">    while(TI == 0);</span><br><span class="line">    TI = 0;</span><br><span class="line">&#125;</span><br><span class="line">//配置printf函数，需包含stdio.h头文件</span><br><span class="line">char putchar(char c)</span><br><span class="line">&#123;</span><br><span class="line">    UartPutc(c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">/* Private function prototypes------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* @name   GPIO_Init</span><br><span class="line">* @brief  通用输入输出端口初始化</span><br><span class="line">* @param  None</span><br><span class="line">* @retval None</span><br><span class="line">*/</span><br><span class="line">static void GPIO_Init()</span><br><span class="line">&#123;</span><br><span class="line">    //M1  M0</span><br><span class="line">    //0   0     准双向口</span><br><span class="line">    //0   1     推挽输出</span><br><span class="line">    //1   0     高阻输入</span><br><span class="line">    //1   1     开漏</span><br><span class="line"></span><br><span class="line">    //P3</span><br><span class="line">    //P32设置为高阻输入</span><br><span class="line">    //P34,P35设置为推挽输出</span><br><span class="line">    P3M1 = 0x04; //0000 0100</span><br><span class="line">    P3M0 = 0x30; //0011 0000</span><br><span class="line"></span><br><span class="line">    P34  = 0;  //关闭运行指示灯</span><br><span class="line">    P35  = 0;  //关闭PWM指示灯</span><br><span class="line"></span><br><span class="line">    P0M1 = 0x00;//配置端口为准双向模式</span><br><span class="line">    P0M0 = 0x00;</span><br><span class="line"></span><br><span class="line">    P1M1 = 0x00;</span><br><span class="line">    P1M0 = 0x00;</span><br><span class="line">&#125;</span><br><span class="line"> /***********************************************</span><br><span class="line">函数名称：Delay_ms</span><br><span class="line">功    能：STC15系列单片机1ms延时程序</span><br><span class="line">入口参数：ms:延时的毫秒数</span><br><span class="line">返 回 值：无</span><br><span class="line">备    注：示波器实测：0.997ms，内部时钟：11.0592MHz           </span><br><span class="line">************************************************/</span><br><span class="line">void Delay_ms(unsigned int ms)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int i;</span><br><span class="line">  while( (ms--) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">    for(i = 0; i &lt; 580; i++); </span><br><span class="line">   &#125;             </span><br><span class="line">&#125;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_Init();</span><br><span class="line">    UartInit();//串口初始化</span><br><span class="line">    printf(&quot;STC15L2K60S2 nRF24L01 Send !\r\n&quot;); //UART发送一个字符串</span><br><span class="line"></span><br><span class="line">    if(NRF_CONFIG(NRF_TX))//nrf初始化，配置为发送模式</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;nRF24L01 Send Init error!\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">&#123;</span><br><span class="line">LED_Run.LED_Flip();</span><br><span class="line">Delay_ms(80);</span><br><span class="line">LED_Run.LED_Flip();</span><br><span class="line">Delay_ms(80);</span><br><span class="line">LED_Run.LED_Flip();</span><br><span class="line">Delay_ms(80);</span><br><span class="line">LED_Run.LED_OFF();</span><br><span class="line">printf(&quot;nRF24L01 Send Init success!\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(P00 == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_TxOrRxPack(NRF_TX, sendbuf, 32, 100);//P35按键按下，发送数据</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “NRF24L01.h”<br>#include “LED.h”<br>#include &lt;intrins.h&gt;<br>#include “stdio.h”<br>xdata u8 sendbuf[32] &#x3D; “Hello World!Perseverance9527”;<br>#define MAIN_Fosc   11059200UL<br>#define Baudrate    115200L<br>#define TM          (65536 -(MAIN_Fosc&#x2F;Baudrate&#x2F;4))<br>&#x2F;&#x2F;配置串口1初始化函数<br>void UartInit(void)<br>{<br>    SCON &#x3D; (SCON &amp; 0x3f) | 0x40;<br>    T2L  &#x3D; TM;<br>    T2H  &#x3D; TM &gt;&gt; 8;<br>    AUXR |&#x3D; 0x15;<br>}<br>&#x2F;&#x2F;串口单字符输出函数<br>void UartPutc(unsigned char dat)<br>{<br>    SBUF &#x3D; dat;<br>    while(TI &#x3D;&#x3D; 0);<br>    TI &#x3D; 0;<br>}<br>&#x2F;&#x2F;配置printf函数，需包含stdio.h头文件<br>char putchar(char c)<br>{<br>    UartPutc(c);<br>    return c;<br>}<br>&#x2F;* Private function prototypes————————————————*&#x2F;</p><p>&#x2F;*<br>    * @name   GPIO_Init<br>    * @brief  通用输入输出端口初始化<br>    * @param  None<br>    * @retval None<br>*&#x2F;<br>static void GPIO_Init()<br>{<br>    &#x2F;&#x2F;M1  M0<br>    &#x2F;&#x2F;0   0     准双向口<br>    &#x2F;&#x2F;0   1     推挽输出<br>    &#x2F;&#x2F;1   0     高阻输入<br>    &#x2F;&#x2F;1   1     开漏</p><pre><code>//P3//P32设置为高阻输入//P34,P35设置为推挽输出P3M1 = 0x04; //0000 0100P3M0 = 0x30; //0011 0000P34  = 0;  //关闭运行指示灯P35  = 0;  //关闭PWM指示灯P0M1 = 0x00;//配置端口为准双向模式P0M0 = 0x00;P1M1 = 0x00;P1M0 = 0x00;</code></pre><p>}<br> &#x2F;***********************************************<br>函数名称：Delay_ms<br>功    能：STC15系列单片机1ms延时程序<br>入口参数：ms:延时的毫秒数<br>返 回 值：无<br>备    注：示波器实测：0.997ms，内部时钟：11.0592MHz<br>************************************************&#x2F;<br>void Delay_ms(unsigned int ms)<br>{<br>      unsigned int i;<br>      while( (ms–) !&#x3D; 0)<br>       {<br>        for(i &#x3D; 0; i &lt; 580; i++);<br>       }<br>}<br>void main(void)<br>{</p><pre><code>    GPIO_Init();UartInit();//串口初始化printf(&quot;STC15L2K60S2 nRF24L01 Send !\r\n&quot;); //UART发送一个字符串if(NRF_CONFIG(NRF_TX))//nrf初始化，配置为发送模式&#123;    printf(&quot;nRF24L01 Send Init error!\r\n&quot;);&#125;else    &#123;        LED_Run.LED_Flip();        Delay_ms(80);        LED_Run.LED_Flip();        Delay_ms(80);        LED_Run.LED_Flip();        Delay_ms(80);        LED_Run.LED_OFF();        printf(&quot;nRF24L01 Send Init success!\r\n&quot;);    &#125;while(1)&#123;    if(P00 == 0)    &#123;        NRF_TxOrRxPack(NRF_TX, sendbuf, 32, 100);//P35按键按下，发送数据            &#125;&#125;</code></pre><p>}&#96;</p><h4 id="📚程序源码（包含收发程）"><a href="#📚程序源码（包含收发程）" class="headerlink" title="📚程序源码（包含收发程）"></a>📚程序源码（包含收发程）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1dwXcKhQWzoho2XAOHUzoZw</span><br><span class="line">提取码: si3t</span><br></pre></td></tr></table></figure><p><code>链接: https://pan.baidu.com/s/1dwXcKhQWzoho2XAOHUzoZw 提取码: si3t</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266 + STC15基于AT指令通过TCP通讯协议控制IO状态</title>
      <link href="/2024/03/Stc15-ESP8266-STC15%E5%9F%BA%E4%BA%8EAT%E6%8C%87%E4%BB%A4%E9%80%9A%E8%BF%87TCP%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6IO%E7%8A%B6%E6%80%81/"/>
      <url>/2024/03/Stc15-ESP8266-STC15%E5%9F%BA%E4%BA%8EAT%E6%8C%87%E4%BB%A4%E9%80%9A%E8%BF%87TCP%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6IO%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="ESP8266-STC15基于AT指令通过TCP通讯协议控制IO状态"><a href="#ESP8266-STC15基于AT指令通过TCP通讯协议控制IO状态" class="headerlink" title="ESP8266 + STC15基于AT指令通过TCP通讯协议控制IO状态"></a>ESP8266 + STC15基于AT指令通过TCP通讯协议控制IO状态</h1><h3 id="ESP8266-STC15基于AT指令通过TCP通讯协议控制IO状态-1"><a href="#ESP8266-STC15基于AT指令通过TCP通讯协议控制IO状态-1" class="headerlink" title="ESP8266 + STC15基于AT指令通过TCP通讯协议控制IO状态"></a>ESP8266 + STC15基于AT指令通过TCP通讯协议控制IO状态</h3><ul><li>📌ESP8266 AT固件基于安信可AT固件，相关刷AT固件可以参考《NodeMCU-刷写AT固件》</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/116032378">NodeMCU-刷写AT固件</a></p><p>当然WIFI模块也可以是esp01.</p><ul><li>STC15 单片机采用的是：STC15F2K60S2 晶振频率采用内部：22.1184MHz</li></ul><p><code>STC15F2K60S2</code></p><p><code>22.1184</code></p><h4 id="🌼功能介绍"><a href="#🌼功能介绍" class="headerlink" title="🌼功能介绍"></a>🌼功能介绍</h4><p>通过电脑端的网络调试助手，给建立TCP连接端的esp8266发送指定的控制指令后，esp8266将收到的数据通过串口发给STC15单片机，STC15单片机串口2对接收到的数据进行处理，从而实现远程控制功能。STC15开启双串口，串口2用于和esp8266通讯，串口1用于查看调试信息。</p><p><img src="https://img-blog.csdnimg.cn/9b9b307c24e9440295956ffcfad840bb.png" alt="在这里插入图片描述"></p><h4 id="📑原理实现介绍"><a href="#📑原理实现介绍" class="headerlink" title="📑原理实现介绍"></a>📑原理实现介绍</h4><ul><li>ESP8266模块单独刷完AT固件后，在电脑端开启一个TCP服务端，用于给esp8266来连接的。esp8266烧录完AT固件后，默认串口通讯波特率为115200，esp8266串口和STC15单片机串口2（P10，P11），进行连接。通过STC15单片机的串口2发送相对应TCP连接AT指令给esp8266,来主动连接电脑端开启的TCP服务端。建立连接后，通过电脑端的TCP服务端给esp8266发送数据，esp8266 TCP客户端接收到数据后通过串口将接收到的数据发给stc15单片机。</li></ul><p><code>115200</code></p><h4 id="🍁通讯方式"><a href="#🍁通讯方式" class="headerlink" title="🍁通讯方式"></a>🍁通讯方式</h4><ul><li><p>esp8266 —上位机软件（网络调试助手）通过局域网TCP通讯</p></li><li><p>esp8266 —STC15单片机通过串口通讯。</p></li><li><p>esp8266收到上位机软件放过来的数据后，将数据通过串口发给STC15单片机。</p></li></ul><h4 id="🛠ESP8266模块配置"><a href="#🛠ESP8266模块配置" class="headerlink" title="🛠ESP8266模块配置"></a>🛠ESP8266模块配置</h4><ul><li>烧录完AT固件后，将网络信息配置到里面，为什么不将配网信息放到单片机里面是因为模块配网时间可能比较长。（如果想放到stc15单片机程序里也是可以的，只是增加2条发送指令而已）。</li><li>通过串口发送AT指令，提前将WIFI接入信息存到esp8266中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AT+CWMODE=1//配置STA模式</span><br><span class="line">AT+CWJAP_DEF=&quot;MERCURY_D268G&quot;,&quot;pba5ayzk&quot;//配置WIFI，信息掉电不丢失</span><br></pre></td></tr></table></figure><p><code>AT+CWMODE=1//配置STA模式 AT+CWJAP_DEF=&quot;MERCURY_D268G&quot;,&quot;pba5ayzk&quot;//配置WIFI，信息掉电不丢失</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ai-Thinker Technology Co. Ltd.</span><br><span class="line"></span><br><span class="line">ready</span><br><span class="line">WIFI CONNECTED</span><br><span class="line">WIFI GOT IP</span><br><span class="line">AT+CWMODE=1</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">AT+CWJAP_DEF=&quot;MERCURY_D268G&quot;,&quot;pba5ayzk&quot;</span><br><span class="line">WIFI CONNECTED</span><br><span class="line">WIFI GOT IP</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>&#96;Ai-Thinker Technology Co. Ltd.</p><p>ready<br>WIFI CONNECTED<br>WIFI GOT IP<br>AT+CWMODE&#x3D;1</p><p>OK<br>AT+CWJAP_DEF&#x3D;”MERCURY_D268G”,”pba5ayzk”<br>WIFI CONNECTED<br>WIFI GOT IP</p><p>OK&#96;</p><p><img src="https://img-blog.csdnimg.cn/1a5c03e9f8f34842a3d1aa8793de63c8.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/942aa62d2f3f4045a4e1cac96a799cc8.png" alt="在这里插入图片描述"></p><h4 id="⛳注意事项"><a href="#⛳注意事项" class="headerlink" title="⛳注意事项"></a>⛳注意事项</h4><ul><li>⚡如果在打开网络调试助手TCP server不能成功连接的情况，那么说明默认的8080端口被其他通讯连接占用了，换一个端口号即可。改成其他的端口号。</li></ul><p><code>8080</code></p><p><img src="https://img-blog.csdnimg.cn/286aa4f93b3e49168b330f0fc443b245.png" alt="在这里插入图片描述"></p><h4 id="📝主程序代码"><a href="#📝主程序代码" class="headerlink" title="📝主程序代码"></a>📝主程序代码</h4><ul><li>🌿工程架构</li></ul><p><img src="https://img-blog.csdnimg.cn/84e93f8377bc4e25ae6c9988ec38c124.png" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;delay.h&quot;</span><br><span class="line">#include &quot;uart.h&quot;</span><br><span class="line">#include &quot;esp8266.h&quot;</span><br><span class="line"></span><br><span class="line">sbit led1 = P0 ^ 6;</span><br><span class="line">sbit led2 = P0 ^ 7;</span><br><span class="line"></span><br><span class="line">uint16 b;</span><br><span class="line">uint8 RE_Data;</span><br><span class="line">uint8 RE_flag = 0;</span><br><span class="line">void Uart2_Init(void);//P1.0/RxD_2,P1.1/TxD_2</span><br><span class="line">void Uart1_Init(void);//串口1：115200bps@22.1184MHz</span><br><span class="line">/*********************定时器函数************************************/</span><br><span class="line"></span><br><span class="line">void Timer0Init()       //2毫秒@22.1184MHz</span><br><span class="line">&#123;</span><br><span class="line">    AUXR |= 0x80;       //定时器时钟1T模式</span><br><span class="line">    TMOD &amp;= 0xF0;       //设置定时器模式</span><br><span class="line">    TL0 = 0x33;             //设置定时初始值</span><br><span class="line">    TH0 = 0x53;             //设置定时初始值</span><br><span class="line">    TF0 = 0;        //清除TF0标志</span><br><span class="line">    TR0 = 1;        //定时器0开始计时</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void timer0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TL0 = 0x33;             //设置定时初始值</span><br><span class="line">    TH0 = 0x53;             //设置定时初始值</span><br><span class="line">    TF0 = 0;</span><br><span class="line">    b++;</span><br><span class="line">    if (b &gt; 500)</span><br><span class="line">    &#123;</span><br><span class="line">        b = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">//    Timer0Init();//初始化定时器0</span><br><span class="line">    ET0 = 1; //开启定时器0中断</span><br><span class="line">    EA = 1; //开启总中断</span><br><span class="line">    Delayus(6000);</span><br><span class="line">    P0M0 = 0X00;</span><br><span class="line">    P0M1 = 0X00;</span><br><span class="line">    P1M0 = 0X00;</span><br><span class="line">    P1M1 = 0X00;</span><br><span class="line">    P2M0 = 0X00;</span><br><span class="line">    P2M1 = 0X00;</span><br><span class="line">    P3M0 = 0X00;</span><br><span class="line">    P3M1 = 0X00;</span><br><span class="line">    P4M0 = 0X00;</span><br><span class="line">    P4M1 = 0X00;</span><br><span class="line">    Uart2_Init();</span><br><span class="line">    Uart1_Init();</span><br><span class="line">    ESP8266_Init();</span><br><span class="line">    led1 = 0;</span><br><span class="line">    led2 = 0;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        if (RE_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            UART1_SendStr(&amp;RE_Data);</span><br><span class="line">            RE_flag = 0;</span><br><span class="line">            if (RE_Data == &#x27;1&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                led1 = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (RE_Data == &#x27;2&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                led1 = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (RE_Data == &#x27;3&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                led2 = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (RE_Data == &#x27;4&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                led2 = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (RE_Data == &#x27;5&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                led1 = 0;</span><br><span class="line">                led2 = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (RE_Data == &#x27;6&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                led1 = 1;</span><br><span class="line">                led2 = 1;</span><br><span class="line">            &#125;</span><br><span class="line">RE_Data=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*----------------------------</span><br><span class="line">UART 中断服务程序</span><br><span class="line">-----------------------------*/</span><br><span class="line">void Uart() interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    if (RI)</span><br><span class="line">    &#123;</span><br><span class="line">        RI = 0;                 //清除RI位</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (TI)</span><br><span class="line">    &#123;</span><br><span class="line">        TI = 0;                 //清除TI位</span><br><span class="line">        UART1_busy = 0;               //清忙标志</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Uart2() interrupt 8 using 1</span><br><span class="line">&#123;</span><br><span class="line">    static  uint8 a = 0, value = 0;</span><br><span class="line"></span><br><span class="line">    if (S2CON &amp; S2RI)</span><br><span class="line">    &#123;</span><br><span class="line">        S2CON &amp;= ~S2RI;   //清除S2RI</span><br><span class="line">        value = S2BUF;</span><br><span class="line">        if (value == &#x27;:&#x27;) //接收到&quot;48:&quot;时，说明后面的就是时间报文了</span><br><span class="line">        &#123;</span><br><span class="line">            a = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            if (num == 2)</span><br><span class="line">            &#123;</span><br><span class="line">                RE_Data = S2BUF;</span><br><span class="line">                num = 0;</span><br><span class="line">                a = 0;</span><br><span class="line">                RE_flag = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (S2CON &amp; S2TI)</span><br><span class="line">    &#123;</span><br><span class="line">        S2CON &amp;= ~S2TI;         //清除S2TI位</span><br><span class="line">        UART2_busy = 0;               //清忙标志</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “delay.h”<br>#include “uart.h”<br>#include “esp8266.h”</p><p>sbit led1 &#x3D; P0 ^ 6;<br>sbit led2 &#x3D; P0 ^ 7;</p><p>uint16 b;<br>uint8 RE_Data;<br>uint8 RE_flag &#x3D; 0;<br>void Uart2_Init(void);&#x2F;&#x2F;P1.0&#x2F;RxD_2,P1.1&#x2F;TxD_2<br>void Uart1_Init(void);&#x2F;&#x2F;串口1：<a href="mailto:&#x31;&#49;&#53;&#x32;&#x30;&#48;&#98;&#112;&#115;&#64;&#x32;&#50;&#46;&#49;&#x31;&#x38;&#52;&#x4d;&#72;&#x7a;">&#x31;&#49;&#53;&#x32;&#x30;&#48;&#98;&#112;&#115;&#64;&#x32;&#50;&#46;&#49;&#x31;&#x38;&#52;&#x4d;&#72;&#x7a;</a><br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>定时器函数</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>***************&#x2F;</p><p>void Timer0Init()       &#x2F;&#x2F;2毫秒@22.1184MHz<br>{<br>    AUXR |&#x3D; 0x80;       &#x2F;&#x2F;定时器时钟1T模式<br>    TMOD &amp;&#x3D; 0xF0;       &#x2F;&#x2F;设置定时器模式<br>    TL0 &#x3D; 0x33;             &#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0x53;             &#x2F;&#x2F;设置定时初始值<br>    TF0 &#x3D; 0;        &#x2F;&#x2F;清除TF0标志<br>    TR0 &#x3D; 1;        &#x2F;&#x2F;定时器0开始计时<br>}</p><p>void timer0() interrupt 1<br>{<br>    TL0 &#x3D; 0x33;             &#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0x53;             &#x2F;&#x2F;设置定时初始值<br>    TF0 &#x3D; 0;<br>    b++;<br>    if (b &gt; 500)<br>    {<br>        b &#x3D; 0;</p><pre><code>&#125;</code></pre><p>}</p><p>void main()<br>{<br>&#x2F;&#x2F;    Timer0Init();&#x2F;&#x2F;初始化定时器0<br>    ET0 &#x3D; 1; &#x2F;&#x2F;开启定时器0中断<br>    EA &#x3D; 1; &#x2F;&#x2F;开启总中断<br>    Delayus(6000);<br>    P0M0 &#x3D; 0X00;<br>    P0M1 &#x3D; 0X00;<br>    P1M0 &#x3D; 0X00;<br>    P1M1 &#x3D; 0X00;<br>    P2M0 &#x3D; 0X00;<br>    P2M1 &#x3D; 0X00;<br>    P3M0 &#x3D; 0X00;<br>    P3M1 &#x3D; 0X00;<br>    P4M0 &#x3D; 0X00;<br>    P4M1 &#x3D; 0X00;<br>    Uart2_Init();<br>    Uart1_Init();<br>    ESP8266_Init();<br>    led1 &#x3D; 0;<br>    led2 &#x3D; 0;<br>    while (1)<br>    {<br>        if (RE_flag)<br>        {<br>            UART1_SendStr(&amp;RE_Data);<br>            RE_flag &#x3D; 0;<br>            if (RE_Data &#x3D;&#x3D; ‘1’)<br>            {<br>                led1 &#x3D; 0;<br>            }<br>            if (RE_Data &#x3D;&#x3D; ‘2’)<br>            {<br>                led1 &#x3D; 1;<br>            }<br>            if (RE_Data &#x3D;&#x3D; ‘3’)<br>            {<br>                led2 &#x3D; 0;<br>            }<br>            if (RE_Data &#x3D;&#x3D; ‘4’)<br>            {<br>                led2 &#x3D; 1;<br>            }<br>            if (RE_Data &#x3D;&#x3D; ‘5’)<br>            {<br>                led1 &#x3D; 0;<br>                led2 &#x3D; 0;<br>            }<br>            if (RE_Data &#x3D;&#x3D; ‘6’)<br>            {<br>                led1 &#x3D; 1;<br>                led2 &#x3D; 1;<br>            }<br>                    RE_Data&#x3D;0;<br>        }<br>    }<br>}</p><p>&#x2F;<em>—————————-<br>UART 中断服务程序<br>—————————–</em>&#x2F;<br>void Uart() interrupt 4<br>{<br>    if (RI)<br>    {<br>        RI &#x3D; 0;                 &#x2F;&#x2F;清除RI位</p><pre><code>&#125;if (TI)&#123;    TI = 0;                 //清除TI位    UART1_busy = 0;               //清忙标志&#125;</code></pre><p>}</p><p>void Uart2() interrupt 8 using 1<br>{<br>    static  uint8 a &#x3D; 0, value &#x3D; 0;</p><pre><code>if (S2CON &amp; S2RI)&#123;    S2CON &amp;= ~S2RI;   //清除S2RI    value = S2BUF;    if (value == &#39;:&#39;) //接收到&quot;48:&quot;时，说明后面的就是时间报文了    &#123;        a = 1;    &#125;    if (a == 1)    &#123;        num++;        if (num == 2)        &#123;            RE_Data = S2BUF;            num = 0;            a = 0;            RE_flag = 1;        &#125;    &#125;&#125;if (S2CON &amp; S2TI)&#123;    S2CON &amp;= ~S2TI;         //清除S2TI位    UART2_busy = 0;               //清忙标志&#125;</code></pre><p>}&#96;</p><h4 id="📚工程源码"><a href="#📚工程源码" class="headerlink" title="📚工程源码"></a>📚工程源码</h4><ul><li>📍包含网络调试助手</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/1IxLv8_0TPdnaCJGDFXudKQ</span><br><span class="line">提取码: evu2</span><br></pre></td></tr></table></figure><p><code>链接: https://pan.baidu.com/s/1IxLv8_0TPdnaCJGDFXudKQ 提取码: evu2</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15单片机+DHT11+LCD1602+PCF8574转IIC接口温度显示</title>
      <link href="/2024/03/Stc15-STC15%E5%8D%95%E7%89%87%E6%9C%BADHT11LCD1602PCF8574%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E6%B8%A9%E5%BA%A6%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Stc15-STC15%E5%8D%95%E7%89%87%E6%9C%BADHT11LCD1602PCF8574%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E6%B8%A9%E5%BA%A6%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15单片机-DHT11-LCD1602-PCF8574转IIC接口温度显示"><a href="#STC15单片机-DHT11-LCD1602-PCF8574转IIC接口温度显示" class="headerlink" title="STC15单片机+DHT11+LCD1602+PCF8574转IIC接口温度显示"></a>STC15单片机+DHT11+LCD1602+PCF8574转IIC接口温度显示</h1><h3 id="STC15单片机-DHT11-LCD1602-PCF8574转IIC接口温度显示-1"><a href="#STC15单片机-DHT11-LCD1602-PCF8574转IIC接口温度显示-1" class="headerlink" title="STC15单片机+DHT11+LCD1602+PCF8574转IIC接口温度显示"></a>STC15单片机+DHT11+LCD1602+PCF8574转IIC接口温度显示</h3><ul><li>📺效果演示：</li><li>🌿LCD1602+PCF8574转IIC接口屏幕</li><li>🌿DHT11温湿度传感器</li></ul><p><img src="https://img-blog.csdnimg.cn/4c6212081a8844678e988c342d285d77.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/6e0117743c2846b6a1d8ab881a01844b.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/cf01c46c02f94e03814fd2dbadab36de.png" alt="在这里插入图片描述"></p><p>本示例基于自制的STC开发板，主控采用的：IAP15W4K61S4</p><p><code>IAP15W4K61S4</code></p><ul><li>相关篇《【PCB开源分享】STC&#x2F;IAP15W4K61S4开发板》</li><li>《【开源分享】自制STC15W408AS开发板》</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/126185155">【PCB开源分享】STC&#x2F;IAP15W4K61S4开发板</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/122150323">【开源分享】自制STC15W408AS开发板</a></p><h4 id="🌼接线说明"><a href="#🌼接线说明" class="headerlink" title="🌼接线说明"></a>🌼接线说明</h4><ul><li>🌴LCD1602+PCF8574转IIC接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCL -----&gt; STC15 P1.0</span><br><span class="line">SDA -----&gt; STC15 P1.1</span><br></pre></td></tr></table></figure><p><code>SCL -----&gt; STC15 P1.0 SDA -----&gt; STC15 P1.1</code></p><ul><li>🌴DHT11</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA -----&gt; P1.3</span><br></pre></td></tr></table></figure><p><code>DATA -----&gt; P1.3</code></p><ul><li>✅工程架构</li></ul><p><img src="https://img-blog.csdnimg.cn/b2a2b44ba25c4e419abcf6ce5a1981e1.png" alt="在这里插入图片描述"></p><h4 id="📝主程序代码"><a href="#📝主程序代码" class="headerlink" title="📝主程序代码"></a>📝主程序代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;lcd1602.h&quot;</span><br><span class="line">#include &quot;delay.h&quot;</span><br><span class="line">#include &quot;dht11.h&quot;</span><br><span class="line">//#include &lt;STC15F2K60S2.H&gt;</span><br><span class="line"></span><br><span class="line">//#define uchar unsigned char</span><br><span class="line">//#define uint unsigned int</span><br><span class="line"></span><br><span class="line">sfr P0M1 = 0x93;</span><br><span class="line">sfr P0M0 = 0x94;</span><br><span class="line">sfr P1M1 = 0x91;</span><br><span class="line">sfr P1M0 = 0x92;</span><br><span class="line">sfr P2M1 = 0x95;</span><br><span class="line">sfr P2M0 = 0x96;</span><br><span class="line">sfr P3M1 = 0xb1;</span><br><span class="line">sfr P3M0 = 0xb2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern unsigned char rec_dat[4];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">    float tem = 0.0,hum = 0.0;</span><br><span class="line">    unsigned char Tempbuf[5],Humbuf[8];</span><br><span class="line">P0M0 = 0x00;</span><br><span class="line">    P0M1 = 0x00;</span><br><span class="line">    P1M0 = 0x00;</span><br><span class="line">    P1M1 = 0x00;</span><br><span class="line">    P2M0 = 0x00;</span><br><span class="line">    P2M1 = 0x00;</span><br><span class="line">    P3M0 = 0x00;</span><br><span class="line">    P3M1 = 0x00;</span><br><span class="line">    Init_Lcd();</span><br><span class="line"></span><br><span class="line">    led = 0;</span><br><span class="line">    led2 = 0;</span><br><span class="line">DHT11_receive();//接收DHT11数据</span><br><span class="line">delay1(2000);</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        DHT11_receive();//接收DHT11数据</span><br><span class="line">if(led)</span><br><span class="line">&#123;</span><br><span class="line">        hum = rec_dat[0] + rec_dat[1]*0.1;//湿度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tem = rec_dat[2];</span><br><span class="line">if(rec_dat[2] &amp; 0x80)&#123;</span><br><span class="line">tem = -1 - tem;//零度以下</span><br><span class="line">&#125;</span><br><span class="line">tem += (rec_dat[3] &amp; 0x0f)*0.1;//温度</span><br><span class="line"></span><br><span class="line">        sprintf(Tempbuf, &quot;%2.1f&quot;,tem);</span><br><span class="line">        sprintf(Humbuf, &quot;%2.1f%%RH&quot;, hum);</span><br><span class="line">led =0;</span><br><span class="line">LCD_write_command(0x01); // 清屏</span><br><span class="line">&#125;</span><br><span class="line">Write_LCD(3, 1, &quot;Temp:&quot;);//在第一行第一个位置显示字符串</span><br><span class="line">        Write_LCD(3, 0, &quot;Hum:&quot;);//在第一行第一个位置显示字符串</span><br><span class="line">        Write_LCD(7, 0, Humbuf);</span><br><span class="line">        Write_LCD(8, 1, Tempbuf);</span><br><span class="line">LCD_write_data(0xdf);</span><br><span class="line">  LCD_write_data(&#x27;C&#x27;);</span><br><span class="line">delay1(2000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “stdio.h”<br>#include “lcd1602.h”<br>#include “delay.h”<br>#include “dht11.h”<br>&#x2F;&#x2F;#include &lt;STC15F2K60S2.H&gt;</p><p>&#x2F;&#x2F;#define uchar unsigned char<br>&#x2F;&#x2F;#define uint unsigned int</p><p>sfr P0M1 &#x3D; 0x93;<br>sfr P0M0 &#x3D; 0x94;<br>sfr P1M1 &#x3D; 0x91;<br>sfr P1M0 &#x3D; 0x92;<br>sfr P2M1 &#x3D; 0x95;<br>sfr P2M0 &#x3D; 0x96;<br>sfr P3M1 &#x3D; 0xb1;<br>sfr P3M0 &#x3D; 0xb2;</p><p>extern unsigned char rec_dat[4];</p><p>void main() {</p><pre><code>float tem = 0.0,hum = 0.0;unsigned char Tempbuf[5],Humbuf[8];    P0M0 = 0x00;P0M1 = 0x00;P1M0 = 0x00;P1M1 = 0x00;P2M0 = 0x00;P2M1 = 0x00;P3M0 = 0x00;P3M1 = 0x00;Init_Lcd();led = 0;led2 = 0;DHT11_receive();//接收DHT11数据delay1(2000);while(1) &#123;    DHT11_receive();//接收DHT11数据            if(led)            &#123;    hum = rec_dat[0] + rec_dat[1]*0.1;//湿度            tem = rec_dat[2];            if(rec_dat[2] &amp; 0x80)&#123;                    tem = -1 - tem;//零度以下            &#125;            tem += (rec_dat[3] &amp; 0x0f)*0.1;//温度                    sprintf(Tempbuf, &quot;%2.1f&quot;,tem);    sprintf(Humbuf, &quot;%2.1f%%RH&quot;, hum);                led =0;                LCD_write_command(0x01); // 清屏            &#125;            Write_LCD(3, 1, &quot;Temp:&quot;);//在第一行第一个位置显示字符串    Write_LCD(3, 0, &quot;Hum:&quot;);//在第一行第一个位置显示字符串    Write_LCD(7, 0, Humbuf);    Write_LCD(8, 1, Tempbuf);            LCD_write_data(0xdf);          LCD_write_data(&#39;C&#39;);            delay1(2000);&#125;</code></pre><p>}&#96;</p><h4 id="📚程序源码"><a href="#📚程序源码" class="headerlink" title="📚程序源码"></a>📚程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1vYY_NhLntjBH5kNaZekhzg </span><br><span class="line">提取码：04l7</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1vYY_NhLntjBH5kNaZekhzg  提取码：04l7</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STC15单片机+DS18B20+LCD1602+PCF8574转IIC接口温度显示</title>
      <link href="/2024/03/Stc15-STC15%E5%8D%95%E7%89%87%E6%9C%BADS18B20LCD1602PCF8574%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E6%B8%A9%E5%BA%A6%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Stc15-STC15%E5%8D%95%E7%89%87%E6%9C%BADS18B20LCD1602PCF8574%E8%BD%ACIIC%E6%8E%A5%E5%8F%A3%E6%B8%A9%E5%BA%A6%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="STC15单片机-DS18B20-LCD1602-PCF8574转IIC接口温度显示"><a href="#STC15单片机-DS18B20-LCD1602-PCF8574转IIC接口温度显示" class="headerlink" title="STC15单片机+DS18B20+LCD1602+PCF8574转IIC接口温度显示"></a>STC15单片机+DS18B20+LCD1602+PCF8574转IIC接口温度显示</h1><h3 id="STC15单片机-DS18B20-LCD1602-PCF8574转IIC接口温度显示-1"><a href="#STC15单片机-DS18B20-LCD1602-PCF8574转IIC接口温度显示-1" class="headerlink" title="STC15单片机+DS18B20+LCD1602+PCF8574转IIC接口温度显示"></a>STC15单片机+DS18B20+LCD1602+PCF8574转IIC接口温度显示</h3><ul><li>📺显示效果</li><li>🌼LCD1602 IIC接口</li></ul><p><img src="https://img-blog.csdnimg.cn/afba56693cd54598a0caa5dced61df72.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/045f1d33c3d0404f9e19b37d9d01ed6f.png" alt="在这里插入图片描述"></p><ul><li>✨本示例基于自制的STC开发板，主控采用的：IAP15W4K61S4</li></ul><p><code>IAP15W4K61S4</code></p><ul><li>相关篇《【PCB开源分享】STC&#x2F;IAP15W4K61S4开发板》</li><li>《【开源分享】自制STC15W408AS开发板》</li></ul><p><a href="https://blog.csdn.net/weixin_42880082/article/details/126185155">【PCB开源分享】STC&#x2F;IAP15W4K61S4开发板</a></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/122150323">【开源分享】自制STC15W408AS开发板</a></p><h4 id="🌼接线说明"><a href="#🌼接线说明" class="headerlink" title="🌼接线说明"></a>🌼接线说明</h4><ul><li>🌿CD1602+PCF8574转IIC接口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCL -----&gt; STC15 P1.0</span><br><span class="line">SDA -----&gt; STC15 P1.1</span><br></pre></td></tr></table></figure><p><code>SCL -----&gt; STC15 P1.0 SDA -----&gt; STC15 P1.1</code></p><ul><li>🌿DS18B20</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data--- STC P1.3</span><br></pre></td></tr></table></figure><p><code>data--- STC P1.3</code></p><ul><li>🚩STC-ISP下载是选择内部时钟，频率设置为11.0592MHz</li></ul><p><code>11.0592</code></p><p><img src="https://img-blog.csdnimg.cn/08d7920bcc27400a8aecc7cc9b22127a.png" alt="在这里插入图片描述"></p><h4 id="⛳注意事项"><a href="#⛳注意事项" class="headerlink" title="⛳注意事项"></a>⛳注意事项</h4><ul><li>🚩如果使用IAP15W4K61S4-30I-P单片机使用P1.2作为基准电压输入引脚请避开。</li><li>🚩所使能的DS18B20引脚，需要在main函数中，配置为准双向IO模式，否则读不到数据。</li></ul><p><code>IAP15W4K61S4-30I-P</code></p><p><code>P1.2</code></p><ul><li>经测试,程序不做任何修改在STC12C5A60S2上也能读取成功。STC12属于Y3指令集的，而stc15属于Y5指令集的。</li></ul><p><code>STC12C5A60S2</code></p><p><img src="https://img-blog.csdnimg.cn/5701162012b64f6a88ef81a9c07e01c8.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/0c6ef9b8518145e4b122d17f96523349.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/5ea3571853c04704b43b4b9bd7b7c2af.png" alt="在这里插入图片描述"></p><h5 id="如果项在STC12上运行最好还是修改一下微秒延时，参照上面。在stc12上跑此代码如果需要串口输出，还需要修改一下串口配置："><a href="#如果项在STC12上运行最好还是修改一下微秒延时，参照上面。在stc12上跑此代码如果需要串口输出，还需要修改一下串口配置：" class="headerlink" title="如果项在STC12上运行最好还是修改一下微秒延时，参照上面。在stc12上跑此代码如果需要串口输出，还需要修改一下串口配置："></a>如果项在STC12上运行最好还是修改一下微秒延时，参照上面。在stc12上跑此代码如果需要串口输出，还需要修改一下串口配置：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCON = 0x50;                //8位可变波特率</span><br><span class="line">    AUXR = 0x40;                //定时器1为1T模式</span><br><span class="line">AUXR &amp;= 0xFE;//串口1选择定时器1为波特率发生器</span><br><span class="line">TMOD &amp;= 0x0F;//设置定时器模式</span><br><span class="line">TMOD |= 0x20;//设置定时器模式</span><br><span class="line">TL1 = 0xFD;//设置定时初始值</span><br><span class="line">TH1 = 0xFD;//设置定时重载值</span><br></pre></td></tr></table></figure><p><code>SCON = 0x50;                //8位可变波特率     AUXR = 0x40;                //定时器1为1T模式     AUXR &amp;= 0xFE;//串口1选择定时器1为波特率发生器     TMOD &amp;= 0x0F;//设置定时器模式     TMOD |= 0x20;//设置定时器模式     TL1 = 0xFD;//设置定时初始值     TH1 = 0xFD;//设置定时重载值</code></p><ul><li>🌿工程架构</li></ul><p><img src="https://img-blog.csdnimg.cn/5b43fef28a414fc09d5c7495f7b14561.png" alt="在这里插入图片描述"></p><h4 id="📝主程序代码"><a href="#📝主程序代码" class="headerlink" title="📝主程序代码"></a>📝主程序代码</h4><p>温度数据也会从串口打印输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;lcd1602.h&quot;</span><br><span class="line">#include &quot;delay.h&quot;</span><br><span class="line">#include &quot;DS18B20.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define FOSC 11059200L          //系统频率</span><br><span class="line">#define BAUD 115200             //串口波特率</span><br><span class="line"></span><br><span class="line">#define NONE_PARITY     0       //无校验</span><br><span class="line">#define ODD_PARITY      1       //奇校验</span><br><span class="line">#define EVEN_PARITY     2       //偶校验</span><br><span class="line">#define MARK_PARITY     3       //标记校验</span><br><span class="line">#define SPACE_PARITY    4       //空白校验</span><br><span class="line"></span><br><span class="line">#define PARITYBIT NONE_PARITY   //定义校验位</span><br><span class="line"></span><br><span class="line">sfr AUXR  = 0x8e;               //辅助寄存器</span><br><span class="line"></span><br><span class="line">sfr P_SW1   = 0xA2;             //外设功能切换寄存器1</span><br><span class="line"></span><br><span class="line">#define S1_S0 0x40              //P_SW1.6</span><br><span class="line">#define S1_S1 0x80              //P_SW1.7</span><br><span class="line">bit busy;</span><br><span class="line"></span><br><span class="line">sbit led = P1^5;//DHT响应指示灯</span><br><span class="line">sbit led2 = P1^6;//效验数据指示灯</span><br><span class="line"></span><br><span class="line">sfr P0M1 = 0x93;</span><br><span class="line">sfr P0M0 = 0x94;</span><br><span class="line">sfr P1M1 = 0x91;</span><br><span class="line">sfr P1M0 = 0x92;</span><br><span class="line">sfr P2M1 = 0x95;</span><br><span class="line">sfr P2M0 = 0x96;</span><br><span class="line">sfr P3M1 = 0xb1;</span><br><span class="line">sfr P3M0 = 0xb2;</span><br><span class="line"></span><br><span class="line">extern unsigned char MinusFlag;</span><br><span class="line">//*************************************** 在指定位置显示字符串 *************************************</span><br><span class="line"></span><br><span class="line">void SendData(unsigned char dat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">   float  tem = 0.0;</span><br><span class="line">unsigned char Tempbuf[5];</span><br><span class="line"></span><br><span class="line">    P0M0 = 0x00;</span><br><span class="line">    P0M1 = 0x00;</span><br><span class="line">    P1M0 = 0x00;</span><br><span class="line">    P1M1 = 0x00;</span><br><span class="line">    P2M0 = 0x00;</span><br><span class="line">    P2M1 = 0x00;</span><br><span class="line">    P3M0 = 0x00;</span><br><span class="line">    P3M1 = 0x00;</span><br><span class="line"></span><br><span class="line"> ACC = P_SW1;</span><br><span class="line">    ACC &amp;= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0</span><br><span class="line">    P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)</span><br><span class="line">    </span><br><span class="line">    SCON = 0x50;                //8位可变波特率</span><br><span class="line"></span><br><span class="line">    AUXR = 0x40;                //定时器1为1T模式</span><br><span class="line">    TMOD = 0x00;                //定时器1为模式0(16位自动重载)</span><br><span class="line">    TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值</span><br><span class="line">    TH1 = (65536 - (FOSC/4/BAUD))&gt;&gt;8;</span><br><span class="line">    TR1 = 1;                    //定时器1开始启动</span><br><span class="line">    ES = 1;                     //使能串口中断</span><br><span class="line">    EA = 1;</span><br><span class="line">    Init_Lcd();</span><br><span class="line"></span><br><span class="line">    led = 0;</span><br><span class="line">    led2 = 0;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">delayms(2000);</span><br><span class="line">tem=(float)ReadTemperature();  //读取温度</span><br><span class="line">tem= tem*0.1;</span><br><span class="line">printf(&quot;Temp=%.1f&quot;,tem);</span><br><span class="line">LCD_write_command(0x01); // 清屏</span><br><span class="line">if(MinusFlag)  //负数标志</span><br><span class="line">&#123;</span><br><span class="line">Write_LCD(5, 0, &quot;-&quot;);//在第一行第一个位置显示字符串</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Write_LCD(5, 0, &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Write_LCD(0, 0, &quot;Temp:&quot;);//在第一行第一个位置显示字符串</span><br><span class="line"> sprintf(Tempbuf, &quot;%2.1f&quot;,tem);</span><br><span class="line">Write_LCD(6, 0, Tempbuf);</span><br><span class="line">LCD_write_data(0xdf);</span><br><span class="line">  LCD_write_data(&#x27;C&#x27;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*----------------------------</span><br><span class="line">UART 中断服务程序</span><br><span class="line">-----------------------------*/</span><br><span class="line">void Uart() interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">//    if (RI)</span><br><span class="line">//    &#123;</span><br><span class="line">//        RI = 0;                 //清除RI位</span><br><span class="line">//        P0 = SBUF;              //P0显示串口数据</span><br><span class="line">//    &#125;</span><br><span class="line">    if (TI)</span><br><span class="line">    &#123;</span><br><span class="line">        TI = 0;                 //清除TI位</span><br><span class="line">        busy = 0;               //清忙标志</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*----------------------------</span><br><span class="line">发送串口数据</span><br><span class="line">----------------------------*/</span><br><span class="line">void SendData(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    while (busy);               //等待前面的数据发送完成</span><br><span class="line">    ACC = dat;                  //获取校验位P (PSW.0)</span><br><span class="line">    if (P)                      //根据P来设置校验位</span><br><span class="line">    &#123;</span><br><span class="line">#if (PARITYBIT == ODD_PARITY)</span><br><span class="line">        TB8 = 0;                //设置校验位为0</span><br><span class="line">#elif (PARITYBIT == EVEN_PARITY)</span><br><span class="line">        TB8 = 1;                //设置校验位为1</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">#if (PARITYBIT == ODD_PARITY)</span><br><span class="line">        TB8 = 1;                //设置校验位为1</span><br><span class="line">#elif (PARITYBIT == EVEN_PARITY)</span><br><span class="line">        TB8 = 0;                //设置校验位为0</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    busy = 1;</span><br><span class="line">    SBUF = ACC;                 //写数据到UART数据寄存器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char putchar(char c)</span><br><span class="line">&#123;</span><br><span class="line">SendData(c);</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “stdio.h”<br>#include “lcd1602.h”<br>#include “delay.h”<br>#include “DS18B20.h”</p><p>#define FOSC 11059200L          &#x2F;&#x2F;系统频率<br>#define BAUD 115200             &#x2F;&#x2F;串口波特率</p><p>#define NONE_PARITY     0       &#x2F;&#x2F;无校验<br>#define ODD_PARITY      1       &#x2F;&#x2F;奇校验<br>#define EVEN_PARITY     2       &#x2F;&#x2F;偶校验<br>#define MARK_PARITY     3       &#x2F;&#x2F;标记校验<br>#define SPACE_PARITY    4       &#x2F;&#x2F;空白校验</p><p>#define PARITYBIT NONE_PARITY   &#x2F;&#x2F;定义校验位</p><p>sfr AUXR  &#x3D; 0x8e;               &#x2F;&#x2F;辅助寄存器</p><p>sfr P_SW1   &#x3D; 0xA2;             &#x2F;&#x2F;外设功能切换寄存器1</p><p>#define S1_S0 0x40              &#x2F;&#x2F;P_SW1.6<br>#define S1_S1 0x80              &#x2F;&#x2F;P_SW1.7<br>bit busy;</p><p>sbit led &#x3D; P1^5;&#x2F;&#x2F;DHT响应指示灯<br>sbit led2 &#x3D; P1^6;&#x2F;&#x2F;效验数据指示灯</p><p>sfr P0M1 &#x3D; 0x93;<br>sfr P0M0 &#x3D; 0x94;<br>sfr P1M1 &#x3D; 0x91;<br>sfr P1M0 &#x3D; 0x92;<br>sfr P2M1 &#x3D; 0x95;<br>sfr P2M0 &#x3D; 0x96;<br>sfr P3M1 &#x3D; 0xb1;<br>sfr P3M0 &#x3D; 0xb2;</p><p>extern unsigned char MinusFlag;<br>&#x2F;&#x2F;*************************************** 在指定位置显示字符串 *************************************</p><p>void SendData(unsigned char dat);</p><p>void main() {</p><p>   float  tem &#x3D; 0.0;<br>unsigned char Tempbuf[5];</p><pre><code>P0M0 = 0x00;P0M1 = 0x00;P1M0 = 0x00;P1M1 = 0x00;P2M0 = 0x00;P2M1 = 0x00;P3M0 = 0x00;P3M1 = 0x00; ACC = P_SW1;ACC &amp;= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)SCON = 0x50;                //8位可变波特率AUXR = 0x40;                //定时器1为1T模式TMOD = 0x00;                //定时器1为模式0(16位自动重载)TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值TH1 = (65536 - (FOSC/4/BAUD))&gt;&gt;8;TR1 = 1;                    //定时器1开始启动ES = 1;                     //使能串口中断EA = 1;Init_Lcd();led = 0;led2 = 0;while(1) &#123;            delayms(2000);        tem=(float)ReadTemperature();  //读取温度        tem= tem*0.1;        printf(&quot;Temp=%.1f&quot;,tem);        LCD_write_command(0x01); // 清屏    if(MinusFlag)  //负数标志    &#123;        Write_LCD(5, 0, &quot;-&quot;);//在第一行第一个位置显示字符串    &#125;    else    &#123;        Write_LCD(5, 0, &quot; &quot;);    &#125;                    Write_LCD(0, 0, &quot;Temp:&quot;);//在第一行第一个位置显示字符串             sprintf(Tempbuf, &quot;%2.1f&quot;,tem);            Write_LCD(6, 0, Tempbuf);            LCD_write_data(0xdf);          LCD_write_data(&#39;C&#39;);    &#125;</code></pre><p>}</p><p>&#x2F;<em>—————————-<br>UART 中断服务程序<br>—————————–</em>&#x2F;<br>void Uart() interrupt 4<br>{<br>&#x2F;&#x2F;    if (RI)<br>&#x2F;&#x2F;    {<br>&#x2F;&#x2F;        RI &#x3D; 0;                 &#x2F;&#x2F;清除RI位<br>&#x2F;&#x2F;        P0 &#x3D; SBUF;              &#x2F;&#x2F;P0显示串口数据<br>&#x2F;&#x2F;    }<br>    if (TI)<br>    {<br>        TI &#x3D; 0;                 &#x2F;&#x2F;清除TI位<br>        busy &#x3D; 0;               &#x2F;&#x2F;清忙标志<br>    }<br>}<br>&#x2F;<em>—————————-<br>发送串口数据<br>—————————-</em>&#x2F;<br>void SendData(unsigned char dat)<br>{<br>    while (busy);               &#x2F;&#x2F;等待前面的数据发送完成<br>    ACC &#x3D; dat;                  &#x2F;&#x2F;获取校验位P (PSW.0)<br>    if (P)                      &#x2F;&#x2F;根据P来设置校验位<br>    {<br>#if (PARITYBIT &#x3D;&#x3D; ODD_PARITY)<br>        TB8 &#x3D; 0;                &#x2F;&#x2F;设置校验位为0<br>#elif (PARITYBIT &#x3D;&#x3D; EVEN_PARITY)<br>        TB8 &#x3D; 1;                &#x2F;&#x2F;设置校验位为1<br>#endif<br>    }<br>    else<br>    {<br>#if (PARITYBIT &#x3D;&#x3D; ODD_PARITY)<br>        TB8 &#x3D; 1;                &#x2F;&#x2F;设置校验位为1<br>#elif (PARITYBIT &#x3D;&#x3D; EVEN_PARITY)<br>        TB8 &#x3D; 0;                &#x2F;&#x2F;设置校验位为0<br>#endif<br>    }<br>    busy &#x3D; 1;<br>    SBUF &#x3D; ACC;                 &#x2F;&#x2F;写数据到UART数据寄存器<br>}</p><p>char putchar(char c)<br>{<br>SendData(c);<br>return c;<br>}&#96;</p><ul><li>🌿温度符合的组成：ascii字符集 0xdf 配合大写字母C组成。</li></ul><p><code>0xdf</code></p><p><code>C</code></p><h4 id="📚工程源码"><a href="#📚工程源码" class="headerlink" title="📚工程源码"></a>📚工程源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1jNSZdcXhDA1d2xLs-WbcoA </span><br><span class="line">提取码：8h9j</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1jNSZdcXhDA1d2xLs-WbcoA  提取码：8h9j</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ADC0809 8通道轮流采样LCD1602显示</title>
      <link href="/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-ADC0809-8%E9%80%9A%E9%81%93%E8%BD%AE%E6%B5%81%E9%87%87%E6%A0%B7LCD1602%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/proteus%E4%BB%BF%E7%9C%9F%E5%B8%B8%E7%94%A8%E8%8A%AF%E7%89%87-ADC0809-8%E9%80%9A%E9%81%93%E8%BD%AE%E6%B5%81%E9%87%87%E6%A0%B7LCD1602%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="ADC0809-8通道轮流采样LCD1602显示"><a href="#ADC0809-8通道轮流采样LCD1602显示" class="headerlink" title="ADC0809 8通道轮流采样LCD1602显示"></a>ADC0809 8通道轮流采样LCD1602显示</h1><h3 id="ADC0809-8通道轮流采样LCD1602显示-1"><a href="#ADC0809-8通道轮流采样LCD1602显示-1" class="headerlink" title="ADC0809 8通道轮流采样LCD1602显示"></a>ADC0809 8通道轮流采样LCD1602显示</h3><ul><li>📽🎞📺🎬Proteus仿真演示：</li><li>📌相关篇《51单片机 ADC0809模数转换与显示+Proteus仿真》</li></ul><p><img src="https://img-blog.csdnimg.cn/cd14e00b85bb4434a6ba24acd44f5550.gif#pic_center" alt="在这里插入图片描述"></p><p><a href="https://blog.csdn.net/weixin_42880082/article/details/121048776">51单片机 ADC0809模数转换与显示+Proteus仿真</a></p><h5 id="📑本示例将ADC08098个通道的采样数据分别显示在LCD1602对应位置，保留小数点后2位精度。这样依赖lcd1602整个屏幕刚好显示8组数据，中间没有间隔空余。"><a href="#📑本示例将ADC08098个通道的采样数据分别显示在LCD1602对应位置，保留小数点后2位精度。这样依赖lcd1602整个屏幕刚好显示8组数据，中间没有间隔空余。" class="headerlink" title="📑本示例将ADC08098个通道的采样数据分别显示在LCD1602对应位置，保留小数点后2位精度。这样依赖lcd1602整个屏幕刚好显示8组数据，中间没有间隔空余。"></a>📑本示例将ADC08098个通道的采样数据分别显示在LCD1602对应位置，保留小数点后2位精度。这样依赖lcd1602整个屏幕刚好显示8组数据，中间没有间隔空余。</h5><h4 id="📓功能说明"><a href="#📓功能说明" class="headerlink" title="📓功能说明"></a>📓功能说明</h4><ul><li><p>🌿定时器0用来给ADC0809提供时钟源。</p></li><li><p>🌿定时器1用来产生0.5s定时，用来查询各个ADC通道数据。</p></li><li><p>🔰如果想单通道显示可以启用外部中断0，用来作为通道切换的按键。</p></li><li><p>✨如果觉得不美观，当然也可以只显示单通道，然后使用按键来切换通道显示,，调整显示函数。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void exint0() interrupt 0           //(location at 0003H)</span><br><span class="line">&#123;</span><br><span class="line">    n++;</span><br><span class="line"> if(n==8)n=0;</span><br><span class="line">&#125;</span><br><span class="line">//在main中添加：，用来开启外部中断</span><br><span class="line">    IT0 = 1;   //set INT0 int type (1:Falling 0:Low level)下降沿触发</span><br><span class="line">    EX0 = 1;   //enable INT0 interrupt</span><br></pre></td></tr></table></figure><p><code>void exint0() interrupt 0           //(location at 0003H) &#123;     n++;      if(n==8)n=0; &#125; //在main中添加：，用来开启外部中断     IT0 = 1;   //set INT0 int type (1:Falling 0:Low level)下降沿触发     EX0 = 1;   //enable INT0 interrupt</code></p><ul><li>工程架构</li><li>相关未启用的函数警告处理：移除未使用的函数。</li></ul><p><img src="https://img-blog.csdnimg.cn/6b248ad6250e4413b92fe16c2b6c2188.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/99214d50fcbc4beb9a8712adc0c7c887.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/84db67407d2a4af888af930f599595b8.png" alt="在这里插入图片描述"></p><h4 id="📖main主程序"><a href="#📖main主程序" class="headerlink" title="📖main主程序"></a>📖main主程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;LCD1602.h&quot;</span><br><span class="line"></span><br><span class="line">sbit key1= P1^6;</span><br><span class="line">sbit key2= P1^7;</span><br><span class="line">unsigned char dat,results;</span><br><span class="line">volatile unsigned char n,CNT;</span><br><span class="line"></span><br><span class="line">sbit CLK=P3^5;</span><br><span class="line">/*ADC通道选择*/</span><br><span class="line">sbit P10=P1^0;</span><br><span class="line">sbit P11=P1^1;</span><br><span class="line">sbit P12=P1^2;</span><br><span class="line"></span><br><span class="line">sbit EOC = P3^1;</span><br><span class="line">sbit OE = P3^0;</span><br><span class="line">sbit START = P3^4 ;</span><br><span class="line"></span><br><span class="line">void Timer0Init(void)//100微秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">TMOD &amp;= 0xF0;//设置定时器模式</span><br><span class="line">TMOD |= 0x02;//设置定时器模式</span><br><span class="line">TL0 = 0x9C;//设置定时初始值</span><br><span class="line">TH0 = 0x9C;//设置定时重载值</span><br><span class="line">TF0 = 0;//清除TF0标志</span><br><span class="line">TR0 = 1;//定时器0开始计时</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定时器中断</span><br><span class="line">void Timer0_INT() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">   CLK =!CLK;//给ADC0809提供时钟频率</span><br><span class="line">TF0 = 0;//清除TF0标志</span><br><span class="line">TL0 = 0x9C;//设置定时初始值100微秒=10KHz</span><br><span class="line">TH0 = 0x9C;//设置定时重载值</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">//External interrupt0 service routine外部中断0：P32</span><br><span class="line">void exint0() interrupt 0           //(location at 0003H)</span><br><span class="line">&#123;</span><br><span class="line">    n++;</span><br><span class="line"> if(n==8)n=0;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void Timer1Init(void)//50毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">TMOD &amp;= 0x0F;//设置定时器模式</span><br><span class="line">TMOD |= 0x10;//设置定时器模式</span><br><span class="line">TL1 = 0xB0;//设置定时初始值</span><br><span class="line">TH1 = 0x3C;//设置定时初始值</span><br><span class="line">TF1 = 0;//清除TF0标志</span><br><span class="line">TR1 = 1;//定时器0开始计时</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Timer1 interrupt routine */</span><br><span class="line">void tm1_isr() interrupt 3</span><br><span class="line">&#123;</span><br><span class="line">TF1 = 0;//清除TF0标志</span><br><span class="line">TL0 = 0xB0;//设置定时初始值</span><br><span class="line">TH0 = 0x3C;//设置定时初始值</span><br><span class="line"></span><br><span class="line">    if (CNT++ == 10)   //50ms * 20 -&gt; 2s</span><br><span class="line">    &#123;</span><br><span class="line">        CNT = 0;  //归零</span><br><span class="line">        n++;</span><br><span class="line">if(n==8)n=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Channel(unsigned char x)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   switch(x)&#123;</span><br><span class="line">    case 0:   P10=0; P11=0; P12=0;break;</span><br><span class="line">    case 1:   P10=1; P11=0; P12=0;break;</span><br><span class="line">    case 2:   P10=0; P11=1; P12=0;break;</span><br><span class="line">    case 3:   P10=1; P11=1; P12=0;break;</span><br><span class="line">    case 4:   P10=0; P11=0; P12=1;break;</span><br><span class="line">    case 5:   P10=1; P11=0; P12=1;break;</span><br><span class="line">    case 6:   P10=0; P11=1; P12=1;break;</span><br><span class="line">    case 7:   P10=1; P11=1; P12=1;break;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line"> &#123; </span><br><span class="line">  unsigned char Int,Dec;</span><br><span class="line">   unsigned int Value;</span><br><span class="line">//    IT0 = 1;   //set INT0 int type (1:Falling 0:Low level)</span><br><span class="line">//    EX0 = 1;   //enable INT0 interrupt</span><br><span class="line"> Timer0Init();</span><br><span class="line"> Timer1Init();</span><br><span class="line">     LCMInit();         //将液晶初始化</span><br><span class="line">   ET0 =1;//开启定时器0</span><br><span class="line"> ET1 = 1;//开启定时器1</span><br><span class="line"> EA =1;//开启总中断</span><br><span class="line"> DisplayListChar(0,0,5, &quot; .   .   .   .&quot;);//字符串显示</span><br><span class="line"> DisplayListChar(1,0,5, &quot; .   .   .   .&quot;);//字符串显示</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">      delayms(16); </span><br><span class="line">Channel(n); //选择通道</span><br><span class="line"></span><br><span class="line">      START=0;     </span><br><span class="line">      START=1;</span><br><span class="line">      START=0;//当低电平来时开始读取数据</span><br><span class="line">      while(EOC==0);</span><br><span class="line">      OE=1;</span><br><span class="line">     dat = P2; //将数据赋给P2</span><br><span class="line">      OE = 0;       </span><br><span class="line"> Value = (dat*100)/51;</span><br><span class="line"> Int = dat/51;//dat*5/255</span><br><span class="line"> Dec = Value%100;//处理数据</span><br><span class="line">if(n&lt;4)&#123;</span><br><span class="line">  DisplayOneChar(0 ,4*n,Int+0x30);</span><br><span class="line">DisplayOneChar(0 ,2+4*n,Dec/10 +0x30);</span><br><span class="line">    DisplayOneChar(0 ,3+4*n,Dec%10 +0x30);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">DisplayOneChar(1 ,4*n,Int+0x30);</span><br><span class="line">DisplayOneChar(1 ,2+4*n,Dec/10 +0x30);</span><br><span class="line">    DisplayOneChar(1 ,3+4*n,Dec%10 +0x30);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include “LCD1602.h”</p><p>sbit key1&#x3D; P1^6;<br>sbit key2&#x3D; P1^7;<br>unsigned char dat,results;<br>volatile unsigned char n,CNT;</p><p>sbit CLK&#x3D;P3^5;<br>&#x2F;<em>ADC通道选择</em>&#x2F;<br>sbit P10&#x3D;P1^0;<br>sbit P11&#x3D;P1^1;<br>sbit P12&#x3D;P1^2;</p><p>sbit EOC &#x3D; P3^1;<br>sbit OE &#x3D; P3^0;<br>sbit START &#x3D; P3^4 ;</p><p>void Timer0Init(void)&#x2F;&#x2F;100微秒@12.000MHz<br>{<br>    TMOD &amp;&#x3D; 0xF0;&#x2F;&#x2F;设置定时器模式<br>    TMOD |&#x3D; 0x02;&#x2F;&#x2F;设置定时器模式<br>    TL0 &#x3D; 0x9C;&#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0x9C;&#x2F;&#x2F;设置定时重载值<br>    TF0 &#x3D; 0;&#x2F;&#x2F;清除TF0标志<br>    TR0 &#x3D; 1;&#x2F;&#x2F;定时器0开始计时<br>}</p><p>&#x2F;&#x2F;定时器中断<br>void Timer0_INT() interrupt 1<br>{<br>   CLK &#x3D;!CLK;&#x2F;&#x2F;给ADC0809提供时钟频率<br>    TF0 &#x3D; 0;&#x2F;&#x2F;清除TF0标志<br>    TL0 &#x3D; 0x9C;&#x2F;&#x2F;设置定时初始值100微秒&#x3D;10KHz<br>    TH0 &#x3D; 0x9C;&#x2F;&#x2F;设置定时重载值</p><p>}<br>&#x2F;*<br>&#x2F;&#x2F;External interrupt0 service routine外部中断0：P32<br>void exint0() interrupt 0           &#x2F;&#x2F;(location at 0003H)<br>{<br>    n++;<br>     if(n&#x3D;&#x3D;8)n&#x3D;0;<br>}<br>*&#x2F;</p><p>void Timer1Init(void)&#x2F;&#x2F;50毫秒@12.000MHz<br>{<br>    TMOD &amp;&#x3D; 0x0F;&#x2F;&#x2F;设置定时器模式<br>    TMOD |&#x3D; 0x10;&#x2F;&#x2F;设置定时器模式<br>    TL1 &#x3D; 0xB0;&#x2F;&#x2F;设置定时初始值<br>    TH1 &#x3D; 0x3C;&#x2F;&#x2F;设置定时初始值<br>    TF1 &#x3D; 0;&#x2F;&#x2F;清除TF0标志<br>    TR1 &#x3D; 1;&#x2F;&#x2F;定时器0开始计时<br>}</p><p>&#x2F;* Timer1 interrupt routine *&#x2F;<br>void tm1_isr() interrupt 3<br>{<br>    TF1 &#x3D; 0;&#x2F;&#x2F;清除TF0标志<br>    TL0 &#x3D; 0xB0;&#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; 0x3C;&#x2F;&#x2F;设置定时初始值</p><pre><code>if (CNT++ == 10)   //50ms * 20 -&gt; 2s&#123;    CNT = 0;  //归零    n++;            if(n==8)n=0;&#125;</code></pre><p>}<br>void Channel(unsigned char x)<br>{</p><p>   switch(x){<br>    case 0:   P10&#x3D;0; P11&#x3D;0; P12&#x3D;0;break;<br>    case 1:   P10&#x3D;1; P11&#x3D;0; P12&#x3D;0;break;<br>    case 2:   P10&#x3D;0; P11&#x3D;1; P12&#x3D;0;break;<br>    case 3:   P10&#x3D;1; P11&#x3D;1; P12&#x3D;0;break;<br>    case 4:   P10&#x3D;0; P11&#x3D;0; P12&#x3D;1;break;<br>    case 5:   P10&#x3D;1; P11&#x3D;0; P12&#x3D;1;break;<br>    case 6:   P10&#x3D;0; P11&#x3D;1; P12&#x3D;1;break;<br>    case 7:   P10&#x3D;1; P11&#x3D;1; P12&#x3D;1;break;<br>   }</p><p>} </p><p>void main(void)<br> {<br>      unsigned char Int,Dec;<br>   unsigned int Value;<br>&#x2F;&#x2F;    IT0 &#x3D; 1;   &#x2F;&#x2F;set INT0 int type (1:Falling 0:Low level)<br>&#x2F;&#x2F;    EX0 &#x3D; 1;   &#x2F;&#x2F;enable INT0 interrupt<br>     Timer0Init();<br>     Timer1Init();<br>     LCMInit();         &#x2F;&#x2F;将液晶初始化<br>   ET0 &#x3D;1;&#x2F;&#x2F;开启定时器0<br>     ET1 &#x3D; 1;&#x2F;&#x2F;开启定时器1<br>     EA &#x3D;1;&#x2F;&#x2F;开启总中断<br>     DisplayListChar(0,0,5, “ .   .   .   .”);&#x2F;&#x2F;字符串显示<br>     DisplayListChar(1,0,5, “ .   .   .   .”);&#x2F;&#x2F;字符串显示<br>    while(1)<br>    {<br>      delayms(16);<br>        Channel(n); &#x2F;&#x2F;选择通道</p><pre><code>  START=0;       START=1;  START=0;//当低电平来时开始读取数据  while(EOC==0);      OE=1;     dat = P2; //将数据赋给P2      OE = 0;        Value = (dat*100)/51; Int = dat/51;//dat*5/255 Dec = Value%100;//处理数据if(n&lt;4)&#123;  DisplayOneChar(0 ,4*n,Int+0x30);    DisplayOneChar(0 ,2+4*n,Dec/10 +0x30);DisplayOneChar(0 ,3+4*n,Dec%10 +0x30);&#125;else&#123;    DisplayOneChar(1 ,4*n,Int+0x30);    DisplayOneChar(1 ,2+4*n,Dec/10 +0x30);DisplayOneChar(1 ,3+4*n,Dec%10 +0x30);&#125;</code></pre><p> }<br>}&#96;</p><h4 id="📚程序源码"><a href="#📚程序源码" class="headerlink" title="📚程序源码"></a>📚程序源码</h4><p>⚡本示例基于Proteus8.12平台。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/11oPIiMOxxYKugudXKRwYaw </span><br><span class="line">提取码：q5yz</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/11oPIiMOxxYKugudXKRwYaw  提取码：q5yz</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】STC15单片机 + LCD1602+5X8点阵字符显示</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FSTC15%E5%8D%95%E7%89%87%E6%9C%BA-LCD16025X8%E7%82%B9%E9%98%B5%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9FSTC15%E5%8D%95%E7%89%87%E6%9C%BA-LCD16025X8%E7%82%B9%E9%98%B5%E5%AD%97%E7%AC%A6%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】STC15单片机-LCD1602-5X8点阵字符显示"><a href="#【Proteus仿真】STC15单片机-LCD1602-5X8点阵字符显示" class="headerlink" title="【Proteus仿真】STC15单片机 + LCD1602+5X8点阵字符显示"></a>【Proteus仿真】STC15单片机 + LCD1602+5X8点阵字符显示</h1><h3 id="【Proteus仿真】STC15单片机-LCD1602-5X8点阵字符显示-1"><a href="#【Proteus仿真】STC15单片机-LCD1602-5X8点阵字符显示-1" class="headerlink" title="【Proteus仿真】STC15单片机 + LCD1602+5X8点阵字符显示"></a>【Proteus仿真】STC15单片机 + LCD1602+5X8点阵字符显示</h3><ul><li>Proteus仿真演示</li></ul><p><img src="https://img-blog.csdnimg.cn/1cd4fa776fb445d1a1486ea0be9558d5.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="相关函数说明"><a href="#相关函数说明" class="headerlink" title="相关函数说明"></a>相关函数说明</h4><ul><li>unsigned char *uchartostr(unsigned num); &#x2F;&#x2F;将一个字节的数据转换为字符串 或10进制</li></ul><p><code>unsigned char *uchartostr(unsigned num);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *uchartostr(unsigned num)//将一个字节的数据转换为字符串 或10进制</span><br><span class="line">&#123;</span><br><span class="line">unsigned char x2,x1,x0,i;</span><br><span class="line">x2=num/100;</span><br><span class="line">x1=num%100/10;</span><br><span class="line">x0=num%100%10;</span><br><span class="line">i=0;</span><br><span class="line">if(x2!=0)</span><br><span class="line">&#123;</span><br><span class="line">str[i]=x2+48;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(x1!=0)</span><br><span class="line">&#123;</span><br><span class="line">str[i]=x1+48;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">str[i]=x0+48;</span><br><span class="line">i++;</span><br><span class="line">str[i]=&#x27;\0&#x27;;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unsigned char *uchartostr(unsigned num)//将一个字节的数据转换为字符串 或10进制 &#123;     unsigned char x2,x1,x0,i;     x2=num/100;     x1=num%100/10;     x0=num%100%10;     i=0;     if(x2!=0)     &#123;         str[i]=x2+48;         i++;     &#125;     if(x1!=0)     &#123;         str[i]=x1+48;         i++;     &#125;     str[i]=x0+48;     i++;     str[i]=&#39;\0&#39;;     return str; &#125;</code></p><ul><li>WriteROM(); &#x2F;&#x2F; 将自定义字形码写入LCD1602内部存储器</li></ul><p><code>WriteROM(); // 将自定义字形码写入LCD1602内部存储器</code></p><p>将84bit，8字节的数据写入到LCD1602 CGRAM寄存器，</p><p><code>CGRAM</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void WriteROM()//LCD1602内部数据寄存器写入函数</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">Write_CMD(0x40); // 操作CGRAM的命令码，</span><br><span class="line">for(i=0;i&lt;64;i++)            // 写入数组中数据  </span><br><span class="line">&#123;</span><br><span class="line">Write_DIS_Data(table[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void WriteROM()//LCD1602内部数据寄存器写入函数 &#123;         unsigned char i;     Write_CMD(0x40); // 操作CGRAM的命令码，     for(i=0;i&lt;64;i++)            // 写入数组中数据       &#123;         Write_DIS_Data(table[i]);     &#125; &#125;</code></p><ul><li>参考信息《LCD1602液晶使用介绍–（完整版）》</li><li>LCD17602内置DDRAM、CGROM和CGRAM。</li></ul><p><a href="https://blog.csdn.net/weixin_46897073/article/details/110282736">LCD1602液晶使用介绍–（完整版）</a></p><p>CGRAM的容量是64个字节，而一个字符是8个字节，所以一共能显示8个自定义的字符。内部常用字符的显示是从0x20开始的，0x00 ~ 0x0F是专门留给自定义字符显示用的，0x00-0x07和0x08~0x0F显示的内容是一样的，也就是说0x00&#x3D;0x08,0x01&#x3D;0x09，以此类推。CGRAM共128个位，地址是0x40-0x7F，128&#x2F;8&#x3D;16正好对应的是0x00-0x0F共16个.</p><p><img src="https://img-blog.csdnimg.cn/e20d1d9ca1ff4a2e8e9677031555a6b8.png" alt="在这里插入图片描述"></p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br></pre></td><td class="code"><pre><span class="line">/*************本程序功能说明**************</span><br><span class="line"></span><br><span class="line">驱动LCD1602字符屏.</span><br><span class="line"></span><br><span class="line">显示效果为:  DS1302 + LCD1602显示时间</span><br><span class="line"></span><br><span class="line">******************************************/</span><br><span class="line">#include&quot;STC15Fxxxx.H&quot;</span><br><span class="line"></span><br><span class="line">#define T1MS (65536-MAIN_Fosc/12/1000)   //12T模式1ms定时</span><br><span class="line">#define  interval  1000 //设置延时时间间隔</span><br><span class="line">/*************本地变量声明**************/</span><br><span class="line">static volatile unsigned long sysRunmillis = 0;//系统运行时间计数，保存单片机从上电复位以来运行的时间，单位是毫秒。该数值由定时器T0的中断响应子函数更新</span><br><span class="line">unsigned long previousMillis = 0;</span><br><span class="line">unsigned char str[4];//uchartostr函数转换的字符串 同时可以把16进制转成10进制</span><br><span class="line">sbit Buzzer = P3^7;</span><br><span class="line">unsigned char code table[]=</span><br><span class="line">&#123;</span><br><span class="line">    0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,        // 一，显示时的ASCII码 0x00</span><br><span class="line">    0x00,0x00,0x00,0x0e,0x00,0xff,0x00,0x00,        // 二，显示时的ASCII码 0x01</span><br><span class="line">    0x00,0x00,0xff,0x00,0x0e,0x00,0xff,0x00,        // 三，显示时的ASCII码 0x02</span><br><span class="line">    0x00,0x00,0xff,0xf5,0xfb,0xf1,0xff,0x00,        // 四，显示时的ASCII码 0x03</span><br><span class="line">    0x00,0xfe,0x08,0xfe,0x0a,0x0a,0xff,0x00,        // 五，显示时的ASCII码 0x04</span><br><span class="line">    0x00,0x04,0x00,0xff,0x00,0x0a,0x11,0x00,        // 六，显示时的ASCII码 0x05</span><br><span class="line">0x00,0x1f,0x11,0x1f,0x11,0x11,0x1f,0x00,        // 日，显示时的ASCII码 0x06</span><br><span class="line">0x18,0x18,0x07,0x08,0x08,0x08,0x07,0x00,        // ℃，显示时的ASCII码 0x07</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Timer0Init(void);//1毫秒@12.000MHz</span><br><span class="line">void  delay_ms(unsigned long ms);</span><br><span class="line">voidInitialize_LCD(void);</span><br><span class="line">voidWrite_AC(u8 hang,u8 lie);</span><br><span class="line">voidWrite_DIS_Data(u8 DIS_Data);</span><br><span class="line">void WriteROM();//LCD1602内部数据寄存器写入函数</span><br><span class="line">voidClearLine(u8 row);</span><br><span class="line">u8BIN_ASCII(u8 tmp);</span><br><span class="line">void PutString(u8 row, u8 column, u8 *puts);</span><br><span class="line">voidWriteChar(u8 row, u8 column, u8 dat);</span><br><span class="line">void Buzzer_Di(void);</span><br><span class="line">unsigned char *uchartostr(unsigned num);//将一个字节的数据转换为字符串 或10进制</span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void main(void)</span><br><span class="line">// 描述: 主函数。</span><br><span class="line">//========================================================================</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long currentMillis;//当前时间</span><br><span class="line">unsigned char i =0;</span><br><span class="line">P0M1 = 0;P0M0 = 0;//设置为准双向口</span><br><span class="line">P1M1 = 0;P1M0 = 0;//设置为准双向口</span><br><span class="line">P2M1 = 0;P2M0 = 0;//设置为准双向口</span><br><span class="line">P3M1 = 0;P3M0 = 0;//设置为准双向口</span><br><span class="line">P4M1 = 0;P4M0 = 0;//设置为准双向口</span><br><span class="line">P5M1 = 0;P5M0 = 0;//设置为准双向口</span><br><span class="line">P6M1 = 0;P6M0 = 0;//设置为准双向口</span><br><span class="line">P7M1 = 0;P7M0 = 0;//设置为准双向口</span><br><span class="line">Timer0Init();//1毫秒@12.000MHz</span><br><span class="line">Initialize_LCD();//LCD初始化函数</span><br><span class="line">ClearLine(0);</span><br><span class="line">ClearLine(1);</span><br><span class="line">PutString(0,0,&quot;STC15W4K&quot;);</span><br><span class="line">WriteROM();   // 将自定义字形码写入LCD1602内部存储器</span><br><span class="line">  WriteChar(1, 0, 0);</span><br><span class="line">WriteChar(1, 1, 1);</span><br><span class="line">WriteChar(1, 2, 2);</span><br><span class="line">WriteChar(1, 3, 3);</span><br><span class="line">WriteChar(1, 4, 4);</span><br><span class="line">WriteChar(1, 5, 5);</span><br><span class="line">WriteChar(1, 6, 6);</span><br><span class="line">WriteChar(1, 7, 7);</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">currentMillis = sysRunmillis;</span><br><span class="line">if (currentMillis - previousMillis  &gt;= interval)</span><br><span class="line">&#123;//每隔1秒翻转一次</span><br><span class="line">    previousMillis = sysRunmillis;</span><br><span class="line">if(++i &lt;= 255)&#123;</span><br><span class="line">PutString(0,9,uchartostr(i));</span><br><span class="line">WriteChar(0, 14, i);</span><br><span class="line"></span><br><span class="line">PutString(1,9,uchartostr(255 -i));</span><br><span class="line">WriteChar(1, 14, 255 -i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void Timer0Init(void)//1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0x7F;//定时器时钟12T模式</span><br><span class="line">TMOD &amp;= 0xF0;//设置定时器模式</span><br><span class="line">TL0 = T1MS ;//设置定时初始值</span><br><span class="line">TH0 = T1MS &gt;&gt;8;//设置定时初始值</span><br><span class="line">//TL0 = 0x18;//设置定时初始值</span><br><span class="line">//TH0 = 0xFC;//设置定时初始值</span><br><span class="line"></span><br><span class="line">TF0 = 0;//清除TF0标志</span><br><span class="line">TR0 = 1;//定时器0开始计时</span><br><span class="line">ET0 = 1;     //enable timer0 interrupt</span><br><span class="line">  EA = 1;      //open global interrupt switch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Timer0 interrupt routine */</span><br><span class="line">void tm0_isr() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">//TL0 = 0x18;//设置定时初始值</span><br><span class="line">//TH0 = 0xFC;//设置定时初始值</span><br><span class="line">    TL0 = T1MS;                     //reload timer0 low byte</span><br><span class="line">    TH0 = T1MS &gt;&gt; 8;                //reload timer0 high byte</span><br><span class="line">sysRunmillis ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void  delay_ms(u8 ms)</span><br><span class="line">// 描述: 延时函数。</span><br><span class="line">// 参数: ms,要延时的ms数, 这里只支持1~255ms. 自动适应主时钟.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void  delay_ms(unsigned long ms)</span><br><span class="line">&#123;</span><br><span class="line">unsigned longtemp = sysRunmillis ;</span><br><span class="line">    while(sysRunmillis - temp &lt; ms );</span><br><span class="line">//     unsigned int i;</span><br><span class="line">// do&#123;</span><br><span class="line">//      i = MAIN_Fosc / 13000;</span><br><span class="line">//  while(--i);   //14T per loop</span><br><span class="line">//     &#125;while(--ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/************* LCD1602相关程序*****************************************************/</span><br><span class="line">//8位数据访问方式LCD1602标准程序梁工编写2014-2-21</span><br><span class="line"></span><br><span class="line">#define LineLength16//16x2</span><br><span class="line"></span><br><span class="line">/*************Pin define*****************************************************/</span><br><span class="line"></span><br><span class="line">sfrLCD_BUS = 0x80;//P0--0x80, P1--0x90, P2--0xA0, P3--0xB0</span><br><span class="line"></span><br><span class="line">sbitLCD_B7  = LCD_BUS^7;//D7 -- Pin 14LED- -- Pin 16 </span><br><span class="line">sbitLCD_B6  = LCD_BUS^6;//D6 -- Pin 13LED+ -- Pin 15</span><br><span class="line">sbitLCD_B5  = LCD_BUS^5;//D5 -- Pin 12Vo   -- Pin 3</span><br><span class="line">sbitLCD_B4  = LCD_BUS^4;//D4 -- Pin 11VDD  -- Pin 2</span><br><span class="line">sbitLCD_B3  = LCD_BUS^3;//D3 -- Pin 10VSS  -- Pin 1</span><br><span class="line">sbitLCD_B2  = LCD_BUS^2;//D2 -- Pin  9</span><br><span class="line">sbitLCD_B1  = LCD_BUS^1;//D1 -- Pin  8</span><br><span class="line">sbitLCD_B0  = LCD_BUS^0;//D0 -- Pin  7</span><br><span class="line"></span><br><span class="line">sbitLCD_ENA= P2^2;//Pin 6</span><br><span class="line">sbitLCD_RW= P2^1;//Pin 5//LCD_RS   R/W   DB7--DB0        FOUNCTION</span><br><span class="line">sbitLCD_RS= P2^0;//Pin 4//00  INPUT      write the command to LCD model</span><br><span class="line">//01     OUTPUT     read BF and AC pointer from LCD model</span><br><span class="line">//10     INPUT      write the data to LCD  model</span><br><span class="line">//11     OUTPUT     read the data from LCD model</span><br><span class="line">/*</span><br><span class="line">total 2 lines, 16x2= 32</span><br><span class="line">first line address:  0~15</span><br><span class="line">second line address: 64~79</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define C_CLEAR0x01//clear LCD</span><br><span class="line">#define C_HOME 0x02//cursor go home</span><br><span class="line">#define C_CUR_L0x04//cursor shift left after input</span><br><span class="line">#define C_RIGHT0x05//picture shift right after input</span><br><span class="line">#define C_CUR_R0x06//cursor shift right after input</span><br><span class="line">#define C_LEFT 0x07//picture shift left after input</span><br><span class="line">#define C_OFF  0x08//turn off LCD</span><br><span class="line">#define C_ON   0x0C//turn on  LCD</span><br><span class="line">#define C_FLASH0x0D//turn on  LCD, flash </span><br><span class="line">#define C_CURSOR0x0E//turn on  LCD and cursor</span><br><span class="line">#define C_FLASH_ALL0x0F//turn on  LCD and cursor, flash</span><br><span class="line">#define C_CURSOR_LEFT0x10//single cursor shift left</span><br><span class="line">#define C_CURSOR_RIGHT0x10//single cursor shift right</span><br><span class="line">#define C_PICTURE_LEFT0x10//single picture shift left</span><br><span class="line">#define C_PICTURE_RIGHT0x10//single picture shift right</span><br><span class="line">#define C_BIT80x30//set the data is 8 bits</span><br><span class="line">#define C_BIT40x20//set the data is 4 bits</span><br><span class="line">#define C_L1DOT70x30//8 bits,one line 5*7  dots</span><br><span class="line">#define C_L1DOT100x34//8 bits,one line 5*10 dots</span><br><span class="line">#define C_L2DOT70x38//8 bits,tow lines 5*7 dots</span><br><span class="line">#define C_4bitL2DOT70x28//4 bits,tow lines 5*7 dots</span><br><span class="line">#define C_CGADDRESS00x40//CGRAM address0 (addr=40H+x)</span><br><span class="line">#define C_DDADDRESS00x80//DDRAM address0 (addr=80H+x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#defineLCD_DelayNop()NOP(15)</span><br><span class="line"></span><br><span class="line">#defineLCD_BusData(dat)LCD_BUS = dat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: voidCheckBusy(void)</span><br><span class="line">// 描述: 检测忙函数</span><br><span class="line">// 参数: none.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">voidCheckBusy(void)</span><br><span class="line">&#123;</span><br><span class="line">u16i;</span><br><span class="line">for(i=0; i&lt;5000; i++)&#123;if(!LCD_B7)break;&#125;//check the LCD busy or not. With time out</span><br><span class="line">//while(LCD_B7);//check the LCD busy or not. Without time out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void IniSendCMD(u8 cmd)</span><br><span class="line">// 描述: 初始化写命令(不检测忙)</span><br><span class="line">// 参数: cmd: 要写的命令.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void IniSendCMD(u8 cmd)</span><br><span class="line">&#123;</span><br><span class="line">LCD_RW = 0;</span><br><span class="line">LCD_BusData(cmd);</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 1;</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 0;</span><br><span class="line">LCD_BusData(0xff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void Write_CMD(u8 cmd)</span><br><span class="line">// 描述: 写命令(检测忙)</span><br><span class="line">// 参数: cmd: 要写的命令.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void Write_CMD(u8 cmd)</span><br><span class="line">&#123;</span><br><span class="line">LCD_RS  = 0;</span><br><span class="line">LCD_RW = 1;</span><br><span class="line">LCD_BusData(0xff);</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 1;</span><br><span class="line">CheckBusy();//check the LCD busy or not.</span><br><span class="line">LCD_ENA = 0;</span><br><span class="line">LCD_RW = 0;</span><br><span class="line"></span><br><span class="line">LCD_BusData(cmd);</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 1;</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 0;</span><br><span class="line">LCD_BusData(0xff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void Write_DIS_Data(u8 dat)</span><br><span class="line">// 描述: 写显示数据(检测忙)</span><br><span class="line">// 参数: dat: 要写的数据.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void Write_DIS_Data(u8 dat)</span><br><span class="line">&#123;</span><br><span class="line">LCD_RS = 0;</span><br><span class="line">LCD_RW = 1;</span><br><span class="line"></span><br><span class="line">LCD_BusData(0xff);</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 1;</span><br><span class="line">CheckBusy();//check the LCD busy or not.</span><br><span class="line">LCD_ENA = 0;</span><br><span class="line">LCD_RW = 0;</span><br><span class="line">LCD_RS  = 1;</span><br><span class="line"></span><br><span class="line">LCD_BusData(dat);</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 1;</span><br><span class="line">LCD_DelayNop();</span><br><span class="line">LCD_ENA = 0;</span><br><span class="line">LCD_BusData(0xff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char *uchartostr(unsigned num)//将一个字节的数据转换为字符串 或10进制</span><br><span class="line">&#123;</span><br><span class="line">unsigned char x2,x1,x0,i;</span><br><span class="line">x2=num/100;</span><br><span class="line">x1=num%100/10;</span><br><span class="line">x0=num%100%10;</span><br><span class="line">i=0;</span><br><span class="line">if(x2!=0)</span><br><span class="line">&#123;</span><br><span class="line">str[i]=x2+48;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(x1!=0)</span><br><span class="line">&#123;</span><br><span class="line">str[i]=x1+48;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">str[i]=x0+48;</span><br><span class="line">i++;</span><br><span class="line">str[i]=&#x27;\0&#x27;;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void Initialize_LCD(void)</span><br><span class="line">// 描述: 初始化函数</span><br><span class="line">// 参数: none.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void Initialize_LCD(void)</span><br><span class="line">&#123;</span><br><span class="line">LCD_ENA = 0;</span><br><span class="line">LCD_RS  = 0;</span><br><span class="line">LCD_RW = 0;</span><br><span class="line"></span><br><span class="line">delay_ms(100);</span><br><span class="line">IniSendCMD(C_BIT8);//set the data is 8 bits</span><br><span class="line"></span><br><span class="line">delay_ms(10);</span><br><span class="line">Write_CMD(C_L2DOT7);//tow lines 5*7 dots</span><br><span class="line"></span><br><span class="line">delay_ms(6);</span><br><span class="line">Write_CMD(C_CLEAR);//clear LCD RAM</span><br><span class="line">Write_CMD(C_CUR_R);//Curror Shift Right</span><br><span class="line">Write_CMD(C_ON);//turn on  LCD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void ClearLine(u8 row)</span><br><span class="line">// 描述: 清除1行</span><br><span class="line">// 参数: row: 行(0或1)</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void ClearLine(u8 row)</span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line">Write_CMD(((row &amp; 1) &lt;&lt; 6) | 0x80);</span><br><span class="line">for(i=0; i&lt;LineLength; i++)Write_DIS_Data(&#x27; &#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: voidWriteChar(u8 row, u8 column, u8 dat)</span><br><span class="line">// 描述: 指定行、列和字符, 写一个字符</span><br><span class="line">// 参数: row: 行(0或1),  column: 第几个字符(0~15),  dat: 要写的字符.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">voidWriteChar(u8 row, u8 column, u8 dat)</span><br><span class="line">&#123;</span><br><span class="line">Write_CMD((((row &amp; 1) &lt;&lt; 6) + column) | 0x80);</span><br><span class="line">Write_DIS_Data(dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//========================================================================</span><br><span class="line">// 函数: void PutString(u8 row, u8 column, u8 *puts)</span><br><span class="line">// 描述: 写一个字符串，指定行、列和字符串首地址</span><br><span class="line">// 参数: row: 行(0或1),  column: 第几个字符(0~15),  puts: 要写的字符串指针.</span><br><span class="line">// 返回: none.</span><br><span class="line">// 版本: VER1.0</span><br><span class="line">// 日期: 2013-4-1</span><br><span class="line">// 备注: </span><br><span class="line">//========================================================================</span><br><span class="line">void PutString(u8 row, u8 column, u8 *puts)</span><br><span class="line">&#123;</span><br><span class="line">Write_CMD((((row &amp; 1) &lt;&lt; 6) + column) | 0x80);</span><br><span class="line">for ( ;  *puts != 0;  puts++)//遇到停止符0结束</span><br><span class="line">&#123;</span><br><span class="line">Write_DIS_Data(*puts);</span><br><span class="line">if(++column &gt;= LineLength)break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void WriteROM()//LCD1602内部数据寄存器写入函数</span><br><span class="line">&#123;</span><br><span class="line">unsigned char i;</span><br><span class="line">Write_CMD(0x40); // 操作CGRAM的命令码</span><br><span class="line">for(i=0;i&lt;64;i++)            // 写入数组中数据  </span><br><span class="line">&#123;</span><br><span class="line">Write_DIS_Data(table[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//******************** LCD20 Module END ***************************</span><br><span class="line">//****************************************************</span><br><span class="line">//蜂鸣器程序</span><br><span class="line">//****************************************************</span><br><span class="line">void Buzzer_Di(void)&#123;</span><br><span class="line">Buzzer = 0;</span><br><span class="line">delay_ms(3);</span><br><span class="line">Buzzer = 1;</span><br><span class="line">delay_ms(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#x2F;*************本程序功能说明**************</p><p>驱动LCD1602字符屏.</p><p>显示效果为:  DS1302 + LCD1602显示时间</p><p>******************************************&#x2F;<br>#include“STC15Fxxxx.H”</p><p>#define T1MS (65536-MAIN_Fosc&#x2F;12&#x2F;1000)   &#x2F;&#x2F;12T模式1ms定时<br>#define  interval  1000 &#x2F;&#x2F;设置延时时间间隔<br>&#x2F;*************本地变量声明**************&#x2F;<br>static volatile unsigned long sysRunmillis &#x3D; 0;&#x2F;&#x2F;系统运行时间计数，保存单片机从上电复位以来运行的时间，单位是毫秒。该数值由定时器T0的中断响应子函数更新<br>unsigned long previousMillis &#x3D; 0;<br>unsigned char str[4];&#x2F;&#x2F;uchartostr函数转换的字符串 同时可以把16进制转成10进制<br>sbit Buzzer &#x3D; P3^7;<br>unsigned char code table[]&#x3D;<br>{<br>    0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,        &#x2F;&#x2F; 一，显示时的ASCII码 0x00<br>    0x00,0x00,0x00,0x0e,0x00,0xff,0x00,0x00,        &#x2F;&#x2F; 二，显示时的ASCII码 0x01<br>    0x00,0x00,0xff,0x00,0x0e,0x00,0xff,0x00,        &#x2F;&#x2F; 三，显示时的ASCII码 0x02<br>    0x00,0x00,0xff,0xf5,0xfb,0xf1,0xff,0x00,        &#x2F;&#x2F; 四，显示时的ASCII码 0x03<br>    0x00,0xfe,0x08,0xfe,0x0a,0x0a,0xff,0x00,        &#x2F;&#x2F; 五，显示时的ASCII码 0x04<br>    0x00,0x04,0x00,0xff,0x00,0x0a,0x11,0x00,        &#x2F;&#x2F; 六，显示时的ASCII码 0x05<br>    0x00,0x1f,0x11,0x1f,0x11,0x11,0x1f,0x00,        &#x2F;&#x2F; 日，显示时的ASCII码 0x06<br>    0x18,0x18,0x07,0x08,0x08,0x08,0x07,0x00,        &#x2F;&#x2F; ℃，显示时的ASCII码 0x07<br>};</p><p>void Timer0Init(void);&#x2F;&#x2F;1毫秒@12.000MHz<br>void  delay_ms(unsigned long ms);<br>voidInitialize_LCD(void);<br>voidWrite_AC(u8 hang,u8 lie);<br>voidWrite_DIS_Data(u8 DIS_Data);<br>void WriteROM();&#x2F;&#x2F;LCD1602内部数据寄存器写入函数<br>voidClearLine(u8 row);<br>u8BIN_ASCII(u8 tmp);<br>void PutString(u8 row, u8 column, u8 *puts);<br>voidWriteChar(u8 row, u8 column, u8 dat);<br>void Buzzer_Di(void);<br>unsigned char *uchartostr(unsigned num);&#x2F;&#x2F;将一个字节的数据转换为字符串 或10进制<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void main(void)<br>&#x2F;&#x2F; 描述: 主函数。<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void main(void)<br>{<br>    unsigned long currentMillis;&#x2F;&#x2F;当前时间<br>    unsigned char i &#x3D;0;<br>    P0M1 &#x3D; 0;P0M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P1M1 &#x3D; 0;P1M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P2M1 &#x3D; 0;P2M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P3M1 &#x3D; 0;P3M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P4M1 &#x3D; 0;P4M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P5M1 &#x3D; 0;P5M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P6M1 &#x3D; 0;P6M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    P7M1 &#x3D; 0;P7M0 &#x3D; 0;&#x2F;&#x2F;设置为准双向口<br>    Timer0Init();&#x2F;&#x2F;1毫秒@12.000MHz<br>    Initialize_LCD();&#x2F;&#x2F;LCD初始化函数<br>    ClearLine(0);<br>    ClearLine(1);<br>    PutString(0,0,”STC15W4K”);<br>    WriteROM();   &#x2F;&#x2F; 将自定义字形码写入LCD1602内部存储器<br>  WriteChar(1, 0, 0);<br>    WriteChar(1, 1, 1);<br>    WriteChar(1, 2, 2);<br>    WriteChar(1, 3, 3);<br>    WriteChar(1, 4, 4);<br>    WriteChar(1, 5, 5);<br>    WriteChar(1, 6, 6);<br>    WriteChar(1, 7, 7);<br>    while(1)<br>    {<br>        currentMillis &#x3D; sysRunmillis;<br>    if (currentMillis - previousMillis  &gt;&#x3D; interval)<br>        {&#x2F;&#x2F;每隔1秒翻转一次<br>    previousMillis &#x3D; sysRunmillis;<br>        if(++i &lt;&#x3D; 255){<br>            PutString(0,9,uchartostr(i));<br>            WriteChar(0, 14, i);</p><pre><code>        PutString(1,9,uchartostr(255 -i));        WriteChar(1, 14, 255 -i);            &#125;    &#125;&#125;</code></pre><p>} </p><p>void Timer0Init(void)&#x2F;&#x2F;1毫秒@12.000MHz<br>{<br>    AUXR &amp;&#x3D; 0x7F;&#x2F;&#x2F;定时器时钟12T模式<br>    TMOD &amp;&#x3D; 0xF0;&#x2F;&#x2F;设置定时器模式<br>    TL0 &#x3D; T1MS ;&#x2F;&#x2F;设置定时初始值<br>    TH0 &#x3D; T1MS &gt;&gt;8;&#x2F;&#x2F;设置定时初始值<br>&#x2F;&#x2F;TL0 &#x3D; 0x18;&#x2F;&#x2F;设置定时初始值<br>&#x2F;&#x2F;TH0 &#x3D; 0xFC;&#x2F;&#x2F;设置定时初始值</p><pre><code>TF0 = 0;//清除TF0标志TR0 = 1;//定时器0开始计时ET0 = 1;     //enable timer0 interrupt</code></pre><p>  EA &#x3D; 1;      &#x2F;&#x2F;open global interrupt switch<br>}</p><p>&#x2F;* Timer0 interrupt routine *&#x2F;<br>void tm0_isr() interrupt 1<br>{<br>&#x2F;&#x2F;TL0 &#x3D; 0x18;&#x2F;&#x2F;设置定时初始值<br>&#x2F;&#x2F;TH0 &#x3D; 0xFC;&#x2F;&#x2F;设置定时初始值<br>    TL0 &#x3D; T1MS;                     &#x2F;&#x2F;reload timer0 low byte<br>    TH0 &#x3D; T1MS &gt;&gt; 8;                &#x2F;&#x2F;reload timer0 high byte<br>    sysRunmillis ++;<br>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void  delay_ms(u8 ms)<br>&#x2F;&#x2F; 描述: 延时函数。<br>&#x2F;&#x2F; 参数: ms,要延时的ms数, 这里只支持1~255ms. 自动适应主时钟.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void  delay_ms(unsigned long ms)<br>{<br>    unsigned longtemp &#x3D; sysRunmillis ;<br>    while(sysRunmillis - temp &lt; ms );<br>&#x2F;&#x2F;     unsigned int i;<br>&#x2F;&#x2F; do{<br>&#x2F;&#x2F;      i &#x3D; MAIN_Fosc &#x2F; 13000;<br>&#x2F;&#x2F;  while(–i);   &#x2F;&#x2F;14T per loop<br>&#x2F;&#x2F;     }while(–ms);<br>}</p><p>&#x2F;************* LCD1602相关程序*****************************************************&#x2F;<br>&#x2F;&#x2F;8位数据访问方式LCD1602标准程序梁工编写2014-2-21</p><p>#define LineLength16&#x2F;&#x2F;16x2</p><p>&#x2F;*************Pin define*****************************************************&#x2F;</p><p>sfrLCD_BUS &#x3D; 0x80;&#x2F;&#x2F;P0–0x80, P1–0x90, P2–0xA0, P3–0xB0</p><p>sbitLCD_B7  &#x3D; LCD_BUS^7;&#x2F;&#x2F;D7 – Pin 14LED- – Pin 16<br>sbitLCD_B6  &#x3D; LCD_BUS^6;&#x2F;&#x2F;D6 – Pin 13LED+ – Pin 15<br>sbitLCD_B5  &#x3D; LCD_BUS^5;&#x2F;&#x2F;D5 – Pin 12Vo   – Pin 3<br>sbitLCD_B4  &#x3D; LCD_BUS^4;&#x2F;&#x2F;D4 – Pin 11VDD  – Pin 2<br>sbitLCD_B3  &#x3D; LCD_BUS^3;&#x2F;&#x2F;D3 – Pin 10VSS  – Pin 1<br>sbitLCD_B2  &#x3D; LCD_BUS^2;&#x2F;&#x2F;D2 – Pin  9<br>sbitLCD_B1  &#x3D; LCD_BUS^1;&#x2F;&#x2F;D1 – Pin  8<br>sbitLCD_B0  &#x3D; LCD_BUS^0;&#x2F;&#x2F;D0 – Pin  7</p><p>sbitLCD_ENA&#x3D; P2^2;&#x2F;&#x2F;Pin 6<br>sbitLCD_RW&#x3D; P2^1;&#x2F;&#x2F;Pin 5&#x2F;&#x2F;LCD_RS   R&#x2F;W   DB7–DB0        FOUNCTION<br>sbitLCD_RS&#x3D; P2^0;&#x2F;&#x2F;Pin 4&#x2F;&#x2F;00  INPUT      write the command to LCD model<br>                                &#x2F;&#x2F;01     OUTPUT     read BF and AC pointer from LCD model<br>                                &#x2F;&#x2F;10     INPUT      write the data to LCD  model<br>                                &#x2F;&#x2F;11     OUTPUT     read the data from LCD model<br>&#x2F;*<br>total 2 lines, 16x2&#x3D; 32<br>first line address:  0<del>15<br>second line address: 64</del>79</p><p>*&#x2F;</p><p>#define C_CLEAR0x01&#x2F;&#x2F;clear LCD<br>#define C_HOME 0x02&#x2F;&#x2F;cursor go home<br>#define C_CUR_L0x04&#x2F;&#x2F;cursor shift left after input<br>#define C_RIGHT0x05&#x2F;&#x2F;picture shift right after input<br>#define C_CUR_R0x06&#x2F;&#x2F;cursor shift right after input<br>#define C_LEFT 0x07&#x2F;&#x2F;picture shift left after input<br>#define C_OFF  0x08&#x2F;&#x2F;turn off LCD<br>#define C_ON   0x0C&#x2F;&#x2F;turn on  LCD<br>#define C_FLASH0x0D&#x2F;&#x2F;turn on  LCD, flash<br>#define C_CURSOR0x0E&#x2F;&#x2F;turn on  LCD and cursor<br>#define C_FLASH_ALL0x0F&#x2F;&#x2F;turn on  LCD and cursor, flash<br>#define C_CURSOR_LEFT0x10&#x2F;&#x2F;single cursor shift left<br>#define C_CURSOR_RIGHT0x10&#x2F;&#x2F;single cursor shift right<br>#define C_PICTURE_LEFT0x10&#x2F;&#x2F;single picture shift left<br>#define C_PICTURE_RIGHT0x10&#x2F;&#x2F;single picture shift right<br>#define C_BIT80x30&#x2F;&#x2F;set the data is 8 bits<br>#define C_BIT40x20&#x2F;&#x2F;set the data is 4 bits<br>#define C_L1DOT70x30&#x2F;&#x2F;8 bits,one line 5<em>7  dots<br>#define C_L1DOT100x34&#x2F;&#x2F;8 bits,one line 5</em>10 dots<br>#define C_L2DOT70x38&#x2F;&#x2F;8 bits,tow lines 5<em>7 dots<br>#define C_4bitL2DOT70x28&#x2F;&#x2F;4 bits,tow lines 5</em>7 dots<br>#define C_CGADDRESS00x40&#x2F;&#x2F;CGRAM address0 (addr&#x3D;40H+x)<br>#define C_DDADDRESS00x80&#x2F;&#x2F;DDRAM address0 (addr&#x3D;80H+x)</p><p>#defineLCD_DelayNop()NOP(15)</p><p>#defineLCD_BusData(dat)LCD_BUS &#x3D; dat</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: voidCheckBusy(void)<br>&#x2F;&#x2F; 描述: 检测忙函数<br>&#x2F;&#x2F; 参数: none.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>voidCheckBusy(void)<br>{<br>    u16i;<br>    for(i&#x3D;0; i&lt;5000; i++){if(!LCD_B7)break;}&#x2F;&#x2F;check the LCD busy or not. With time out<br>&#x2F;&#x2F;while(LCD_B7);&#x2F;&#x2F;check the LCD busy or not. Without time out<br>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void IniSendCMD(u8 cmd)<br>&#x2F;&#x2F; 描述: 初始化写命令(不检测忙)<br>&#x2F;&#x2F; 参数: cmd: 要写的命令.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void IniSendCMD(u8 cmd)<br>{<br>    LCD_RW &#x3D; 0;<br>    LCD_BusData(cmd);<br>    LCD_DelayNop();<br>    LCD_ENA &#x3D; 1;<br>    LCD_DelayNop();<br>    LCD_ENA &#x3D; 0;<br>    LCD_BusData(0xff);<br>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void Write_CMD(u8 cmd)<br>&#x2F;&#x2F; 描述: 写命令(检测忙)<br>&#x2F;&#x2F; 参数: cmd: 要写的命令.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void Write_CMD(u8 cmd)<br>{<br>    LCD_RS  &#x3D; 0;<br>    LCD_RW &#x3D; 1;<br>    LCD_BusData(0xff);<br>    LCD_DelayNop();<br>    LCD_ENA &#x3D; 1;<br>    CheckBusy();&#x2F;&#x2F;check the LCD busy or not.<br>    LCD_ENA &#x3D; 0;<br>    LCD_RW &#x3D; 0;</p><pre><code>LCD_BusData(cmd);LCD_DelayNop();LCD_ENA = 1;LCD_DelayNop();LCD_ENA = 0;LCD_BusData(0xff);</code></pre><p>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void Write_DIS_Data(u8 dat)<br>&#x2F;&#x2F; 描述: 写显示数据(检测忙)<br>&#x2F;&#x2F; 参数: dat: 要写的数据.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void Write_DIS_Data(u8 dat)<br>{<br>    LCD_RS &#x3D; 0;<br>    LCD_RW &#x3D; 1;</p><pre><code>LCD_BusData(0xff);LCD_DelayNop();LCD_ENA = 1;CheckBusy();//check the LCD busy or not.LCD_ENA = 0;LCD_RW = 0;LCD_RS  = 1;LCD_BusData(dat);LCD_DelayNop();LCD_ENA = 1;LCD_DelayNop();LCD_ENA = 0;LCD_BusData(0xff);</code></pre><p>}</p><p>unsigned char *uchartostr(unsigned num)&#x2F;&#x2F;将一个字节的数据转换为字符串 或10进制<br>{<br>    unsigned char x2,x1,x0,i;<br>    x2&#x3D;num&#x2F;100;<br>    x1&#x3D;num%100&#x2F;10;<br>    x0&#x3D;num%100%10;<br>    i&#x3D;0;<br>    if(x2!&#x3D;0)<br>    {<br>        str[i]&#x3D;x2+48;<br>        i++;<br>    }<br>    if(x1!&#x3D;0)<br>    {<br>        str[i]&#x3D;x1+48;<br>        i++;<br>    }<br>    str[i]&#x3D;x0+48;<br>    i++;<br>    str[i]&#x3D;’\0’;<br>    return str;<br>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void Initialize_LCD(void)<br>&#x2F;&#x2F; 描述: 初始化函数<br>&#x2F;&#x2F; 参数: none.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void Initialize_LCD(void)<br>{<br>    LCD_ENA &#x3D; 0;<br>    LCD_RS  &#x3D; 0;<br>    LCD_RW &#x3D; 0;</p><pre><code>delay_ms(100);IniSendCMD(C_BIT8);//set the data is 8 bitsdelay_ms(10);Write_CMD(C_L2DOT7);//tow lines 5*7 dotsdelay_ms(6);Write_CMD(C_CLEAR);//clear LCD RAMWrite_CMD(C_CUR_R);//Curror Shift RightWrite_CMD(C_ON);//turn on  LCD</code></pre><p>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void ClearLine(u8 row)<br>&#x2F;&#x2F; 描述: 清除1行<br>&#x2F;&#x2F; 参数: row: 行(0或1)<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void ClearLine(u8 row)<br>{<br>    u8 i;<br>    Write_CMD(((row &amp; 1) &lt;&lt; 6) | 0x80);<br>    for(i&#x3D;0; i&lt;LineLength; i++)Write_DIS_Data(‘ ‘);<br>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: voidWriteChar(u8 row, u8 column, u8 dat)<br>&#x2F;&#x2F; 描述: 指定行、列和字符, 写一个字符<br>&#x2F;&#x2F; 参数: row: 行(0或1),  column: 第几个字符(0~15),  dat: 要写的字符.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>voidWriteChar(u8 row, u8 column, u8 dat)<br>{<br>    Write_CMD((((row &amp; 1) &lt;&lt; 6) + column) | 0x80);<br>    Write_DIS_Data(dat);<br>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>&#x2F;&#x2F; 函数: void PutString(u8 row, u8 column, u8 *puts)<br>&#x2F;&#x2F; 描述: 写一个字符串，指定行、列和字符串首地址<br>&#x2F;&#x2F; 参数: row: 行(0或1),  column: 第几个字符(0~15),  puts: 要写的字符串指针.<br>&#x2F;&#x2F; 返回: none.<br>&#x2F;&#x2F; 版本: VER1.0<br>&#x2F;&#x2F; 日期: 2013-4-1<br>&#x2F;&#x2F; 备注:<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>void PutString(u8 row, u8 column, u8 *puts)<br>{<br>    Write_CMD((((row &amp; 1) &lt;&lt; 6) + column) | 0x80);<br>    for ( ;  *puts !&#x3D; 0;  puts++)&#x2F;&#x2F;遇到停止符0结束<br>    {<br>        Write_DIS_Data(*puts);<br>        if(++column &gt;&#x3D; LineLength)break;<br>    }<br>}<br>void WriteROM()&#x2F;&#x2F;LCD1602内部数据寄存器写入函数<br>{<br>        unsigned char i;<br>    Write_CMD(0x40); &#x2F;&#x2F; 操作CGRAM的命令码<br>    for(i&#x3D;0;i&lt;64;i++)            &#x2F;&#x2F; 写入数组中数据<br>    {<br>        Write_DIS_Data(table[i]);<br>    }<br>}</p><p>&#x2F;&#x2F;******************** LCD20 Module END ***************************<br>&#x2F;&#x2F;****************************************************<br>&#x2F;&#x2F;蜂鸣器程序<br>&#x2F;&#x2F;****************************************************<br>void Buzzer_Di(void){<br>    Buzzer &#x3D; 0;<br>    delay_ms(3);<br>    Buzzer &#x3D; 1;<br>    delay_ms(3);<br>}&#96;</p><h4 id="程序源码和仿真资源"><a href="#程序源码和仿真资源" class="headerlink" title="程序源码和仿真资源"></a>程序源码和仿真资源</h4><p>本实验基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1Q7PCk5sDC2lwsVZjvHmvlw </span><br><span class="line">提取码：pzl3//请使用复制粘贴命令，手工输入容易出错</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1Q7PCk5sDC2lwsVZjvHmvlw  提取码：pzl3//请使用复制粘贴命令，手工输入容易出错</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁</title>
      <link href="/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%94%A824C04%E4%B8%8E1602LCD%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E9%94%81/"/>
      <url>/2024/03/Proteus-Proteus%E4%BB%BF%E7%9C%9F%E7%94%A824C04%E4%B8%8E1602LCD%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%AE%80%E6%98%93%E5%8A%A0%E5%AF%86%E7%94%B5%E5%AD%90%E5%AF%86%E7%A0%81%E9%94%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁"><a href="#【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁" class="headerlink" title="【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁"></a>【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁</h1><h3 id="【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁-1"><a href="#【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁-1" class="headerlink" title="【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁"></a>【Proteus仿真】用24C04与1602LCD设计的简易加密电子密码锁</h3><ul><li>Proteus仿真演示</li><li>VSCode 演示生成BIN文件</li></ul><p>Proteus仿真演示</p><p><img src="https://img-blog.csdnimg.cn/198cd9c897614743b28f99c45fdb21f4.gif#pic_center" alt="在这里插入图片描述"></p><p>VSCode 演示生成BIN文件</p><p><code>VSCode</code></p><p><code>BIN</code></p><p><img src="https://img-blog.csdnimg.cn/38c3072c2faf45cb98d21819214ba205.gif#pic_center" alt="在这里插入图片描述"></p><h4 id="24C04密码字库生成方法"><a href="#24C04密码字库生成方法" class="headerlink" title="24C04密码字库生成方法"></a>24C04密码字库生成方法</h4><ul><li>需要使用VSCode来编译生成。</li><li>前提是需要先按照Code Runner插件。</li></ul><p><code>VSCode</code></p><p><img src="https://img-blog.csdnimg.cn/26af65f1f0074f79a4070223fcc7f650.png" alt="在这里插入图片描述"></p><p><code>Code Runner</code></p><p><img src="https://img-blog.csdnimg.cn/441287ab3d064ab1a41f887dd285ac1d.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fe91e54956654ac991d1a27c0f8d94f8.png" alt="在这里插入图片描述"></p><ul><li>.ccp文件</li></ul><p><code>.ccp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  fp = fopen(&quot;24c04a.bin&quot;,&quot;wb&quot;);//编译时在项目文件夹内生成二进制24c04a.bin文件</span><br><span class="line">  fwrite(&quot;654321\x0&quot;,1,7,fp);//写入的内容</span><br><span class="line">  fclose(fp);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#include &lt;stdio.h&gt; int main() &#123;   FILE *fp;   fp = fopen(&quot;24c04a.bin&quot;,&quot;wb&quot;);//编译时在项目文件夹内生成二进制24c04a.bin文件   fwrite(&quot;654321\x0&quot;,1,7,fp);//写入的内容   fclose(fp);   return 0; &#125;</code></p><h4 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg51.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#define uint unsigned int</span><br><span class="line">#define     LCDIO      P0</span><br><span class="line">#define delay4us() _nop_();_nop_();_nop_();_nop_();</span><br><span class="line">uchar buffer[6]=&#123;0&#125;; </span><br><span class="line">sbit sda=P3^3;</span><br><span class="line">sbit scl=P3^2;</span><br><span class="line">sbit beep=P3^7;</span><br><span class="line">bit  flag=0,aa;        //用户蹲渊义定时溢出标志位</span><br><span class="line">uchar  DSY_BUFFER[16]=&quot;                &quot;;</span><br><span class="line">uchar  DSY_BUFFER1[16]=&quot;                &quot;;</span><br><span class="line">uchar  Userpassword[6]=&#123;0&#125;;</span><br><span class="line">sbit  rs=P2^0;  </span><br><span class="line">sbit  rd=P2^1;</span><br><span class="line">sbit  lcden=P2^2;</span><br><span class="line">sbit  led=P2^7;</span><br><span class="line">uchar code table2[]=&quot;123456&quot;;</span><br><span class="line">uchar code table[]=&quot;Your Password...&quot;;</span><br><span class="line">void delayms(uint z)</span><br><span class="line">&#123;</span><br><span class="line">  uint x,y;</span><br><span class="line">  for(x=z;x&gt;0;x--)</span><br><span class="line">    for(y=110;y&gt;0;y--);</span><br><span class="line">&#125;</span><br><span class="line">void delay()      //短延时，两个机器周期,做总线的延时用</span><br><span class="line">&#123;;;&#125;</span><br><span class="line">void write_com(uchar com)</span><br><span class="line">&#123;</span><br><span class="line">  rs=0;</span><br><span class="line">  rd=0;</span><br><span class="line">  lcden=0;</span><br><span class="line">  P0=com;</span><br><span class="line">  delayms(3);</span><br><span class="line">  lcden=1;</span><br><span class="line">  delayms(3);</span><br><span class="line">  lcden=0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_date(uchar date)</span><br><span class="line">&#123;</span><br><span class="line">  rs=1;</span><br><span class="line">  rd=0;</span><br><span class="line">  lcden=0;</span><br><span class="line">  P0=date;</span><br><span class="line">  delayms(3);</span><br><span class="line">  lcden=1;</span><br><span class="line">  delayms(3);</span><br><span class="line">  lcden=0;  </span><br><span class="line">&#125;</span><br><span class="line">void Display_String(uchar *p,uchar com)</span><br><span class="line">&#123;  uchar i;</span><br><span class="line">   write_com(com);</span><br><span class="line">   for(i=0;i&lt;16;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   write_date(p[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init_lcd()</span><br><span class="line">&#123;</span><br><span class="line">  lcden=0;</span><br><span class="line">  write_com(0x38);</span><br><span class="line">  write_com(0x0c);</span><br><span class="line">  write_com(0x06);</span><br><span class="line">  write_com(0x01);</span><br><span class="line">  write_com(0x80);</span><br><span class="line">    Display_String(table,0x80);</span><br><span class="line">  Display_String(&quot;Lock OK!         &quot;,0xc0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void start()</span><br><span class="line">&#123;</span><br><span class="line">  sda=1;</span><br><span class="line">  scl=1;</span><br><span class="line">  delay4us();</span><br><span class="line">  sda=0;</span><br><span class="line">  delay4us();</span><br><span class="line">  scl=0;</span><br><span class="line">&#125;</span><br><span class="line">void stop()</span><br><span class="line">&#123;</span><br><span class="line">  sda=0;</span><br><span class="line">  scl=1;</span><br><span class="line">  delay4us();</span><br><span class="line">  sda=1;</span><br><span class="line">  delay4us();</span><br><span class="line">  scl=0;</span><br><span class="line">&#125;</span><br><span class="line">void init()              //初始化</span><br><span class="line">&#123;</span><br><span class="line">sda=1;</span><br><span class="line">delay();</span><br><span class="line">scl=1;</span><br><span class="line">delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ack()</span><br><span class="line">&#123;</span><br><span class="line">  sda=0;</span><br><span class="line">  scl=1;</span><br><span class="line">  delay4us();</span><br><span class="line">  scl=0;</span><br><span class="line">  sda=1;</span><br><span class="line">&#125;</span><br><span class="line">void noack()</span><br><span class="line">&#123;</span><br><span class="line">  sda=1;</span><br><span class="line">  scl=1;</span><br><span class="line">  delay4us();</span><br><span class="line">  scl=0;</span><br><span class="line">  sda=0;</span><br><span class="line">&#125;</span><br><span class="line">uchar recbyte()</span><br><span class="line">&#123;</span><br><span class="line">  uchar i,rd;</span><br><span class="line">  rd=0x00;</span><br><span class="line">  sda=1;</span><br><span class="line">  for(i=0;i&lt;8;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    scl=1;</span><br><span class="line">    rd&lt;&lt;=1;</span><br><span class="line">    rd|=sda;</span><br><span class="line">    delay4us();</span><br><span class="line">    scl=0;</span><br><span class="line">    delay4us();</span><br><span class="line">  &#125;</span><br><span class="line">  scl=0;</span><br><span class="line">  delay4us();</span><br><span class="line">  return rd;</span><br><span class="line">&#125;</span><br><span class="line">uchar sendbyte(uchar wd)</span><br><span class="line">&#123;</span><br><span class="line">  uchar i;</span><br><span class="line">  bit ack0;</span><br><span class="line">  for(i=0;i&lt;8;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sda=(bit)(wd&amp;0x80);</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    scl=1;</span><br><span class="line">    delay4us();</span><br><span class="line">    scl=0;</span><br><span class="line">    wd&lt;&lt;=1;</span><br><span class="line">  &#125;</span><br><span class="line">  delay4us();</span><br><span class="line">  sda=1;</span><br><span class="line">  scl=1;</span><br><span class="line">  delay4us();</span><br><span class="line">  ack0=!sda;</span><br><span class="line">  scl=0;</span><br><span class="line">  delay4us();</span><br><span class="line">  return ack0;</span><br><span class="line">&#125;</span><br><span class="line">uchar Recstring(uchar slave,uchar subaddr,uchar *buffer,uchar n)</span><br><span class="line">&#123;</span><br><span class="line"> uchar i; </span><br><span class="line"> start();</span><br><span class="line"> if(!sendbyte(slave)) return 0;</span><br><span class="line"> if(!sendbyte(subaddr)) return 0;</span><br><span class="line"> start();</span><br><span class="line"> if(!sendbyte(slave+1)) return 0;</span><br><span class="line"> for(i=0;i&lt;n-1;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    buffer[i]=recbyte();</span><br><span class="line">  ack();</span><br><span class="line">  &#125;</span><br><span class="line"> buffer[n-1]=recbyte();</span><br><span class="line"> noack();</span><br><span class="line"> stop();</span><br><span class="line"> return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar Sendstring(uchar slave,uchar subaddr,uchar *buffer,uchar n)</span><br><span class="line">&#123;</span><br><span class="line">  uchar i;</span><br><span class="line">  start();</span><br><span class="line">  if(!sendbyte(slave)) return 0;</span><br><span class="line">  if(!sendbyte(subaddr)) return 0;</span><br><span class="line">  for(i=0;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(!sendbyte(buffer[i])) return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  stop();</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line">void clear_password( )</span><br><span class="line">&#123;  uchar i;</span><br><span class="line">  for(i=0;i&lt;6;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   Userpassword[i]=&#x27; &#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">  for(i=0;i&lt;16;i++)</span><br><span class="line">  &#123;</span><br><span class="line">     DSY_BUFFER[i]=&#x27; &#x27;;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">uchar Keys_Scan()</span><br><span class="line">&#123;  </span><br><span class="line">  uchar temp,keynum;</span><br><span class="line">  P1=0x0F;</span><br><span class="line">  delayms(5);</span><br><span class="line">  temp=P1^0x0F;</span><br><span class="line">  switch(temp)</span><br><span class="line">  &#123;</span><br><span class="line">    case 1:keynum=0;break;</span><br><span class="line">    case 2:keynum=1;break;</span><br><span class="line">    case 4:keynum=2;break;</span><br><span class="line">    case 8:keynum=3;break;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  P1=0xF0;</span><br><span class="line">  delayms(5);</span><br><span class="line">  temp=P1&gt;&gt;4^0x0F;</span><br><span class="line">  switch(temp)</span><br><span class="line">  &#123;</span><br><span class="line">    case 1:keynum+=0;break;</span><br><span class="line">    case 2:keynum+=4;break;</span><br><span class="line">    case 4:keynum+=8;break;</span><br><span class="line">    case 8:keynum+=12;break;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  delayms(600);</span><br><span class="line">   return keynum;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;   uchar temp,i=0,j=0,k=0,n;</span><br><span class="line">  uchar IS_valid_user; </span><br><span class="line">  beep=1;</span><br><span class="line">  init();      </span><br><span class="line">    init_lcd();</span><br><span class="line">  delayms(5);</span><br><span class="line">  aa=Sendstring(0xa0,1,table2,6);</span><br><span class="line">  delayms(5);</span><br><span class="line">  aa=Recstring(0xa0,1,buffer,6);</span><br><span class="line">  delayms(10);</span><br><span class="line">   P1=0x0f;     </span><br><span class="line">    while(1)</span><br><span class="line">    &#123; </span><br><span class="line">     </span><br><span class="line">      if(P1!=0x0f)</span><br><span class="line">      &#123;  </span><br><span class="line">          temp=Keys_Scan();</span><br><span class="line">          switch(temp)</span><br><span class="line">                 &#123;</span><br><span class="line">                       case 0:  case 1: case 2: case 3: case 4: </span><br><span class="line">                       case 5:  case 6: case 7: case 8: case 9:</span><br><span class="line">                        </span><br><span class="line">                       if (i&lt;=5)             //密码限制在6位以内</span><br><span class="line">                       &#123;</span><br><span class="line">                        Userpassword[i]=temp;</span><br><span class="line">                        DSY_BUFFER[i]=&#x27;*&#x27;;</span><br><span class="line">                        Display_String(DSY_BUFFER,0xc0);    </span><br><span class="line">            i++;</span><br><span class="line">                         &#125;                </span><br><span class="line">                        break;</span><br><span class="line">                </span><br><span class="line">                        case 10: //按A键开锁</span><br><span class="line">            for(k=0;k&lt;6;k++)</span><br><span class="line">            &#123;</span><br><span class="line">              if(buffer[k]==(Userpassword[k]+48))</span><br><span class="line">              flag=1;</span><br><span class="line">              else</span><br><span class="line">              flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">                        if (flag==1) </span><br><span class="line">                        &#123; flag=0;</span><br><span class="line">              i=0;</span><br><span class="line">                          led=0;  //点亮LED</span><br><span class="line">                           clear_password();</span><br><span class="line">                           Display_String(&quot;OPEN    OK!      &quot;,0xc0);</span><br><span class="line">                           IS_valid_user = 1;</span><br><span class="line">               j=0;</span><br><span class="line">                        &#125;</span><br><span class="line">                       else </span><br><span class="line">                        &#123; </span><br><span class="line">             j++;</span><br><span class="line">                         led=1;   //关闭LED</span><br><span class="line">                         clear_password();</span><br><span class="line">                         Display_String(&quot;ERROR!Have try   &quot;,0xc0);</span><br><span class="line">             write_com(0xcf);</span><br><span class="line">             write_date(0x30+j);</span><br><span class="line">                         IS_valid_user=0;</span><br><span class="line">                         &#125;</span><br><span class="line">                        i=0;</span><br><span class="line">                        break;</span><br><span class="line">                    </span><br><span class="line">                      case 11: //按B键上锁</span><br><span class="line">                      led=1;   </span><br><span class="line">                      clear_password();</span><br><span class="line">                      Display_String(table,0x80);</span><br><span class="line">                      Display_String(&quot;Lock OK!         &quot;,0xc0);</span><br><span class="line">                      i=0;                         </span><br><span class="line">                      IS_valid_user=0;               </span><br><span class="line">                      break;</span><br><span class="line">                                   </span><br><span class="line">                      case 12: //按C键设置新密码</span><br><span class="line">                       //如果是合法用户则提示输入新密码    </span><br><span class="line">                      if ( !IS_valid_user) </span><br><span class="line">            &#123;</span><br><span class="line">             i=0;</span><br><span class="line">             Display_String(&quot;No rights !      &quot;,0xc0);</span><br><span class="line">             delayms(1000);</span><br><span class="line">             Display_String(&quot;Your Password...&quot;,0x80);</span><br><span class="line">             Display_String(&quot;Lock OK!         &quot;,0xc0);</span><br><span class="line">             &#125;</span><br><span class="line">                       else </span><br><span class="line">                        &#123;</span><br><span class="line">                          i=0;</span><br><span class="line">                          Display_String(&quot;New Password:   &quot;,0x80);</span><br><span class="line">                          Display_String(&quot;                &quot;,0xc0);</span><br><span class="line">                         &#125;</span><br><span class="line">           </span><br><span class="line">                       break;                        </span><br><span class="line">                    </span><br><span class="line">                      case 13: //按D键保存新密码</span><br><span class="line">                      if ( !IS_valid_user)</span><br><span class="line">            &#123;   i=0;</span><br><span class="line">               Display_String(&quot;No rights !       &quot;,0xc0);</span><br><span class="line">                delayms(1000);</span><br><span class="line">             Display_String(&quot;Your Password...&quot;,0x80);</span><br><span class="line">             Display_String(&quot;Lock OK!         &quot;,0xc0);</span><br><span class="line">             &#125;</span><br><span class="line">                       else </span><br><span class="line">                      &#123;i = 0;  </span><br><span class="line">             init();</span><br><span class="line">             delayms(5);</span><br><span class="line">             for(k=0;k&lt;6;k++)</span><br><span class="line">             &#123;</span><br><span class="line">               Userpassword[k]=Userpassword[k]+48;</span><br><span class="line">             &#125;</span><br><span class="line">                       aa=Sendstring(0xa0,1,Userpassword,6);</span><br><span class="line">             delayms(5);</span><br><span class="line">                       aa=Recstring(0xa0,1,buffer,6);  </span><br><span class="line">             delayms(5); </span><br><span class="line">                       clear_password();                         </span><br><span class="line">                       Display_String(table,0x00);</span><br><span class="line">                       Display_String(&quot;Password Saved!   &quot;,0xc0);</span><br><span class="line">             delayms(1000);</span><br><span class="line">             Display_String(&quot;Do lock agian ?   &quot;,0xc0);</span><br><span class="line">                      &#125;               </span><br><span class="line">                      break;                        </span><br><span class="line">       </span><br><span class="line">                      case 14: //按E键消除所有输入</span><br><span class="line">                      i=0;</span><br><span class="line">                      clear_password();</span><br><span class="line">                      Display_String(&quot;                &quot;,0xc0);            </span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            case 15:   //清除一位</span><br><span class="line">             if(i!=0)i--;</span><br><span class="line">             for(n=0;n&lt;i;n++)</span><br><span class="line">             &#123;</span><br><span class="line">               DSY_BUFFER1[n]=&#x27;*&#x27;;  </span><br><span class="line">             &#125;</span><br><span class="line">             Display_String(DSY_BUFFER1,0xc0);    </span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line">            P1=0x0f;</span><br><span class="line">      &#125;</span><br><span class="line">      if(j==3)</span><br><span class="line">      &#123;  Display_String(&quot;THIEF!!!THIEF!!!&quot;,0xc0); </span><br><span class="line">        j=0;</span><br><span class="line">        beep=0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;#include&lt;reg51.h&gt;<br>#include&lt;string.h&gt;<br>#include&lt;intrins.h&gt;<br>#define uchar unsigned char<br>#define uint unsigned int<br>#define     LCDIO      P0<br>#define delay4us() <em>nop</em>();<em>nop</em>();<em>nop</em>();<em>nop</em>();<br>uchar buffer[6]&#x3D;{0};<br>sbit sda&#x3D;P3^3;<br>sbit scl&#x3D;P3^2;<br>sbit beep&#x3D;P3^7;<br>bit  flag&#x3D;0,aa;        &#x2F;&#x2F;用户蹲渊义定时溢出标志位<br>uchar  DSY_BUFFER[16]&#x3D;”                “;<br>uchar  DSY_BUFFER1[16]&#x3D;”                “;<br>uchar  Userpassword[6]&#x3D;{0};<br>sbit  rs&#x3D;P2^0;<br>sbit  rd&#x3D;P2^1;<br>sbit  lcden&#x3D;P2^2;<br>sbit  led&#x3D;P2^7;<br>uchar code table2[]&#x3D;”123456”;<br>uchar code table[]&#x3D;”Your Password…”;<br>void delayms(uint z)<br>{<br>  uint x,y;<br>  for(x&#x3D;z;x&gt;0;x–)<br>    for(y&#x3D;110;y&gt;0;y–);<br>}<br>void delay()      &#x2F;&#x2F;短延时，两个机器周期,做总线的延时用<br>{;;}<br>void write_com(uchar com)<br>{<br>  rs&#x3D;0;<br>  rd&#x3D;0;<br>  lcden&#x3D;0;<br>  P0&#x3D;com;<br>  delayms(3);<br>  lcden&#x3D;1;<br>  delayms(3);<br>  lcden&#x3D;0;<br>}</p><p>void write_date(uchar date)<br>{<br>  rs&#x3D;1;<br>  rd&#x3D;0;<br>  lcden&#x3D;0;<br>  P0&#x3D;date;<br>  delayms(3);<br>  lcden&#x3D;1;<br>  delayms(3);<br>  lcden&#x3D;0;<br>}<br>void Display_String(uchar *p,uchar com)<br>{  uchar i;<br>   write_com(com);<br>   for(i&#x3D;0;i&lt;16;i++)<br>   {<br>   write_date(p[i]);<br>  }<br>}<br>void init_lcd()<br>{<br>  lcden&#x3D;0;<br>  write_com(0x38);<br>  write_com(0x0c);<br>  write_com(0x06);<br>  write_com(0x01);<br>  write_com(0x80);<br>    Display_String(table,0x80);<br>  Display_String(“Lock OK!         “,0xc0);<br>}</p><p>void start()<br>{<br>  sda&#x3D;1;<br>  scl&#x3D;1;<br>  delay4us();<br>  sda&#x3D;0;<br>  delay4us();<br>  scl&#x3D;0;<br>}<br>void stop()<br>{<br>  sda&#x3D;0;<br>  scl&#x3D;1;<br>  delay4us();<br>  sda&#x3D;1;<br>  delay4us();<br>  scl&#x3D;0;<br>}<br>void init()              &#x2F;&#x2F;初始化<br>{<br>sda&#x3D;1;<br>delay();<br>scl&#x3D;1;<br>delay();<br>}</p><p>void ack()<br>{<br>  sda&#x3D;0;<br>  scl&#x3D;1;<br>  delay4us();<br>  scl&#x3D;0;<br>  sda&#x3D;1;<br>}<br>void noack()<br>{<br>  sda&#x3D;1;<br>  scl&#x3D;1;<br>  delay4us();<br>  scl&#x3D;0;<br>  sda&#x3D;0;<br>}<br>uchar recbyte()<br>{<br>  uchar i,rd;<br>  rd&#x3D;0x00;<br>  sda&#x3D;1;<br>  for(i&#x3D;0;i&lt;8;i++)<br>  {<br>    scl&#x3D;1;<br>    rd&lt;&lt;&#x3D;1;<br>    rd|&#x3D;sda;<br>    delay4us();<br>    scl&#x3D;0;<br>    delay4us();<br>  }<br>  scl&#x3D;0;<br>  delay4us();<br>  return rd;<br>}<br>uchar sendbyte(uchar wd)<br>{<br>  uchar i;<br>  bit ack0;<br>  for(i&#x3D;0;i&lt;8;i++)<br>  {<br>    sda&#x3D;(bit)(wd&amp;0x80);<br>    <em>nop</em>();<br>    <em>nop</em>();<br>    scl&#x3D;1;<br>    delay4us();<br>    scl&#x3D;0;<br>    wd&lt;&lt;&#x3D;1;<br>  }<br>  delay4us();<br>  sda&#x3D;1;<br>  scl&#x3D;1;<br>  delay4us();<br>  ack0&#x3D;!sda;<br>  scl&#x3D;0;<br>  delay4us();<br>  return ack0;<br>}<br>uchar Recstring(uchar slave,uchar subaddr,uchar *buffer,uchar n)<br>{<br> uchar i;<br> start();<br> if(!sendbyte(slave)) return 0;<br> if(!sendbyte(subaddr)) return 0;<br> start();<br> if(!sendbyte(slave+1)) return 0;<br> for(i&#x3D;0;i&lt;n-1;i++)<br>  {<br>    buffer[i]&#x3D;recbyte();<br>  ack();<br>  }<br> buffer[n-1]&#x3D;recbyte();<br> noack();<br> stop();<br> return 1;<br>}</p><p>uchar Sendstring(uchar slave,uchar subaddr,uchar *buffer,uchar n)<br>{<br>  uchar i;<br>  start();<br>  if(!sendbyte(slave)) return 0;<br>  if(!sendbyte(subaddr)) return 0;<br>  for(i&#x3D;0;i&lt;n;i++)<br>  {<br>    if(!sendbyte(buffer[i])) return 0;<br>  }<br>  stop();<br>  return 1;<br>}<br>void clear_password( )<br>{  uchar i;<br>  for(i&#x3D;0;i&lt;6;i++)<br>  {<br>   Userpassword[i]&#x3D;’ ‘;<br>  }<br>  for(i&#x3D;0;i&lt;16;i++)<br>  {<br>     DSY_BUFFER[i]&#x3D;’ ‘;<br>   }<br>}<br>uchar Keys_Scan()<br>{<br>  uchar temp,keynum;<br>  P1&#x3D;0x0F;<br>  delayms(5);<br>  temp&#x3D;P1^0x0F;<br>  switch(temp)<br>  {<br>    case 1:keynum&#x3D;0;break;<br>    case 2:keynum&#x3D;1;break;<br>    case 4:keynum&#x3D;2;break;<br>    case 8:keynum&#x3D;3;break;<br>    break;<br>  }<br>  P1&#x3D;0xF0;<br>  delayms(5);<br>  temp&#x3D;P1&gt;&gt;4^0x0F;<br>  switch(temp)<br>  {<br>    case 1:keynum+&#x3D;0;break;<br>    case 2:keynum+&#x3D;4;break;<br>    case 4:keynum+&#x3D;8;break;<br>    case 8:keynum+&#x3D;12;break;<br>    break;<br>  }<br>  delayms(600);<br>   return keynum;<br>}<br>void main()<br>{   uchar temp,i&#x3D;0,j&#x3D;0,k&#x3D;0,n;<br>  uchar IS_valid_user;<br>  beep&#x3D;1;<br>  init();<br>    init_lcd();<br>  delayms(5);<br>  aa&#x3D;Sendstring(0xa0,1,table2,6);<br>  delayms(5);<br>  aa&#x3D;Recstring(0xa0,1,buffer,6);<br>  delayms(10);<br>   P1&#x3D;0x0f;<br>    while(1)<br>    { </p><pre><code>  if(P1!=0x0f)  &#123;        temp=Keys_Scan();      switch(temp)             &#123;                   case 0:  case 1: case 2: case 3: case 4:                    case 5:  case 6: case 7: case 8: case 9:                                       if (i&lt;=5)             //密码限制在6位以内                   &#123;                    Userpassword[i]=temp;                    DSY_BUFFER[i]=&#39;*&#39;;                    Display_String(DSY_BUFFER,0xc0);            i++;                     &#125;                                    break;                                case 10: //按A键开锁        for(k=0;k&lt;6;k++)        &#123;          if(buffer[k]==(Userpassword[k]+48))          flag=1;          else          flag=0;        &#125;                    if (flag==1)                     &#123; flag=0;          i=0;                      led=0;  //点亮LED                       clear_password();                       Display_String(&quot;OPEN    OK!      &quot;,0xc0);                       IS_valid_user = 1;           j=0;                    &#125;                   else                     &#123;          j++;                     led=1;   //关闭LED                     clear_password();                     Display_String(&quot;ERROR!Have try   &quot;,0xc0);         write_com(0xcf);         write_date(0x30+j);                     IS_valid_user=0;                     &#125;                    i=0;                    break;                                  case 11: //按B键上锁                  led=1;                     clear_password();                  Display_String(table,0x80);                  Display_String(&quot;Lock OK!         &quot;,0xc0);                  i=0;                                           IS_valid_user=0;                                 break;                                                 case 12: //按C键设置新密码                   //如果是合法用户则提示输入新密码                      if ( !IS_valid_user)         &#123;         i=0;         Display_String(&quot;No rights !      &quot;,0xc0);         delayms(1000);         Display_String(&quot;Your Password...&quot;,0x80);         Display_String(&quot;Lock OK!         &quot;,0xc0);         &#125;                   else                     &#123;                      i=0;                      Display_String(&quot;New Password:   &quot;,0x80);                      Display_String(&quot;                &quot;,0xc0);                     &#125;                          break;                                                          case 13: //按D键保存新密码                  if ( !IS_valid_user)        &#123;   i=0;           Display_String(&quot;No rights !       &quot;,0xc0);            delayms(1000);         Display_String(&quot;Your Password...&quot;,0x80);         Display_String(&quot;Lock OK!         &quot;,0xc0);         &#125;                   else                   &#123;i = 0;           init();         delayms(5);         for(k=0;k&lt;6;k++)         &#123;           Userpassword[k]=Userpassword[k]+48;         &#125;                   aa=Sendstring(0xa0,1,Userpassword,6);         delayms(5);                   aa=Recstring(0xa0,1,buffer,6);           delayms(5);                    clear_password();                                            Display_String(table,0x00);                   Display_String(&quot;Password Saved!   &quot;,0xc0);         delayms(1000);         Display_String(&quot;Do lock agian ?   &quot;,0xc0);                  &#125;                                 break;                                             case 14: //按E键消除所有输入                  i=0;                  clear_password();                  Display_String(&quot;                &quot;,0xc0);                    break;        case 15:   //清除一位         if(i!=0)i--;         for(n=0;n&lt;i;n++)         &#123;           DSY_BUFFER1[n]=&#39;*&#39;;           &#125;         Display_String(DSY_BUFFER1,0xc0);                     &#125;        P1=0x0f;  &#125;  if(j==3)  &#123;  Display_String(&quot;THIEF!!!THIEF!!!&quot;,0xc0);     j=0;    beep=0;  &#125;&#125;</code></pre><p>}&#96;</p><h4 id="仿真资源和程序源码"><a href="#仿真资源和程序源码" class="headerlink" title="仿真资源和程序源码"></a>仿真资源和程序源码</h4><p>本示例基于Proteus8.12平台</p><p><code>Proteus8.12</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1i7_6NMLvZ1EFCz80qveBuQ </span><br><span class="line">提取码：77p0//建议使用复制粘贴命令，手动输入容易出错</span><br></pre></td></tr></table></figure><p><code>链接：https://pan.baidu.com/s/1i7_6NMLvZ1EFCz80qveBuQ  提取码：77p0//建议使用复制粘贴命令，手动输入容易出错</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用WSL2时控制台输出“wsl 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理“</title>
      <link href="/2024/03/wsl-%E4%BD%BF%E7%94%A8WSL2%E6%97%B6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E2%80%9Cwsl-%E6%A3%80%E6%B5%8B%E5%88%B0-localhost-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BD%86%E6%9C%AA%E9%95%9C%E5%83%8F%E5%88%B0-WSL%E3%80%82NAT-%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-WSL-%E4%B8%8D%E6%94%AF%E6%8C%81-localhost-%E4%BB%A3%E7%90%86%E2%80%9C/"/>
      <url>/2024/03/wsl-%E4%BD%BF%E7%94%A8WSL2%E6%97%B6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E2%80%9Cwsl-%E6%A3%80%E6%B5%8B%E5%88%B0-localhost-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BD%86%E6%9C%AA%E9%95%9C%E5%83%8F%E5%88%B0-WSL%E3%80%82NAT-%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-WSL-%E4%B8%8D%E6%94%AF%E6%8C%81-localhost-%E4%BB%A3%E7%90%86%E2%80%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>WSL2版本：2.0.9.0</p><p>Windows版本：10.0.22621.2715</p><ol><li>打开或创建WSL配置文件(位于C:&#x2F;User&#x2F;%你的用户名&#x2F;.wslconfig),并添加以下内容:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=<span class="literal">true</span></span><br><span class="line">firewall=<span class="literal">true</span></span><br><span class="line">autoProxy=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>打开命令提示符并执行 <code>wsl --shutdown</code>命令。</p></li><li><p>重新启动wsl就可以了</p></li></ol><p>注意：wsl2版本2.0以前的不支持这个方法</p><p>使用镜像模式后，wsl2会自动共享主机的代理，比以前方便了不少。</p>]]></content>
      
      
      <categories>
          
          <category> wsl </category>
          
          <category> 报错解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> 报错解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言解释器的实现</title>
      <link href="/2024/03/C%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/03/C%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80-C%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在写CuteC文本编辑器的同时，为了使之有脚本执行能力。特意实现了一个简易的C语言解释器，所谓的解释器，就是它是解析执行脚本文件的，并不产生可执行的目标代码。它具备了C语言的几乎全部的语法。随着时间的推移，我打算把它作为一个独立的项目来开发了。在这个过程中，自己也学到了不少的知识，所以也打算跟大家分享。写这些东西，虽然是重复发明轮子的事，但也不至于是在浪费生命。程序员嘛，我总觉得应该是要理解我们每天所编译出来的程序是怎么被执行，应该明白我们敲打的每行代码的实际意义。<br>我打算写一个系列的文章来说明这个解释器的实现过程，其中对于编译原理的理论知识不做太多的讲解，一是不容易提高大家的积极性，二是自己水平有限。所以我觉得大部分从例子出发，讲解一个个目标的实现过程，大家慢慢体会，估计收获会比较大。</p><p>通过这一系列的文章，大家应该可以学到以下的知识。<br>1.更深入的理解C的内部细节，对以后的开发总是有好处的。例如，你能很清楚C语言的类型定义，通过基本的类型为何能够定义出无穷的各种类型。<br>2.了解表达式的解析，中间代码的产生。这点非常有意思，了解了这点，可以用同样的方法做很多事情，包括设计个计算器，解析复杂的配置文件，在软件中解析命令等等。<br>3.对编译器有一个感性的认识，虽然离写出编译器还比较遥远，但对于语法解析，预编译，理解的就比较深入了。现在很多软件都有预编译的模块在里面，比如Pro*C, GSoap等等。<br>4.我们产生的中间代码其实已经非常接近汇编代码，这对理解C的执行过程总是有好处的。</p><p>总之，晒晒自己的成果，怎么说也是我亲亲苦苦写出来的，希望大家能找到点可以借鉴的东西吧~代码我还在努力的编写，过一段时间再放出来一个初级的版本。如果工作忙，那估计就要再等一段时间了。</p><p>以前我发过上一个版本的解释器，可以在<a href="https://link.zhihu.com/?target=http://www.cnblogs.com/linxr/archive/2011/03/23/1992644.html">这篇文章</a>中下载，不过我现在已经重写了解释器，所以要看结果可以先下载下来看看:）。</p><p>目录：</p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/16/2290502.html%23mempool">1. 内存池</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/16/2290502.html%23stack">2. 栈</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/16/2290502.html%23hash">3. Hash表</a></p><h3 id="1-内存池"><a href="#1-内存池" class="headerlink" title="1.内存池"></a><strong>1.内存池</strong></h3><p>在一些小的程序里，没什么必要添加内存管理模块在里面。但是对于比较复杂的代码，如果需要很多的内存操作，那么加入自己的内存管理是有必要的。至少有一些好处：能够加快内存的申请和释放；能够轻松的查找内存泄露问题；能够对整个软件的内存消耗做一个比较精确的统计；对以后的优化有很大的好处等等。所以，在我的解释器里，我加入了一个简单的内存管理模块，仿造了内存池的做法。<br>主要思想是这样的：<br>a.记录所有的申请的内存<br>b.当释放内存时，记录下来以供下次申请使用<br>c.申请内存时，可以直接使用前面释放过的内存<br>为了达到以上的功能。我为申请内存的大小划分粒度，例如：我得粒度这么安排{16,32,64,128,…}那么申请17个字节的大小时候，我会申请32个字节的大小。这样子方便管理。并且为每个粒度创建一个可用内存的双向链表。申请内存时，就可直接从这些链表头中申请（即将一个节点从链表头移除，作为被申请的空间，并插入到在使用的链表中），内存的释放则是一个想法的过程。这些的存储结构如下所示：</p><p>图1.1 内存池的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pool_block</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">void</span> * data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pool_block</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pool_block</span> * <span class="title">pre</span>;</span></span><br><span class="line">&#125;<span class="type">pool_block_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pool</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num_all;</span><br><span class="line">    <span class="type">int</span> num_free;</span><br><span class="line">    <span class="type">pool_block_t</span> * list_all;</span><br><span class="line">    <span class="type">pool_block_t</span> * list_free[POOL_ATOM_NUM];</span><br><span class="line">&#125;<span class="type">pool_t</span>;</span><br><span class="line"><span class="type">int</span> pool_atom_tab[POOL_ATOM_NUM] = &#123;</span><br><span class="line">    <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明：<br>a.内存的申请会按照pool_atom_tab数组中的大小对齐，比如申请10byte，那么，我会申请32byte.</p><p>b.为每个粒度保存一个双向链表，用于保存被释放的内存。如果要申请的内存超过8192，那么我直接调用系统的malloc，释放时，直接调用free.</p><p>c.内存申请过程：到相应的粒度链表（list_free）中查看是否有可用内存，如果有，直接将它从该list_free链表中移动到list_all链表。<br>d.内存释放过程：要释放的内存必定保存在list_all中，根据它的大小，把它移动到相应的list_free链表。<br>e.pool_block_t结构被放置在申请内存的前面，则在释放时，直接根据Buffer指针就可得到pool_block_t的位置，从而得到next和pre，快速的在链表中移动。</p><h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a><strong>2.栈</strong></h3><p>栈在解释器中用到的地方很多，不管是表达式的解析，还是代码块的解析，类型的解析，等等都用到了栈。所以不实现它是不可能的事，不过在数据结构中他是最简单的了，无非就是申请一个空间，按一个一个的节点保存进去，按一个一个的节点取出来。没什么技巧在里面，只是这个我让栈的大小空间是自动增长和减小的，这么做的目的是：栈的空间仅仅限制于内存的大小。但是，这么做得缺点是，当栈的空间大小自动变化时，栈内的数据要被复制一遍，这务必会影响效率。但没有办法，暂时之能这样了。唯一的办法是在时间和空间上做一个选择。<br>栈的存储结构如下：</p><p>图1.2 栈的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> item_len;</span><br><span class="line">    <span class="type">int</span> item_num;</span><br><span class="line">    <span class="type">int</span> stack_size;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">&#125;<span class="type">stack_t</span>;</span><br></pre></td></tr></table></figure><p>说明：<br>item_len: 保存每个节点的长度<br>item_num: 栈中节点的个数<br>stack_size: 栈中可保存的节点个数<br>p: 指向栈空间<br>a.当节点的个数item_num大于stack_size,那么必须重新申请空间，将原来的数据拷贝到新的空间。<br>b.当节点的个数减小到一定的数量时，可以重新申请小的数据空间，释放原来大的空间。</p><h3 id="3-hash表"><a href="#3-hash表" class="headerlink" title="3.hash表"></a><strong>3.hash表</strong></h3><p>hash由于其快速的查找能力而著称，但是它太浪费内存了，所以用得的比较少，仅仅是在函数的调用时被使用。因为函数的调用是频繁的，如果从头查找函数，那将浪费很多的时间。这里引入hash也是必要的。</p><p>hash表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HH_TAB_SIZE 128</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hh_node</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash, klen, dlen;</span><br><span class="line">    <span class="type">void</span> * key;</span><br><span class="line">    <span class="type">void</span> * data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">hh_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="type">hh_node_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hh_head</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> node_num;</span><br><span class="line">    <span class="type">hh_node_t</span> *  node_list;</span><br><span class="line">&#125;<span class="type">hh_head_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hh_hash</span>&#123;</span></span><br><span class="line">    <span class="type">hh_opts_t</span> opts;</span><br><span class="line">    <span class="type">hh_head_t</span> tabs[HH_TAB_SIZE];</span><br><span class="line">&#125;<span class="type">hh_hash_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hh_opts</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> (*cmp_key)(<span class="type">void</span> *key1, <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_hash)</span><span class="params">(<span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="type">void</span> * (*new_key)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> * (*new_data)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> (*del_key)(<span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*del_data)(<span class="type">void</span> *data);</span><br><span class="line">&#125;<span class="type">hh_opts_t</span>;</span><br></pre></td></tr></table></figure><h2 id="词法分析-二"><a href="#词法分析-二" class="headerlink" title="词法分析(二)"></a>词法分析(二)</h2><p>词法分析是编译原理中最容易理解的，就算没有了解过编译原理，也能写出一个词法分析器。我们不用理解正则表达式，不用理解状态机原理，就可以轻松的完成词法的分析。</p><p>这里首先介绍下自顶向下的解析过程，所谓的自顶向下，按我的理解，就是从一个大的集合解析到小的集合。例如：解析一个文件，那么进入文件，解析一个函数，进入一个函数，解析局部变量，解析表达式，进入表达式，解析变量、常量等等，最终完成一个C文件的解析过程。整个过程，其实就是一个猜测的过程。但是这个过程中，我们必须依赖于文件中的每个词（token），token可以看成是解析过程中的一个单位。</p><p>例如：</p><ol><li><p>关键词有：int char double long for while ……</p></li><li><p>运算符有：+ - * &#x2F; ……</p></li><li><p>数字常量：12 0x34 3.45</p></li><li><p>字符串 ：”hello”</p></li></ol><p>…</p><p>等等.</p><p>那么我们必须实现一个函数get_token，执行这个函数，我们获取文件中的一个token。例如现在一个C文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">char</span> **argv )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么多次执行get_token，分别得到的token为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span></span><br><span class="line"><span class="params">(           ③</span></span><br><span class="line"><span class="params"><span class="type">int</span></span></span><br><span class="line"><span class="params">argc</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure><p>除了一个get_token函数外，还需要一个叫做put_back的函数，因为脚本解析是一个猜测的过程。有时候我们必须知道下一个的token是什么，才能判断该走哪个分支。还是上面的例子，在③的地方，我们得到了”(“，所以知道main是一个函数，那么如果该token不是”(“， 而是”&#x3D;”, 我们知道它不是一个函数，而是一个基本的变量定义，并且需要初始化。那么我们必须调用put_back函数，把该token重新放到缓存中，使得下次get_token的时候，还会拿到这个token,而不是下个token。</p><p>至于get_token和put_back函数如何实现，我就不多说了。我使用了最笨的方法，无非就是每个字符一个一个的向后扫描，判断是该返回什么标示。每个token被分为各种类型token_type:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum tok_types&#123; DELIMITER = 1, IDENTIFIER, KEYWORD, TEMP, STRING, CHARACTOR, NUMBER, TYPE, BLOCK, PRECOMPILE &#125;;</span><br></pre></td></tr></table></figure><p><strong>类型 意义 例如</strong></p><hr><p>DELIMITER 标示分隔符 ; | + -</p><p>IDENTIFIER 标示ID标示符 var hello</p><p>KEYWORD 关键字 int char while do</p><p>STRING 字符串 “string”</p><p>CHARACTOR 字符 ‘c’</p><p>NUMBER 数字常量 123 012 0x34</p><p>TYPE 类型 typedef int int32; 那么int32就被标示为TYPE</p><p>BLOCK 块标志 { }</p><p>PRECOMPILE 预编译行 #define</p><p>TEMP 保留</p><p>词法分析的目的就是扫描源码，区分出这些类型，变返回该token。供解释器的其他模块使用。</p><h2 id="类型解析-三"><a href="#类型解析-三" class="headerlink" title="类型解析(三)"></a>类型解析(三)</h2><h3 id="1-类型的表示"><a href="#1-类型的表示" class="headerlink" title="1.类型的表示"></a>1.类型的表示</h3><p>C语言的类型是相当灵活的，除了标准的类型(int char float double long 等等)外，自己根据需求，能定义出无穷的类型。一个具体的例子：<br><strong><em>int * a[10];</em></strong><br>它表示的意思是：<br><strong><em>a is ARRAY 0..9 of POINTER to INT</em></strong><br>仔细观察它的意思，就会发现，这个类型是其他基本类型按照一定顺序的组合：ARRAY|POINTER|INT。要表示这种形式，链表是最合适不过的了。如下图：</p><p>图2.1类型的表示</p><p>还有一些情况，比如结构体类型，那么上述的表示就不大合适了。例如下面的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> * p[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构中的每个域分别是由一个个的类型组成的。那么，我们可以用一个类型链表组成。具体就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_a is STRUCT of</span><br><span class="line">    n: INT</span><br><span class="line">    p: ARRAY <span class="number">0.</span><span class="number">.9</span> of POINTER to INT</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p>图2.2结构体的表示</p><p>程序中的类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> <span class="title">ttype_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">type_t</span> * <span class="title">ptype_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">type_list_t</span> <span class="title">ttype_list_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">type_list_t</span> * <span class="title">ptype_list_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> bty;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">ptype_t</span> ty;</span><br><span class="line">    <span class="type">ptype_list_t</span> sty;</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">char</span> * tag;</span><br><span class="line">    <span class="type">char</span> * pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_list_t</span>&#123;</span></span><br><span class="line">    <span class="type">ptype_t</span> ty;</span><br><span class="line">    <span class="type">ptype_list_t</span> next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-类型解析"><a href="#2-类型解析" class="headerlink" title="2.类型解析"></a>2.类型解析</h3><p>定义一个类型，我们可以把它分成三个部分：<br>specifier + id + dclor<br>对应到一个具体的定义：int * p[10]; 这三部分分别是：<br>specifier int *<br>id p<br>dclor [10]<br>类型的解析过程是这样的，首先找到id，然后根据一个规则（向右再向左），依次解析出这个类型：</p><p>图2.3类型的解析过程</p><p>在第2步，有几种情况：<br>a. [ 表示数组，如果遇到[ 则进入解析数组函数<br>b. ( 表示函数，如果遇到( 则进入解析参数列表函数</p><p>所以我们的解析函数是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dclor</span><span class="params">( <span class="type">ptype_t</span> ty )</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>( *token )&#123;</span><br><span class="line">    <span class="keyword">case</span> ALY: dcl_arrays(ty); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: ty-&gt;pos = prog;  dcl_args(ty); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dcl_pointers(ty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(tok_top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( *tok_stack[tok_top].token == <span class="string">&#x27;(&#x27;</span> )&#123;  <span class="comment">//左边是( 继续向右解析</span></span><br><span class="line">            token_pop();</span><br><span class="line">            get_token();</span><br><span class="line">            dclor(ty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> token_node  node;</span><br><span class="line">            node = token_pop();</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">strcmp</span>( node.token, <span class="string">&quot;splitor&quot;</span> ) == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( node.ty != <span class="literal">NULL</span> )&#123;</span><br><span class="line">                sbt.ty = node.ty;</span><br><span class="line">            &#125;</span><br><span class="line">            dcl_specifier( node.tok, <span class="literal">NULL</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类型的解析，我这里推荐下《C专家编程》中的类型解释部分，里面讲解得更加透彻。</p><h2 id="表达式解析-四"><a href="#表达式解析-四" class="headerlink" title="表达式解析(四)"></a>表达式解析(四)</h2><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/28/2304742.html%23BNF">1. BNF定义</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/28/2304742.html%23exp2">2.表达式解析</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/28/2304742.html%23exp3">3. 后缀表达式</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/28/2304742.html%23exp4">4.后缀表达式到中间代码</a></p><p><a href="https://link.zhihu.com/?target=https://www.cnblogs.com/linxr/archive/2011/12/28/2304742.html%23exp5">5.中间代码的表示</a></p><h3 id="1-BNF定义"><a href="#1-BNF定义" class="headerlink" title="1. BNF定义"></a><strong>1. BNF定义</strong></h3><p>虽然不想多提理论知识，但是有些东西还是避免不了。在解析表达式的时候，我们必须知道它的BNF定义，这样解析起来就非常方便了。所谓的BNF定义，相信大家看一眼就知道了：<br><strong><em>exp_additive</em></strong> <strong><em>-&gt;</em></strong> <strong><em>exp_multiplicative ( “+”|”-“ ) exp_multiplicative</em></strong><br><strong><em>exp_multiplicative</em></strong> <strong><em>-&gt;</em></strong> <strong><em>exp_cast ( “*”|”&#x2F;“|”%” ) exp_cast</em></strong><br><strong><em>exp_cast</em></strong> <strong><em>-&gt;</em></strong> <strong><em>…</em></strong><br>意思是：<br>加法表达式可以表示为 “乘法表达式 + 乘法表达式”<br>乘法表达式可以表示为 “类型转换表达式 *或&#x2F;或% 类型转换表达式”<br>…</p><p>知道了整个C语言的BNF定义，我们就可以很简单的按照这个定义来解析了。整个C的BNF定义可以查看以下的链接：<br><a href="https://link.zhihu.com/?target=http://lists.canonical.org/pipermail/kragen-hacks/1999-October/000201.html">http://lists.canonical.org/pip ermail/kragen-hacks/1999-October/000201.html</a></p><h3 id="2-表达式解析"><a href="#2-表达式解析" class="headerlink" title="2. 表达式解析"></a><strong>2. 表达式解析</strong></h3><p>知道了上面的BNF定义，那么我们的解析代码就可以这么写：<br><em>void exp_additive(){</em><br><em>char op;</em><br><em>exp_multiplicative();</em><br><em>while(</em><br><em>(op &#x3D; OPERATOR( ‘+’ )) ||</em><br><em>op &#x3D; OPERATOR( ‘-‘ )) ){</em><br><em>get_token();</em><br><em>exp_multiplicative();</em><br><em>…</em><br><em>}</em><br><em>}</em></p><p><em>void exp_multiplicative(){</em><br><em>char op;</em><br><em>exp_cast();</em><br><em>while(</em><br><em>(op &#x3D; OPERATOR( ‘*’ )) ||</em><br><em>(op &#x3D; OPERATOR( ‘&#x2F;‘ )) ||</em><br><em>(op &#x3D; OPERATOR( ‘%’ )) ){</em><br><em>get_token();</em><br><em>exp_cast();</em><br><em>…</em><br><em>}</em><br><em>}</em><br>过程是这样的：<br><strong>a.</strong> 调用exp_additive时，先调用exp_multiplicative<br><strong>b.</strong> 然后判断后面是否是 + 或 -，如果是，再次调用exp_multiplicative<br>这样就完成了加法表达式的解析。如果非要问为什么这么写就能解析出表达式，那么我们可以举个例子：<br><em><strong>a &#x3D; a * b + c * d;</strong></em><br>那么，他的语法树应该是这样的：</p><p>（图4.2 语法树）<br>我们向下递归调用的过程，其实就是构造这个语法树的过程。但是我们不会真的创建出这个语法树，而是保存了一个与它等价的一种形式–后缀表达式,其实后缀表达式就是语法树的后续遍历。</p><h3 id="3-后缀表达式"><a href="#3-后缀表达式" class="headerlink" title="3. 后缀表达式"></a><strong>3. 后缀表达式</strong></h3><p>什么是后缀表达式？我们还是从例子出发，上面的表达式，转化成后缀表达式就是这样子的：<br><strong><em>a a b * c d * + &#x3D;</em></strong><br>为什么要写成这种奇怪的形式？我们不是吃饱了撑着，从左往右分别查看这个表达式您就知道原因了。<br><strong>a</strong><br><strong>a</strong><br><strong>b</strong><br>***** 得到<em>号，那么拿前面的两个变量a b求和<br><strong>c</strong><br><strong>d</strong><br>***** 得到</em>号，那么拿前面的两个变量c d求和<br><strong>+</strong> 的到+号，获取前面的两个变量 a<em>b c</em>d 的结果，求和<br><strong>&#x3D;</strong> 得到&#x3D;号，将前面的结果赋给a<br>为了生成后缀表达式，我们要改造上面的解析函数。<br><em>void exp_additive(){</em><br><em>char op;</em><br><em>exp_multiplicative();</em><br><em>while(</em><br><em>(op &#x3D; OPERATOR( ‘+’ )) ||</em><br><em>op &#x3D; OPERATOR( ‘-‘ )) ){</em><br><em>get_token();</em><br><em>exp_multiplicative();</em><br><strong><em>EXP_OPR( op );</em></strong><br><em>}</em><br><em>}</em></p><p><em>void exp_multiplicative(){</em><br><em>char op;</em><br><em>exp_cast();</em><br><em>while(</em><br><em>(op &#x3D; OPERATOR( ‘*’ )) ||</em><br><em>(op &#x3D; OPERATOR( ‘&#x2F;‘ )) ||</em><br><em>(op &#x3D; OPERATOR( ‘%’ )) ){</em><br><em>get_token();</em><br><em>exp_cast();</em><br><em><strong>EXP_OPR( op );</strong></em><br><em>}</em><br><em>}</em><br>那么解析完成以后，我们的栈中就会形成后缀表达式了。有了表达式的后缀形式，我们就可以很轻松的产生后缀表达式的中间代码了。</p><h3 id="4-后缀表达式到中间代码"><a href="#4-后缀表达式到中间代码" class="headerlink" title="4.后缀表达式到中间代码"></a><strong>4.后缀表达式到中间代码</strong></h3><p>首先我们先说明一下我们的中间代码是怎样的一种形式，这里暂且叫它为三元表达式，是因为这个种中间代码的形式是固定的。例如，紧接上节的例子，表达式 a &#x3D; a * b + c * d;的中间代码最终应该是这样子的：</p><p><em>@1 &#x3D; a * b;</em><br><em>@2 &#x3D; c * d;</em><br><em>@3 &#x3D; @1 + @2;</em><br><em>@4 &#x3D; a &#x3D; @3;</em></p><p>其中以@开头的都是我们为之产生的中间变量。生成上述的中间代码后，将会对我们后续的解析提供很大的帮助，应为它结构固定，所以我们不用再去解析源程序，而是通过这个中间代码产生最终的执行代码。这里先声明下，我所说的执行代码，不是真正意义上得可执行代码，而是能够被我的软件解析的命令序列。其实它已经非常接近汇编代码。但是我们的目标是解析执行，并不产生汇编代码，所以产生简单的命令序列已经可以完成目标了。</p><p>我们前面解析表达式，产生后缀形式，为的就是生产这种中间表达式。表达式”a &#x3D; a * b + c * d;”的后缀形式是”a a b * c d * + &#x3D;;” 我们要根据这个后缀形式产生中间代码的过程如下：</p><p><strong>5.中间代码的表示</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">code</span> <span class="title">code_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">code</span> * <span class="title">pcode_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">code</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> opr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="type">int</span>  i, n, t;</span><br><span class="line">    &#125;lab;</span><br><span class="line">    <span class="type">v_t</span> var[<span class="number">4</span>];</span><br><span class="line">    <span class="type">code_t</span> * next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它是一个链表，每个节点保存了一个形如”@1 &#x3D; a * b;”的中间代码。其中，opr表示运算符”*”;lab表示该节点为一个LAB,留到后面章节讲解;var表示运算变量，如上面表达式的”@1, a, b”。<br>这样子，当一个表达式解析完成后，会生成一个链表，表示该表达式的中间代码。</p><h2 id="语法解析-五"><a href="#语法解析-五" class="headerlink" title="语法解析(五)"></a>语法解析(五)</h2><h3 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1.代码块"></a><strong>1.代码块</strong></h3><p>代码块是由多个表达式组成的一组代码。它可以看成是以下的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    exp1</span><br><span class="line">    exp2</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它由”{“开始，由”}”结束，中间包含多条表达式，或者是控制语句。如果不是以”{“开始，那么，一个代码块就是一条表达式。在上面的章节，我们已经介绍过了，每个表达式会产生一个中间代码。它是一个链表 struct _code * ，而一个代码块，是由多个表达式组成的，所以我们将每个表达式的中间代码链表连到一起就成了代码块的中间代码了。<br>如果代码块中包含控制语句，那么，我们必须做一些处理，即在代码链表中插入跳转语句，和跳转位置(Lab)。</p><h3 id="2-控制语句"><a href="#2-控制语句" class="headerlink" title="2.控制语句"></a><strong>2.控制语句</strong></h3><p><strong>2.1 C语言中，控制语句有这些：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a. <span class="keyword">if</span>( <span class="built_in">exp</span> ) stmt <span class="keyword">else</span> stmt</span><br><span class="line">b. <span class="keyword">do</span> stmt <span class="keyword">while</span>( <span class="built_in">exp</span> )</span><br><span class="line">c. <span class="keyword">while</span>( <span class="built_in">exp</span> ) stmt</span><br><span class="line">d. <span class="keyword">for</span>( exp1; exp2; exp3 ) stmt</span><br><span class="line">e. <span class="keyword">switch</span>( <span class="built_in">exp</span> ) stmt</span><br><span class="line">f. <span class="keyword">goto</span> lab</span><br></pre></td></tr></table></figure><p>其中，stmt表示一个代码块。我们如何为这些代码产生中间代码呢？这里还要说明的是跳转语句。比如一个if语句：<br>if( exp ) stmt1 else stmt2<br>那么,它的意思是，当 exp &#x3D;&#x3D; 0 时，跳转到stmt2位置；当exp !&#x3D; 0的时候不做跳转，但是stmt1执行完成后要跳转到stmt2的后面。所以，这中间涉及了两个东西：跳转语句 和 跳转的位置。跳转语句我们用三种命令表示：JE、JNE、JMP，即不等于跳转，等于跳转，无条件跳转。 跳转的位置我们用Lab表示，即在代码链表中插入一个标签，供跳转语句查找要跳转的位置。<br>还是上面的if语句，它产生后的代码应该是这样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> A.  if( exp ) stmt1 else stmt2 --&gt;</span><br><span class="line">       exp</span><br><span class="line">JE L1</span><br><span class="line">       stmt1</span><br><span class="line">JMP L2</span><br><span class="line">L1:</span><br><span class="line">       stmt2</span><br><span class="line">L2:</span><br></pre></td></tr></table></figure><p>其中，L1 L2分别占用代码链表的一个节点，在code_t结构体中，用lab域表示。</p><p><strong>2.2 控制语句中的break和continue</strong>.</p><p>在一些控制语句中，他们支持break和continue，即如果在代码块总出现break，那么他应该跳转到代码块的外面，如果是continue,那么跳转到条件语句继续执行。例如下面的do while语句：</p><p>B. do stmt while( exp ) –&gt;<br><em>L1:</em><br><em>stmt</em></p><p><strong>2.3 其他控制语句的代码形式</strong>：</p><p>C. while( exp ) stmt –&gt;<br><em>JMP</em> <em>L2</em><br><em>L1:</em><br><em>stmt</em><br><em>L2:</em><br><em>exp</em><br><em>JNE</em> <em>L1</em><br><em>L3:</em></p><p>D. for( exp1; exp2; exp3 ) stmt –&gt;<br><em>exp1</em><br><em>JMP</em> <em>L3</em><br><em>L1:</em><br><em>stmt</em><br><em>L2:</em><br><em>exp3</em><br><em>L3:</em><br><em>exp2</em><br><em>JNE</em> <em>goto L1</em><br><em>L4:</em></p><p>E. switch( exp ){<br><em>case 1: stmt1</em><br><em>case i: stmti</em><br><em>default: stmt</em><br><em>…</em><br><em>}</em></p><p><em>exp</em><br><em>selete i and jmp(L1..Ln,L)</em><br><em>Li: stmti</em><br><em>L: stmt</em><br><em>LL:</em></p><p>selete i and jmp(L1..Ln,L) 表示 如果exp的结果是i,那么跳转到Li,否则跳转到L。switch语句跟别的控制语句不一样，其他的控制语句在还没解析代码块的时候，我们就已经知道应该创建几个Lab了，所以我们可以事先创建好Lab，然后在适当的位置插入JMP语句，这个JMP语句中跳转到的Lab这时候已经确定了。但是对于switch语句，我们事先不知道case在什么地方，所以不知道”selete i and jmp(L1..Ln,L)”应该对应什么代码。所以，我们必须解析完stmt(代码块)之后才能产生代码。 具体的做法是在解析代码快的时候记录下所以的Lab，解析完成后再做相应的处理，即构造”selete i and jmp(L1..Ln,L)”代码，将它连接到中间代码的前面。</p><p>F. goto Lab –&gt;<br><em>JMP</em> <em>Lab</em></p><p>在解析goto的时候，必须将”Lab”名称转换成我们的Lab的表示形式。</p><h3 id="3-局部变量的生命周期"><a href="#3-局部变量的生命周期" class="headerlink" title="3.局部变量的生命周期"></a><strong>3.局部变量的生命周期</strong></h3><p>在一个函数中定义的变量称之为局部变量，但是局部变量有自己的生命周期，即在自己的代码块中定义的，那么它只对这个代码块的代码可见。例如有下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么第二个a对printf语句处是不可见的。为了表示变量的生命周期，我们为每个变量加入了begin和end域，用来保存该变量对[begin,end]区间的代码是可见的。所以，这里begin,和end怎么解析是个问题，begin不难，在解析定义的时候就可以确定，但是end确实比较难，因为必须在一个代码块中结束后（即解析到”}”后），才知道end的值。所以为了确定end的值，栈在这里又被征用了。</p><p>{</p><h3 id="4-函数解析"><a href="#4-函数解析" class="headerlink" title="4.函数解析"></a><strong>4.函数解析</strong></h3><p>一个函数包括这几个部分：<br>a. 返回值类型<br>b. 形参列表<br>c. 局部变量<br>d. 代码块<br>例如下面的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">( <span class="type">int</span> a, <span class="type">int</span> b )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它的返回值类型是int, 参数列表是a、b，局部变量有c, 执行代码是 “ c &#x3D; a + b; return c; “ 。仔细观察，它其实是由函数声明和一个代码块组成的。所以解析这个函数也很简单，其实就是解析声明，得到函数名，参数列表和返回值类型。然后执行上一章节描述的解析代码块函数，得到该函数的中间代码链。</p><h3 id="5-附"><a href="#5-附" class="headerlink" title="5.附"></a><strong>5.附</strong></h3><p>比如有如下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> **argv )</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( a=<span class="number">0</span>; a&lt;<span class="number">10</span>; a++ )&#123;</span><br><span class="line">        b *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个函数所对应的中间代码是这样的：<br>fun: main 2-args: argc argv b a<br><em>@0 &#x3D; b &#x3D; 1</em><br><em>@1 &#x3D; a &#x3D; 0</em><br><em>JMP 7</em><br><em>LAB_5:</em><br><em>@4 &#x3D; b *&#x3D; 2</em><br><em>LAB_6:</em><br><em>@3 &#x3D; a ++</em><br><em>LAB_7:</em><br><em>@2 &#x3D; a &lt; 10</em><br><em>JNE 5</em><br><em>LAB_8:</em><br><em>@5 &#x3D; b</em></p>]]></content>
      
      
      <categories>
          
          <category> w报错解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> 报错解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 HAL库驱动DHT11读取温湿度程序</title>
      <link href="/2024/03/stm32-STM32-HAL%E5%BA%93%E9%A9%B1%E5%8A%A8DHT11%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/03/stm32-STM32-HAL%E5%BA%93%E9%A9%B1%E5%8A%A8DHT11%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="STM32使用HAL库驱动DHT11读取温湿度程序"><a href="#STM32使用HAL库驱动DHT11读取温湿度程序" class="headerlink" title="STM32使用HAL库驱动DHT11读取温湿度程序"></a>STM32使用HAL库驱动DHT11读取温湿度程序</h2><p><strong>驱动DHT11、DHT22、DS18BB20等温湿度模块时序是比较简单的，关键在于控制好时序的 <code>&amp;#x5EF6;&amp;#x65F6;&amp;#x65F6;&amp;#x95F4;</code> ，HAL库的延时函数HAL_Delay是毫秒级别延时函数，所关键点就是实现微秒级别的延时函数。</strong></p><p><strong>微秒级别延时函数实现见我的另一篇博客：<a href="https://blog.csdn.net/qq153471503/article/details/102930097">https://blog.csdn.net/qq153471503/article/details/102930097</a></strong></p><p><strong>扫描以下二维码，关注公众号 <code>&amp;#x96CD;&amp;#x6B63;&amp;#x4E0D;&amp;#x79C3;&amp;#x5934;</code> 获取更多STM32资源及干货！</strong><br><img src="https://img-blog.csdnimg.cn/20210126155428872.png"></p><h3 id="sys-h"><a href="#sys-h" class="headerlink" title=";  sys.h"></a><a name="sysh_13">;</a>  sys.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SYS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SYS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ODR_Addr    (GPIOA_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR_Addr    (GPIOB_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ODR_Addr    (GPIOC_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ODR_Addr    (GPIOD_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ODR_Addr    (GPIOE_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr    (GPIOF_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_ODR_Addr    (GPIOG_BASE+12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR_Addr    (GPIOA_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_IDR_Addr    (GPIOB_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_IDR_Addr    (GPIOC_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_IDR_Addr    (GPIOD_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_IDR_Addr    (GPIOE_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr    (GPIOF_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_IDR_Addr    (GPIOG_BASE+8)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dht11-h"><a href="#dht11-h" class="headerlink" title="dht11.h"></a>dht11.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11_IO_IN()  &#123;IODHT22_GPIO_Port-&gt;CRH &amp;= 0xFFFFF0FF;IODHT22_GPIO_Port-&gt;CRH |= 8 &lt;&lt; 8;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11_IO_OUT() &#123;IODHT22_GPIO_Port-&gt;CRH &amp;= 0xFFFFF0FF;IODHT22_GPIO_Port-&gt;CRH |= 3 &lt;&lt; 8;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DHT11_DQ_OUT PCout(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DHT11_DQ_IN  PCin(10)</span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data</span><span class="params">(u8 *temp, u8 *humi)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Byte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Bit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Check</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Rst</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data_Float</span><span class="params">(<span class="type">float</span> *temp,<span class="type">float</span> *humi)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dht11-c"><a href="#dht11-c" class="headerlink" title="dht11.c"></a>dht11.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Rst</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DHT11_IO_OUT();</span><br><span class="line">    DHT11_DQ_OUT=<span class="number">0</span>;</span><br><span class="line">    delay_ms(<span class="number">20</span>);</span><br><span class="line">    DHT11_DQ_OUT=<span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Check</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 retry=<span class="number">0</span>;</span><br><span class="line">    DHT11_IO_IN();</span><br><span class="line">    <span class="keyword">while</span> (DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(retry&gt;=<span class="number">100</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> retry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(retry&gt;=<span class="number">100</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Bit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 retry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    retry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    delay_us(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span>(DHT11_DQ_IN)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Byte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i,dat;</span><br><span class="line">    dat=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dat&lt;<span class="number">1</span>;</span><br><span class="line">        dat|=DHT11_Read_Bit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data</span><span class="params">(u8 *temp,u8 *humi)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buf[<span class="number">5</span>];</span><br><span class="line">    u8 i;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    <span class="keyword">if</span>(DHT11_Check()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]=DHT11_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((buf[<span class="number">0</span>]+buf[<span class="number">1</span>]+buf[<span class="number">2</span>]+buf[<span class="number">3</span>])==buf[<span class="number">4</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            *humi=buf[<span class="number">0</span>];</span><br><span class="line">            *temp=buf[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data_Float</span><span class="params">(<span class="type">float</span> *temp,<span class="type">float</span> *humi)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buf[<span class="number">5</span>];</span><br><span class="line">    u8 i;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    <span class="keyword">if</span>(DHT11_Check()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]=DHT11_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((buf[<span class="number">0</span>]+buf[<span class="number">1</span>]+buf[<span class="number">2</span>]+buf[<span class="number">3</span>])==buf[<span class="number">4</span>])</span><br><span class="line">        &#123;</span><br><span class="line">*humi=((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) + buf[<span class="number">1</span>]) / <span class="number">10.0</span>;</span><br><span class="line">*temp=((buf[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) + buf[<span class="number">3</span>]) / <span class="number">10.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ret = <span class="number">1</span>;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    ret = DHT11_Check();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dht11 init %s. \r\n&quot;</span>, ret == <span class="number">0</span> ? <span class="string">&quot;ok&quot;</span> : <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 实现 44 矩阵键盘扫描（HAL库、标准库 都适用） - 白菜没我白 - 博客园</title>
      <link href="/2024/03/stm32-STM32-%E5%AE%9E%E7%8E%B0-44-%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E6%89%AB%E6%8F%8F%EF%BC%88HAL%E5%BA%93%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93-%E9%83%BD%E9%80%82%E7%94%A8%EF%BC%89-%E7%99%BD%E8%8F%9C%E6%B2%A1%E6%88%91%E7%99%BD-%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
      <url>/2024/03/stm32-STM32-%E5%AE%9E%E7%8E%B0-44-%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E6%89%AB%E6%8F%8F%EF%BC%88HAL%E5%BA%93%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93-%E9%83%BD%E9%80%82%E7%94%A8%EF%BC%89-%E7%99%BD%E8%8F%9C%E6%B2%A1%E6%88%91%E7%99%BD-%E5%8D%9A%E5%AE%A2%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文实现的代码是基于STM32HAL库的基础上的，不过标准库也可以用，只是调用的库函数不同，逻辑跟配置是一样的，按我这里的逻辑来配置即可。</p><p><strong>1、键盘原理图：</strong></p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190313172634453-1011388660.png"></p><p>原理举例：先把 F0-F7 内部拉高，这样这个8个引脚都是高电平，然后就进行列扫描。例如：假如按下3按钮，Y3 列扫描，把F4先拉低，然后读取F0-F3的状态，就会读出为1110，这就可 以知道是F3行拉低了，同时这时候是程序控制F4拉低的，这样就可以知道是F4列导致它转态变化了的，这样就可以定位出是F4列F3行的按键按下了；其他的列也是这样子扫描，就可以实现了。</p><p><strong>2、STM32 cubemx 引脚配置图：</strong></p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190313173013856-453677748.png"></p><p>这里用外部晶振内部晶振都可以，时钟对这个没什么影响，不用开中断，所以其他的配置就不细说了，下面再说一下这8个GPIO的配置。</p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190313173246180-1491953324.png"></p><p>4个引脚配推挽输出，这4个配输出的引脚内部上下拉不用配置；另外4个配成输入，内部上拉。</p><p><strong>3、生成代码后，开始编写逻辑：</strong></p><p>编写之前我们先做一下头文件的定义，把一些要用到的宏定义好：</p><pre><span>#ifndef __HW_key_H__</span><span>#define</span> __HW_key_H__<span>#include </span><span>&quot;</span><span>main.h</span><span>&quot;</span><span>#include </span><span>&quot;</span><span>stm32f1xx_hal.h</span><span>&quot;</span><span>#include </span>&lt;<span>string</span>.h&gt;<span>char</span> KEY_SCAN(<span>void</span><span>);</span><span>char</span> KEY_ROW_SCAN(<span>void</span><span>);</span><span>void</span> HW_KEY_FUNCTION(<span>void</span><span>);</span><span>#define</span> KEY_CLO0_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_7,GPIO_PIN_RESET)<span>#define</span> KEY_CLO1_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_RESET)<span>#define</span> KEY_CLO2_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_9,GPIO_PIN_RESET)<span>#define</span> KEY_CLO3_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,GPIO_PIN_RESET)<span>#define</span> KEY_CLO0_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_7,GPIO_PIN_SET)<span>#define</span> KEY_CLO1_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_SET)<span>#define</span> KEY_CLO2_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_9,GPIO_PIN_SET)<span>#define</span> KEY_CLO3_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,GPIO_PIN_SET)<span>#endif</span></pre><p>然后包含头文件以及定义一些要用到的变量数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;HW_key.h&quot;</span><br><span class="line">uint8_t Key_row[1]=&#123;0xff&#125;;   //保存按键行扫描情况的状态数组</span><br></pre></td></tr></table></figure><p>接着可以写扫描逻辑了，先编写横扫描的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *函数名：KEY_ROW_SCAN</span><br><span class="line"> *功  能：按键行扫描</span><br><span class="line"> *返回值：1~4，对应1~4行按键位置</span><br><span class="line"> */</span><br><span class="line">char KEY_ROW_SCAN(void)</span><br><span class="line">&#123;</span><br><span class="line">    //读出行扫描状态</span><br><span class="line">    Key_row[0] = HAL_GPIO_ReadPin(GPIOE,KEY_row0_Pin)&lt;&lt;3;</span><br><span class="line">    Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_row1_Pin)&lt;&lt;2);</span><br><span class="line">    Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_row2_Pin)&lt;&lt;1);</span><br><span class="line">    Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_row3_Pin));</span><br><span class="line"></span><br><span class="line">    if(Key_row[0] != 0x0f)         //行扫描有变化，判断该列有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">      HAL_Delay(10);                    //消抖</span><br><span class="line">      if(Key_row[0] != 0x0f)</span><br><span class="line">        &#123;</span><br><span class="line">                //printf(&quot;Key_Row_DATA = 0x%x\r\n&quot;,Key_row[0]);</span><br><span class="line">                switch(Key_row[0])</span><br><span class="line">                &#123;</span><br><span class="line">                    case 0x07:         //0111 判断为该列第1行的按键按下</span><br><span class="line">                        return 1;</span><br><span class="line">                    case 0x0b:         //1011 判断为该列第2行的按键按下</span><br><span class="line">                        return 2;</span><br><span class="line">                    case 0x0d:         //1101 判断为该列第3行的按键按下</span><br><span class="line">                        return 3;</span><br><span class="line">                    case 0x0e:         //1110 判断为该列第4行的按键按下</span><br><span class="line">                        return 4;</span><br><span class="line">                    default :</span><br><span class="line">                        return 0;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数，可以判断哪一行有按键按下，并返回有按键按下的行数。</p><p>接着编写列扫描的代码，这里的思想是，先扫描第一列，接着判断第一列有没有行被按下，有的话就可以直接定位到这一列的哪一行，其他4列逻辑一样，这样就可以定位到哪个按键按下了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *函数名：KEY_SCAN</span><br><span class="line"> *功  能：4*4按键扫描</span><br><span class="line"> *返回值：0~16，对应16个按键</span><br><span class="line"> */</span><br><span class="line">char KEY_SCAN(void)</span><br><span class="line">&#123;</span><br><span class="line">    char Key_Num=0;       //1-16对应的按键数</span><br><span class="line">    char key_row_num=0;        //行扫描结果记录</span><br><span class="line"></span><br><span class="line">    KEY_CLO0_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);  //消抖</span><br><span class="line">        Key_Num = 0 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_1\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO0_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    KEY_CLO1_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);</span><br><span class="line">        Key_Num = 4 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_2\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO1_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    KEY_CLO2_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);</span><br><span class="line">    Key_Num = 8 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_3\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO2_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    KEY_CLO3_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">//        Key_row[0] = HAL_GPIO_ReadPin(GPIOE,KEY_col0_Pin)&lt;//        Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_col1_Pin)&lt;//        Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_col2_Pin)&lt;//        Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_col3_Pin));</span><br><span class="line">//        printf(&quot;Key_Clo4_DATA = 0x%x\r\n&quot;,Key_row[0]);</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);</span><br><span class="line">        Key_Num = 12 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_4\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO3_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    return Key_Num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就可以直接返回1-16个按键的按键数了，按下第一个按键就返回1，第2个就返回2，以此类推。下面可以调用这个函数做按键按下的操作了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *函数名：KEY_ROW_SCAN</span><br><span class="line"> *功  能：执行按下按键后的操作</span><br><span class="line"> *返回值：无</span><br><span class="line"> */</span><br><span class="line">void HW_KEY_FUNCTION(void)</span><br><span class="line">&#123;</span><br><span class="line">    char key_confirm;</span><br><span class="line">    key_confirm = KEY_SCAN();</span><br><span class="line">    if( 0 &lt; key_confirm  &amp;&amp; key_confirm &lt; 17 )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Key_NUM = %d \r\n&quot;,key_confirm); //按下1-16个按键的操作</span><br><span class="line">        printf(&quot;= = = = = = = = = = = \r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里就是用串口助手打印出来查看哪个按键按下的，实测可用。</p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190318150541397-1921208533.png"></p><p><strong>4、总结：</strong></p><p>（1）先配置8个引脚，4个配置输入，上拉；4个配置成推挽（PP）输出，不用上下拉，输出高电平；</p><p>（2）软件逻辑：</p><p>a. 先说一下行扫描的原理，因为如果有按键按下的话，某一个输入的引脚就会跟对应的输出引脚连接，因为输出为高电平，所以对应的输入引脚会被拉高，读取引脚的状态，判断哪个引脚被拉高就可以知道哪一行有按键按下了；总的来说是通过高四位输出高电平来对矩阵键盘进行逐行扫描，当低四位接收到的数据不全为1的时候，说明有按键按下，然后通过接收到的数据是哪一位为0来判断是哪一行按键被按下；</p><p>b. 列扫描原理：思路是先把第一列输出低电平，接着读取高4位的电平转态，单不全为1时，说明这一列有按键按下，同时结合行扫描判断出来的行数定位到按下的按键。程序里是扫描第一列的时候第一列给低电平，接着进行行扫描判断，因为输入输出引脚都是高电平了，只有第一列的引脚是低电平，所以当第一列有按键按下的时候，行扫描读到的4个引脚就不全为1，这时因为第一列的电平是我们自己给的，所以就可以直接判断这一列有按键按下；接着利用行扫描原理定位哪一行有按键按下，这样就可以判断出第一列的某一行的按键被按下了，其他3列同理，然后轮流扫描4列就可以判断16个按键了。</p><p>通俗点说，就是如果我给这一列低电平，造成了行扫描有变化，那就直接知道这一列有按键按下，接着查看行变化的电平变化，推算出哪一行变化了，就可以知道这一列的第几个按键被按下了。</p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX  HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</title>
      <link href="/2024/03/stm32-STM32CubeMX-HAL%E5%BA%93%E7%9A%84ADC%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E8%BD%AE%E8%AE%AD%E3%80%81DMA%E3%80%81DMA-TIM-%E3%80%81%E8%AF%BB%E5%8F%96%E5%86%85%E9%83%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B8%A9%E5%BA%A6/"/>
      <url>/2024/03/stm32-STM32CubeMX-HAL%E5%BA%93%E7%9A%84ADC%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E8%BD%AE%E8%AE%AD%E3%80%81DMA%E3%80%81DMA-TIM-%E3%80%81%E8%AF%BB%E5%8F%96%E5%86%85%E9%83%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="STM32CubeMX-HAL库的ADC多通道数据采集（轮训、DMA、DMA-TIM-、读取内部传感器温度"><a href="#STM32CubeMX-HAL库的ADC多通道数据采集（轮训、DMA、DMA-TIM-、读取内部传感器温度" class="headerlink" title="STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度"></a>STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#stm32cubemx--haladcdmadmatim-0">STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</a></li><li><ul><li><ul><li><a href="#1adc-11">1、ADC简介</a></li><li><ul><li><a href="#11--13">1.1 采样定理</a></li><li><a href="#12--15">1.2 模式介绍</a></li><li><a href="#13--24">1.3 采样时间和采样频率的计算</a></li></ul></li><li><a href="#2-56">2、轮训方式的多通道采集</a></li><li><ul><li><a href="#21--57">2.1 方式一：间断模式+扫描模式</a></li><li><a href="#22--72">2.2 方式二：完全轮训</a></li></ul></li><li><a href="#3dma-108">3、DMA实现多通道采集</a></li><li><a href="#4timdma-136">4、TIM+DMA实现多通道采集</a></li><li><a href="#5adc-179">5、补充：内部温度传感器ADC通道</a></li></ul></li></ul></li></ul><p><em>注：本片文章以STM32F103系列为例，其他系列可能稍有不同。</em></p><h4 id="1、ADC简介"><a href="#1、ADC简介" class="headerlink" title="1、ADC简介"></a>1、ADC简介</h4><h5 id="1-1-采样定理"><a href="#1-1-采样定理" class="headerlink" title="1.1 采样定理"></a>1.1 采样定理</h5><h5 id="1-2-模式介绍"><a href="#1-2-模式介绍" class="headerlink" title="1.2 模式介绍"></a>1.2 模式介绍</h5><ul><li><strong>扫描模式：</strong> 使用STM32CUBEMX配置了多通道后，这一项默认开启且无法设置成关闭。这个模式就是自动扫描你开启的所有通道进行转换，直至转换完。例如你开启了CH0、CH1、CH2、CH3这四个通道，启动转换后ADC会自动将这4个通道全部转换完，但是这种连续性是可以被打断的，所以就引出了间断模式。</li><li><strong>连续模式：</strong> 在CUBE中选中ENABLE就是连续模式，DISABLE就是单次模式。开启连续模式后，ADC的转换不由其他控制。例如将ADC设置为了定时器的TGRO触发采样，如果开启连续模式，ADC将忽略定时器的触发采样。（连续转换模式开启后其实就是满频率的采样）。</li><li><strong>间断模式：</strong> 可以将多个通道进行 <strong>分组采集</strong>，例如你开启了CH0~3这4个通道，假如你设置了间断次数为4，就相当于将4个通道分成了4组，每组1个通道，那么要想采集完这4个通道就需要手动触发4次ADC采集；如果设置了间断次数为2，那么采集完4个通道就需要手动触发2次ADC采集。</li></ul><h5 id="1-3-采样时间和采样频率的计算"><a href="#1-3-采样时间和采样频率的计算" class="headerlink" title="1.3 采样时间和采样频率的计算"></a>1.3 采样时间和采样频率的计算</h5><p><strong>ADC采样两点间隔的时间一定要大于ADC的采样时间！</strong> 采样时间怎么算，下面就细说一下。</p><p>STM32F103一般将时钟配置主频为72M、APB2为72M。ADC挂在APB2时钟总线上，且ADC的时钟不能超过14M。所以一般将ADC的分频设置为6，ADC的时钟主频就为72&#x2F;6&#x3D;12MHz。那么一个周期就是：1&#x2F;12MHz&#x3D;0.0833us。</p><p>以下截图为STM32F1参考手册（手册编号RM0008，可在ST官网直接搜索下载）：</p><p><img src="https://img-blog.csdnimg.cn/84ca12cd9d40459eb3e03c54889e9df3.png"></p><p>上图的意思是：ADC对输入电压采样若干个ADC_CLK周期，这些周期可通过ADC_SMPR1和ADC_SMPR2寄存器中的SMP[2:0]位进行修改。每个通道都可以用不同的采样时间进行采样。</p><p><strong>ADC转换时间 &#x3D; 采样时间 + 12.5个周期</strong></p><p>示例：</p><pre><code class="当ADC时钟主频为14MHz并且采样时间为1.5个周期时：采样时间">STM32F1系列的时钟主频一般设置为了12M，采样时间的设置所对应采样频率如下图所示：![](https://img-blog.csdnimg.cn/de1135452e21490a94b671995f48824f.png)知道了最短时间后，当ADC时钟主频为12M并且采样时间为1.5个周期时，ADC采样两点的时间必须大于1.17us。而STM32F031系列的ADC时钟主频为14MHz，采样时间的设置所对应采样频率如下图所示：![](https://img-blog.csdnimg.cn/4616052a159b4c6da44230ee81f9a4a0.png)当ADC时钟主频为14M并且采样时间为1.5个周期时，ADC采样两点的时间必须大于1us。#### &lt;a name=&quot;2_56&quot;&gt;;&lt;/a&gt;  2、轮训方式的多通道采集##### 2.1 方式一：间断模式+扫描模式我开启了通道0、1、2以及内部温度读取通道一共四个通道：![](https://img-blog.csdnimg.cn/20200820144708671.png#pic_center)![](https://img-blog.csdnimg.cn/20200820144717271.png#pic_center)如果想使用轮训方式并且不使用DMA的多通道采集，那么就要配置为 **【单次模式+间断模式】**，并且将Number Of Discontinuous Conversions为1，也就是每个通道分成了一个组，配置如下图：![](https://img-blog.csdnimg.cn/20200820145205371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)由于我这里设置间断数为1，也就是将4个通道分成了4组，那么我每次采集的时候都需要手动去触发ADC采集，也就是调用一次HAL_ADC_Start函数，完整代码如下：![](https://img-blog.csdnimg.cn/2020082014582133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)我将通道0分别接到3.3V和GND上，4通道采集运行效果如下：![](https://img-blog.csdnimg.cn/20200820150008132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)##### &lt;a name=&quot;22__72&quot;&gt;;&lt;/a&gt;  2.2 方式二：完全轮训完全使用轮训的方式不能使用 **扫描模式**（理论上来说多通道需要使用扫描模式，而不是完全轮训），但是使用STM32CUBEMX配置多通道扫描模式不无法被关闭的，所以我们先用STM32CUBEMX配置成一个通道：![](https://img-blog.csdnimg.cn/0b4c62f299d54bcf89ba61ea0aee0eca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeS16aGVuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)然后读取ADC采集数值的函数是这样：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_Read</span><span class="params">(<span class="type">uint32_t</span> Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">ADC_ChannelConfTypeDef sConfig = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">sConfig.Channel = Channel;</span><br><span class="line">sConfig.Rank = ADC_REGULAR_RANK_1;</span><br><span class="line">sConfig.SamplingTime = ADC_SAMPLETIME_55CYCLES_5;</span><br><span class="line"><span class="keyword">if</span> (HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, HAL_MAX_DELAY);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint16_t</span>)HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>#### 3、DMA实现多通道采集通过DMA实现多通道数据采集， **要将连续模式和间断模式关闭！**如果连续模式开启，那么通过DMA传输到的数组中，每个通道所采集到的值对应数组中的一个位置就是不固定的。例如你开启了IN0~IN3这四个通道，并通过DMA将这四个通道的数据放到ADC_Value这个大小为4的u16类型数组，你在第一次采集的时候IN0通道的数值通过DMA被放在ADC_Value[0]，第二次采集的时候IN0采集到的数值就可能被放到了ADC_Value[1]，这样的话就极不方便我们对每个通道的数据进行分析和提取。配置如下，将连续转换模式和间断转换模式关闭，并开启ADC的DMA通道，将DMA的模式配置为周期模式：![](https://img-blog.csdnimg.cn/20200820152200735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)![](https://img-blog.csdnimg.cn/ddd590ed84b44942863728c7b84ff639.png)代码如下：![](https://img-blog.csdnimg.cn/c457e847f73847ceb3a35f112f66667e.png)4个通道采集运行效果如下：![](https://img-blog.csdnimg.cn/20200820152427227.png#pic_center)#### &lt;a name=&quot;4timdma_136&quot;&gt;;&lt;/a&gt;  4、TIM+DMA实现多通道采集在不使用DMA的情况下，定时器控制ADC进行数据采集只能是单通道！如果开启了多通道，读取到的ADC采集值只会是最后一个通道的值！所以，要想使用定时器控制ADC采集 **多通道**，必须使用DMA！CubeMX配置如下，使能ADC的DMA：![](https://img-blog.csdnimg.cn/42aa3e7658df4d89ac32b7f2a1ebc643.png)ADC的触发方式设置为定时器3的触发事件：![](https://img-blog.csdnimg.cn/c4ff90b3330b44fda0a609316e2370db.png)采样时间设置为了55.5个周期，对应采样频率为176.47KHz，所以定时器3的频率设置要低于176.47KHz。设置定时器3分频系数为72，重载值为10，得到 `72MHz / 72&amp;#x5206;&amp;#x9891; / 10 = 100KHz`的定时器3：![](https://img-blog.csdnimg.cn/a50e71979339457e90f451449ec69d86.png)代码如下：![](https://img-blog.csdnimg.cn/c418cbe4d5b340a2ae94438927728da5.png)运行结果如下：![](https://img-blog.csdnimg.cn/534899ff62e24bcb9909ffaff4b29065.png)当然也可以选择进行一组数据，例如将32个点为一组数据进行采集，设置如下：![](https://img-blog.csdnimg.cn/a08aa8f0ae7c4cd8bfd70d40a980b3e1.png)运行结果如下：![](https://img-blog.csdnimg.cn/eb3feca6e37140eeb65f794634e86da3.png)#### 5、补充：内部温度传感器ADC通道![](https://img-blog.csdnimg.cn/87fe51b0eb7b447798ade02be31b4329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70)上面图片是截取在STM32F103RC的datasheet中的，中文意思就是：温度传感器必须产生随温度线性变化的电压。转换范围在2v &lt; VDDA &lt; 3.6 V之间。温度传感器内部连接ADC1_IN16输入通道，用于将传感器输出电压转换为数字值。内部温度计算公式：【Temperature = &#123;(V25 - VSENSE) / Avg_Slope&#125; + 25】字段说明：* **V25：** 最小1.34V，最大1.52V，典型值1.43V* **Avg_Slope：** 最小4.0，最大4.6，典型值4.3mv/℃* **VSENSE：** ADC采集到的电压![](https://img-blog.csdnimg.cn/da0745b68e874c41b42573887a74e20e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70)ADC值转电压值计算公式：【电压 = ADC采集到的值 * 3.3 / 4096】看上图我采集到的值为1703，先转换为电压值：1703*3.3/4096≈1.37**（1.43 - 1.37）/ 0.0043 + 25 ≈ 38.95℃**ends...</code></pre>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HAL库】STM32+ESP8266+Onenet+MQTT，极简工程，hal库移植。</title>
      <link href="/2024/03/stm32-%E3%80%90HAL%E5%BA%93%E3%80%91STM32-ESP8266-Onenet-MQTT%EF%BC%8C%E6%9E%81%E7%AE%80%E5%B7%A5%E7%A8%8B%EF%BC%8Chal%E5%BA%93%E7%A7%BB%E6%A4%8D%E3%80%82/"/>
      <url>/2024/03/stm32-%E3%80%90HAL%E5%BA%93%E3%80%91STM32-ESP8266-Onenet-MQTT%EF%BC%8C%E6%9E%81%E7%AE%80%E5%B7%A5%E7%A8%8B%EF%BC%8Chal%E5%BA%93%E7%A7%BB%E6%A4%8D%E3%80%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="ESP8266-Onenet-MQTT"><a href="#ESP8266-Onenet-MQTT" class="headerlink" title="ESP8266+Onenet+MQTT"></a>ESP8266+Onenet+MQTT</h4><ul><li><ul><li><a href="#1-chled-12">1 导入.c.h文件（不再赘述，详细见LED部分）</a></li><li><a href="#2-cubemx-21">2 Cubemx配置</a></li><li><a href="#3--ch--27">3 修改 .c.h 文件</a></li><li><a href="#4--65">4 测试</a></li></ul></li></ul><p>ESP8266通过MQTT协议连接Onenet。从标准库移到了HAL库，过程有点麻烦，整了一天。做完后整理了一下，这个极简的工程，方便以后开发，也希望能帮助到大家，节约时间。</p><p>代码工程：<br><a href="https://github.com/wyfroom/ESP8266-Onenet-MQTT">https://github.com/wyfroom/ESP8266-Onenet-MQTT</a></p><p>该份代码硬件配置：<br>板子：STM32F103C8T6最小系统板。<br>外设：串口1用作调试，串口3用作esp8266。<br>esp8266：淘宝，esp-01s</p><h3 id="1-导入-c-h文件（不再赘述，详细见LED部分）"><a href="#1-导入-c-h文件（不再赘述，详细见LED部分）" class="headerlink" title="1 导入.c.h文件（不再赘述，详细见LED部分）"></a>1 导入.c.h文件（不再赘述，详细见LED部分）</h3><p>在keil工程中导入之前写好的.c.h文件。这个是我从标准库移倒hal库的，直接从我工程里复制就行，很纯净，没有加多余的东西。下面介绍如何根据个人实际使用情况更改一些参数。</p><blockquote><p>cubemx详细使用教程及所有模块整合见这篇：<br><a href="http://t.csdn.cn/Awtl9">【HAL库】HAL库STM32cubemx快速使用</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/913840e121e5a09eff4133733245efe9.png"></p><h3 id="2-Cubemx配置"><a href="#2-Cubemx配置" class="headerlink" title=";  2 Cubemx配置"></a><a name="2_cubemx_21">;</a>  2 Cubemx配置</h3><p>串口1用于调试，串口3用于ESP8266通信，打开中断。</p><p>基础的我就不配置了，可以看前面的详细讲解。</p><h3 id="3-修改-c-h-文件"><a href="#3-修改-c-h-文件" class="headerlink" title="3 修改 .c.h 文件"></a>3 修改 .c.h 文件</h3><p>移植时要修改的地方：</p><p>1 改所用串口</p><p>发送部分：在esp8266.c里，将huart3全部替换为要修改的串口号，比如串口2。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/87b34edd334476992b18233290799fe3.png"></p><p>接收部分：用串口中断接收esp8266发来的消息。随便在哪个文件夹填加串口回调函数，我个人是之前专门建了个uart.c文件放串口相关的所有代码。</p><p>加入下面的代码（串口号根据个人情况修改）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart3)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(esp8266_cnt &gt;= <span class="keyword">sizeof</span>(esp8266_buf))</span><br><span class="line">&#123;</span><br><span class="line">esp8266_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">esp8266_buf[esp8266_cnt++] = Uart3_RxData;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart3,(<span class="type">uint8_t</span> *)&amp;Uart3_RxData, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 改wifi名字和密码</p><p><img src="https://img-blog.csdnimg.cn/img_convert/601b58b84f41ec638f86d9e63eeb4c41.png"></p><p>3 改产品ID、设备ID、鉴权信息。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/03f4e721469e45d2729425eca9a8d38a.png"></p><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h3><p><strong>添加头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;onenet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp8266.h&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>添加初始化</strong></p><p>别忘了开串口中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart3,(<span class="type">uint8_t</span> *)&amp;Uart3_RxData, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">2000</span>);</span><br><span class="line">ESP8266_Init();</span><br><span class="line">HAL_Delay(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">while</span>(OneNet_DevLink())</span><br><span class="line">HAL_Delay(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>连接成功的话，onenet会显示设备在线。串口也会打印成功。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e08522ae2a3d08bd5f99c7fdeda41379.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e1ab1158b6bfc9430b57a31e27cfab3.png"></p><p><strong>发送数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OneNet_SendData();//&amp;#x53D1;&amp;#x9001;&amp;#x6570;&amp;#x636E;</span><br><span class="line">ESP8266_Clear();//&amp;#x6E05;&amp;#x7A7A;&amp;#x6570;&amp;#x636E;&amp;#x7F13;&amp;#x5B58;&amp;#x533A;</span><br><span class="line">HAL_Delay(3000);//3s&amp;#x53D1;&amp;#x9001;&amp;#x4E00;&amp;#x6B21;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/05e4629537d4b953e7e7f4bc651a0267.png"></p><p>要发什么数据，在这里改：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2e0513318f4aa1042b26a9f18b546071.png"></p><p><strong>接收数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataPtr = ESP8266_GetIPD(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dataPtr != <span class="literal">NULL</span>)</span><br><span class="line">OneNet_RevPro(dataPtr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32F103C8T6（HAL库）的HC-SR501红外人体传感及HC-SR04超声波测距</title>
      <link href="/2024/03/stm32-%E5%9F%BA%E4%BA%8ESTM32F103C8T6%EF%BC%88HAL%E5%BA%93%EF%BC%89%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E4%BA%BA%E4%BD%93%E4%BC%A0%E6%84%9F%E5%8F%8AHC-SR04%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D/"/>
      <url>/2024/03/stm32-%E5%9F%BA%E4%BA%8ESTM32F103C8T6%EF%BC%88HAL%E5%BA%93%EF%BC%89%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E4%BA%BA%E4%BD%93%E4%BC%A0%E6%84%9F%E5%8F%8AHC-SR04%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h2><p><a href="https://blog.csdn.net/h568630659/article/details/121404155">一、基于STM32F103C8T6最小系统板和STM32CubeMX实现LED灯循环闪烁</a><br><a href="https://blog.csdn.net/h568630659/article/details/121427218">二、基于STM32F103C8T6和STM32CubeMX实现UART串口通信数据收发</a><br><a href="https://blog.csdn.net/h568630659/article/details/121465665">三、实战小例程 基于STM32F103C8T6最小系统板和STM32CubeMX驱动WS2812B光立方</a><br><a href="https://blog.csdn.net/h568630659/article/details/121764481">四、基于STM32F103C8T6最小系统板HAL库CubeMX驱动HC-SR501红外人体传感模块</a><br><a href="https://blog.csdn.net/h568630659/article/details/122058600">五、基于STM32F103C8T6（HAL库）的HC-SR501红外人体传感及HC-SR04超声波测距</a></p><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="#-0">系列文章目录</a></li><li><a href="#-16">前言</a></li><li><a href="#-22">一、模块简介</a></li><li><a href="#cubemx-45">二、配置CubeMX</a></li><li><a href="#-67">三、硬件连线部分</a></li><li><a href="#-94">四、逻辑代码部分</a></li><li><ul><li><a href="#hc-sr04c-97">HC_SR04.c</a></li><li><a href="#hc-sr04h-181">HC_SR04.h</a></li><li><a href="#mainc-193">main.c</a></li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在上一篇文章中驱动了HC-SR501红外人体传感模块，但在测试过程中发现，这个模块的热释电探头过于灵敏了，甚至有的时候往上哈气，会因为检测到类似于人体的温度而误判为感应到人体，所以为了减少误判概率，我打算再添加一个测距模块，在红外感应到人体时，再次判断人体与传感器的距离，在满足预设的距离范围时，才确定有人体接近，进行后续操作。</p><h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p><strong>HC-SR501红外人体感应模块资料介绍：</strong><br><a href="https://www.arduino.cn/thread-2851-1-1.html">探究人体红外传感器HC-SR501</a></p><p><strong>HC-SR04超声波测距模块资料介绍：</strong></p><p><img src="https://img-blog.csdnimg.cn/92ad9fec95424c4daee75611f36e9b7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>引脚名称引脚作用VCC<br><strong>3-5.5V</strong></p><p>供电（实测发现可以3.3V供电，但没有5V供电测得准）GND接地Trig外部触发信号输入，输入一个高于10μs的高电平即可触发模块测距Echo回响信号输出，测距结束时此管脚输出一个高电平，电平宽度反映超声波往返时间之和</p><p><strong>工作原理：</strong></p><p><img src="https://img-blog.csdnimg.cn/2440fa92274644939b0de5e59ef1852b.png"><br><img src="https://img-blog.csdnimg.cn/0fa754c51ca94c2188fbdfa59f3604ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>简而言之：<br> 给Trig一个10μS以上的高电平,模块开始工作，模块内自动发送八个40khz方波，并自主检测是否有电波返回。此时需要检测Echo处的电平，当为高电平的时候记一个时间；当Echo出为低电平的时候再记一个时间，这两个时间的差就是高电平持续的时间，最后用测距公式进行计算</strong>。</p><h2 id="二、配置CubeMX"><a href="#二、配置CubeMX" class="headerlink" title="; 二、配置CubeMX"></a><a name="cubemx_45">;</a> 二、配置CubeMX</h2><p><strong>1、新建工程;<br>2、配置时钟源，在RCC里面的HSE配置的是晶振时钟;<br>3、配置程序烧录引脚SYS为SWD模式;<br>4、配置GPIO输出口，配置一个LED灯（我的板子是PC13），起到检测到人体时的指示作用;<br>5、配置GPIO输入口，用来读取HC-SR501模块的输出电平，我选的是PA1口;</strong><br><strong>6、配置GPIO输入口，用来检测HC-SR04超声波测距模块的回响信号输出，我选择PB5口，命名为HC_SR04_Echo_Pin;<br>7、配置GPIO输出口，用来触发HC-SR04超声波测距模块，我选择PB4口，命名为HC_SR04_Trig_Pin;<br>8、使能定时器，用来实现微秒延时，和测量HC-SR04模块高电平时间，我选择TIM2，并使能TIM2中断;</strong><br><img src="https://img-blog.csdnimg.cn/f5c269ef459b4f58a202b49397c11036.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_17,color_FFFFFF,t_70,g_se,x_16"><br>TIM2挂载在APB1，时钟来源频率为36MHz，故取预分频系数 <code>PSC=36-1</code>，计数周期 <code>Counter</code>设为 <code>60000-1</code>。即此时定时器频率为36M&#x2F;36&#x3D;1MHz，每60ms进一次中断，60000μs对应实际测距范围大概为10m，远远超过我的需求。</p><p><img src="https://img-blog.csdnimg.cn/96058ff9807d44dea3a1b773f47f9330.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/14c2aefe04d5410b89a5300226b73aa6.png"></p><p><strong>9、配置串口收发引脚;<br>10、配置时钟树，我还是开到最高的72MHz;<br>11、进行项目设置，最后生成代码，CubeMX部分就大功告成了</strong></p><p><img src="https://img-blog.csdnimg.cn/1b053bd5569c41b7b11caeba75037c7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="三、硬件连线部分"><a href="#三、硬件连线部分" class="headerlink" title="三、硬件连线部分"></a>三、硬件连线部分</h2><p>CH340 ↔ STM32F103C8T6最小系统板：<br>TX ↔ RX<br>RX ↔ TX</p><p>DAP-LINK ↔ STM32F103C8T6最小系统板<br>3.3V ↔ VCC<br>GND ↔ GND<br>SWIO ↔ SWIO<br>SWCLK ↔ SWCLK</p><p>HC-SR501模块 ↔ STM32F103C8T6最小系统板<br>OUT ↔ PA1<br>GND ↔ GND</p><p>HC-SR501模块 ↔ DAP-LINK <strong>（这里注意模块供电范围为4.5V-20V，用3.3V无法驱动）</strong><br>VCC ↔ 5V</p><p>HC-SR04模块 ↔ CH340<br>VCC ↔ 5V</p><p>HC-SR04模块 ↔ STM32F103C8T6最小系统板<br>Trig ↔ PB4<br>Echo ↔ PB5<br>GND ↔ GND</p><h2 id="四、逻辑代码部分"><a href="#四、逻辑代码部分" class="headerlink" title="四、逻辑代码部分"></a>四、逻辑代码部分</h2><p>代码框架是基于上一篇HC-SR501红外人体感应模块修改而成的，想要完整代码的话可以和上篇文章一起看。</p><h3 id="HC-SR04-c"><a href="#HC-SR04-c" class="headerlink" title="HC_SR04.c"></a>HC_SR04.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HC_SR04.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_it.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> distance_result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint16_t</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> a1=TIM2-&gt;CNT;</span><br><span class="line"><span class="keyword">while</span>(TIM2-&gt;CNT-a1&lt;time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HC_SR04_startrange</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(HC_SR04_Trig_GPIO_Port,HC_SR04_Trig_Pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">Delay_us(<span class="number">10</span>);</span><br><span class="line">HAL_GPIO_WritePin(HC_SR04_Trig_GPIO_Port,HC_SR04_Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">HC_SR04_gettime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> a;</span><br><span class="line">a=TIM2-&gt;CNT;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">HC_SR04_getdistance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> time_node1;</span><br><span class="line"> <span class="type">uint16_t</span> time_node2;</span><br><span class="line">  <span class="type">uint16_t</span> measure;</span><br><span class="line"></span><br><span class="line">  HC_SR04_startrange();</span><br><span class="line"></span><br><span class="line">TIM2-&gt;CNT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(HAL_GPIO_ReadPin(HC_SR04_Echo_GPIO_Port,HC_SR04_Echo_Pin)==RESET);</span><br><span class="line">time_node1=HC_SR04_gettime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(HAL_GPIO_ReadPin(HC_SR04_Echo_GPIO_Port,HC_SR04_Echo_Pin)==SET);</span><br><span class="line">time_node2=HC_SR04_gettime();</span><br><span class="line"></span><br><span class="line">measure=time_node2-time_node1;</span><br><span class="line"></span><br><span class="line">distance_result = measure * <span class="number">17.0</span>/<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> distance_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HC-SR04-h"><a href="#HC-SR04-h" class="headerlink" title="HC_SR04.h"></a>HC_SR04.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HC_SR04_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HC_SR04_H_</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint16_t</span> time)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HC_SR04_startrange</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">HC_SR04_getdistance</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">HC_SR04_gettime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">HC_SR04_distance=HC_SR04_getdistance();</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_RESET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;有人,目前距离为：%.2f cm\r\n&quot;</span>,HC_SR04_distance);</span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_SET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没人\r\n&quot;</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现象：</strong></p><p>感应到人体，板载LED绿灯亮，同时串口打印测距结果。<br><img src="https://img-blog.csdnimg.cn/fdf542a1e5f54fb497c66664fcf7880e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>注意：</strong><br><strong>重定义printf后，必须在target里面勾选上MicroLIB，调用一下这个微型库，不然一直卡在里面。</strong></p><p><img src="https://img-blog.csdnimg.cn/bba9468e9009467abfafc8111b94ac0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>参考博客：<br><a href="https://blog.csdn.net/sasasatori/article/details/81199455">stm32f1驱动HC-SR04超声波测距模块</a></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32的HC-SR501红外感应模块驱动与应用</title>
      <link href="/2024/03/stm32-%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E6%84%9F%E5%BA%94%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/stm32-%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E6%84%9F%E5%BA%94%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>一、 简介<br>HC-SR501红外感应模块是一种常用的人体红外感应模块，常用于安防监控、智能家居等领域。本文将介绍如何在STM32单片机上驱动和应用HC-SR501红外感应模块，实现基本的人体检测功能。</strong></p><p><strong>二、 模块原理</strong><br>HC-SR501红外感应模块基于红外热释电传感器（PIR sensor）原理，当检测到人体或其他热源时，输出高电平信号。该模块有延迟时间和重复触发时间两个可调节的螺旋调节器，可根据需求调节模块的灵敏度和触发后的输出信号时长。</p><p><strong>三、 连接与驱动<br>1. 连接</strong><br>连接HC-SR501模块至STM32单片机，将模块的OUT引脚连接至STM32的GPIO引脚，以接收感应模块的输出信号。同时，通过电源模块连接模块至单片机的供电引脚。</p><p><img src="https://img-blog.csdnimg.cn/direct/12a9a768aaa04891b1c9bfc0d758aae5.png"></p><p><strong>2. 驱动</strong><br>在STM32的开发环境中，编写对HC-SR501模块的驱动程序。以下是一个简单的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">```c</span><br><span class="line">#include &quot;stm32f4xx.h&quot;</span><br><span class="line"></span><br><span class="line">#define HC_SR501_PIN GPIO_PIN_0</span><br><span class="line">#define HC_SR501_PORT GPIOA</span><br><span class="line"></span><br><span class="line">void HC_SR501_Init(void) &#123;</span><br><span class="line">&amp;#xA0; GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">&amp;#xA0; __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">&amp;#xA0; GPIO_InitStruct.Pin = HC_SR501_PIN;</span><br><span class="line">&amp;#xA0; GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">&amp;#xA0; GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">&amp;#xA0; HAL_GPIO_Init(HC_SR501_PORT, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HC_SR501_Read(void) &#123;</span><br><span class="line">&amp;#xA0; return HAL_GPIO_ReadPin(HC_SR501_PORT, HC_SR501_PIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HC_SR501_Application(void) &#123;</span><br><span class="line">&amp;#xA0; while (1) &#123;</span><br><span class="line">&amp;#xA0; &amp;#xA0; if (HC_SR501_Read()) &#123;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &amp;#xA0; // &amp;#x68C0;&amp;#x6D4B;&amp;#x5230;&amp;#x4EBA;&amp;#x4F53;&amp;#xFF0C;&amp;#x6267;&amp;#x884C;&amp;#x76F8;&amp;#x5E94;&amp;#x64CD;&amp;#x4F5C;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &#125; else &#123;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &amp;#xA0; // &amp;#x672A;&amp;#x68C0;&amp;#x6D4B;&amp;#x5230;&amp;#x4EBA;&amp;#x4F53;&amp;#xFF0C;&amp;#x6267;&amp;#x884C;&amp;#x76F8;&amp;#x5E94;&amp;#x64CD;&amp;#x4F5C;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &#125;</span><br><span class="line">&amp;#xA0; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">&amp;#xA0; HC_SR501_Init();</span><br><span class="line">&amp;#xA0; HC_SR501_Application();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>以上代码中，首先初始化了GPIO引脚，然后在应用函数中不断读取感应模块的输出信号，根据输出信号执行不同的操作。**四、 应用示例&lt;br&gt;1. 基于HC-SR501红外感应模块的人体检测报警系统**通过连接HC-SR501模块至STM32单片机，并配合蜂鸣器或其他报警装置，可以实现一个简单的人体检测报警系统。当检测到人体时，系统触发报警装置，实现安防监控。**2. 基于HC-SR501红外感应模块的智能照明控制系统**将HC-SR501模块连接至STM32单片机，再连接至LED灯或其他照明设备，可以实现智能照明控制系统。当检测到人体时，系统自动开启照明设备，当未检测到人体时则关闭照明设备，实现智能节能控制。**以上是基于STM32的HC-SR501红外感应模块的驱动与应用的基本介绍，通过上述方法，可以实现针对不同场景的人体感应控制系统。**&gt; ✅作者简介：热爱科研的嵌入式开发者，修心和技术同步精进代码获取、问题探讨及文章转载可私信。☁ 愿你的生命中有够多的云翳,来造就一个美丽的黄昏。🍎获取更多嵌入式资料可点击链接进群领取，谢谢支持！👇[点击领取更多详细资料](https://fss.mpay8.cn/article/dmrjinh2C6fjejm &quot;点击领取更多详细资料&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你，通过HAL库实现STM32的超声波测距--以SR-04为例</title>
      <link href="/2024/03/stm32-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%EF%BC%8C%E9%80%9A%E8%BF%87HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D-%E4%BB%A5SR-04%E4%B8%BA%E4%BE%8B/"/>
      <url>/2024/03/stm32-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%EF%BC%8C%E9%80%9A%E8%BF%87HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D-%E4%BB%A5SR-04%E4%B8%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>目录</strong></p><p><a href="#0%E3%80%81sr-04%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" title="0、SR-04基本原理">0、SR-04基本原理</a></p><p><a href="#1%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1、准备工作">1、准备工作</a></p><p><a href="#2%E3%80%81%E8%BF%9E%E7%BA%BF" title="2、连线">2、连线</a></p><p><a href="#%C2%A03%E3%80%81stm32cubemx%E8%AE%BE%E7%BD%AE" title="3、STM32CUBEMX设置">3、STM32CUBEMX设置</a></p><p><a href="#31%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B" title="3.1新建工程">3.1新建工程</a></p><p><a href="#32%E8%8A%AF%E7%89%87%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE" title="3.2芯片通用设置">3.2芯片通用设置</a></p><p><a href="#33%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8D%95%E8%8E%B7%E8%AE%BE%E7%BD%AE" title="3.3定时器捕获设置">3.3定时器捕获设置</a></p><p><a href="#%E2%80%8B34%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE" title="​3.4其他设置">​3.4其他设置</a></p><p><a href="#35%E7%94%9F%E6%88%90%E5%B7%A5%E7%A8%8B" title="3.5生成工程">3.5生成工程</a></p><p><a href="#%C2%A04%E3%80%81%E7%A8%8B%E5%BA%8F%E5%AE%8C%E5%96%84" title="4、程序完善">4、程序完善</a></p><p><a href="#41%E5%AE%8C%E5%96%84%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0" title="4.1完善打印输出函数">4.1完善打印输出函数</a></p><p><a href="#%C2%A042%E5%AE%8C%E5%96%84timc" title="4.2完善tim.c">4.2完善tim.c</a></p><p><a href="#43%E5%AE%8C%E5%96%84gpioc%C2%A0" title="4.3完善gpio.c">4.3完善gpio.c</a></p><p><a href="#44%E5%AE%8C%E5%96%84main%E5%87%BD%E6%95%B0%C2%A0" title="4.4完善main函数">4.4完善main函数</a></p><p><a href="#%C2%A05%E3%80%81%E6%80%BB%E7%BB%93" title="5、总结">5、总结</a></p><h2 id="0、SR-04基本原理"><a href="#0、SR-04基本原理" class="headerlink" title="0、SR-04基本原理"></a>0、SR-04基本原理</h2><p>声波遇到障碍物会反射，而声波的速度已知，所以只需要知道发射到接收的时间差，就能轻松计算出测量距离，再结合发射器和接收器的距离，就能算出障碍物的实际距离。</p><p><img src="https://img-blog.csdnimg.cn/2020032802343260.png"></p><p><img src="https://img-blog.csdnimg.cn/20200328023701292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjU4OTgx,size_16,color_FFFFFF,t_70"></p><p>以HC-SR04硬件为例，端口为VCC、Trig、Echo、GND。</p><p>VCC–接STM32板子+5V；<br>GND–接STM32板子GND；<br>Trig–为触发控制信号输入，触发测距，给至少10us的高电平信号，模块自动发射8个40KHz的方波，自动检测是否有信号返回；<br>Echo–回响信号输出，有信号返回，通过IO口ECHO输出一个高电平，高电平持续时间就是超声波从发射到返回的时间。<br>那用STM32怎么给端口信号呢？又是怎么获取信号呢？<br>Trig端口为超声波模块的输入信号，也就是通过STM23一个端口推挽输出一个至少10us的高电平信号即可，利用delay_ms(20)实现；<br>Echo端口为超声波模块的输出信号，也就是利用STM32端口捕获高电平时间，那么这个端口肯定是可以用做定时器的端口。<br>通过以上分析，这里采用以下STM32端口</p><p><img src="https://img-blog.csdnimg.cn/c10df4b58e2d49cb8b3b363c0e22019c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/3b14aae863264dd4afbc8445ad66a7d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><p>开发板：STM32F1精英版</p><p>软件：STM32CubeMx软件</p><p>IDE： MDK-Keil软件</p><p>传感器：HC-SR04</p><h2 id="2、连线"><a href="#2、连线" class="headerlink" title="2、连线"></a>2、连线</h2><p>选择TIM5的CH1即PA0作为输入捕获引脚（Echo），选择PA5作为触发脚Trig。具体连接线如下：</p><p>红线连接精英版的5V与SR04的VCC脚</p><p>白线连接精英板的GND与SR04的GND脚</p><p>橙色线连接精英板的PA5与Trig脚</p><p>黑色线连接精英板的PA0与Echo脚</p><p><img src="https://img-blog.csdnimg.cn/2e1fa4f5325345729a0a44473dfd2526.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="3、STM32CUBEMX设置"><a href="#3、STM32CUBEMX设置" class="headerlink" title="3、STM32CUBEMX设置"></a>3、STM32CUBEMX设置</h2><h3 id="3-1新建工程"><a href="#3-1新建工程" class="headerlink" title="3.1新建工程"></a>3.1新建工程</h3><p>1）新建工程</p><p><img src="https://img-blog.csdnimg.cn/7115721af4f7487fae5b0ff66f45667d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2）选择芯片</p><p><img src="https://img-blog.csdnimg.cn/9cecc36eced643b185e29591bbe60cf0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="3-2芯片通用设置"><a href="#3-2芯片通用设置" class="headerlink" title="3.2芯片通用设置"></a>3.2芯片通用设置</h3><p>1）时钟芯片设置</p><p><img src="https://img-blog.csdnimg.cn/e262e3fba4f8447ab4c8c567225173a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2）时钟设置</p><p><img src="https://img-blog.csdnimg.cn/abb1957bcbce4521af21421c25464c77.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>3）系统调试设置</p><p><img src="https://img-blog.csdnimg.cn/ed518ef9e29c4359bd52a2ca81e8823e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="3-3定时器捕获设置"><a href="#3-3定时器捕获设置" class="headerlink" title="3.3定时器捕获设置"></a>3.3定时器捕获设置</h3><p>由于前文连线中，我们将TIMER5CH1作为输入捕获引脚，所以对TIMER5进行设置：</p><p>Channel 1选择：Input Capture direct mode</p><p>与分频系数填写：72-1（则每次计数为1us）</p><p>Polarity Selection选择：Rising Edge（上升沿）</p><p>其他保持不变。</p><p><img src="https://img-blog.csdnimg.cn/c4191f72c63049fdbfb8f8b96f672f66.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>NVIC settings选择TIM5 global interrupt</p><h3 id="3-4其他设置"><a href="#3-4其他设置" class="headerlink" title="  3.4其他设置"></a><img src="https://img-blog.csdnimg.cn/d1d24efee88d46178d8001eb1f8eaf61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16">  3.4其他设置</h3><p>1）USART1设置</p><p>为了方便调试，将测量所得数据通过串口传递到电脑上进行显示，此处使用串口1通过printf将输出发送至电脑。</p><p><img src="https://img-blog.csdnimg.cn/82ca9b0ff3e94cfa8286e7d5573fac1a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2）GPIO配置</p><p>此处选择PA5作为Trig脚，具体配置如下：</p><p><img src="https://img-blog.csdnimg.cn/47ed779ee47641cfb88d1b94d4804ce0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="3-5生成工程"><a href="#3-5生成工程" class="headerlink" title="3.5生成工程"></a>3.5生成工程</h3><p><img src="https://img-blog.csdnimg.cn/a6e90e647fe24e5087daa4b099e7da40.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/46dfa628b984462d95dc70b4a37152c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="4、程序完善"><a href="#4、程序完善" class="headerlink" title="4、程序完善"></a>4、程序完善</h2><h3 id="4-1完善打印输出函数"><a href="#4-1完善打印输出函数" class="headerlink" title="4.1完善打印输出函数"></a>4.1完善打印输出函数</h3><p>在main函数中加入下面语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* Private includes ----------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">/* Private user code ---------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">#ifdef __GNUC__</span><br><span class="line">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line">#else</span><br><span class="line">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xFFFF);</span><br><span class="line">return ch;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>加入此语句之后可以在main函数中加入printf语句测试是否成功。</p><p>将精英板USB232口通过USB数据线与电脑连接，并在电脑上打开串口调试软件： <img src="https://img-blog.csdnimg.cn/a79a767a9dfa4baeb621c05235cbc92b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/d27a80b3c0fa4d30999384ca8c8a46d7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="4-2完善tim-c"><a href="#4-2完善tim-c" class="headerlink" title="4.2完善tim.c"></a>4.2完善tim.c</h3><p>在tim.c中加入以下程序：</p><p>定义变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">//&amp;#x6355;&amp;#x83B7;&amp;#x72B6;&amp;#x6001;</span><br><span class="line">//[7]:0,&amp;#x6CA1;&amp;#x6709;&amp;#x6210;&amp;#x529F;&amp;#x7684;&amp;#x6355;&amp;#x83B7;;1,&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x6B21;.</span><br><span class="line"></span><br><span class="line">//[6]:0,&amp;#x8FD8;&amp;#x6CA1;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4F4E;&amp;#x7535;&amp;#x5E73;;1,&amp;#x5DF2;&amp;#x7ECF;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4F4E;&amp;#x7535;&amp;#x5E73;&amp;#x4E86;.</span><br><span class="line"></span><br><span class="line">//[5:0]:&amp;#x6355;&amp;#x83B7;&amp;#x4F4E;&amp;#x7535;&amp;#x5E73;&amp;#x540E;&amp;#x6EA2;&amp;#x51FA;&amp;#x7684;&amp;#x6B21;&amp;#x6570;</span><br><span class="line">uint8_t  TIM5CH2_CAPTURE_STA=0;//&amp;#x8F93;&amp;#x5165;&amp;#x6355;&amp;#x83B7;&amp;#x72B6;&amp;#x6001;</span><br><span class="line">uint16_t TIM5CH2_CAPTURE_VAL;//&amp;#x8F93;&amp;#x5165;&amp;#x6355;&amp;#x83B7;&amp;#x503C;(TIM2&amp;#x662F;16&amp;#x4F4D;)</span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>在底部加入溢出回调函数和输入捕获回调函数。其中参考了正点原子官方的的输入 捕获回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 1 */</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)//&amp;#x66F4;&amp;#x65B0;&amp;#x4E2D;&amp;#x65AD;&amp;#xFF08;&amp;#x6EA2;&amp;#x51FA;&amp;#xFF09;&amp;#x53D1;&amp;#x751F;&amp;#x65F6;&amp;#x6267;&amp;#x884C;</span><br><span class="line">&#123;</span><br><span class="line">if((TIM5CH2_CAPTURE_STA&amp;0X80) ==0)//&amp;#x8FD8;&amp;#x672A;&amp;#x6355;&amp;#x83B7;&amp;#x6210;&amp;#x529F;</span><br><span class="line">&#123;</span><br><span class="line">if(TIM5CH2_CAPTURE_STA&amp;0X40)//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x4E2A;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;</span><br><span class="line">&#123;</span><br><span class="line">if((TIM5CH2_CAPTURE_STA&amp;0X3F)==0X3F)//&amp;#x9AD8;&amp;#x7535;&amp;#x5E73;&amp;#x65F6;&amp;#x95F4;&amp;#x592A;&amp;#x957F;&amp;#x4E86;</span><br><span class="line">&#123;</span><br><span class="line">TIM5CH2_CAPTURE_STA |= 0X80;//&amp;#x6807;&amp;#x8BB0;&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x4E00;&amp;#x6B21;</span><br><span class="line">TIM5CH2_CAPTURE_VAL = 0XFFFF;//</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">TIM5CH2_CAPTURE_STA++;//&amp;#x5426;&amp;#x5219;&amp;#x6807;&amp;#x8BB0;&amp;#x6EA2;&amp;#x51FA;&amp;#x6570;&amp;#x52A0;&amp;#x4E00;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)//&amp;#x6355;&amp;#x83B7;&amp;#x4E2D;&amp;#x65AD;&amp;#x53D1;&amp;#x751F;&amp;#x65F6;&amp;#x6267;&amp;#x884C;</span><br><span class="line">&#123;</span><br><span class="line">if((TIM5CH2_CAPTURE_STA&amp;0x80)==0)//&amp;#x8FD8;&amp;#x672A;&amp;#x6355;&amp;#x83B7;&amp;#x6210;&amp;#x529F;</span><br><span class="line">&#123;</span><br><span class="line">if(TIM5CH2_CAPTURE_STA&amp;0x40)//&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x4E2A;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;</span><br><span class="line">&#123;</span><br><span class="line">TIM5CH2_CAPTURE_STA |= 0X80;//&amp;#x6807;&amp;#x8BB0;&amp;#x6210;&amp;#x529F;&amp;#xFF0C;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x6B21;&amp;#x9AD8;&amp;#x7535;&amp;#x5E73;&amp;#x5B8C;&amp;#x6210;</span><br><span class="line">TIM5CH2_CAPTURE_VAL  = HAL_TIM_ReadCapturedValue(&amp;htim5, TIM_CHANNEL_1);//&amp;#x83B7;&amp;#x53D6;&amp;#x5F53;&amp;#x524D;&amp;#x6355;&amp;#x83B7;&amp;#x503C;</span><br><span class="line">TIM_RESET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1);//&amp;#x6E05;&amp;#x9664;&amp;#x539F;&amp;#x6765;&amp;#x8BBE;&amp;#x7F6E;</span><br><span class="line">TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING);//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;&amp;#x540E;&amp;#xFF0C;&amp;#x5C06;&amp;#x6355;&amp;#x83B7;&amp;#x590D;&amp;#x4F4D;&amp;#x5230;&amp;#x6355;&amp;#x83B7;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x4E2A;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;</span><br><span class="line">&#123;</span><br><span class="line">TIM5CH2_CAPTURE_STA = 0;</span><br><span class="line">TIM5CH2_CAPTURE_VAL = 0;</span><br><span class="line">TIM5CH2_CAPTURE_STA |= 0x40;//&amp;#x7B2C;&amp;#x516D;&amp;#x4F4D;&amp;#x6807;&amp;#x8BB0;&amp;#x4E3A;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;</span><br><span class="line">__HAL_TIM_DISABLE(&amp;htim5);//&amp;#x5173;&amp;#x95ED;&amp;#x5B9A;&amp;#x65F6;&amp;#x5668;</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim5, 0);//&amp;#x5B9A;&amp;#x65F6;&amp;#x5668;&amp;#x521D;&amp;#x59CB;&amp;#x503C;&amp;#x8BBE;&amp;#x7F6E;&amp;#x4E3A;0</span><br><span class="line">TIM_RESET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1);</span><br><span class="line">TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING);//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;&amp;#x4E4B;&amp;#x540E;&amp;#xFF0C;&amp;#x5C06;&amp;#x6355;&amp;#x83B7;&amp;#x8BBE;&amp;#x7F6E;&amp;#x4E3A;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;</span><br><span class="line">__HAL_TIM_ENABLE(&amp;htim5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 1 */</span><br></pre></td></tr></table></figure><h3 id="4-3完善gpio-c"><a href="#4-3完善gpio-c" class="headerlink" title="4.3完善gpio.c"></a>4.3完善gpio.c</h3><p>模拟Trig脚，先置位，过40us后，复位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 2 */</span><br><span class="line">void CHL_capture(void)</span><br><span class="line">&#123;</span><br><span class="line">uint32_t i;</span><br><span class="line"></span><br><span class="line">HAL_GPIO_WritePin(TRIG_GPIO_Port, TRIG_Pin, GPIO_PIN_SET);</span><br><span class="line">for(i=0;i&lt;72*40;i++) 2 __nop(); hal_gpio_writepin(trig_gpio_port, trig_pin, gpio_pin_reset); &#125; * user code end &lt;&gt;&lt;/72*40;i++)&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4完善main函数"><a href="#4-4完善main函数" class="headerlink" title="4.4完善main函数"></a>4.4完善main函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 1 */</span><br><span class="line">float len = 0;</span><br><span class="line">uint32_t time= 0;</span><br><span class="line">uint8_t count = 0;</span><br><span class="line">  /* USER CODE END 1 */</span><br><span class="line"></span><br><span class="line">  /* MCU Configuration--------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN Init */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END Init */</span><br><span class="line"></span><br><span class="line">  /* Configure the system clock */</span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN SysInit */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END SysInit */</span><br><span class="line"></span><br><span class="line">  /* Initialize all configured peripherals */</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_TIM5_Init();</span><br><span class="line">  MX_USART1_UART_Init();</span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">printf(&quot;Hello World!\r\n&quot;);</span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);   //&amp;#x5F00;&amp;#x542F;TIM2&amp;#x7684;&amp;#x6355;&amp;#x83B7;&amp;#x901A;&amp;#x9053;2&amp;#xFF0C;&amp;#x5E76;&amp;#x4E14;&amp;#x5F00;&amp;#x542F;&amp;#x6355;&amp;#x83B7;&amp;#x4E2D;&amp;#x65AD;</span><br><span class="line">    __HAL_TIM_ENABLE_IT(&amp;htim5,TIM_IT_UPDATE);   //&amp;#x4F7F;&amp;#x80FD;&amp;#x66F4;&amp;#x65B0;&amp;#x4E2D;&amp;#x65AD;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  HAL_Delay(100);</span><br><span class="line">  CHL_capture();</span><br><span class="line">  if(TIM5CH2_CAPTURE_STA &amp; 0x80)//&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x4E00;&amp;#x4E2A;&amp;#x8109;&amp;#x5BBD;</span><br><span class="line">  &#123;</span><br><span class="line">time = TIM5CH2_CAPTURE_STA &amp; 0x3F;//&amp;#x83B7;&amp;#x53D6;&amp;#x6EA2;&amp;#x51FA;&amp;#x6B21;&amp;#x6570;</span><br><span class="line">time *= 65536;//&amp;#x83B7;&amp;#x5F97;&amp;#x6EA2;&amp;#x51FA;&amp;#x7684;&amp;#x65F6;&amp;#x95F4;&amp;#x503C;</span><br><span class="line">time += TIM5CH2_CAPTURE_VAL;//&amp;#x52A0;&amp;#x4E0A;&amp;#x6700;&amp;#x540E;&amp;#x4E00;&amp;#x6B21;&amp;#x53D6;&amp;#x5F97;&amp;#x7684;&amp;#x503C;</span><br><span class="line">len = time * 342.62*100/2000000;</span><br><span class="line"></span><br><span class="line">TIM5CH2_CAPTURE_STA = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;LENGTH: %f CM\r\n&quot;, len);</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 3 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>本文介绍了通过HAL库完成SR-04超声波传感器距离的测量。包括了，超声波传感器的原理、STM32CUBEMX的配置，以及程序的完善。最终的结果如下：</p><p><img src="https://img-blog.csdnimg.cn/bdd5e4a431694f4897745b2ebb55fbdd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 HAL库驱动DHT11读取温湿度程序</title>
      <link href="/2024/03/stm32-stm32-STM32-HAL%E5%BA%93%E9%A9%B1%E5%8A%A8DHT11%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/03/stm32-stm32-STM32-HAL%E5%BA%93%E9%A9%B1%E5%8A%A8DHT11%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="STM32使用HAL库驱动DHT11读取温湿度程序"><a href="#STM32使用HAL库驱动DHT11读取温湿度程序" class="headerlink" title="STM32使用HAL库驱动DHT11读取温湿度程序"></a>STM32使用HAL库驱动DHT11读取温湿度程序</h2><p><strong>驱动DHT11、DHT22、DS18BB20等温湿度模块时序是比较简单的，关键在于控制好时序的 <code>&amp;#x5EF6;&amp;#x65F6;&amp;#x65F6;&amp;#x95F4;</code> ，HAL库的延时函数HAL_Delay是毫秒级别延时函数，所关键点就是实现微秒级别的延时函数。</strong></p><p><strong>微秒级别延时函数实现见我的另一篇博客：<a href="https://blog.csdn.net/qq153471503/article/details/102930097">https://blog.csdn.net/qq153471503/article/details/102930097</a></strong></p><p><strong>扫描以下二维码，关注公众号 <code>&amp;#x96CD;&amp;#x6B63;&amp;#x4E0D;&amp;#x79C3;&amp;#x5934;</code> 获取更多STM32资源及干货！</strong><br><img src="https://img-blog.csdnimg.cn/20210126155428872.png"></p><h3 id="sys-h"><a href="#sys-h" class="headerlink" title=";  sys.h"></a><a name="sysh_13">;</a>  sys.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SYS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SYS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ODR_Addr    (GPIOA_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR_Addr    (GPIOB_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ODR_Addr    (GPIOC_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ODR_Addr    (GPIOD_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ODR_Addr    (GPIOE_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr    (GPIOF_BASE+12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_ODR_Addr    (GPIOG_BASE+12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR_Addr    (GPIOA_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_IDR_Addr    (GPIOB_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_IDR_Addr    (GPIOC_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_IDR_Addr    (GPIOD_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_IDR_Addr    (GPIOE_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr    (GPIOF_BASE+8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_IDR_Addr    (GPIOG_BASE+8)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dht11-h"><a href="#dht11-h" class="headerlink" title="dht11.h"></a>dht11.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DHT11_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DHT11_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11_IO_IN()  &#123;IODHT22_GPIO_Port-&gt;CRH &amp;= 0xFFFFF0FF;IODHT22_GPIO_Port-&gt;CRH |= 8 &lt;&lt; 8;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11_IO_OUT() &#123;IODHT22_GPIO_Port-&gt;CRH &amp;= 0xFFFFF0FF;IODHT22_GPIO_Port-&gt;CRH |= 3 &lt;&lt; 8;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DHT11_DQ_OUT PCout(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>DHT11_DQ_IN  PCin(10)</span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data</span><span class="params">(u8 *temp, u8 *humi)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Byte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Bit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Check</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Rst</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data_Float</span><span class="params">(<span class="type">float</span> *temp,<span class="type">float</span> *humi)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dht11-c"><a href="#dht11-c" class="headerlink" title="dht11.c"></a>dht11.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dht11.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DHT11_Rst</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DHT11_IO_OUT();</span><br><span class="line">    DHT11_DQ_OUT=<span class="number">0</span>;</span><br><span class="line">    delay_ms(<span class="number">20</span>);</span><br><span class="line">    DHT11_DQ_OUT=<span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Check</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 retry=<span class="number">0</span>;</span><br><span class="line">    DHT11_IO_IN();</span><br><span class="line">    <span class="keyword">while</span> (DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(retry&gt;=<span class="number">100</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> retry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(retry&gt;=<span class="number">100</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Bit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 retry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    retry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!DHT11_DQ_IN&amp;&amp;retry&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    delay_us(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span>(DHT11_DQ_IN)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Byte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i,dat;</span><br><span class="line">    dat=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dat&lt;<span class="number">1</span>;</span><br><span class="line">        dat|=DHT11_Read_Bit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data</span><span class="params">(u8 *temp,u8 *humi)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buf[<span class="number">5</span>];</span><br><span class="line">    u8 i;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    <span class="keyword">if</span>(DHT11_Check()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]=DHT11_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((buf[<span class="number">0</span>]+buf[<span class="number">1</span>]+buf[<span class="number">2</span>]+buf[<span class="number">3</span>])==buf[<span class="number">4</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            *humi=buf[<span class="number">0</span>];</span><br><span class="line">            *temp=buf[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Read_Data_Float</span><span class="params">(<span class="type">float</span> *temp,<span class="type">float</span> *humi)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buf[<span class="number">5</span>];</span><br><span class="line">    u8 i;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    <span class="keyword">if</span>(DHT11_Check()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]=DHT11_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((buf[<span class="number">0</span>]+buf[<span class="number">1</span>]+buf[<span class="number">2</span>]+buf[<span class="number">3</span>])==buf[<span class="number">4</span>])</span><br><span class="line">        &#123;</span><br><span class="line">*humi=((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) + buf[<span class="number">1</span>]) / <span class="number">10.0</span>;</span><br><span class="line">*temp=((buf[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) + buf[<span class="number">3</span>]) / <span class="number">10.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">DHT11_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ret = <span class="number">1</span>;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    ret = DHT11_Check();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dht11 init %s. \r\n&quot;</span>, ret == <span class="number">0</span> ? <span class="string">&quot;ok&quot;</span> : <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 实现 44 矩阵键盘扫描（HAL库、标准库 都适用） - 白菜没我白 - 博客园</title>
      <link href="/2024/03/stm32-stm32-STM32-%E5%AE%9E%E7%8E%B0-44-%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E6%89%AB%E6%8F%8F%EF%BC%88HAL%E5%BA%93%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93-%E9%83%BD%E9%80%82%E7%94%A8%EF%BC%89-%E7%99%BD%E8%8F%9C%E6%B2%A1%E6%88%91%E7%99%BD-%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
      <url>/2024/03/stm32-stm32-STM32-%E5%AE%9E%E7%8E%B0-44-%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98%E6%89%AB%E6%8F%8F%EF%BC%88HAL%E5%BA%93%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93-%E9%83%BD%E9%80%82%E7%94%A8%EF%BC%89-%E7%99%BD%E8%8F%9C%E6%B2%A1%E6%88%91%E7%99%BD-%E5%8D%9A%E5%AE%A2%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文实现的代码是基于STM32HAL库的基础上的，不过标准库也可以用，只是调用的库函数不同，逻辑跟配置是一样的，按我这里的逻辑来配置即可。</p><p><strong>1、键盘原理图：</strong></p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190313172634453-1011388660.png"></p><p>原理举例：先把 F0-F7 内部拉高，这样这个8个引脚都是高电平，然后就进行列扫描。例如：假如按下3按钮，Y3 列扫描，把F4先拉低，然后读取F0-F3的状态，就会读出为1110，这就可 以知道是F3行拉低了，同时这时候是程序控制F4拉低的，这样就可以知道是F4列导致它转态变化了的，这样就可以定位出是F4列F3行的按键按下了；其他的列也是这样子扫描，就可以实现了。</p><p><strong>2、STM32 cubemx 引脚配置图：</strong></p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190313173013856-453677748.png"></p><p>这里用外部晶振内部晶振都可以，时钟对这个没什么影响，不用开中断，所以其他的配置就不细说了，下面再说一下这8个GPIO的配置。</p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190313173246180-1491953324.png"></p><p>4个引脚配推挽输出，这4个配输出的引脚内部上下拉不用配置；另外4个配成输入，内部上拉。</p><p><strong>3、生成代码后，开始编写逻辑：</strong></p><p>编写之前我们先做一下头文件的定义，把一些要用到的宏定义好：</p><pre><span>#ifndef __HW_key_H__</span><span>#define</span> __HW_key_H__<span>#include </span><span>&quot;</span><span>main.h</span><span>&quot;</span><span>#include </span><span>&quot;</span><span>stm32f1xx_hal.h</span><span>&quot;</span><span>#include </span>&lt;<span>string</span>.h&gt;<span>char</span> KEY_SCAN(<span>void</span><span>);</span><span>char</span> KEY_ROW_SCAN(<span>void</span><span>);</span><span>void</span> HW_KEY_FUNCTION(<span>void</span><span>);</span><span>#define</span> KEY_CLO0_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_7,GPIO_PIN_RESET)<span>#define</span> KEY_CLO1_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_RESET)<span>#define</span> KEY_CLO2_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_9,GPIO_PIN_RESET)<span>#define</span> KEY_CLO3_OUT_LOW  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,GPIO_PIN_RESET)<span>#define</span> KEY_CLO0_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_7,GPIO_PIN_SET)<span>#define</span> KEY_CLO1_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_SET)<span>#define</span> KEY_CLO2_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_9,GPIO_PIN_SET)<span>#define</span> KEY_CLO3_OUT_HIGH  HAL_GPIO_WritePin(GPIOE,GPIO_PIN_10,GPIO_PIN_SET)<span>#endif</span></pre><p>然后包含头文件以及定义一些要用到的变量数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;HW_key.h&quot;</span><br><span class="line">uint8_t Key_row[1]=&#123;0xff&#125;;   //保存按键行扫描情况的状态数组</span><br></pre></td></tr></table></figure><p>接着可以写扫描逻辑了，先编写横扫描的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *函数名：KEY_ROW_SCAN</span><br><span class="line"> *功  能：按键行扫描</span><br><span class="line"> *返回值：1~4，对应1~4行按键位置</span><br><span class="line"> */</span><br><span class="line">char KEY_ROW_SCAN(void)</span><br><span class="line">&#123;</span><br><span class="line">    //读出行扫描状态</span><br><span class="line">    Key_row[0] = HAL_GPIO_ReadPin(GPIOE,KEY_row0_Pin)&lt;&lt;3;</span><br><span class="line">    Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_row1_Pin)&lt;&lt;2);</span><br><span class="line">    Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_row2_Pin)&lt;&lt;1);</span><br><span class="line">    Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_row3_Pin));</span><br><span class="line"></span><br><span class="line">    if(Key_row[0] != 0x0f)         //行扫描有变化，判断该列有按键按下</span><br><span class="line">    &#123;</span><br><span class="line">      HAL_Delay(10);                    //消抖</span><br><span class="line">      if(Key_row[0] != 0x0f)</span><br><span class="line">        &#123;</span><br><span class="line">                //printf(&quot;Key_Row_DATA = 0x%x\r\n&quot;,Key_row[0]);</span><br><span class="line">                switch(Key_row[0])</span><br><span class="line">                &#123;</span><br><span class="line">                    case 0x07:         //0111 判断为该列第1行的按键按下</span><br><span class="line">                        return 1;</span><br><span class="line">                    case 0x0b:         //1011 判断为该列第2行的按键按下</span><br><span class="line">                        return 2;</span><br><span class="line">                    case 0x0d:         //1101 判断为该列第3行的按键按下</span><br><span class="line">                        return 3;</span><br><span class="line">                    case 0x0e:         //1110 判断为该列第4行的按键按下</span><br><span class="line">                        return 4;</span><br><span class="line">                    default :</span><br><span class="line">                        return 0;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数，可以判断哪一行有按键按下，并返回有按键按下的行数。</p><p>接着编写列扫描的代码，这里的思想是，先扫描第一列，接着判断第一列有没有行被按下，有的话就可以直接定位到这一列的哪一行，其他4列逻辑一样，这样就可以定位到哪个按键按下了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *函数名：KEY_SCAN</span><br><span class="line"> *功  能：4*4按键扫描</span><br><span class="line"> *返回值：0~16，对应16个按键</span><br><span class="line"> */</span><br><span class="line">char KEY_SCAN(void)</span><br><span class="line">&#123;</span><br><span class="line">    char Key_Num=0;       //1-16对应的按键数</span><br><span class="line">    char key_row_num=0;        //行扫描结果记录</span><br><span class="line"></span><br><span class="line">    KEY_CLO0_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);  //消抖</span><br><span class="line">        Key_Num = 0 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_1\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO0_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    KEY_CLO1_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);</span><br><span class="line">        Key_Num = 4 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_2\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO1_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    KEY_CLO2_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);</span><br><span class="line">    Key_Num = 8 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_3\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO2_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    KEY_CLO3_OUT_LOW;</span><br><span class="line">    if( (key_row_num=KEY_ROW_SCAN()) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">//        Key_row[0] = HAL_GPIO_ReadPin(GPIOE,KEY_col0_Pin)&lt;//        Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_col1_Pin)&lt;//        Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_col2_Pin)&lt;//        Key_row[0] = Key_row[0] | (HAL_GPIO_ReadPin(GPIOE,KEY_col3_Pin));</span><br><span class="line">//        printf(&quot;Key_Clo4_DATA = 0x%x\r\n&quot;,Key_row[0]);</span><br><span class="line">        while(KEY_ROW_SCAN() != 0);</span><br><span class="line">        Key_Num = 12 + key_row_num;</span><br><span class="line">        //printf(&quot;Key_Clo_4\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    KEY_CLO3_OUT_HIGH;</span><br><span class="line"></span><br><span class="line">    return Key_Num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就可以直接返回1-16个按键的按键数了，按下第一个按键就返回1，第2个就返回2，以此类推。下面可以调用这个函数做按键按下的操作了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> *函数名：KEY_ROW_SCAN</span><br><span class="line"> *功  能：执行按下按键后的操作</span><br><span class="line"> *返回值：无</span><br><span class="line"> */</span><br><span class="line">void HW_KEY_FUNCTION(void)</span><br><span class="line">&#123;</span><br><span class="line">    char key_confirm;</span><br><span class="line">    key_confirm = KEY_SCAN();</span><br><span class="line">    if( 0 &lt; key_confirm  &amp;&amp; key_confirm &lt; 17 )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Key_NUM = %d \r\n&quot;,key_confirm); //按下1-16个按键的操作</span><br><span class="line">        printf(&quot;= = = = = = = = = = = \r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里就是用串口助手打印出来查看哪个按键按下的，实测可用。</p><p><img src="https://img2018.cnblogs.com/blog/1433771/201903/1433771-20190318150541397-1921208533.png"></p><p><strong>4、总结：</strong></p><p>（1）先配置8个引脚，4个配置输入，上拉；4个配置成推挽（PP）输出，不用上下拉，输出高电平；</p><p>（2）软件逻辑：</p><p>a. 先说一下行扫描的原理，因为如果有按键按下的话，某一个输入的引脚就会跟对应的输出引脚连接，因为输出为高电平，所以对应的输入引脚会被拉高，读取引脚的状态，判断哪个引脚被拉高就可以知道哪一行有按键按下了；总的来说是通过高四位输出高电平来对矩阵键盘进行逐行扫描，当低四位接收到的数据不全为1的时候，说明有按键按下，然后通过接收到的数据是哪一位为0来判断是哪一行按键被按下；</p><p>b. 列扫描原理：思路是先把第一列输出低电平，接着读取高4位的电平转态，单不全为1时，说明这一列有按键按下，同时结合行扫描判断出来的行数定位到按下的按键。程序里是扫描第一列的时候第一列给低电平，接着进行行扫描判断，因为输入输出引脚都是高电平了，只有第一列的引脚是低电平，所以当第一列有按键按下的时候，行扫描读到的4个引脚就不全为1，这时因为第一列的电平是我们自己给的，所以就可以直接判断这一列有按键按下；接着利用行扫描原理定位哪一行有按键按下，这样就可以判断出第一列的某一行的按键被按下了，其他3列同理，然后轮流扫描4列就可以判断16个按键了。</p><p>通俗点说，就是如果我给这一列低电平，造成了行扫描有变化，那就直接知道这一列有按键按下，接着查看行变化的电平变化，推算出哪一行变化了，就可以知道这一列的第几个按键被按下了。</p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX  HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</title>
      <link href="/2024/03/stm32-stm32-STM32CubeMX-HAL%E5%BA%93%E7%9A%84ADC%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E8%BD%AE%E8%AE%AD%E3%80%81DMA%E3%80%81DMA-TIM-%E3%80%81%E8%AF%BB%E5%8F%96%E5%86%85%E9%83%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B8%A9%E5%BA%A6/"/>
      <url>/2024/03/stm32-stm32-STM32CubeMX-HAL%E5%BA%93%E7%9A%84ADC%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E8%BD%AE%E8%AE%AD%E3%80%81DMA%E3%80%81DMA-TIM-%E3%80%81%E8%AF%BB%E5%8F%96%E5%86%85%E9%83%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="STM32CubeMX-HAL库的ADC多通道数据采集（轮训、DMA、DMA-TIM-、读取内部传感器温度"><a href="#STM32CubeMX-HAL库的ADC多通道数据采集（轮训、DMA、DMA-TIM-、读取内部传感器温度" class="headerlink" title="STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度"></a>STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#stm32cubemx--haladcdmadmatim-0">STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</a></li><li><ul><li><ul><li><a href="#1adc-11">1、ADC简介</a></li><li><ul><li><a href="#11--13">1.1 采样定理</a></li><li><a href="#12--15">1.2 模式介绍</a></li><li><a href="#13--24">1.3 采样时间和采样频率的计算</a></li></ul></li><li><a href="#2-56">2、轮训方式的多通道采集</a></li><li><ul><li><a href="#21--57">2.1 方式一：间断模式+扫描模式</a></li><li><a href="#22--72">2.2 方式二：完全轮训</a></li></ul></li><li><a href="#3dma-108">3、DMA实现多通道采集</a></li><li><a href="#4timdma-136">4、TIM+DMA实现多通道采集</a></li><li><a href="#5adc-179">5、补充：内部温度传感器ADC通道</a></li></ul></li></ul></li></ul><p><em>注：本片文章以STM32F103系列为例，其他系列可能稍有不同。</em></p><h4 id="1、ADC简介"><a href="#1、ADC简介" class="headerlink" title="1、ADC简介"></a>1、ADC简介</h4><h5 id="1-1-采样定理"><a href="#1-1-采样定理" class="headerlink" title="1.1 采样定理"></a>1.1 采样定理</h5><h5 id="1-2-模式介绍"><a href="#1-2-模式介绍" class="headerlink" title="1.2 模式介绍"></a>1.2 模式介绍</h5><ul><li><strong>扫描模式：</strong> 使用STM32CUBEMX配置了多通道后，这一项默认开启且无法设置成关闭。这个模式就是自动扫描你开启的所有通道进行转换，直至转换完。例如你开启了CH0、CH1、CH2、CH3这四个通道，启动转换后ADC会自动将这4个通道全部转换完，但是这种连续性是可以被打断的，所以就引出了间断模式。</li><li><strong>连续模式：</strong> 在CUBE中选中ENABLE就是连续模式，DISABLE就是单次模式。开启连续模式后，ADC的转换不由其他控制。例如将ADC设置为了定时器的TGRO触发采样，如果开启连续模式，ADC将忽略定时器的触发采样。（连续转换模式开启后其实就是满频率的采样）。</li><li><strong>间断模式：</strong> 可以将多个通道进行 <strong>分组采集</strong>，例如你开启了CH0~3这4个通道，假如你设置了间断次数为4，就相当于将4个通道分成了4组，每组1个通道，那么要想采集完这4个通道就需要手动触发4次ADC采集；如果设置了间断次数为2，那么采集完4个通道就需要手动触发2次ADC采集。</li></ul><h5 id="1-3-采样时间和采样频率的计算"><a href="#1-3-采样时间和采样频率的计算" class="headerlink" title="1.3 采样时间和采样频率的计算"></a>1.3 采样时间和采样频率的计算</h5><p><strong>ADC采样两点间隔的时间一定要大于ADC的采样时间！</strong> 采样时间怎么算，下面就细说一下。</p><p>STM32F103一般将时钟配置主频为72M、APB2为72M。ADC挂在APB2时钟总线上，且ADC的时钟不能超过14M。所以一般将ADC的分频设置为6，ADC的时钟主频就为72&#x2F;6&#x3D;12MHz。那么一个周期就是：1&#x2F;12MHz&#x3D;0.0833us。</p><p>以下截图为STM32F1参考手册（手册编号RM0008，可在ST官网直接搜索下载）：</p><p><img src="https://img-blog.csdnimg.cn/84ca12cd9d40459eb3e03c54889e9df3.png"></p><p>上图的意思是：ADC对输入电压采样若干个ADC_CLK周期，这些周期可通过ADC_SMPR1和ADC_SMPR2寄存器中的SMP[2:0]位进行修改。每个通道都可以用不同的采样时间进行采样。</p><p><strong>ADC转换时间 &#x3D; 采样时间 + 12.5个周期</strong></p><p>示例：</p><pre><code class="当ADC时钟主频为14MHz并且采样时间为1.5个周期时：采样时间">STM32F1系列的时钟主频一般设置为了12M，采样时间的设置所对应采样频率如下图所示：![](https://img-blog.csdnimg.cn/de1135452e21490a94b671995f48824f.png)知道了最短时间后，当ADC时钟主频为12M并且采样时间为1.5个周期时，ADC采样两点的时间必须大于1.17us。而STM32F031系列的ADC时钟主频为14MHz，采样时间的设置所对应采样频率如下图所示：![](https://img-blog.csdnimg.cn/4616052a159b4c6da44230ee81f9a4a0.png)当ADC时钟主频为14M并且采样时间为1.5个周期时，ADC采样两点的时间必须大于1us。#### &lt;a name=&quot;2_56&quot;&gt;;&lt;/a&gt;  2、轮训方式的多通道采集##### 2.1 方式一：间断模式+扫描模式我开启了通道0、1、2以及内部温度读取通道一共四个通道：![](https://img-blog.csdnimg.cn/20200820144708671.png#pic_center)![](https://img-blog.csdnimg.cn/20200820144717271.png#pic_center)如果想使用轮训方式并且不使用DMA的多通道采集，那么就要配置为 **【单次模式+间断模式】**，并且将Number Of Discontinuous Conversions为1，也就是每个通道分成了一个组，配置如下图：![](https://img-blog.csdnimg.cn/20200820145205371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)由于我这里设置间断数为1，也就是将4个通道分成了4组，那么我每次采集的时候都需要手动去触发ADC采集，也就是调用一次HAL_ADC_Start函数，完整代码如下：![](https://img-blog.csdnimg.cn/2020082014582133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)我将通道0分别接到3.3V和GND上，4通道采集运行效果如下：![](https://img-blog.csdnimg.cn/20200820150008132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)##### &lt;a name=&quot;22__72&quot;&gt;;&lt;/a&gt;  2.2 方式二：完全轮训完全使用轮训的方式不能使用 **扫描模式**（理论上来说多通道需要使用扫描模式，而不是完全轮训），但是使用STM32CUBEMX配置多通道扫描模式不无法被关闭的，所以我们先用STM32CUBEMX配置成一个通道：![](https://img-blog.csdnimg.cn/0b4c62f299d54bcf89ba61ea0aee0eca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeS16aGVuZw==,size_20,color_FFFFFF,t_70,g_se,x_16)然后读取ADC采集数值的函数是这样：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_Read</span><span class="params">(<span class="type">uint32_t</span> Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">ADC_ChannelConfTypeDef sConfig = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">sConfig.Channel = Channel;</span><br><span class="line">sConfig.Rank = ADC_REGULAR_RANK_1;</span><br><span class="line">sConfig.SamplingTime = ADC_SAMPLETIME_55CYCLES_5;</span><br><span class="line"><span class="keyword">if</span> (HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, HAL_MAX_DELAY);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint16_t</span>)HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>#### 3、DMA实现多通道采集通过DMA实现多通道数据采集， **要将连续模式和间断模式关闭！**如果连续模式开启，那么通过DMA传输到的数组中，每个通道所采集到的值对应数组中的一个位置就是不固定的。例如你开启了IN0~IN3这四个通道，并通过DMA将这四个通道的数据放到ADC_Value这个大小为4的u16类型数组，你在第一次采集的时候IN0通道的数值通过DMA被放在ADC_Value[0]，第二次采集的时候IN0采集到的数值就可能被放到了ADC_Value[1]，这样的话就极不方便我们对每个通道的数据进行分析和提取。配置如下，将连续转换模式和间断转换模式关闭，并开启ADC的DMA通道，将DMA的模式配置为周期模式：![](https://img-blog.csdnimg.cn/20200820152200735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center)![](https://img-blog.csdnimg.cn/ddd590ed84b44942863728c7b84ff639.png)代码如下：![](https://img-blog.csdnimg.cn/c457e847f73847ceb3a35f112f66667e.png)4个通道采集运行效果如下：![](https://img-blog.csdnimg.cn/20200820152427227.png#pic_center)#### &lt;a name=&quot;4timdma_136&quot;&gt;;&lt;/a&gt;  4、TIM+DMA实现多通道采集在不使用DMA的情况下，定时器控制ADC进行数据采集只能是单通道！如果开启了多通道，读取到的ADC采集值只会是最后一个通道的值！所以，要想使用定时器控制ADC采集 **多通道**，必须使用DMA！CubeMX配置如下，使能ADC的DMA：![](https://img-blog.csdnimg.cn/42aa3e7658df4d89ac32b7f2a1ebc643.png)ADC的触发方式设置为定时器3的触发事件：![](https://img-blog.csdnimg.cn/c4ff90b3330b44fda0a609316e2370db.png)采样时间设置为了55.5个周期，对应采样频率为176.47KHz，所以定时器3的频率设置要低于176.47KHz。设置定时器3分频系数为72，重载值为10，得到 `72MHz / 72&amp;#x5206;&amp;#x9891; / 10 = 100KHz`的定时器3：![](https://img-blog.csdnimg.cn/a50e71979339457e90f451449ec69d86.png)代码如下：![](https://img-blog.csdnimg.cn/c418cbe4d5b340a2ae94438927728da5.png)运行结果如下：![](https://img-blog.csdnimg.cn/534899ff62e24bcb9909ffaff4b29065.png)当然也可以选择进行一组数据，例如将32个点为一组数据进行采集，设置如下：![](https://img-blog.csdnimg.cn/a08aa8f0ae7c4cd8bfd70d40a980b3e1.png)运行结果如下：![](https://img-blog.csdnimg.cn/eb3feca6e37140eeb65f794634e86da3.png)#### 5、补充：内部温度传感器ADC通道![](https://img-blog.csdnimg.cn/87fe51b0eb7b447798ade02be31b4329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70)上面图片是截取在STM32F103RC的datasheet中的，中文意思就是：温度传感器必须产生随温度线性变化的电压。转换范围在2v &lt; VDDA &lt; 3.6 V之间。温度传感器内部连接ADC1_IN16输入通道，用于将传感器输出电压转换为数字值。内部温度计算公式：【Temperature = &#123;(V25 - VSENSE) / Avg_Slope&#125; + 25】字段说明：* **V25：** 最小1.34V，最大1.52V，典型值1.43V* **Avg_Slope：** 最小4.0，最大4.6，典型值4.3mv/℃* **VSENSE：** ADC采集到的电压![](https://img-blog.csdnimg.cn/da0745b68e874c41b42573887a74e20e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70)ADC值转电压值计算公式：【电压 = ADC采集到的值 * 3.3 / 4096】看上图我采集到的值为1703，先转换为电压值：1703*3.3/4096≈1.37**（1.43 - 1.37）/ 0.0043 + 25 ≈ 38.95℃**ends...</code></pre>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【HAL库】STM32+ESP8266+Onenet+MQTT，极简工程，hal库移植。</title>
      <link href="/2024/03/stm32-stm32-%E3%80%90HAL%E5%BA%93%E3%80%91STM32-ESP8266-Onenet-MQTT%EF%BC%8C%E6%9E%81%E7%AE%80%E5%B7%A5%E7%A8%8B%EF%BC%8Chal%E5%BA%93%E7%A7%BB%E6%A4%8D%E3%80%82/"/>
      <url>/2024/03/stm32-stm32-%E3%80%90HAL%E5%BA%93%E3%80%91STM32-ESP8266-Onenet-MQTT%EF%BC%8C%E6%9E%81%E7%AE%80%E5%B7%A5%E7%A8%8B%EF%BC%8Chal%E5%BA%93%E7%A7%BB%E6%A4%8D%E3%80%82/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="ESP8266-Onenet-MQTT"><a href="#ESP8266-Onenet-MQTT" class="headerlink" title="ESP8266+Onenet+MQTT"></a>ESP8266+Onenet+MQTT</h4><ul><li><ul><li><a href="#1-chled-12">1 导入.c.h文件（不再赘述，详细见LED部分）</a></li><li><a href="#2-cubemx-21">2 Cubemx配置</a></li><li><a href="#3--ch--27">3 修改 .c.h 文件</a></li><li><a href="#4--65">4 测试</a></li></ul></li></ul><p>ESP8266通过MQTT协议连接Onenet。从标准库移到了HAL库，过程有点麻烦，整了一天。做完后整理了一下，这个极简的工程，方便以后开发，也希望能帮助到大家，节约时间。</p><p>代码工程：<br><a href="https://github.com/wyfroom/ESP8266-Onenet-MQTT">https://github.com/wyfroom/ESP8266-Onenet-MQTT</a></p><p>该份代码硬件配置：<br>板子：STM32F103C8T6最小系统板。<br>外设：串口1用作调试，串口3用作esp8266。<br>esp8266：淘宝，esp-01s</p><h3 id="1-导入-c-h文件（不再赘述，详细见LED部分）"><a href="#1-导入-c-h文件（不再赘述，详细见LED部分）" class="headerlink" title="1 导入.c.h文件（不再赘述，详细见LED部分）"></a>1 导入.c.h文件（不再赘述，详细见LED部分）</h3><p>在keil工程中导入之前写好的.c.h文件。这个是我从标准库移倒hal库的，直接从我工程里复制就行，很纯净，没有加多余的东西。下面介绍如何根据个人实际使用情况更改一些参数。</p><blockquote><p>cubemx详细使用教程及所有模块整合见这篇：<br><a href="http://t.csdn.cn/Awtl9">【HAL库】HAL库STM32cubemx快速使用</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/913840e121e5a09eff4133733245efe9.png"></p><h3 id="2-Cubemx配置"><a href="#2-Cubemx配置" class="headerlink" title=";  2 Cubemx配置"></a><a name="2_cubemx_21">;</a>  2 Cubemx配置</h3><p>串口1用于调试，串口3用于ESP8266通信，打开中断。</p><p>基础的我就不配置了，可以看前面的详细讲解。</p><h3 id="3-修改-c-h-文件"><a href="#3-修改-c-h-文件" class="headerlink" title="3 修改 .c.h 文件"></a>3 修改 .c.h 文件</h3><p>移植时要修改的地方：</p><p>1 改所用串口</p><p>发送部分：在esp8266.c里，将huart3全部替换为要修改的串口号，比如串口2。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/87b34edd334476992b18233290799fe3.png"></p><p>接收部分：用串口中断接收esp8266发来的消息。随便在哪个文件夹填加串口回调函数，我个人是之前专门建了个uart.c文件放串口相关的所有代码。</p><p>加入下面的代码（串口号根据个人情况修改）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart3)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(esp8266_cnt &gt;= <span class="keyword">sizeof</span>(esp8266_buf))</span><br><span class="line">&#123;</span><br><span class="line">esp8266_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">esp8266_buf[esp8266_cnt++] = Uart3_RxData;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart3,(<span class="type">uint8_t</span> *)&amp;Uart3_RxData, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 改wifi名字和密码</p><p><img src="https://img-blog.csdnimg.cn/img_convert/601b58b84f41ec638f86d9e63eeb4c41.png"></p><p>3 改产品ID、设备ID、鉴权信息。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/03f4e721469e45d2729425eca9a8d38a.png"></p><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h3><p><strong>添加头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;onenet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp8266.h&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>添加初始化</strong></p><p>别忘了开串口中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart3,(<span class="type">uint8_t</span> *)&amp;Uart3_RxData, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">2000</span>);</span><br><span class="line">ESP8266_Init();</span><br><span class="line">HAL_Delay(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">while</span>(OneNet_DevLink())</span><br><span class="line">HAL_Delay(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>连接成功的话，onenet会显示设备在线。串口也会打印成功。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e08522ae2a3d08bd5f99c7fdeda41379.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e1ab1158b6bfc9430b57a31e27cfab3.png"></p><p><strong>发送数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OneNet_SendData();//&amp;#x53D1;&amp;#x9001;&amp;#x6570;&amp;#x636E;</span><br><span class="line">ESP8266_Clear();//&amp;#x6E05;&amp;#x7A7A;&amp;#x6570;&amp;#x636E;&amp;#x7F13;&amp;#x5B58;&amp;#x533A;</span><br><span class="line">HAL_Delay(3000);//3s&amp;#x53D1;&amp;#x9001;&amp;#x4E00;&amp;#x6B21;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/05e4629537d4b953e7e7f4bc651a0267.png"></p><p>要发什么数据，在这里改：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2e0513318f4aa1042b26a9f18b546071.png"></p><p><strong>接收数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataPtr = ESP8266_GetIPD(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dataPtr != <span class="literal">NULL</span>)</span><br><span class="line">OneNet_RevPro(dataPtr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32F103C8T6（HAL库）的HC-SR501红外人体传感及HC-SR04超声波测距</title>
      <link href="/2024/03/stm32-stm32-%E5%9F%BA%E4%BA%8ESTM32F103C8T6%EF%BC%88HAL%E5%BA%93%EF%BC%89%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E4%BA%BA%E4%BD%93%E4%BC%A0%E6%84%9F%E5%8F%8AHC-SR04%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D/"/>
      <url>/2024/03/stm32-stm32-%E5%9F%BA%E4%BA%8ESTM32F103C8T6%EF%BC%88HAL%E5%BA%93%EF%BC%89%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E4%BA%BA%E4%BD%93%E4%BC%A0%E6%84%9F%E5%8F%8AHC-SR04%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h2><p><a href="https://blog.csdn.net/h568630659/article/details/121404155">一、基于STM32F103C8T6最小系统板和STM32CubeMX实现LED灯循环闪烁</a><br><a href="https://blog.csdn.net/h568630659/article/details/121427218">二、基于STM32F103C8T6和STM32CubeMX实现UART串口通信数据收发</a><br><a href="https://blog.csdn.net/h568630659/article/details/121465665">三、实战小例程 基于STM32F103C8T6最小系统板和STM32CubeMX驱动WS2812B光立方</a><br><a href="https://blog.csdn.net/h568630659/article/details/121764481">四、基于STM32F103C8T6最小系统板HAL库CubeMX驱动HC-SR501红外人体传感模块</a><br><a href="https://blog.csdn.net/h568630659/article/details/122058600">五、基于STM32F103C8T6（HAL库）的HC-SR501红外人体传感及HC-SR04超声波测距</a></p><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="#-0">系列文章目录</a></li><li><a href="#-16">前言</a></li><li><a href="#-22">一、模块简介</a></li><li><a href="#cubemx-45">二、配置CubeMX</a></li><li><a href="#-67">三、硬件连线部分</a></li><li><a href="#-94">四、逻辑代码部分</a></li><li><ul><li><a href="#hc-sr04c-97">HC_SR04.c</a></li><li><a href="#hc-sr04h-181">HC_SR04.h</a></li><li><a href="#mainc-193">main.c</a></li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在上一篇文章中驱动了HC-SR501红外人体传感模块，但在测试过程中发现，这个模块的热释电探头过于灵敏了，甚至有的时候往上哈气，会因为检测到类似于人体的温度而误判为感应到人体，所以为了减少误判概率，我打算再添加一个测距模块，在红外感应到人体时，再次判断人体与传感器的距离，在满足预设的距离范围时，才确定有人体接近，进行后续操作。</p><h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p><strong>HC-SR501红外人体感应模块资料介绍：</strong><br><a href="https://www.arduino.cn/thread-2851-1-1.html">探究人体红外传感器HC-SR501</a></p><p><strong>HC-SR04超声波测距模块资料介绍：</strong></p><p><img src="https://img-blog.csdnimg.cn/92ad9fec95424c4daee75611f36e9b7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>引脚名称引脚作用VCC<br><strong>3-5.5V</strong></p><p>供电（实测发现可以3.3V供电，但没有5V供电测得准）GND接地Trig外部触发信号输入，输入一个高于10μs的高电平即可触发模块测距Echo回响信号输出，测距结束时此管脚输出一个高电平，电平宽度反映超声波往返时间之和</p><p><strong>工作原理：</strong></p><p><img src="https://img-blog.csdnimg.cn/2440fa92274644939b0de5e59ef1852b.png"><br><img src="https://img-blog.csdnimg.cn/0fa754c51ca94c2188fbdfa59f3604ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>简而言之：<br> 给Trig一个10μS以上的高电平,模块开始工作，模块内自动发送八个40khz方波，并自主检测是否有电波返回。此时需要检测Echo处的电平，当为高电平的时候记一个时间；当Echo出为低电平的时候再记一个时间，这两个时间的差就是高电平持续的时间，最后用测距公式进行计算</strong>。</p><h2 id="二、配置CubeMX"><a href="#二、配置CubeMX" class="headerlink" title="; 二、配置CubeMX"></a><a name="cubemx_45">;</a> 二、配置CubeMX</h2><p><strong>1、新建工程;<br>2、配置时钟源，在RCC里面的HSE配置的是晶振时钟;<br>3、配置程序烧录引脚SYS为SWD模式;<br>4、配置GPIO输出口，配置一个LED灯（我的板子是PC13），起到检测到人体时的指示作用;<br>5、配置GPIO输入口，用来读取HC-SR501模块的输出电平，我选的是PA1口;</strong><br><strong>6、配置GPIO输入口，用来检测HC-SR04超声波测距模块的回响信号输出，我选择PB5口，命名为HC_SR04_Echo_Pin;<br>7、配置GPIO输出口，用来触发HC-SR04超声波测距模块，我选择PB4口，命名为HC_SR04_Trig_Pin;<br>8、使能定时器，用来实现微秒延时，和测量HC-SR04模块高电平时间，我选择TIM2，并使能TIM2中断;</strong><br><img src="https://img-blog.csdnimg.cn/f5c269ef459b4f58a202b49397c11036.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_17,color_FFFFFF,t_70,g_se,x_16"><br>TIM2挂载在APB1，时钟来源频率为36MHz，故取预分频系数 <code>PSC=36-1</code>，计数周期 <code>Counter</code>设为 <code>60000-1</code>。即此时定时器频率为36M&#x2F;36&#x3D;1MHz，每60ms进一次中断，60000μs对应实际测距范围大概为10m，远远超过我的需求。</p><p><img src="https://img-blog.csdnimg.cn/96058ff9807d44dea3a1b773f47f9330.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/14c2aefe04d5410b89a5300226b73aa6.png"></p><p><strong>9、配置串口收发引脚;<br>10、配置时钟树，我还是开到最高的72MHz;<br>11、进行项目设置，最后生成代码，CubeMX部分就大功告成了</strong></p><p><img src="https://img-blog.csdnimg.cn/1b053bd5569c41b7b11caeba75037c7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="三、硬件连线部分"><a href="#三、硬件连线部分" class="headerlink" title="三、硬件连线部分"></a>三、硬件连线部分</h2><p>CH340 ↔ STM32F103C8T6最小系统板：<br>TX ↔ RX<br>RX ↔ TX</p><p>DAP-LINK ↔ STM32F103C8T6最小系统板<br>3.3V ↔ VCC<br>GND ↔ GND<br>SWIO ↔ SWIO<br>SWCLK ↔ SWCLK</p><p>HC-SR501模块 ↔ STM32F103C8T6最小系统板<br>OUT ↔ PA1<br>GND ↔ GND</p><p>HC-SR501模块 ↔ DAP-LINK <strong>（这里注意模块供电范围为4.5V-20V，用3.3V无法驱动）</strong><br>VCC ↔ 5V</p><p>HC-SR04模块 ↔ CH340<br>VCC ↔ 5V</p><p>HC-SR04模块 ↔ STM32F103C8T6最小系统板<br>Trig ↔ PB4<br>Echo ↔ PB5<br>GND ↔ GND</p><h2 id="四、逻辑代码部分"><a href="#四、逻辑代码部分" class="headerlink" title="四、逻辑代码部分"></a>四、逻辑代码部分</h2><p>代码框架是基于上一篇HC-SR501红外人体感应模块修改而成的，想要完整代码的话可以和上篇文章一起看。</p><h3 id="HC-SR04-c"><a href="#HC-SR04-c" class="headerlink" title="HC_SR04.c"></a>HC_SR04.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HC_SR04.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_it.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> distance_result;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint16_t</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> a1=TIM2-&gt;CNT;</span><br><span class="line"><span class="keyword">while</span>(TIM2-&gt;CNT-a1&lt;time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HC_SR04_startrange</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(HC_SR04_Trig_GPIO_Port,HC_SR04_Trig_Pin,GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">Delay_us(<span class="number">10</span>);</span><br><span class="line">HAL_GPIO_WritePin(HC_SR04_Trig_GPIO_Port,HC_SR04_Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">HC_SR04_gettime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> a;</span><br><span class="line">a=TIM2-&gt;CNT;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">HC_SR04_getdistance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> time_node1;</span><br><span class="line"> <span class="type">uint16_t</span> time_node2;</span><br><span class="line">  <span class="type">uint16_t</span> measure;</span><br><span class="line"></span><br><span class="line">  HC_SR04_startrange();</span><br><span class="line"></span><br><span class="line">TIM2-&gt;CNT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(HAL_GPIO_ReadPin(HC_SR04_Echo_GPIO_Port,HC_SR04_Echo_Pin)==RESET);</span><br><span class="line">time_node1=HC_SR04_gettime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(HAL_GPIO_ReadPin(HC_SR04_Echo_GPIO_Port,HC_SR04_Echo_Pin)==SET);</span><br><span class="line">time_node2=HC_SR04_gettime();</span><br><span class="line"></span><br><span class="line">measure=time_node2-time_node1;</span><br><span class="line"></span><br><span class="line">distance_result = measure * <span class="number">17.0</span>/<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> distance_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HC-SR04-h"><a href="#HC-SR04-h" class="headerlink" title="HC_SR04.h"></a>HC_SR04.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HC_SR04_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HC_SR04_H_</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint16_t</span> time)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HC_SR04_startrange</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">HC_SR04_getdistance</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">HC_SR04_gettime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_1) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">HC_SR04_distance=HC_SR04_getdistance();</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_RESET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;有人,目前距离为：%.2f cm\r\n&quot;</span>,HC_SR04_distance);</span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_SET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没人\r\n&quot;</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现象：</strong></p><p>感应到人体，板载LED绿灯亮，同时串口打印测距结果。<br><img src="https://img-blog.csdnimg.cn/fdf542a1e5f54fb497c66664fcf7880e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>注意：</strong><br><strong>重定义printf后，必须在target里面勾选上MicroLIB，调用一下这个微型库，不然一直卡在里面。</strong></p><p><img src="https://img-blog.csdnimg.cn/bba9468e9009467abfafc8111b94ac0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6YGX5b-Y5Li2,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>参考博客：<br><a href="https://blog.csdn.net/sasasatori/article/details/81199455">stm32f1驱动HC-SR04超声波测距模块</a></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32的HC-SR501红外感应模块驱动与应用</title>
      <link href="/2024/03/stm32-stm32-%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E6%84%9F%E5%BA%94%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/stm32-stm32-%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84HC-SR501%E7%BA%A2%E5%A4%96%E6%84%9F%E5%BA%94%E6%A8%A1%E5%9D%97%E9%A9%B1%E5%8A%A8%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>一、 简介<br>HC-SR501红外感应模块是一种常用的人体红外感应模块，常用于安防监控、智能家居等领域。本文将介绍如何在STM32单片机上驱动和应用HC-SR501红外感应模块，实现基本的人体检测功能。</strong></p><p><strong>二、 模块原理</strong><br>HC-SR501红外感应模块基于红外热释电传感器（PIR sensor）原理，当检测到人体或其他热源时，输出高电平信号。该模块有延迟时间和重复触发时间两个可调节的螺旋调节器，可根据需求调节模块的灵敏度和触发后的输出信号时长。</p><p><strong>三、 连接与驱动<br>1. 连接</strong><br>连接HC-SR501模块至STM32单片机，将模块的OUT引脚连接至STM32的GPIO引脚，以接收感应模块的输出信号。同时，通过电源模块连接模块至单片机的供电引脚。</p><p><img src="https://img-blog.csdnimg.cn/direct/12a9a768aaa04891b1c9bfc0d758aae5.png"></p><p><strong>2. 驱动</strong><br>在STM32的开发环境中，编写对HC-SR501模块的驱动程序。以下是一个简单的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">```c</span><br><span class="line">#include &quot;stm32f4xx.h&quot;</span><br><span class="line"></span><br><span class="line">#define HC_SR501_PIN GPIO_PIN_0</span><br><span class="line">#define HC_SR501_PORT GPIOA</span><br><span class="line"></span><br><span class="line">void HC_SR501_Init(void) &#123;</span><br><span class="line">&amp;#xA0; GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">&amp;#xA0; __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">&amp;#xA0; GPIO_InitStruct.Pin = HC_SR501_PIN;</span><br><span class="line">&amp;#xA0; GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">&amp;#xA0; GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">&amp;#xA0; HAL_GPIO_Init(HC_SR501_PORT, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int HC_SR501_Read(void) &#123;</span><br><span class="line">&amp;#xA0; return HAL_GPIO_ReadPin(HC_SR501_PORT, HC_SR501_PIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HC_SR501_Application(void) &#123;</span><br><span class="line">&amp;#xA0; while (1) &#123;</span><br><span class="line">&amp;#xA0; &amp;#xA0; if (HC_SR501_Read()) &#123;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &amp;#xA0; // &amp;#x68C0;&amp;#x6D4B;&amp;#x5230;&amp;#x4EBA;&amp;#x4F53;&amp;#xFF0C;&amp;#x6267;&amp;#x884C;&amp;#x76F8;&amp;#x5E94;&amp;#x64CD;&amp;#x4F5C;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &#125; else &#123;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &amp;#xA0; // &amp;#x672A;&amp;#x68C0;&amp;#x6D4B;&amp;#x5230;&amp;#x4EBA;&amp;#x4F53;&amp;#xFF0C;&amp;#x6267;&amp;#x884C;&amp;#x76F8;&amp;#x5E94;&amp;#x64CD;&amp;#x4F5C;</span><br><span class="line">&amp;#xA0; &amp;#xA0; &#125;</span><br><span class="line">&amp;#xA0; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">&amp;#xA0; HC_SR501_Init();</span><br><span class="line">&amp;#xA0; HC_SR501_Application();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>以上代码中，首先初始化了GPIO引脚，然后在应用函数中不断读取感应模块的输出信号，根据输出信号执行不同的操作。**四、 应用示例&lt;br&gt;1. 基于HC-SR501红外感应模块的人体检测报警系统**通过连接HC-SR501模块至STM32单片机，并配合蜂鸣器或其他报警装置，可以实现一个简单的人体检测报警系统。当检测到人体时，系统触发报警装置，实现安防监控。**2. 基于HC-SR501红外感应模块的智能照明控制系统**将HC-SR501模块连接至STM32单片机，再连接至LED灯或其他照明设备，可以实现智能照明控制系统。当检测到人体时，系统自动开启照明设备，当未检测到人体时则关闭照明设备，实现智能节能控制。**以上是基于STM32的HC-SR501红外感应模块的驱动与应用的基本介绍，通过上述方法，可以实现针对不同场景的人体感应控制系统。**&gt; ✅作者简介：热爱科研的嵌入式开发者，修心和技术同步精进代码获取、问题探讨及文章转载可私信。☁ 愿你的生命中有够多的云翳,来造就一个美丽的黄昏。🍎获取更多嵌入式资料可点击链接进群领取，谢谢支持！👇[点击领取更多详细资料](https://fss.mpay8.cn/article/dmrjinh2C6fjejm &quot;点击领取更多详细资料&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你，通过HAL库实现STM32的超声波测距--以SR-04为例</title>
      <link href="/2024/03/stm32-stm32-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%EF%BC%8C%E9%80%9A%E8%BF%87HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D-%E4%BB%A5SR-04%E4%B8%BA%E4%BE%8B/"/>
      <url>/2024/03/stm32-stm32-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%EF%BC%8C%E9%80%9A%E8%BF%87HAL%E5%BA%93%E5%AE%9E%E7%8E%B0STM32%E7%9A%84%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D-%E4%BB%A5SR-04%E4%B8%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>目录</strong></p><p><a href="#0%E3%80%81sr-04%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" title="0、SR-04基本原理">0、SR-04基本原理</a></p><p><a href="#1%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" title="1、准备工作">1、准备工作</a></p><p><a href="#2%E3%80%81%E8%BF%9E%E7%BA%BF" title="2、连线">2、连线</a></p><p><a href="#%C2%A03%E3%80%81stm32cubemx%E8%AE%BE%E7%BD%AE" title="3、STM32CUBEMX设置">3、STM32CUBEMX设置</a></p><p><a href="#31%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B" title="3.1新建工程">3.1新建工程</a></p><p><a href="#32%E8%8A%AF%E7%89%87%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE" title="3.2芯片通用设置">3.2芯片通用设置</a></p><p><a href="#33%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8D%95%E8%8E%B7%E8%AE%BE%E7%BD%AE" title="3.3定时器捕获设置">3.3定时器捕获设置</a></p><p><a href="#%E2%80%8B34%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE" title="​3.4其他设置">​3.4其他设置</a></p><p><a href="#35%E7%94%9F%E6%88%90%E5%B7%A5%E7%A8%8B" title="3.5生成工程">3.5生成工程</a></p><p><a href="#%C2%A04%E3%80%81%E7%A8%8B%E5%BA%8F%E5%AE%8C%E5%96%84" title="4、程序完善">4、程序完善</a></p><p><a href="#41%E5%AE%8C%E5%96%84%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0" title="4.1完善打印输出函数">4.1完善打印输出函数</a></p><p><a href="#%C2%A042%E5%AE%8C%E5%96%84timc" title="4.2完善tim.c">4.2完善tim.c</a></p><p><a href="#43%E5%AE%8C%E5%96%84gpioc%C2%A0" title="4.3完善gpio.c">4.3完善gpio.c</a></p><p><a href="#44%E5%AE%8C%E5%96%84main%E5%87%BD%E6%95%B0%C2%A0" title="4.4完善main函数">4.4完善main函数</a></p><p><a href="#%C2%A05%E3%80%81%E6%80%BB%E7%BB%93" title="5、总结">5、总结</a></p><h2 id="0、SR-04基本原理"><a href="#0、SR-04基本原理" class="headerlink" title="0、SR-04基本原理"></a>0、SR-04基本原理</h2><p>声波遇到障碍物会反射，而声波的速度已知，所以只需要知道发射到接收的时间差，就能轻松计算出测量距离，再结合发射器和接收器的距离，就能算出障碍物的实际距离。</p><p><img src="https://img-blog.csdnimg.cn/2020032802343260.png"></p><p><img src="https://img-blog.csdnimg.cn/20200328023701292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjU4OTgx,size_16,color_FFFFFF,t_70"></p><p>以HC-SR04硬件为例，端口为VCC、Trig、Echo、GND。</p><p>VCC–接STM32板子+5V；<br>GND–接STM32板子GND；<br>Trig–为触发控制信号输入，触发测距，给至少10us的高电平信号，模块自动发射8个40KHz的方波，自动检测是否有信号返回；<br>Echo–回响信号输出，有信号返回，通过IO口ECHO输出一个高电平，高电平持续时间就是超声波从发射到返回的时间。<br>那用STM32怎么给端口信号呢？又是怎么获取信号呢？<br>Trig端口为超声波模块的输入信号，也就是通过STM23一个端口推挽输出一个至少10us的高电平信号即可，利用delay_ms(20)实现；<br>Echo端口为超声波模块的输出信号，也就是利用STM32端口捕获高电平时间，那么这个端口肯定是可以用做定时器的端口。<br>通过以上分析，这里采用以下STM32端口</p><p><img src="https://img-blog.csdnimg.cn/c10df4b58e2d49cb8b3b363c0e22019c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/3b14aae863264dd4afbc8445ad66a7d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><p>开发板：STM32F1精英版</p><p>软件：STM32CubeMx软件</p><p>IDE： MDK-Keil软件</p><p>传感器：HC-SR04</p><h2 id="2、连线"><a href="#2、连线" class="headerlink" title="2、连线"></a>2、连线</h2><p>选择TIM5的CH1即PA0作为输入捕获引脚（Echo），选择PA5作为触发脚Trig。具体连接线如下：</p><p>红线连接精英版的5V与SR04的VCC脚</p><p>白线连接精英板的GND与SR04的GND脚</p><p>橙色线连接精英板的PA5与Trig脚</p><p>黑色线连接精英板的PA0与Echo脚</p><p><img src="https://img-blog.csdnimg.cn/2e1fa4f5325345729a0a44473dfd2526.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="3、STM32CUBEMX设置"><a href="#3、STM32CUBEMX设置" class="headerlink" title="3、STM32CUBEMX设置"></a>3、STM32CUBEMX设置</h2><h3 id="3-1新建工程"><a href="#3-1新建工程" class="headerlink" title="3.1新建工程"></a>3.1新建工程</h3><p>1）新建工程</p><p><img src="https://img-blog.csdnimg.cn/7115721af4f7487fae5b0ff66f45667d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2）选择芯片</p><p><img src="https://img-blog.csdnimg.cn/9cecc36eced643b185e29591bbe60cf0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="3-2芯片通用设置"><a href="#3-2芯片通用设置" class="headerlink" title="3.2芯片通用设置"></a>3.2芯片通用设置</h3><p>1）时钟芯片设置</p><p><img src="https://img-blog.csdnimg.cn/e262e3fba4f8447ab4c8c567225173a5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2）时钟设置</p><p><img src="https://img-blog.csdnimg.cn/abb1957bcbce4521af21421c25464c77.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>3）系统调试设置</p><p><img src="https://img-blog.csdnimg.cn/ed518ef9e29c4359bd52a2ca81e8823e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="3-3定时器捕获设置"><a href="#3-3定时器捕获设置" class="headerlink" title="3.3定时器捕获设置"></a>3.3定时器捕获设置</h3><p>由于前文连线中，我们将TIMER5CH1作为输入捕获引脚，所以对TIMER5进行设置：</p><p>Channel 1选择：Input Capture direct mode</p><p>与分频系数填写：72-1（则每次计数为1us）</p><p>Polarity Selection选择：Rising Edge（上升沿）</p><p>其他保持不变。</p><p><img src="https://img-blog.csdnimg.cn/c4191f72c63049fdbfb8f8b96f672f66.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>NVIC settings选择TIM5 global interrupt</p><h3 id="3-4其他设置"><a href="#3-4其他设置" class="headerlink" title="  3.4其他设置"></a><img src="https://img-blog.csdnimg.cn/d1d24efee88d46178d8001eb1f8eaf61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16">  3.4其他设置</h3><p>1）USART1设置</p><p>为了方便调试，将测量所得数据通过串口传递到电脑上进行显示，此处使用串口1通过printf将输出发送至电脑。</p><p><img src="https://img-blog.csdnimg.cn/82ca9b0ff3e94cfa8286e7d5573fac1a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>2）GPIO配置</p><p>此处选择PA5作为Trig脚，具体配置如下：</p><p><img src="https://img-blog.csdnimg.cn/47ed779ee47641cfb88d1b94d4804ce0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="3-5生成工程"><a href="#3-5生成工程" class="headerlink" title="3.5生成工程"></a>3.5生成工程</h3><p><img src="https://img-blog.csdnimg.cn/a6e90e647fe24e5087daa4b099e7da40.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/46dfa628b984462d95dc70b4a37152c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="4、程序完善"><a href="#4、程序完善" class="headerlink" title="4、程序完善"></a>4、程序完善</h2><h3 id="4-1完善打印输出函数"><a href="#4-1完善打印输出函数" class="headerlink" title="4.1完善打印输出函数"></a>4.1完善打印输出函数</h3><p>在main函数中加入下面语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* Private includes ----------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">/* Private user code ---------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">#ifdef __GNUC__</span><br><span class="line">#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span><br><span class="line">#else</span><br><span class="line">#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xFFFF);</span><br><span class="line">return ch;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>加入此语句之后可以在main函数中加入printf语句测试是否成功。</p><p>将精英板USB232口通过USB数据线与电脑连接，并在电脑上打开串口调试软件： <img src="https://img-blog.csdnimg.cn/a79a767a9dfa4baeb621c05235cbc92b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/d27a80b3c0fa4d30999384ca8c8a46d7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="4-2完善tim-c"><a href="#4-2完善tim-c" class="headerlink" title="4.2完善tim.c"></a>4.2完善tim.c</h3><p>在tim.c中加入以下程序：</p><p>定义变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line">//&amp;#x6355;&amp;#x83B7;&amp;#x72B6;&amp;#x6001;</span><br><span class="line">//[7]:0,&amp;#x6CA1;&amp;#x6709;&amp;#x6210;&amp;#x529F;&amp;#x7684;&amp;#x6355;&amp;#x83B7;;1,&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x6B21;.</span><br><span class="line"></span><br><span class="line">//[6]:0,&amp;#x8FD8;&amp;#x6CA1;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4F4E;&amp;#x7535;&amp;#x5E73;;1,&amp;#x5DF2;&amp;#x7ECF;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4F4E;&amp;#x7535;&amp;#x5E73;&amp;#x4E86;.</span><br><span class="line"></span><br><span class="line">//[5:0]:&amp;#x6355;&amp;#x83B7;&amp;#x4F4E;&amp;#x7535;&amp;#x5E73;&amp;#x540E;&amp;#x6EA2;&amp;#x51FA;&amp;#x7684;&amp;#x6B21;&amp;#x6570;</span><br><span class="line">uint8_t  TIM5CH2_CAPTURE_STA=0;//&amp;#x8F93;&amp;#x5165;&amp;#x6355;&amp;#x83B7;&amp;#x72B6;&amp;#x6001;</span><br><span class="line">uint16_t TIM5CH2_CAPTURE_VAL;//&amp;#x8F93;&amp;#x5165;&amp;#x6355;&amp;#x83B7;&amp;#x503C;(TIM2&amp;#x662F;16&amp;#x4F4D;)</span><br><span class="line">/* USER CODE END 0 */</span><br></pre></td></tr></table></figure><p>在底部加入溢出回调函数和输入捕获回调函数。其中参考了正点原子官方的的输入 捕获回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 1 */</span><br><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)//&amp;#x66F4;&amp;#x65B0;&amp;#x4E2D;&amp;#x65AD;&amp;#xFF08;&amp;#x6EA2;&amp;#x51FA;&amp;#xFF09;&amp;#x53D1;&amp;#x751F;&amp;#x65F6;&amp;#x6267;&amp;#x884C;</span><br><span class="line">&#123;</span><br><span class="line">if((TIM5CH2_CAPTURE_STA&amp;0X80) ==0)//&amp;#x8FD8;&amp;#x672A;&amp;#x6355;&amp;#x83B7;&amp;#x6210;&amp;#x529F;</span><br><span class="line">&#123;</span><br><span class="line">if(TIM5CH2_CAPTURE_STA&amp;0X40)//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x4E2A;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;</span><br><span class="line">&#123;</span><br><span class="line">if((TIM5CH2_CAPTURE_STA&amp;0X3F)==0X3F)//&amp;#x9AD8;&amp;#x7535;&amp;#x5E73;&amp;#x65F6;&amp;#x95F4;&amp;#x592A;&amp;#x957F;&amp;#x4E86;</span><br><span class="line">&#123;</span><br><span class="line">TIM5CH2_CAPTURE_STA |= 0X80;//&amp;#x6807;&amp;#x8BB0;&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x4E00;&amp;#x6B21;</span><br><span class="line">TIM5CH2_CAPTURE_VAL = 0XFFFF;//</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">TIM5CH2_CAPTURE_STA++;//&amp;#x5426;&amp;#x5219;&amp;#x6807;&amp;#x8BB0;&amp;#x6EA2;&amp;#x51FA;&amp;#x6570;&amp;#x52A0;&amp;#x4E00;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)//&amp;#x6355;&amp;#x83B7;&amp;#x4E2D;&amp;#x65AD;&amp;#x53D1;&amp;#x751F;&amp;#x65F6;&amp;#x6267;&amp;#x884C;</span><br><span class="line">&#123;</span><br><span class="line">if((TIM5CH2_CAPTURE_STA&amp;0x80)==0)//&amp;#x8FD8;&amp;#x672A;&amp;#x6355;&amp;#x83B7;&amp;#x6210;&amp;#x529F;</span><br><span class="line">&#123;</span><br><span class="line">if(TIM5CH2_CAPTURE_STA&amp;0x40)//&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x4E2A;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;</span><br><span class="line">&#123;</span><br><span class="line">TIM5CH2_CAPTURE_STA |= 0X80;//&amp;#x6807;&amp;#x8BB0;&amp;#x6210;&amp;#x529F;&amp;#xFF0C;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x6B21;&amp;#x9AD8;&amp;#x7535;&amp;#x5E73;&amp;#x5B8C;&amp;#x6210;</span><br><span class="line">TIM5CH2_CAPTURE_VAL  = HAL_TIM_ReadCapturedValue(&amp;htim5, TIM_CHANNEL_1);//&amp;#x83B7;&amp;#x53D6;&amp;#x5F53;&amp;#x524D;&amp;#x6355;&amp;#x83B7;&amp;#x503C;</span><br><span class="line">TIM_RESET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1);//&amp;#x6E05;&amp;#x9664;&amp;#x539F;&amp;#x6765;&amp;#x8BBE;&amp;#x7F6E;</span><br><span class="line">TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING);//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;&amp;#x540E;&amp;#xFF0C;&amp;#x5C06;&amp;#x6355;&amp;#x83B7;&amp;#x590D;&amp;#x4F4D;&amp;#x5230;&amp;#x6355;&amp;#x83B7;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E00;&amp;#x4E2A;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;</span><br><span class="line">&#123;</span><br><span class="line">TIM5CH2_CAPTURE_STA = 0;</span><br><span class="line">TIM5CH2_CAPTURE_VAL = 0;</span><br><span class="line">TIM5CH2_CAPTURE_STA |= 0x40;//&amp;#x7B2C;&amp;#x516D;&amp;#x4F4D;&amp;#x6807;&amp;#x8BB0;&amp;#x4E3A;&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;</span><br><span class="line">__HAL_TIM_DISABLE(&amp;htim5);//&amp;#x5173;&amp;#x95ED;&amp;#x5B9A;&amp;#x65F6;&amp;#x5668;</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim5, 0);//&amp;#x5B9A;&amp;#x65F6;&amp;#x5668;&amp;#x521D;&amp;#x59CB;&amp;#x503C;&amp;#x8BBE;&amp;#x7F6E;&amp;#x4E3A;0</span><br><span class="line">TIM_RESET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1);</span><br><span class="line">TIM_SET_CAPTUREPOLARITY(&amp;htim5, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING);//&amp;#x6355;&amp;#x83B7;&amp;#x5230;&amp;#x4E0A;&amp;#x5347;&amp;#x6CBF;&amp;#x4E4B;&amp;#x540E;&amp;#xFF0C;&amp;#x5C06;&amp;#x6355;&amp;#x83B7;&amp;#x8BBE;&amp;#x7F6E;&amp;#x4E3A;&amp;#x4E0B;&amp;#x964D;&amp;#x6CBF;</span><br><span class="line">__HAL_TIM_ENABLE(&amp;htim5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 1 */</span><br></pre></td></tr></table></figure><h3 id="4-3完善gpio-c"><a href="#4-3完善gpio-c" class="headerlink" title="4.3完善gpio.c"></a>4.3完善gpio.c</h3><p>模拟Trig脚，先置位，过40us后，复位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN 2 */</span><br><span class="line">void CHL_capture(void)</span><br><span class="line">&#123;</span><br><span class="line">uint32_t i;</span><br><span class="line"></span><br><span class="line">HAL_GPIO_WritePin(TRIG_GPIO_Port, TRIG_Pin, GPIO_PIN_SET);</span><br><span class="line">for(i=0;i&lt;72*40;i++) 2 __nop(); hal_gpio_writepin(trig_gpio_port, trig_pin, gpio_pin_reset); &#125; * user code end &lt;&gt;&lt;/72*40;i++)&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4完善main函数"><a href="#4-4完善main函数" class="headerlink" title="4.4完善main函数"></a>4.4完善main函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 1 */</span><br><span class="line">float len = 0;</span><br><span class="line">uint32_t time= 0;</span><br><span class="line">uint8_t count = 0;</span><br><span class="line">  /* USER CODE END 1 */</span><br><span class="line"></span><br><span class="line">  /* MCU Configuration--------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN Init */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END Init */</span><br><span class="line"></span><br><span class="line">  /* Configure the system clock */</span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN SysInit */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END SysInit */</span><br><span class="line"></span><br><span class="line">  /* Initialize all configured peripherals */</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_TIM5_Init();</span><br><span class="line">  MX_USART1_UART_Init();</span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">printf(&quot;Hello World!\r\n&quot;);</span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim5,TIM_CHANNEL_1);   //&amp;#x5F00;&amp;#x542F;TIM2&amp;#x7684;&amp;#x6355;&amp;#x83B7;&amp;#x901A;&amp;#x9053;2&amp;#xFF0C;&amp;#x5E76;&amp;#x4E14;&amp;#x5F00;&amp;#x542F;&amp;#x6355;&amp;#x83B7;&amp;#x4E2D;&amp;#x65AD;</span><br><span class="line">    __HAL_TIM_ENABLE_IT(&amp;htim5,TIM_IT_UPDATE);   //&amp;#x4F7F;&amp;#x80FD;&amp;#x66F4;&amp;#x65B0;&amp;#x4E2D;&amp;#x65AD;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  HAL_Delay(100);</span><br><span class="line">  CHL_capture();</span><br><span class="line">  if(TIM5CH2_CAPTURE_STA &amp; 0x80)//&amp;#x6210;&amp;#x529F;&amp;#x6355;&amp;#x83B7;&amp;#x4E00;&amp;#x4E2A;&amp;#x8109;&amp;#x5BBD;</span><br><span class="line">  &#123;</span><br><span class="line">time = TIM5CH2_CAPTURE_STA &amp; 0x3F;//&amp;#x83B7;&amp;#x53D6;&amp;#x6EA2;&amp;#x51FA;&amp;#x6B21;&amp;#x6570;</span><br><span class="line">time *= 65536;//&amp;#x83B7;&amp;#x5F97;&amp;#x6EA2;&amp;#x51FA;&amp;#x7684;&amp;#x65F6;&amp;#x95F4;&amp;#x503C;</span><br><span class="line">time += TIM5CH2_CAPTURE_VAL;//&amp;#x52A0;&amp;#x4E0A;&amp;#x6700;&amp;#x540E;&amp;#x4E00;&amp;#x6B21;&amp;#x53D6;&amp;#x5F97;&amp;#x7684;&amp;#x503C;</span><br><span class="line">len = time * 342.62*100/2000000;</span><br><span class="line"></span><br><span class="line">TIM5CH2_CAPTURE_STA = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;LENGTH: %f CM\r\n&quot;, len);</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 3 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>本文介绍了通过HAL库完成SR-04超声波传感器距离的测量。包括了，超声波传感器的原理、STM32CUBEMX的配置，以及程序的完善。最终的结果如下：</p><p><img src="https://img-blog.csdnimg.cn/bdd5e4a431694f4897745b2ebb55fbdd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rGk5a6q5a6H,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F407使用Helix库软解MP3并通过DAC输出，最精简的STM32+SD卡实现MP3播放器</title>
      <link href="/2024/03/stm32-STM32F407%E4%BD%BF%E7%94%A8Helix%E5%BA%93%E8%BD%AF%E8%A7%A3MP3%E5%B9%B6%E9%80%9A%E8%BF%87DAC%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%80%E7%B2%BE%E7%AE%80%E7%9A%84STM32-SD%E5%8D%A1%E5%AE%9E%E7%8E%B0MP3%E6%92%AD%E6%94%BE%E5%99%A8/"/>
      <url>/2024/03/stm32-STM32F407%E4%BD%BF%E7%94%A8Helix%E5%BA%93%E8%BD%AF%E8%A7%A3MP3%E5%B9%B6%E9%80%9A%E8%BF%87DAC%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%80%E7%B2%BE%E7%AE%80%E7%9A%84STM32-SD%E5%8D%A1%E5%AE%9E%E7%8E%B0MP3%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>只用STM32单片机+SD卡+耳机插座，实现播放MP3播放器！</p><p>看过很多STM32软解MP3的方案，即不通过类似VS1053之类的解码器芯片，直接用STM32和软件库解码MP3文件，通常使用了labmad或者Helix解码库实现，Helix相对labmad占用的RAM更少。但是大多数参考的方案还是用了外接IIS接口WM98xx之类的音频DAC芯片播放音频，稍显复杂繁琐。STM32F407Vx本身就自带了2路12位DAC输出，最高刷新速度333kHz，除了分辨率差点意思，速度上对于MP3通常44.1kHz采样率来说，用来播放音频绰绰有余了。本文给的方案和源码，直接用STM32软解码MP3并使用自带的2个DAC输出引脚输出音频左右声道。</p><p>原理：STM32从SD读取MP3文件原始数据，发送给Helix库解码，Helix解码后输出PCM数据流，将此数据进一步处理转换后，按照左右声道分别存入DAC输出1和2缓存，通过定时器以MP3文件的采样率的频率提供DAC触发节拍，通过DMA取缓存中高12位数据给DAC，在DAC1和2引脚产生音频波形，通过电容耦合到耳机的左右声道上。</p><p>MP3源文件是一种经过若干算法，将原始音频数据压缩得来的，软件解码的过程是逆过程，将压缩的音频反向转换为记录了左右声道、幅值的数据流，通常是PCM格式。</p><p>PCM：是模拟信号以固定的采样频率转换成数字信号后的表现形式。记录了音频采样的数据，双通道、16bit的PCM数据格式是以0轴为中心，范围为-32768~32767的数值，每个数据占用2字节，左声道和右声道交替存储，如图。</p><p><img src="https://img-blog.csdnimg.cn/694e98caa0d54f54939024bb8ccf386e.png"></p><p>软解码得到的PCM数据到STM32的DAC缓存需要进一步处理。STM32的DAC是12位的，其输入范围0<del>4095，而双通道16位的PCM音频数据是左右声道交替存储，且数据范围-32768</del>32767，因此PCM到STM32的DAC缓存要按照顺序一拆为二，分为左右声道，每个数据再加上32768，使其由short int的范围转换为unsigned short int，即0~65535。由于PCM数据是对音频的采样，因此调节音量（幅值）可以在此步骤一并处理，即音频数据 x 音量 &#x2F;最大音量。至于DAC是12位，只需将DAC模式设置为左对齐12位，舍弃低4位即可。</p><p>到此，STM32的DAC输出引脚上应该已经有音频信号了，通常DAC引脚上串联一个1~10uF的电容用来耦合音频信号，电容越大音质越好，电容另一端接耳机插座的左声道&#x2F;右声道，插上耳机就可以欣赏音乐啦！音质嘛，反正我是听不出来好不好，跟商品MP3播放器差不多。如果不串联电容，DAC引脚直连耳机插座左右声道也能听到声音，就是有些数字信号噪声也会传进来。如果希望噪声小一些，DAC引脚输出端加一个下图的低通滤波电路也是可以的。</p><p><img src="https://img-blog.csdnimg.cn/f132f4062140488bbdfc5c5d375776a2.jpeg"></p><p><img src="https://img-blog.csdnimg.cn/44697c32a37541ea990a3a9d5911e091.jpeg"></p><p>Helix移植：</p><p>Helix源码的官网我没找到，直接用了野火的例程里面的代码，移植也很简单，不用改任何代码，只需要将Helix文件夹拷贝到工程目录里，然后在Keil中添加好文件，以及添加头文件途径，编译即可。工程目录如图。</p><p><img src="https://img-blog.csdnimg.cn/bb0d0811712140ae83b917fa128509d9.jpeg"></p><p>源码：dac配置</p><p>dac.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    dac.c</span></span><br><span class="line"><span class="comment">  * @author  ZL</span></span><br><span class="line"><span class="comment">  * @version V0.0.1</span></span><br><span class="line"><span class="comment">  * @date    September-20-2019</span></span><br><span class="line"><span class="comment">  * @brief   DAC configuration.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dac.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   CNT_FREQ          84000000      <span class="comment">// TIM6 counter clock (prescaled APB1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DHR registers offsets */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHR12R1_OFFSET             ((uint32_t)0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHR12R2_OFFSET             ((uint32_t)0x00000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHR12RD_OFFSET             ((uint32_t)0x00000020)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"><span class="type">uint32_t</span> DAC_DHR12R1_ADDR = (<span class="type">uint32_t</span>)DAC_BASE + DHR12R1_OFFSET + DAC_Align_12b_L;</span><br><span class="line"><span class="type">uint32_t</span> DAC_DHR12R2_ADDR = (<span class="type">uint32_t</span>)DAC_BASE + DHR12R2_OFFSET + DAC_Align_12b_L;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> DAC_buff[<span class="number">2</span>][DAC_BUF_LEN]; <span class="comment">//DAC1、DAC2输出缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TIM6_Config</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private functions ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  DAC初始化</span></span><br><span class="line"><span class="comment">  * @param  none</span></span><br><span class="line"><span class="comment">  * @retval none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_Config</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">DAC_InitTypeDef  DAC_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RCC_AHB1PeriphClockCmd</span>(RCC_AHB1Periph_GPIOA, ENABLE);</span><br><span class="line"><span class="built_in">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_DAC, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;</span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;</span><br><span class="line"><span class="built_in">GPIO_Init</span>(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;</span><br><span class="line">DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;</span><br><span class="line">DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;</span><br><span class="line"><span class="built_in">DAC_Init</span>(DAC_Channel_1, &amp;DAC_InitStructure);</span><br><span class="line"><span class="built_in">DAC_Init</span>(DAC_Channel_2, &amp;DAC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置DMA</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line"><span class="built_in">DMA_StructInit</span>(&amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RCC_AHB1PeriphClockCmd</span>(RCC_AHB1Periph_DMA1, ENABLE);</span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (u32)DAC_DHR12R1_ADDR;</span><br><span class="line">DMA_InitStruct.DMA_Memory0BaseAddr = (u32)&amp;DAC_buff[<span class="number">0</span>];<span class="comment">//DAC1</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_MemoryToPeripheral;</span><br><span class="line">DMA_InitStruct.DMA_BufferSize = DAC_BUF_LEN;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_High;</span><br><span class="line">DMA_InitStruct.DMA_Channel = DMA_Channel_7;</span><br><span class="line">DMA_InitStruct.DMA_FIFOMode = DMA_FIFOMode_Disable;</span><br><span class="line">DMA_InitStruct.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;</span><br><span class="line">  DMA_InitStruct.DMA_MemoryBurst   = DMA_MemoryBurst_Single;</span><br><span class="line">  DMA_InitStruct.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DMA_Init</span>(DMA1_Stream5, &amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (u32)DAC_DHR12R2_ADDR;</span><br><span class="line">DMA_InitStruct.DMA_Memory0BaseAddr = (u32)&amp;DAC_buff[<span class="number">1</span>];<span class="comment">//DAC2</span></span><br><span class="line"><span class="built_in">DMA_Init</span>(DMA1_Stream6, &amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启DMA传输完成中断</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream6_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">  <span class="built_in">NVIC_Init</span>(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_TCIF6);</span><br><span class="line"><span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_HTIF6);</span><br><span class="line"><span class="built_in">DMA_ITConfig</span>(DMA1_Stream6, DMA_IT_TC, ENABLE);</span><br><span class="line"><span class="built_in">DMA_ITConfig</span>(DMA1_Stream6, DMA_IT_HT, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Stream5, ENABLE);</span></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Stream6, ENABLE);</span></span><br><span class="line"><span class="built_in">DAC_Cmd</span>(DAC_Channel_1, ENABLE);</span><br><span class="line">  <span class="built_in">DAC_Cmd</span>(DAC_Channel_2, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DAC_DMACmd</span>(DAC_Channel_1, ENABLE);</span><br><span class="line"><span class="built_in">DAC_DMACmd</span>(DAC_Channel_2, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">TIM6_Config</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置DAC采样率和DMA数据长度，并启动DMA DAC</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_DMA_Start</span><span class="params">(<span class="type">uint32_t</span> freq, <span class="type">uint16_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//设置DMA缓冲长度需要停止DMA</span></span><br><span class="line"><span class="built_in">DAC_DMA_Stop</span>();</span><br><span class="line"><span class="comment">//设置DMA DAC缓冲长度</span></span><br><span class="line"><span class="built_in">DMA_SetCurrDataCounter</span>(DMA1_Stream5, len);</span><br><span class="line"><span class="built_in">DMA_SetCurrDataCounter</span>(DMA1_Stream6, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器</span></span><br><span class="line"><span class="built_in">TIM_SetAutoreload</span>(TIM6, (<span class="type">uint16_t</span>)((CNT_FREQ)/freq));</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream5, ENABLE);</span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream6, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止DMA DAC</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_DMA_Stop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream5, DISABLE);</span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream6, DISABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器6用于设置DAC刷新率</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TIM6_Config</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TIM_TimeBaseInitTypeDef TIM6_TimeBase;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_TIM6, ENABLE);</span><br><span class="line">  <span class="built_in">TIM_TimeBaseStructInit</span>(&amp;TIM6_TimeBase);</span><br><span class="line"></span><br><span class="line">  TIM6_TimeBase.TIM_Period        = (<span class="type">uint16_t</span>)((CNT_FREQ)/<span class="number">44100</span>);</span><br><span class="line">  TIM6_TimeBase.TIM_Prescaler     = <span class="number">0</span>;</span><br><span class="line">  TIM6_TimeBase.TIM_ClockDivision = <span class="number">0</span>;</span><br><span class="line">  TIM6_TimeBase.TIM_CounterMode   = TIM_CounterMode_Up;</span><br><span class="line">  <span class="built_in">TIM_TimeBaseInit</span>(TIM6, &amp;TIM6_TimeBase);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TIM_SelectOutputTrigger</span>(TIM6, TIM_TRGOSource_Update);</span><br><span class="line">  <span class="built_in">TIM_Cmd</span>(TIM6, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  DAC out1 PA4输出电压</span></span><br><span class="line"><span class="comment">  * @param  dat：dac数值:，0~4095</span></span><br><span class="line"><span class="comment">  * @retval none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_Out1</span><span class="params">(<span class="type">uint16_t</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DAC_SetChannel1Data</span>(DAC_Align_12b_R,  dat);</span><br><span class="line"><span class="built_in">DAC_SoftwareTriggerCmd</span>(DAC_Channel_1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  DAC out2 PA5输出电压</span></span><br><span class="line"><span class="comment">  * @param  dat：dac数值:，0~4095</span></span><br><span class="line"><span class="comment">  * @retval none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_Out2</span><span class="params">(<span class="type">uint16_t</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DAC_SetChannel2Data</span>(DAC_Align_12b_R,  dat);</span><br><span class="line"><span class="built_in">DAC_SoftwareTriggerCmd</span>(DAC_Channel_2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************* *****END OF FILE****/</span></span><br></pre></td></tr></table></figure><p>源码：MP3播放流程 （原创野火，参考了野火的例程，本人进行整理和修改）</p><p>MP3player.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">******************************************************************************</span></span><br><span class="line"><span class="comment">* @file    mp3Player.c</span></span><br><span class="line"><span class="comment">* @author  fire</span></span><br><span class="line"><span class="comment">* @version V1.0</span></span><br><span class="line"><span class="comment">* @date    2023-08-13</span></span><br><span class="line"><span class="comment">* @brief   mp3解码</span></span><br><span class="line"><span class="comment">******************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ff.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp3Player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp3dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐使用以下格式mp3文件：</span></span><br><span class="line"><span class="comment"> * 采样率：44100Hz</span></span><br><span class="line"><span class="comment"> * 声  道：2</span></span><br><span class="line"><span class="comment"> * 比特率：320kbps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理立体声音频数据时，输出缓冲区需要的最大大小为2304*16/8字节(16为PCM数据为16位)，</span></span><br><span class="line"><span class="comment"> * 这里我们定义MP3BUFFER_SIZE为2304</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MP3BUFFER_SIZE  2304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUTBUF_SIZE   3000</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> HMP3DecoderMp3Decoder;<span class="comment">/* mp3解码器指针*/</span></span><br><span class="line"><span class="type">static</span> MP3FrameInfoMp3FrameInfo;<span class="comment">/* mP3帧信息  */</span></span><br><span class="line"><span class="type">static</span> MP3_TYPE mp3player;            <span class="comment">/* mp3播放设备 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> Isread = <span class="number">0</span>;          <span class="comment">/* DMA传输完成标志 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> dac_ht = <span class="number">0</span>;          <span class="comment">//DAC dma 半传输标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> led_delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> inputbuf[INPUTBUF_SIZE]=&#123;<span class="number">0</span>&#125;;     <span class="comment">/* 解码输入缓冲区，1940字节为最大MP3帧大小  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> outbuffer[MP3BUFFER_SIZE];  <span class="comment">/* 解码输出缓冲区*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> FIL file;<span class="comment">/* file objects */</span></span><br><span class="line"><span class="type">static</span> UINT bw;       <span class="comment">/* File R/W count */</span></span><br><span class="line">FRESULT result;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从SD卡读取MP3源文件进行解码，并传入DAC缓冲区</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MP3DataDecoder</span><span class="params">(<span class="type">uint8_t</span> **read_ptr, <span class="type">int</span> *bytes_left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> err = <span class="number">0</span>, i = <span class="number">0</span>, outputSamps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bufflag开始解码 参数：mp3解码结构体、输入流指针、输入流大小、输出流指针、数据格式</span></span><br><span class="line">err = <span class="built_in">MP3Decode</span>(Mp3Decoder, read_ptr, bytes_left, outbuffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != ERR_MP3_NONE)<span class="comment">//错误处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ERR_MP3_INDATA_UNDERFLOW:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERR_MP3_INDATA_UNDERFLOW\r\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">f_read</span>(&amp;file, inputbuf, INPUTBUF_SIZE, &amp;bw);</span><br><span class="line">*read_ptr = inputbuf;</span><br><span class="line">*bytes_left = bw;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ERR_MP3_MAINDATA_UNDERFLOW:</span><br><span class="line"><span class="comment">/* do nothing - next call to decode will provide more mainData */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERR_MP3_MAINDATA_UNDERFLOW\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UNKNOWN ERROR:%d\r\n&quot;</span>, err);</span><br><span class="line"><span class="comment">// 跳过此帧</span></span><br><span class="line"><span class="keyword">if</span> (*bytes_left &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*bytes_left) --;</span><br><span class="line">read_ptr ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//解码无错误，准备把数据输出到PCM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP3GetLastFrameInfo</span>(Mp3Decoder, &amp;Mp3FrameInfo);<span class="comment">//获取解码信息</span></span><br><span class="line"><span class="comment">/* 输出到DAC */</span></span><br><span class="line">outputSamps = Mp3FrameInfo.outputSamps;<span class="comment">//PCM数据个数</span></span><br><span class="line"><span class="keyword">if</span> (outputSamps &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Mp3FrameInfo.nChans == <span class="number">1</span>)<span class="comment">//单声道</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//单声道数据需要复制一份到另一个声道</span></span><br><span class="line"><span class="keyword">for</span> (i = outputSamps - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">outbuffer[i * <span class="number">2</span>] = outbuffer[i];</span><br><span class="line">outbuffer[i * <span class="number">2</span> + <span class="number">1</span>] = outbuffer[i];</span><br><span class="line">&#125;</span><br><span class="line">outputSamps *= <span class="number">2</span>;</span><br><span class="line">&#125;<span class="comment">//if (Mp3FrameInfo.nChans == 1)//单声道</span></span><br><span class="line">&#125;<span class="comment">//if (outputSamps &gt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据传送至DMA DAC缓冲区</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outputSamps/<span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dac_ht == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">DAC_buff[<span class="number">0</span>][i] = outbuffer[<span class="number">2</span>*i] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">DAC_buff[<span class="number">1</span>][i] = outbuffer[<span class="number">2</span>*i+<span class="number">1</span>] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DAC_buff[<span class="number">0</span>][i+outputSamps/<span class="number">2</span>] = outbuffer[<span class="number">2</span>*i] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">DAC_buff[<span class="number">1</span>][i+outputSamps/<span class="number">2</span>] = outbuffer[<span class="number">2</span>*i+<span class="number">1</span>] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//else 解码正常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一段MP3数据，并把读取的指针赋值read_ptr，长度赋值bytes_left</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">read_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *mp3file, <span class="type">uint8_t</span> **read_ptr, <span class="type">int</span> *bytes_left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">result = <span class="built_in">f_read</span>(&amp;file, inputbuf, INPUTBUF_SIZE, &amp;bw);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result != FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;读取%s失败 -&gt; %d\r\n&quot;</span>, mp3file, result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*read_ptr = inputbuf;</span><br><span class="line">*bytes_left = bw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  MP3格式音频播放主程序</span></span><br><span class="line"><span class="comment">  * @param  mp3file MP3文件路径</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mp3PlayerDemo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *mp3file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">uint8_t</span> *read_ptr = inputbuf;</span><br><span class="line"><span class="type">int</span>read_offset = <span class="number">0</span>;<span class="comment">/* 读偏移指针 */</span></span><br><span class="line"><span class="type">int</span>bytes_left = <span class="number">0</span>;<span class="comment">/* 剩余字节数 */</span></span><br><span class="line"></span><br><span class="line">mp3player.ucStatus = STA_IDLE;</span><br><span class="line">mp3player.ucVolume = <span class="number">15</span>; <span class="comment">//音量值，100满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试打开MP3文件</span></span><br><span class="line">result = <span class="built_in">f_open</span>(&amp;file, mp3file, FA_READ);</span><br><span class="line"><span class="keyword">if</span>(result != FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open mp3file :%s fail!!!-&gt;%d\r\n&quot;</span>, mp3file, result);</span><br><span class="line">result = <span class="built_in">f_close</span> (&amp;file);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">/* 停止播放 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前播放文件 -&gt; %s\n&quot;</span>, mp3file);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化MP3解码器</span></span><br><span class="line">Mp3Decoder = <span class="built_in">MP3InitDecoder</span>();</span><br><span class="line"><span class="keyword">if</span>(Mp3Decoder == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化helix解码库设备失败！\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">/* 停止播放 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化helix解码库完成\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试读取一段MP3数据，并把读取的指针赋值read_ptr，长度赋值bytes_left</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">read_file</span>(mp3file, &amp;read_ptr, &amp;bytes_left))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP3FreeDecoder</span>(Mp3Decoder);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">/* 停止播放 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试解码成功</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">MP3DataDecoder</span>(&amp;read_ptr, &amp;bytes_left))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印MP3信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Bitrate       %dKbps&quot;</span>, Mp3FrameInfo.bitrate/<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Samprate      %dHz&quot;</span>,   Mp3FrameInfo.samprate);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n BitsPerSample %db&quot;</span>,    Mp3FrameInfo.bitsPerSample);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n nChans        %d&quot;</span>,     Mp3FrameInfo.nChans);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Layer         %d&quot;</span>,     Mp3FrameInfo.layer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Version       %d&quot;</span>,     Mp3FrameInfo.version);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n OutputSamps   %d&quot;</span>,     Mp3FrameInfo.outputSamps);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动DAC，开始发声</span></span><br><span class="line"><span class="keyword">if</span> (Mp3FrameInfo.nChans == <span class="number">1</span>)<span class="comment">//单声道要将outputSamps*2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DAC_DMA_Start</span>(Mp3FrameInfo.samprate, <span class="number">2</span> * Mp3FrameInfo.outputSamps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//双声道直接用Mp3FrameInfo.outputSamps</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DAC_DMA_Start</span>(Mp3FrameInfo.samprate, Mp3FrameInfo.outputSamps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//解码失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP3FreeDecoder</span>(Mp3Decoder);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 放音状态 */</span></span><br><span class="line">mp3player.ucStatus = STA_PLAYING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进入主程序循环体 */</span></span><br><span class="line"><span class="keyword">while</span>(mp3player.ucStatus == STA_PLAYING)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//寻找帧同步，返回第一个同步字的位置</span></span><br><span class="line">read_offset = <span class="built_in">MP3FindSyncWord</span>(read_ptr, bytes_left);</span><br><span class="line"><span class="keyword">if</span>(read_offset &lt; <span class="number">0</span>)<span class="comment">//没有找到同步字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">read_file</span>(mp3file, &amp;read_ptr, &amp;bytes_left))<span class="comment">//重新读取一次文件再找</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//回到while(mp3player.ucStatus == STA_PLAYING)后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//找到同步字</span></span><br><span class="line">&#123;</span><br><span class="line">read_ptr   += read_offset;<span class="comment">//偏移至同步字的位置</span></span><br><span class="line">bytes_left -= read_offset;<span class="comment">//同步字之后的数据大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bytes_left &lt; <span class="number">1024</span>)<span class="comment">//如果剩余的数据小于1024字节，补充数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注意这个地方因为采用的是DMA读取，所以一定要4字节对齐  */</span></span><br><span class="line">u16 i = (<span class="type">uint32_t</span>)(bytes_left)&amp;<span class="number">3</span>;<span class="comment">//判断多余的字节</span></span><br><span class="line"><span class="keyword">if</span>(i) i=<span class="number">4</span>-i;<span class="comment">//需要补充的字节</span></span><br><span class="line"><span class="built_in">memcpy</span>(inputbuf+i, read_ptr, bytes_left);<span class="comment">//从对齐位置开始复制</span></span><br><span class="line">read_ptr = inputbuf+i;<span class="comment">//指向数据对齐位置</span></span><br><span class="line">result = <span class="built_in">f_read</span>(&amp;file, inputbuf+bytes_left+i, INPUTBUF_SIZE-bytes_left-i, &amp;bw);<span class="comment">//补充数据</span></span><br><span class="line"><span class="keyword">if</span>(result != FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;读取%s失败 -&gt; %d\r\n&quot;</span>,mp3file,result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bytes_left += bw;<span class="comment">//有效数据流大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3数据解码并送入DAC缓存</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">MP3DataDecoder</span>(&amp;read_ptr, &amp;bytes_left))</span><br><span class="line">&#123;<span class="comment">//如果播放出错，Isread置1，避免卡住死循环</span></span><br><span class="line">Isread = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3文件读取完成，退出</span></span><br><span class="line"><span class="keyword">if</span>(file.fptr == file.fsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单曲播放完毕\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待DAC发送一半或全部中断</span></span><br><span class="line"><span class="keyword">while</span>(Isread == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">led_delay++;</span><br><span class="line"><span class="keyword">if</span>(led_delay == <span class="number">0xffffff</span>)</span><br><span class="line">&#123;</span><br><span class="line">led_delay=<span class="number">0</span>;</span><br><span class="line">LED1_TROG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Input_scan();//等待DMA传输完成，此间可以运行按键扫描及处理事件</span></span><br><span class="line">&#125;</span><br><span class="line">Isread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行到此处，说明单曲播放完成，收尾工作</span></span><br><span class="line"><span class="built_in">DAC_DMA_Stop</span>();<span class="comment">//停止喂DAC数据</span></span><br><span class="line">mp3player.ucStatus = STA_IDLE;</span><br><span class="line"><span class="built_in">MP3FreeDecoder</span>(Mp3Decoder);<span class="comment">//清理缓存</span></span><br><span class="line"><span class="built_in">f_close</span>(&amp;file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DMA1_Stream6_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">DMA_GetITStatus</span>(DMA1_Stream6, DMA_IT_HTIF6) != RESET) <span class="comment">//半传输</span></span><br><span class="line">&#123;</span><br><span class="line">dac_ht = <span class="number">1</span>;</span><br><span class="line">Isread=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_HTIF6);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">DMA_GetITStatus</span>(DMA1_Stream6, DMA_IT_TCIF6) != RESET) <span class="comment">//全传输</span></span><br><span class="line">&#123;</span><br><span class="line">dac_ht = <span class="number">0</span>;</span><br><span class="line">Isread=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_TCIF6);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************** (END OF FILE) *********************************/</span></span><br></pre></td></tr></table></figure><p>源码：main.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    ../User/main.c</span></span><br><span class="line"><span class="comment">  * @author  ZL</span></span><br><span class="line"><span class="comment">  * @version V1.0</span></span><br><span class="line"><span class="comment">  * @date    2015-12-26</span></span><br><span class="line"><span class="comment">  * @brief   Main program body</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw_includes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ff.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exfuns.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp3Player.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历目录文件并打印输出</span></span><br><span class="line"><span class="function">u8 <span class="title">scan_files</span><span class="params">(u8 * path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FRESULT res;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> *fn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _USE_LFN</span></span><br><span class="line"> fileinfo.lfsize = _MAX_LFN * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">fileinfo.lfname = buf;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">f_opendir</span>(&amp;dir,(<span class="type">const</span> TCHAR*)path);</span><br><span class="line"><span class="keyword">if</span> (res == FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">f_readdir</span>(&amp;dir, &amp;fileinfo);</span><br><span class="line"><span class="keyword">if</span> (res != FR_OK || fileinfo.fname[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _USE_LFN</span></span><br><span class="line">fn = *fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">fn = fileinfo.fname;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/&quot;</span>, path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Main program</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">delay_init</span>(<span class="number">168</span>);</span><br><span class="line"><span class="built_in">usart1_Init</span>(<span class="number">115200</span>);</span><br><span class="line"><span class="built_in">LED_Init</span>();</span><br><span class="line"><span class="built_in">DAC_Config</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">SD_Init</span>())</span><br><span class="line"> &#123;</span><br><span class="line"><span class="built_in">exfuns_init</span>();<span class="comment">//为fatfs相关变量申请内存</span></span><br><span class="line"><span class="built_in">f_mount</span>(fs[<span class="number">0</span>],<span class="string">&quot;0:&quot;</span>,<span class="number">1</span>); <span class="comment">//挂载SD卡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印SD目录和文件</span></span><br><span class="line"><span class="built_in">scan_files</span>(<span class="string">&quot;0:&quot;</span>);</span><br><span class="line"></span><br><span class="line">LED0_ON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mp3PlayerDemo</span>(<span class="string">&quot;0:/断桥残雪.MP3&quot;</span>);</span><br><span class="line"><span class="built_in">mp3PlayerDemo</span>(<span class="string">&quot;0:/张国荣-玻璃之情.MP3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">delay_ms</span>(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为方便调试测试，使用usart1打印数据。实测效果：</p><p><img src="https://img-blog.csdnimg.cn/bad9436c9a4e40de9bbd62abbae67b7c.jpeg"></p><p><img src="https://img-blog.csdnimg.cn/54ff22470d72499bb3e585a487abab46.jpeg"></p><p>程序源码与原理图，测试音频：</p><p>链接：<a href="https://pan.baidu.com/s/10hYXkrqnuBQgs0DWKLUUOA?pwd=iatt">https://pan.baidu.com/s/10hYXkrqnuBQgs0DWKLUUOA?pwd=iatt</a><br>提取码：iatt</p><p>知道这里下载要积分登录什么的麻烦得很，所以程序放到百度网盘了，假如连接失效，记得在评论区喊我更新！</p><p>理论上STM32F1或者其他系列也能用这个方案，要自己改改测试喽，本文把思路分享出来抛砖引玉。</p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32】HAL库 STM32CubeMX教程十三---RTC时钟</title>
      <link href="/2024/03/stm32-%E3%80%90STM32%E3%80%91HAL%E5%BA%93-STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-RTC%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/stm32-%E3%80%90STM32%E3%80%91HAL%E5%BA%93-STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-RTC%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>前言：</p><p>本系列教程将 对应外设原理，HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用</p><p>所用工具：</p><p>1、芯片： STM32F407ZET6&#x2F; STM32F103ZET6</p><p>2、STM32CubeMx软件</p><p>3、IDE： MDK-Keil软件</p><p>4、STM32F1xx&#x2F;STM32F4xxHAL库</p><p>知识概括：</p><p>通过本篇博客您将学到：</p><p>RTC时钟原理</p><p>STM32CubeMX创建RTC例程</p><p>HAL库定时器RTC函数库</p><p><strong>PS: 这里的RTC讲解，我们只将原理，不讲寄存器，如果要看RTC的寄存器，请看这篇文章</strong><br><a href="https://blog.csdn.net/as480133937/article/details/105026033">【STM32】RTC实时时钟，步骤超细详解，一文看懂RTC</a></p><h3 id="什么是RTC"><a href="#什么是RTC" class="headerlink" title="什么是RTC"></a>什么是RTC</h3><p>**RTC (Real Time Clock)**：实时时钟</p><p><strong>RTC是个独立的定时器</strong>。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。</p><p><img src="https://img-blog.csdnimg.cn/20200423215123488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。</strong></p><p>RTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。</p><p>两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。</p><p>上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。</p><p>无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。</p><h4 id="RCT特征："><a href="#RCT特征：" class="headerlink" title="; RCT特征："></a><a name="rct_47">;</a> <strong>RCT特征：</strong></h4><p>● <strong>可编程的预分频系数：分频系数高为220。</strong><br>● <strong>32位的可编程计数器，可用于较长时间段的测量。</strong><br>● <strong>2个分离的时钟：用于APB1接口的PCLK1和RTC时钟(RTC时钟的频率必须小于PCLK1时钟 频率的四分之一以上)。</strong><br>● 可以选择以下 <strong>三种RTC的时钟源</strong>：<br>● HSE时钟除以128；<br>● LSE振荡器时钟；<br>● LSI振荡器时钟</p><p>● <strong>2个独立的复位类型：</strong><br>● APB1接口由系统复位；<br>● RTC核心(预分频器、闹钟、计数器和分频器)只能由后备域复位</p><p>● <strong>3个专门的可屏蔽中断：</strong><br>● 1. <strong>闹钟中断</strong>，用来产生一个软件可编程的闹钟中断。</p><p>● 2. <strong>秒中断</strong>，用来产生一个可编程的周期性中断信号(长可达1秒)。</p><p>● 3. <strong>溢出中断</strong>，指示内部可编程计数器溢出并回转为0的状态。</p><p><strong>RTC时钟源：</strong><br>三种不同的时钟源可被用来驱动系统时钟(SYSCLK)：</p><p>● <strong>HSI振荡器时钟</strong><br>● <strong>HSE振荡器时钟</strong><br>● <strong>PLL时钟</strong></p><p>这些设备有以下2种二级时钟源：</p><p>● 40kHz低速内部RC，可以用于驱动独立看门狗和通过程序选择驱动RTC。 RTC用于从停机&#x2F;待机模式下自动唤醒系统。<br>● 32.768kHz低速外部晶体也可用来通过程序选择驱动RTC(RTCCLK)。</p><h4 id="RTC原理框图"><a href="#RTC原理框图" class="headerlink" title="RTC原理框图"></a>RTC原理框图</h4><p><img src="https://img-blog.csdnimg.cn/20200322144525734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br>RTC时钟的框图还是比较简单的，这里我们把他分成 <strong><code>&amp;#x4E24;&amp;#x4E2A;&amp;#x90E8;&amp;#x5206;</code></strong>:</p><p><strong>APB1 接口</strong>：用来和 APB1 总线相连。 此单元还包含一组 16 位寄存器，可通过 APB1 总线对其进行读写操作。APB1 接口由 APB1 总 线时钟驱动，用来与 APB1 总线连接。</p><p>通过APB1接口可以访问RTC的相关寄存器（预分频值，计数器值，闹钟值）。</p><p><strong>RTC 核心接口</strong>：由一组可编程计数器组成，分成 ** <code>&amp;#x4E24;&amp;#x4E2A;&amp;#x4E3B;&amp;#x8981;&amp;#x6A21;&amp;#x5757;</code>** 。<br><img src="https://img-blog.csdnimg.cn/20200322223612113.png">g)<br><strong>第一个模块是 RTC 的 预分频模块</strong>，它可编程产生 1 秒的 RTC 时间基准 TR_CLK。RTC 的预分频模块包含了一个 20 位的可编程分频器(RTC 预分频器)。如果在 RTC_CR 寄存器中设置了相应的允许位，则在每个 TR_CLK 周期中 RTC 产生一个中断(秒中断)。<br><img src="https://img-blog.csdnimg.cn/2020032222362770.png"><br><strong>第二个模块是一个 32 位的可编程计数器 （RTC_CNT）</strong>，可被初始化为当前的系统时间，一个 32 位的时钟计数器，按秒钟计算，可以记 录 4294967296 秒，约合 136 年左右，作为一般应用，这已经是足够了的。</p><h4 id="RTC具体流程："><a href="#RTC具体流程：" class="headerlink" title="; RTC具体流程："></a><a name="rtc_107">;</a> <strong>RTC具体流程：</strong></h4><p><strong>RTCCLK经过RTC_DIV预分频，RTC_PRL设置预分频系数，然后得到TR_CLK时钟信号，我们一般设置其周期为1s，RTC_CNT计数器计数，假如1970设置为时间起点为0s，通过当前时间的秒数计算得到当前的时间。RTC_ALR是设置闹钟时间，RTC_CNT计数到RTC_ALR就会产生计数中断，</strong></p><ul><li><strong>RTC_Second</strong>为秒中断，用于刷新时间，</li><li><strong>RTC_Overflow</strong>是溢出中断。</li><li><strong>RTC Alarm</strong> 控制开关机</li></ul><h4 id="RTC时钟选择"><a href="#RTC时钟选择" class="headerlink" title="RTC时钟选择"></a>RTC时钟选择</h4><p><strong>使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响,因此没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE,频率为实时时钟模块中常用的32.768KHz,因为32768 &#x3D; 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</strong></p><h4 id="RTC复位过程"><a href="#RTC复位过程" class="headerlink" title="RTC复位过程"></a>RTC复位过程</h4><p>除了RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器外，所有的系统寄存器都由系统复位或电源复位进行异步复位。<br>RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器仅能通过备份域复位信号复位。</p><p><strong>系统复位后,禁止访问后备寄存器和RCT,防止对后卫区域(BKP)的意外写操作</strong></p><h4 id="RTC中断"><a href="#RTC中断" class="headerlink" title="RTC中断"></a>RTC中断</h4><p><strong>秒中断：</strong><br>这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的”秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p><p><strong>闹钟中断：</strong><br>闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p><h3 id="CubeMX配置RTC"><a href="#CubeMX配置RTC" class="headerlink" title="CubeMX配置RTC"></a>CubeMX配置RTC</h3><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p><strong>1设置RCC</strong><br><img src="https://img-blog.csdnimg.cn/20200425101549368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li><strong>设置高速外部时钟HSE 选择外部时钟源</strong></li><li>*<em>使能外部晶振LSE</em></li></ul><p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE</strong></p><ol start="2"><li><strong>配置RTC</strong><br><img src="https://img-blog.csdnimg.cn/20200425110730403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></li></ol><ul><li><strong>Activate Clock Source 激活时钟源</strong></li><li>*<em>Activate calendar激活日历</em></li></ul><p><strong>这两个都要点，作用也很明显，先是使能时钟源，再使能RTC日历</strong></p><ul><li><strong>RTC_OUT： Not RTC_OUT</strong></li><li><strong>Tamper：</strong> *<em>×</em></li></ul><p>第一个是是否使能 <strong>tamper（PC13）引脚上输出校正的秒脉冲时钟，</strong></p><p>第二个： <strong>RTC入侵检测校验功能</strong></p><p><strong>RTC校验功能，使能侵入检测功能。RTC时钟经64分频输出到侵入检测引脚TAMPER上<br> 当 TAMPER引脚上的信号从 0变成1或者从 1变成 0(取决于备份控制寄存器BKP_CR的 TPAL位)，会产生一个侵入检测事件。侵入检测事件将所有数据备份寄存器内容清除。</strong></p><ol><li>也就是第一个是使能tamper（PC13）引脚作为时钟脉冲输出</li><li>第二个是使能tamper（PC13）引脚作为入侵检测功能</li></ol><p>下面是两个RTC的中断：</p><ul><li><strong>RTC全局中断RTC_IRQHandler()</strong></li><li>*<em>闹钟中断函数RTCAlarm_IRQHandler()</em></li></ul><p><img src="https://img-blog.csdnimg.cn/2020042514381771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>此处设置时间为2020&#x2F;04&#x2F;25 13:30:00</strong></p><ul><li>Data Format: 日期格式</li></ul><p><strong>Binary data format 十六进制<br>BCD data format BCD码进制</strong></p><p>使用自动配置，初始化时间必须使用BCD data format，原因是库函数存在bug，如果使用Binary data format，月份配置会出错，比如说11月，配置时会赋值为RTC_MONTH_NOVEMBER，而此宏定义值为0x11，也就是说其十进制值为17</p><ul><li><strong>Hours： 小时</strong></li><li><strong>Minutes： 分钟</strong></li><li><strong>Seconds： 秒</strong></li><li><strong>Week Day： 星期</strong></li><li><strong>Month 月份</strong></li><li><strong>Date： 日期</strong></li><li>*<em>Year： 年份</em></li></ul><p><strong>3 使能串口</strong><br><img src="https://img-blog.csdnimg.cn/20200425143944495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br><strong>使能一下串口，因为发送日期到上位机</strong></p><p><strong>4时钟源设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144337169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>我的是 外部晶振为8MHz</p><ul><li>1选择外部时钟HSE 8MHz</li><li>2PLL锁相环倍频9倍</li><li>3系统时钟来源选择为PLL</li><li>4设置APB1分频器为 &#x2F;2</li><li>5 使能CSS监视时钟</li><li>*<em>6 设置RTC时钟为LSE</em></li></ul><p>32的时钟树框图 如果不懂的话请看<a href="https://blog.csdn.net/as480133937/article/details/98845509">《【STM32】系统时钟RCC详解(超详细，超全面)》</a></p><p><strong>5项目文件设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li>1 设置项目名称</li><li>2 设置存储路径</li><li>3 选择所用IDE<br><img src="https://img-blog.csdnimg.cn/2020042514462236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></li></ul><p><strong>6创建工程文件</strong></p><p><strong>然后点击GENERATE CODE 创建工程</strong></p><p><strong>配置下载工具</strong><br>新建的工程所有配置都是默认的 我们需要自行选择下载模式，勾选上下载后复位运行</p><p><img src="https://img-blog.csdnimg.cn/202004251446415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC-HAL库函数"><a href="#RTC-HAL库函数" class="headerlink" title=";  RTC_HAL库函数"></a><a name="rtc_hal_243">;</a>  RTC_HAL库函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm_IT</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">__weak <span class="keyword">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)</span></span><br><span class="line"></span><br><span class="line">uint32_t <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister</span></span><br></pre></td></tr></table></figure><p>我们可以看到前面的四个函数，分别是</p><ul><li><strong>设置系统时间：HAL_RTC_SetTime();</strong></li><li><strong>读取系统时间: HAL_RTC_GetTime();</strong></li><li><strong>设置系统日期: HAL_RTC_SetDate();</strong></li><li>*<em>读取系统日期: HAL_RTC_GetDate();</em></li></ul><p>因为系统的时间和日期开始的时候已经设置过了，所以我们这里只用两个读取函数</p><p><strong>读取系统时间函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的时间</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2</li><li><strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体，</li><li>Format： <strong>获取时间的格式</strong><br>*<em>RTC_FORMAT_BIN 使用16进制<br>RTC_FORMAT_BCD 使用BCD进制</em></li></ul><p><strong>读取系统日期函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的日期</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2</li><li><strong>RTC_DateTypeDef</strong> *sTime： 获取RTC日期的结构体，</li><li>Format： <strong>获取日期的格式</strong><br>*<em>RTC_FORMAT_BIN 使用16进制<br>RTC_FORMAT_BCD 使用BCD进制</em></li></ul><p>在stm32f1xx_hal_rtc.h头文件中，可以找到 <code>RTC_TimeTypeDef</code>， <code>RTC_DateTypeDef</code>这两个结构体的成员变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;</span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;</span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br></pre></td></tr></table></figure><p><strong>程序代码：</strong></p><p>main.c</p><p><strong>在main.c中重写fputc函数，使得能够使用printf函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *f)</span>&#123;</span><br><span class="line"> <span class="type">uint8_t</span> temp[<span class="number">1</span>]=&#123;ch&#125;;</span><br><span class="line"> HAL_UART_Transmit(&amp;huart1,temp,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义两个结构体来获取日期和时间：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTC_DateTypeDef GetData;</span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef GetTime;</span><br></pre></td></tr></table></figure><p>在while循环中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">   HAL_RTC_GetDate(&amp;hrtc, &amp;GetData, RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%02d/%02d/%02d\r\n&quot;</span>,<span class="number">2000</span> + GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d\r\n&quot;</span>,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>程序中使用HAL_RTC_GetTime（）,HAL_RTC_GetDate()读取时间和日期，并保存到结构体变量中，然后通过串口输出读取的时间和日期。</strong></p><p><strong>例程测试正常：</strong><br><img src="https://img-blog.csdnimg.cn/20200425153330941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC掉电重置"><a href="#RTC掉电重置" class="headerlink" title="RTC掉电重置"></a>RTC掉电重置</h4><p>但是呢，在hal库中生成的代码， <strong>每次断电就RTC时间会重置</strong>，每次上电都会重新初始化时间</p><p>因为HAL库设置了一个BKP寄存器保存一个标志。每次单片机启动时都读取这个标志并判断是不是预先设定的值：如度果不是就初始化RTC并设置时间，再设置标志为预期值；如果是预期值就跳过初始化和时间设置，继续执行后面的程序</p><p><strong>所以这里我们只需要每次上电执行RTC初始化之前，将标志设置为预期值即可</strong></p><p><strong>在rtc.c中的RTC_Init修改为以下内容即可</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">MX_RTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef time;</span><br><span class="line">RTC_DateTypeDef datebuff;</span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__HAL_RCC_BKP_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= <span class="number">0x5051</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  sTime.Hours = <span class="number">0x14</span>;</span><br><span class="line">  sTime.Minutes = <span class="number">0x30</span>;</span><br><span class="line">  sTime.Seconds = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  DateToUpdate.WeekDay = RTC_WEEKDAY_SATURDAY;</span><br><span class="line">  DateToUpdate.Month = RTC_MONTH_APRIL;</span><br><span class="line">  DateToUpdate.Date = <span class="number">0x25</span>;</span><br><span class="line">  DateToUpdate.Year = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC);</span><br><span class="line">datebuff = DateToUpdate;</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, <span class="number">0x5051</span>);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR2, (<span class="type">uint16_t</span>)datebuff.Year);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR3, (<span class="type">uint16_t</span>)datebuff.Month);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR4, (<span class="type">uint16_t</span>)datebuff.Date);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR5, (<span class="type">uint16_t</span>)datebuff.WeekDay);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">datebuff.Year    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR2);</span><br><span class="line">datebuff.Month   = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR3);</span><br><span class="line">datebuff.Date    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR4);</span><br><span class="line">datebuff.WeekDay = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR5);</span><br><span class="line">DateToUpdate = datebuff;</span><br><span class="line"><span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BIN) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425165901167.gif"><br><img src="https://img-blog.csdnimg.cn/20200425165904365.gif"></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F407使用Helix库软解MP3并通过DAC输出，最精简的STM32+SD卡实现MP3播放器</title>
      <link href="/2024/03/stm32-stm32-STM32F407%E4%BD%BF%E7%94%A8Helix%E5%BA%93%E8%BD%AF%E8%A7%A3MP3%E5%B9%B6%E9%80%9A%E8%BF%87DAC%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%80%E7%B2%BE%E7%AE%80%E7%9A%84STM32-SD%E5%8D%A1%E5%AE%9E%E7%8E%B0MP3%E6%92%AD%E6%94%BE%E5%99%A8/"/>
      <url>/2024/03/stm32-stm32-STM32F407%E4%BD%BF%E7%94%A8Helix%E5%BA%93%E8%BD%AF%E8%A7%A3MP3%E5%B9%B6%E9%80%9A%E8%BF%87DAC%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%80%E7%B2%BE%E7%AE%80%E7%9A%84STM32-SD%E5%8D%A1%E5%AE%9E%E7%8E%B0MP3%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>只用STM32单片机+SD卡+耳机插座，实现播放MP3播放器！</p><p>看过很多STM32软解MP3的方案，即不通过类似VS1053之类的解码器芯片，直接用STM32和软件库解码MP3文件，通常使用了labmad或者Helix解码库实现，Helix相对labmad占用的RAM更少。但是大多数参考的方案还是用了外接IIS接口WM98xx之类的音频DAC芯片播放音频，稍显复杂繁琐。STM32F407Vx本身就自带了2路12位DAC输出，最高刷新速度333kHz，除了分辨率差点意思，速度上对于MP3通常44.1kHz采样率来说，用来播放音频绰绰有余了。本文给的方案和源码，直接用STM32软解码MP3并使用自带的2个DAC输出引脚输出音频左右声道。</p><p>原理：STM32从SD读取MP3文件原始数据，发送给Helix库解码，Helix解码后输出PCM数据流，将此数据进一步处理转换后，按照左右声道分别存入DAC输出1和2缓存，通过定时器以MP3文件的采样率的频率提供DAC触发节拍，通过DMA取缓存中高12位数据给DAC，在DAC1和2引脚产生音频波形，通过电容耦合到耳机的左右声道上。</p><p>MP3源文件是一种经过若干算法，将原始音频数据压缩得来的，软件解码的过程是逆过程，将压缩的音频反向转换为记录了左右声道、幅值的数据流，通常是PCM格式。</p><p>PCM：是模拟信号以固定的采样频率转换成数字信号后的表现形式。记录了音频采样的数据，双通道、16bit的PCM数据格式是以0轴为中心，范围为-32768~32767的数值，每个数据占用2字节，左声道和右声道交替存储，如图。</p><p><img src="https://img-blog.csdnimg.cn/694e98caa0d54f54939024bb8ccf386e.png"></p><p>软解码得到的PCM数据到STM32的DAC缓存需要进一步处理。STM32的DAC是12位的，其输入范围0<del>4095，而双通道16位的PCM音频数据是左右声道交替存储，且数据范围-32768</del>32767，因此PCM到STM32的DAC缓存要按照顺序一拆为二，分为左右声道，每个数据再加上32768，使其由short int的范围转换为unsigned short int，即0~65535。由于PCM数据是对音频的采样，因此调节音量（幅值）可以在此步骤一并处理，即音频数据 x 音量 &#x2F;最大音量。至于DAC是12位，只需将DAC模式设置为左对齐12位，舍弃低4位即可。</p><p>到此，STM32的DAC输出引脚上应该已经有音频信号了，通常DAC引脚上串联一个1~10uF的电容用来耦合音频信号，电容越大音质越好，电容另一端接耳机插座的左声道&#x2F;右声道，插上耳机就可以欣赏音乐啦！音质嘛，反正我是听不出来好不好，跟商品MP3播放器差不多。如果不串联电容，DAC引脚直连耳机插座左右声道也能听到声音，就是有些数字信号噪声也会传进来。如果希望噪声小一些，DAC引脚输出端加一个下图的低通滤波电路也是可以的。</p><p><img src="https://img-blog.csdnimg.cn/f132f4062140488bbdfc5c5d375776a2.jpeg"></p><p><img src="https://img-blog.csdnimg.cn/44697c32a37541ea990a3a9d5911e091.jpeg"></p><p>Helix移植：</p><p>Helix源码的官网我没找到，直接用了野火的例程里面的代码，移植也很简单，不用改任何代码，只需要将Helix文件夹拷贝到工程目录里，然后在Keil中添加好文件，以及添加头文件途径，编译即可。工程目录如图。</p><p><img src="https://img-blog.csdnimg.cn/bb0d0811712140ae83b917fa128509d9.jpeg"></p><p>源码：dac配置</p><p>dac.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    dac.c</span></span><br><span class="line"><span class="comment">  * @author  ZL</span></span><br><span class="line"><span class="comment">  * @version V0.0.1</span></span><br><span class="line"><span class="comment">  * @date    September-20-2019</span></span><br><span class="line"><span class="comment">  * @brief   DAC configuration.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dac.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   CNT_FREQ          84000000      <span class="comment">// TIM6 counter clock (prescaled APB1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DHR registers offsets */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHR12R1_OFFSET             ((uint32_t)0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHR12R2_OFFSET             ((uint32_t)0x00000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHR12RD_OFFSET             ((uint32_t)0x00000020)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"><span class="type">uint32_t</span> DAC_DHR12R1_ADDR = (<span class="type">uint32_t</span>)DAC_BASE + DHR12R1_OFFSET + DAC_Align_12b_L;</span><br><span class="line"><span class="type">uint32_t</span> DAC_DHR12R2_ADDR = (<span class="type">uint32_t</span>)DAC_BASE + DHR12R2_OFFSET + DAC_Align_12b_L;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> DAC_buff[<span class="number">2</span>][DAC_BUF_LEN]; <span class="comment">//DAC1、DAC2输出缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TIM6_Config</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private functions ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  DAC初始化</span></span><br><span class="line"><span class="comment">  * @param  none</span></span><br><span class="line"><span class="comment">  * @retval none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_Config</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">DAC_InitTypeDef  DAC_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RCC_AHB1PeriphClockCmd</span>(RCC_AHB1Periph_GPIOA, ENABLE);</span><br><span class="line"><span class="built_in">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_DAC, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;</span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;</span><br><span class="line"><span class="built_in">GPIO_Init</span>(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;</span><br><span class="line">DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;</span><br><span class="line">DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;</span><br><span class="line"><span class="built_in">DAC_Init</span>(DAC_Channel_1, &amp;DAC_InitStructure);</span><br><span class="line"><span class="built_in">DAC_Init</span>(DAC_Channel_2, &amp;DAC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置DMA</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line"><span class="built_in">DMA_StructInit</span>(&amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RCC_AHB1PeriphClockCmd</span>(RCC_AHB1Periph_DMA1, ENABLE);</span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (u32)DAC_DHR12R1_ADDR;</span><br><span class="line">DMA_InitStruct.DMA_Memory0BaseAddr = (u32)&amp;DAC_buff[<span class="number">0</span>];<span class="comment">//DAC1</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_MemoryToPeripheral;</span><br><span class="line">DMA_InitStruct.DMA_BufferSize = DAC_BUF_LEN;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_High;</span><br><span class="line">DMA_InitStruct.DMA_Channel = DMA_Channel_7;</span><br><span class="line">DMA_InitStruct.DMA_FIFOMode = DMA_FIFOMode_Disable;</span><br><span class="line">DMA_InitStruct.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;</span><br><span class="line">  DMA_InitStruct.DMA_MemoryBurst   = DMA_MemoryBurst_Single;</span><br><span class="line">  DMA_InitStruct.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DMA_Init</span>(DMA1_Stream5, &amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (u32)DAC_DHR12R2_ADDR;</span><br><span class="line">DMA_InitStruct.DMA_Memory0BaseAddr = (u32)&amp;DAC_buff[<span class="number">1</span>];<span class="comment">//DAC2</span></span><br><span class="line"><span class="built_in">DMA_Init</span>(DMA1_Stream6, &amp;DMA_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启DMA传输完成中断</span></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream6_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">  <span class="built_in">NVIC_Init</span>(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_TCIF6);</span><br><span class="line"><span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_HTIF6);</span><br><span class="line"><span class="built_in">DMA_ITConfig</span>(DMA1_Stream6, DMA_IT_TC, ENABLE);</span><br><span class="line"><span class="built_in">DMA_ITConfig</span>(DMA1_Stream6, DMA_IT_HT, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Stream5, ENABLE);</span></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Stream6, ENABLE);</span></span><br><span class="line"><span class="built_in">DAC_Cmd</span>(DAC_Channel_1, ENABLE);</span><br><span class="line">  <span class="built_in">DAC_Cmd</span>(DAC_Channel_2, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DAC_DMACmd</span>(DAC_Channel_1, ENABLE);</span><br><span class="line"><span class="built_in">DAC_DMACmd</span>(DAC_Channel_2, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">TIM6_Config</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置DAC采样率和DMA数据长度，并启动DMA DAC</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_DMA_Start</span><span class="params">(<span class="type">uint32_t</span> freq, <span class="type">uint16_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//设置DMA缓冲长度需要停止DMA</span></span><br><span class="line"><span class="built_in">DAC_DMA_Stop</span>();</span><br><span class="line"><span class="comment">//设置DMA DAC缓冲长度</span></span><br><span class="line"><span class="built_in">DMA_SetCurrDataCounter</span>(DMA1_Stream5, len);</span><br><span class="line"><span class="built_in">DMA_SetCurrDataCounter</span>(DMA1_Stream6, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置定时器</span></span><br><span class="line"><span class="built_in">TIM_SetAutoreload</span>(TIM6, (<span class="type">uint16_t</span>)((CNT_FREQ)/freq));</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream5, ENABLE);</span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream6, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止DMA DAC</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_DMA_Stop</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream5, DISABLE);</span><br><span class="line"><span class="built_in">DMA_Cmd</span>(DMA1_Stream6, DISABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器6用于设置DAC刷新率</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TIM6_Config</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TIM_TimeBaseInitTypeDef TIM6_TimeBase;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RCC_APB1PeriphClockCmd</span>(RCC_APB1Periph_TIM6, ENABLE);</span><br><span class="line">  <span class="built_in">TIM_TimeBaseStructInit</span>(&amp;TIM6_TimeBase);</span><br><span class="line"></span><br><span class="line">  TIM6_TimeBase.TIM_Period        = (<span class="type">uint16_t</span>)((CNT_FREQ)/<span class="number">44100</span>);</span><br><span class="line">  TIM6_TimeBase.TIM_Prescaler     = <span class="number">0</span>;</span><br><span class="line">  TIM6_TimeBase.TIM_ClockDivision = <span class="number">0</span>;</span><br><span class="line">  TIM6_TimeBase.TIM_CounterMode   = TIM_CounterMode_Up;</span><br><span class="line">  <span class="built_in">TIM_TimeBaseInit</span>(TIM6, &amp;TIM6_TimeBase);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TIM_SelectOutputTrigger</span>(TIM6, TIM_TRGOSource_Update);</span><br><span class="line">  <span class="built_in">TIM_Cmd</span>(TIM6, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  DAC out1 PA4输出电压</span></span><br><span class="line"><span class="comment">  * @param  dat：dac数值:，0~4095</span></span><br><span class="line"><span class="comment">  * @retval none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_Out1</span><span class="params">(<span class="type">uint16_t</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DAC_SetChannel1Data</span>(DAC_Align_12b_R,  dat);</span><br><span class="line"><span class="built_in">DAC_SoftwareTriggerCmd</span>(DAC_Channel_1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  DAC out2 PA5输出电压</span></span><br><span class="line"><span class="comment">  * @param  dat：dac数值:，0~4095</span></span><br><span class="line"><span class="comment">  * @retval none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DAC_Out2</span><span class="params">(<span class="type">uint16_t</span> dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">DAC_SetChannel2Data</span>(DAC_Align_12b_R,  dat);</span><br><span class="line"><span class="built_in">DAC_SoftwareTriggerCmd</span>(DAC_Channel_2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************* *****END OF FILE****/</span></span><br></pre></td></tr></table></figure><p>源码：MP3播放流程 （原创野火，参考了野火的例程，本人进行整理和修改）</p><p>MP3player.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">******************************************************************************</span></span><br><span class="line"><span class="comment">* @file    mp3Player.c</span></span><br><span class="line"><span class="comment">* @author  fire</span></span><br><span class="line"><span class="comment">* @version V1.0</span></span><br><span class="line"><span class="comment">* @date    2023-08-13</span></span><br><span class="line"><span class="comment">* @brief   mp3解码</span></span><br><span class="line"><span class="comment">******************************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ff.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp3Player.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp3dec.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dac.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐使用以下格式mp3文件：</span></span><br><span class="line"><span class="comment"> * 采样率：44100Hz</span></span><br><span class="line"><span class="comment"> * 声  道：2</span></span><br><span class="line"><span class="comment"> * 比特率：320kbps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理立体声音频数据时，输出缓冲区需要的最大大小为2304*16/8字节(16为PCM数据为16位)，</span></span><br><span class="line"><span class="comment"> * 这里我们定义MP3BUFFER_SIZE为2304</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MP3BUFFER_SIZE  2304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUTBUF_SIZE   3000</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> HMP3DecoderMp3Decoder;<span class="comment">/* mp3解码器指针*/</span></span><br><span class="line"><span class="type">static</span> MP3FrameInfoMp3FrameInfo;<span class="comment">/* mP3帧信息  */</span></span><br><span class="line"><span class="type">static</span> MP3_TYPE mp3player;            <span class="comment">/* mp3播放设备 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> Isread = <span class="number">0</span>;          <span class="comment">/* DMA传输完成标志 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> dac_ht = <span class="number">0</span>;          <span class="comment">//DAC dma 半传输标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> led_delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> inputbuf[INPUTBUF_SIZE]=&#123;<span class="number">0</span>&#125;;     <span class="comment">/* 解码输入缓冲区，1940字节为最大MP3帧大小  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> outbuffer[MP3BUFFER_SIZE];  <span class="comment">/* 解码输出缓冲区*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> FIL file;<span class="comment">/* file objects */</span></span><br><span class="line"><span class="type">static</span> UINT bw;       <span class="comment">/* File R/W count */</span></span><br><span class="line">FRESULT result;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从SD卡读取MP3源文件进行解码，并传入DAC缓冲区</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MP3DataDecoder</span><span class="params">(<span class="type">uint8_t</span> **read_ptr, <span class="type">int</span> *bytes_left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> err = <span class="number">0</span>, i = <span class="number">0</span>, outputSamps = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bufflag开始解码 参数：mp3解码结构体、输入流指针、输入流大小、输出流指针、数据格式</span></span><br><span class="line">err = <span class="built_in">MP3Decode</span>(Mp3Decoder, read_ptr, bytes_left, outbuffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != ERR_MP3_NONE)<span class="comment">//错误处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (err)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ERR_MP3_INDATA_UNDERFLOW:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERR_MP3_INDATA_UNDERFLOW\r\n&quot;</span>);</span><br><span class="line">result = <span class="built_in">f_read</span>(&amp;file, inputbuf, INPUTBUF_SIZE, &amp;bw);</span><br><span class="line">*read_ptr = inputbuf;</span><br><span class="line">*bytes_left = bw;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ERR_MP3_MAINDATA_UNDERFLOW:</span><br><span class="line"><span class="comment">/* do nothing - next call to decode will provide more mainData */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERR_MP3_MAINDATA_UNDERFLOW\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UNKNOWN ERROR:%d\r\n&quot;</span>, err);</span><br><span class="line"><span class="comment">// 跳过此帧</span></span><br><span class="line"><span class="keyword">if</span> (*bytes_left &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*bytes_left) --;</span><br><span class="line">read_ptr ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//解码无错误，准备把数据输出到PCM</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP3GetLastFrameInfo</span>(Mp3Decoder, &amp;Mp3FrameInfo);<span class="comment">//获取解码信息</span></span><br><span class="line"><span class="comment">/* 输出到DAC */</span></span><br><span class="line">outputSamps = Mp3FrameInfo.outputSamps;<span class="comment">//PCM数据个数</span></span><br><span class="line"><span class="keyword">if</span> (outputSamps &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Mp3FrameInfo.nChans == <span class="number">1</span>)<span class="comment">//单声道</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//单声道数据需要复制一份到另一个声道</span></span><br><span class="line"><span class="keyword">for</span> (i = outputSamps - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">outbuffer[i * <span class="number">2</span>] = outbuffer[i];</span><br><span class="line">outbuffer[i * <span class="number">2</span> + <span class="number">1</span>] = outbuffer[i];</span><br><span class="line">&#125;</span><br><span class="line">outputSamps *= <span class="number">2</span>;</span><br><span class="line">&#125;<span class="comment">//if (Mp3FrameInfo.nChans == 1)//单声道</span></span><br><span class="line">&#125;<span class="comment">//if (outputSamps &gt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据传送至DMA DAC缓冲区</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outputSamps/<span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dac_ht == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">DAC_buff[<span class="number">0</span>][i] = outbuffer[<span class="number">2</span>*i] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">DAC_buff[<span class="number">1</span>][i] = outbuffer[<span class="number">2</span>*i+<span class="number">1</span>] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DAC_buff[<span class="number">0</span>][i+outputSamps/<span class="number">2</span>] = outbuffer[<span class="number">2</span>*i] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">DAC_buff[<span class="number">1</span>][i+outputSamps/<span class="number">2</span>] = outbuffer[<span class="number">2</span>*i+<span class="number">1</span>] * mp3player.ucVolume /<span class="number">100</span> + <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//else 解码正常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一段MP3数据，并把读取的指针赋值read_ptr，长度赋值bytes_left</span></span><br><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">read_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *mp3file, <span class="type">uint8_t</span> **read_ptr, <span class="type">int</span> *bytes_left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">result = <span class="built_in">f_read</span>(&amp;file, inputbuf, INPUTBUF_SIZE, &amp;bw);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result != FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;读取%s失败 -&gt; %d\r\n&quot;</span>, mp3file, result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*read_ptr = inputbuf;</span><br><span class="line">*bytes_left = bw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  MP3格式音频播放主程序</span></span><br><span class="line"><span class="comment">  * @param  mp3file MP3文件路径</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mp3PlayerDemo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *mp3file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">uint8_t</span> *read_ptr = inputbuf;</span><br><span class="line"><span class="type">int</span>read_offset = <span class="number">0</span>;<span class="comment">/* 读偏移指针 */</span></span><br><span class="line"><span class="type">int</span>bytes_left = <span class="number">0</span>;<span class="comment">/* 剩余字节数 */</span></span><br><span class="line"></span><br><span class="line">mp3player.ucStatus = STA_IDLE;</span><br><span class="line">mp3player.ucVolume = <span class="number">15</span>; <span class="comment">//音量值，100满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试打开MP3文件</span></span><br><span class="line">result = <span class="built_in">f_open</span>(&amp;file, mp3file, FA_READ);</span><br><span class="line"><span class="keyword">if</span>(result != FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Open mp3file :%s fail!!!-&gt;%d\r\n&quot;</span>, mp3file, result);</span><br><span class="line">result = <span class="built_in">f_close</span> (&amp;file);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">/* 停止播放 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前播放文件 -&gt; %s\n&quot;</span>, mp3file);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化MP3解码器</span></span><br><span class="line">Mp3Decoder = <span class="built_in">MP3InitDecoder</span>();</span><br><span class="line"><span class="keyword">if</span>(Mp3Decoder == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化helix解码库设备失败！\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">/* 停止播放 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;初始化helix解码库完成\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试读取一段MP3数据，并把读取的指针赋值read_ptr，长度赋值bytes_left</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">read_file</span>(mp3file, &amp;read_ptr, &amp;bytes_left))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP3FreeDecoder</span>(Mp3Decoder);</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">/* 停止播放 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试解码成功</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">MP3DataDecoder</span>(&amp;read_ptr, &amp;bytes_left))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印MP3信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Bitrate       %dKbps&quot;</span>, Mp3FrameInfo.bitrate/<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Samprate      %dHz&quot;</span>,   Mp3FrameInfo.samprate);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n BitsPerSample %db&quot;</span>,    Mp3FrameInfo.bitsPerSample);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n nChans        %d&quot;</span>,     Mp3FrameInfo.nChans);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Layer         %d&quot;</span>,     Mp3FrameInfo.layer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n Version       %d&quot;</span>,     Mp3FrameInfo.version);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; \r\n OutputSamps   %d&quot;</span>,     Mp3FrameInfo.outputSamps);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动DAC，开始发声</span></span><br><span class="line"><span class="keyword">if</span> (Mp3FrameInfo.nChans == <span class="number">1</span>)<span class="comment">//单声道要将outputSamps*2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DAC_DMA_Start</span>(Mp3FrameInfo.samprate, <span class="number">2</span> * Mp3FrameInfo.outputSamps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//双声道直接用Mp3FrameInfo.outputSamps</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DAC_DMA_Start</span>(Mp3FrameInfo.samprate, Mp3FrameInfo.outputSamps);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//解码失败</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP3FreeDecoder</span>(Mp3Decoder);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 放音状态 */</span></span><br><span class="line">mp3player.ucStatus = STA_PLAYING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进入主程序循环体 */</span></span><br><span class="line"><span class="keyword">while</span>(mp3player.ucStatus == STA_PLAYING)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//寻找帧同步，返回第一个同步字的位置</span></span><br><span class="line">read_offset = <span class="built_in">MP3FindSyncWord</span>(read_ptr, bytes_left);</span><br><span class="line"><span class="keyword">if</span>(read_offset &lt; <span class="number">0</span>)<span class="comment">//没有找到同步字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">read_file</span>(mp3file, &amp;read_ptr, &amp;bytes_left))<span class="comment">//重新读取一次文件再找</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//回到while(mp3player.ucStatus == STA_PLAYING)后面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//找到同步字</span></span><br><span class="line">&#123;</span><br><span class="line">read_ptr   += read_offset;<span class="comment">//偏移至同步字的位置</span></span><br><span class="line">bytes_left -= read_offset;<span class="comment">//同步字之后的数据大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bytes_left &lt; <span class="number">1024</span>)<span class="comment">//如果剩余的数据小于1024字节，补充数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注意这个地方因为采用的是DMA读取，所以一定要4字节对齐  */</span></span><br><span class="line">u16 i = (<span class="type">uint32_t</span>)(bytes_left)&amp;<span class="number">3</span>;<span class="comment">//判断多余的字节</span></span><br><span class="line"><span class="keyword">if</span>(i) i=<span class="number">4</span>-i;<span class="comment">//需要补充的字节</span></span><br><span class="line"><span class="built_in">memcpy</span>(inputbuf+i, read_ptr, bytes_left);<span class="comment">//从对齐位置开始复制</span></span><br><span class="line">read_ptr = inputbuf+i;<span class="comment">//指向数据对齐位置</span></span><br><span class="line">result = <span class="built_in">f_read</span>(&amp;file, inputbuf+bytes_left+i, INPUTBUF_SIZE-bytes_left-i, &amp;bw);<span class="comment">//补充数据</span></span><br><span class="line"><span class="keyword">if</span>(result != FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;读取%s失败 -&gt; %d\r\n&quot;</span>,mp3file,result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bytes_left += bw;<span class="comment">//有效数据流大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3数据解码并送入DAC缓存</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">MP3DataDecoder</span>(&amp;read_ptr, &amp;bytes_left))</span><br><span class="line">&#123;<span class="comment">//如果播放出错，Isread置1，避免卡住死循环</span></span><br><span class="line">Isread = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3文件读取完成，退出</span></span><br><span class="line"><span class="keyword">if</span>(file.fptr == file.fsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单曲播放完毕\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待DAC发送一半或全部中断</span></span><br><span class="line"><span class="keyword">while</span>(Isread == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">led_delay++;</span><br><span class="line"><span class="keyword">if</span>(led_delay == <span class="number">0xffffff</span>)</span><br><span class="line">&#123;</span><br><span class="line">led_delay=<span class="number">0</span>;</span><br><span class="line">LED1_TROG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Input_scan();//等待DMA传输完成，此间可以运行按键扫描及处理事件</span></span><br><span class="line">&#125;</span><br><span class="line">Isread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行到此处，说明单曲播放完成，收尾工作</span></span><br><span class="line"><span class="built_in">DAC_DMA_Stop</span>();<span class="comment">//停止喂DAC数据</span></span><br><span class="line">mp3player.ucStatus = STA_IDLE;</span><br><span class="line"><span class="built_in">MP3FreeDecoder</span>(Mp3Decoder);<span class="comment">//清理缓存</span></span><br><span class="line"><span class="built_in">f_close</span>(&amp;file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DMA1_Stream6_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">DMA_GetITStatus</span>(DMA1_Stream6, DMA_IT_HTIF6) != RESET) <span class="comment">//半传输</span></span><br><span class="line">&#123;</span><br><span class="line">dac_ht = <span class="number">1</span>;</span><br><span class="line">Isread=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_HTIF6);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">DMA_GetITStatus</span>(DMA1_Stream6, DMA_IT_TCIF6) != RESET) <span class="comment">//全传输</span></span><br><span class="line">&#123;</span><br><span class="line">dac_ht = <span class="number">0</span>;</span><br><span class="line">Isread=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DMA_ClearITPendingBit</span>(DMA1_Stream6, DMA_IT_TCIF6);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************** (END OF FILE) *********************************/</span></span><br></pre></td></tr></table></figure><p>源码：main.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    ../User/main.c</span></span><br><span class="line"><span class="comment">  * @author  ZL</span></span><br><span class="line"><span class="comment">  * @version V1.0</span></span><br><span class="line"><span class="comment">  * @date    2015-12-26</span></span><br><span class="line"><span class="comment">  * @brief   Main program body</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hw_includes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ff.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exfuns.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp3Player.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历目录文件并打印输出</span></span><br><span class="line"><span class="function">u8 <span class="title">scan_files</span><span class="params">(u8 * path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FRESULT res;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> *fn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _USE_LFN</span></span><br><span class="line"> fileinfo.lfsize = _MAX_LFN * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">fileinfo.lfname = buf;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">res = <span class="built_in">f_opendir</span>(&amp;dir,(<span class="type">const</span> TCHAR*)path);</span><br><span class="line"><span class="keyword">if</span> (res == FR_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">f_readdir</span>(&amp;dir, &amp;fileinfo);</span><br><span class="line"><span class="keyword">if</span> (res != FR_OK || fileinfo.fname[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _USE_LFN</span></span><br><span class="line">fn = *fileinfo.lfname ? fileinfo.lfname : fileinfo.fname;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">fn = fileinfo.fname;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s/&quot;</span>, path);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Main program</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">delay_init</span>(<span class="number">168</span>);</span><br><span class="line"><span class="built_in">usart1_Init</span>(<span class="number">115200</span>);</span><br><span class="line"><span class="built_in">LED_Init</span>();</span><br><span class="line"><span class="built_in">DAC_Config</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">SD_Init</span>())</span><br><span class="line"> &#123;</span><br><span class="line"><span class="built_in">exfuns_init</span>();<span class="comment">//为fatfs相关变量申请内存</span></span><br><span class="line"><span class="built_in">f_mount</span>(fs[<span class="number">0</span>],<span class="string">&quot;0:&quot;</span>,<span class="number">1</span>); <span class="comment">//挂载SD卡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印SD目录和文件</span></span><br><span class="line"><span class="built_in">scan_files</span>(<span class="string">&quot;0:&quot;</span>);</span><br><span class="line"></span><br><span class="line">LED0_ON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mp3PlayerDemo</span>(<span class="string">&quot;0:/断桥残雪.MP3&quot;</span>);</span><br><span class="line"><span class="built_in">mp3PlayerDemo</span>(<span class="string">&quot;0:/张国荣-玻璃之情.MP3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">delay_ms</span>(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为方便调试测试，使用usart1打印数据。实测效果：</p><p><img src="https://img-blog.csdnimg.cn/bad9436c9a4e40de9bbd62abbae67b7c.jpeg"></p><p><img src="https://img-blog.csdnimg.cn/54ff22470d72499bb3e585a487abab46.jpeg"></p><p>程序源码与原理图，测试音频：</p><p>链接：<a href="https://pan.baidu.com/s/10hYXkrqnuBQgs0DWKLUUOA?pwd=iatt">https://pan.baidu.com/s/10hYXkrqnuBQgs0DWKLUUOA?pwd=iatt</a><br>提取码：iatt</p><p>知道这里下载要积分登录什么的麻烦得很，所以程序放到百度网盘了，假如连接失效，记得在评论区喊我更新！</p><p>理论上STM32F1或者其他系列也能用这个方案，要自己改改测试喽，本文把思路分享出来抛砖引玉。</p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32】HAL库 STM32CubeMX教程十三---RTC时钟</title>
      <link href="/2024/03/stm32-stm32-%E3%80%90STM32%E3%80%91HAL%E5%BA%93-STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-RTC%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/stm32-stm32-%E3%80%90STM32%E3%80%91HAL%E5%BA%93-STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-RTC%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>前言：</p><p>本系列教程将 对应外设原理，HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用</p><p>所用工具：</p><p>1、芯片： STM32F407ZET6&#x2F; STM32F103ZET6</p><p>2、STM32CubeMx软件</p><p>3、IDE： MDK-Keil软件</p><p>4、STM32F1xx&#x2F;STM32F4xxHAL库</p><p>知识概括：</p><p>通过本篇博客您将学到：</p><p>RTC时钟原理</p><p>STM32CubeMX创建RTC例程</p><p>HAL库定时器RTC函数库</p><p><strong>PS: 这里的RTC讲解，我们只将原理，不讲寄存器，如果要看RTC的寄存器，请看这篇文章</strong><br><a href="https://blog.csdn.net/as480133937/article/details/105026033">【STM32】RTC实时时钟，步骤超细详解，一文看懂RTC</a></p><h3 id="什么是RTC"><a href="#什么是RTC" class="headerlink" title="什么是RTC"></a>什么是RTC</h3><p>**RTC (Real Time Clock)**：实时时钟</p><p><strong>RTC是个独立的定时器</strong>。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。</p><p><img src="https://img-blog.csdnimg.cn/20200423215123488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。</strong></p><p>RTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。</p><p>两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。</p><p>上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。</p><p>无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。</p><h4 id="RCT特征："><a href="#RCT特征：" class="headerlink" title="; RCT特征："></a><a name="rct_47">;</a> <strong>RCT特征：</strong></h4><p>● <strong>可编程的预分频系数：分频系数高为220。</strong><br>● <strong>32位的可编程计数器，可用于较长时间段的测量。</strong><br>● <strong>2个分离的时钟：用于APB1接口的PCLK1和RTC时钟(RTC时钟的频率必须小于PCLK1时钟 频率的四分之一以上)。</strong><br>● 可以选择以下 <strong>三种RTC的时钟源</strong>：<br>● HSE时钟除以128；<br>● LSE振荡器时钟；<br>● LSI振荡器时钟</p><p>● <strong>2个独立的复位类型：</strong><br>● APB1接口由系统复位；<br>● RTC核心(预分频器、闹钟、计数器和分频器)只能由后备域复位</p><p>● <strong>3个专门的可屏蔽中断：</strong><br>● 1. <strong>闹钟中断</strong>，用来产生一个软件可编程的闹钟中断。</p><p>● 2. <strong>秒中断</strong>，用来产生一个可编程的周期性中断信号(长可达1秒)。</p><p>● 3. <strong>溢出中断</strong>，指示内部可编程计数器溢出并回转为0的状态。</p><p><strong>RTC时钟源：</strong><br>三种不同的时钟源可被用来驱动系统时钟(SYSCLK)：</p><p>● <strong>HSI振荡器时钟</strong><br>● <strong>HSE振荡器时钟</strong><br>● <strong>PLL时钟</strong></p><p>这些设备有以下2种二级时钟源：</p><p>● 40kHz低速内部RC，可以用于驱动独立看门狗和通过程序选择驱动RTC。 RTC用于从停机&#x2F;待机模式下自动唤醒系统。<br>● 32.768kHz低速外部晶体也可用来通过程序选择驱动RTC(RTCCLK)。</p><h4 id="RTC原理框图"><a href="#RTC原理框图" class="headerlink" title="RTC原理框图"></a>RTC原理框图</h4><p><img src="https://img-blog.csdnimg.cn/20200322144525734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br>RTC时钟的框图还是比较简单的，这里我们把他分成 <strong><code>&amp;#x4E24;&amp;#x4E2A;&amp;#x90E8;&amp;#x5206;</code></strong>:</p><p><strong>APB1 接口</strong>：用来和 APB1 总线相连。 此单元还包含一组 16 位寄存器，可通过 APB1 总线对其进行读写操作。APB1 接口由 APB1 总 线时钟驱动，用来与 APB1 总线连接。</p><p>通过APB1接口可以访问RTC的相关寄存器（预分频值，计数器值，闹钟值）。</p><p><strong>RTC 核心接口</strong>：由一组可编程计数器组成，分成 ** <code>&amp;#x4E24;&amp;#x4E2A;&amp;#x4E3B;&amp;#x8981;&amp;#x6A21;&amp;#x5757;</code>** 。<br><img src="https://img-blog.csdnimg.cn/20200322223612113.png">g)<br><strong>第一个模块是 RTC 的 预分频模块</strong>，它可编程产生 1 秒的 RTC 时间基准 TR_CLK。RTC 的预分频模块包含了一个 20 位的可编程分频器(RTC 预分频器)。如果在 RTC_CR 寄存器中设置了相应的允许位，则在每个 TR_CLK 周期中 RTC 产生一个中断(秒中断)。<br><img src="https://img-blog.csdnimg.cn/2020032222362770.png"><br><strong>第二个模块是一个 32 位的可编程计数器 （RTC_CNT）</strong>，可被初始化为当前的系统时间，一个 32 位的时钟计数器，按秒钟计算，可以记 录 4294967296 秒，约合 136 年左右，作为一般应用，这已经是足够了的。</p><h4 id="RTC具体流程："><a href="#RTC具体流程：" class="headerlink" title="; RTC具体流程："></a><a name="rtc_107">;</a> <strong>RTC具体流程：</strong></h4><p><strong>RTCCLK经过RTC_DIV预分频，RTC_PRL设置预分频系数，然后得到TR_CLK时钟信号，我们一般设置其周期为1s，RTC_CNT计数器计数，假如1970设置为时间起点为0s，通过当前时间的秒数计算得到当前的时间。RTC_ALR是设置闹钟时间，RTC_CNT计数到RTC_ALR就会产生计数中断，</strong></p><ul><li><strong>RTC_Second</strong>为秒中断，用于刷新时间，</li><li><strong>RTC_Overflow</strong>是溢出中断。</li><li><strong>RTC Alarm</strong> 控制开关机</li></ul><h4 id="RTC时钟选择"><a href="#RTC时钟选择" class="headerlink" title="RTC时钟选择"></a>RTC时钟选择</h4><p><strong>使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响,因此没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE,频率为实时时钟模块中常用的32.768KHz,因为32768 &#x3D; 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</strong></p><h4 id="RTC复位过程"><a href="#RTC复位过程" class="headerlink" title="RTC复位过程"></a>RTC复位过程</h4><p>除了RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器外，所有的系统寄存器都由系统复位或电源复位进行异步复位。<br>RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器仅能通过备份域复位信号复位。</p><p><strong>系统复位后,禁止访问后备寄存器和RCT,防止对后卫区域(BKP)的意外写操作</strong></p><h4 id="RTC中断"><a href="#RTC中断" class="headerlink" title="RTC中断"></a>RTC中断</h4><p><strong>秒中断：</strong><br>这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的”秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p><p><strong>闹钟中断：</strong><br>闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p><h3 id="CubeMX配置RTC"><a href="#CubeMX配置RTC" class="headerlink" title="CubeMX配置RTC"></a>CubeMX配置RTC</h3><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p><strong>1设置RCC</strong><br><img src="https://img-blog.csdnimg.cn/20200425101549368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li><strong>设置高速外部时钟HSE 选择外部时钟源</strong></li><li>*<em>使能外部晶振LSE</em></li></ul><p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE</strong></p><ol start="2"><li><strong>配置RTC</strong><br><img src="https://img-blog.csdnimg.cn/20200425110730403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></li></ol><ul><li><strong>Activate Clock Source 激活时钟源</strong></li><li>*<em>Activate calendar激活日历</em></li></ul><p><strong>这两个都要点，作用也很明显，先是使能时钟源，再使能RTC日历</strong></p><ul><li><strong>RTC_OUT： Not RTC_OUT</strong></li><li><strong>Tamper：</strong> *<em>×</em></li></ul><p>第一个是是否使能 <strong>tamper（PC13）引脚上输出校正的秒脉冲时钟，</strong></p><p>第二个： <strong>RTC入侵检测校验功能</strong></p><p><strong>RTC校验功能，使能侵入检测功能。RTC时钟经64分频输出到侵入检测引脚TAMPER上<br> 当 TAMPER引脚上的信号从 0变成1或者从 1变成 0(取决于备份控制寄存器BKP_CR的 TPAL位)，会产生一个侵入检测事件。侵入检测事件将所有数据备份寄存器内容清除。</strong></p><ol><li>也就是第一个是使能tamper（PC13）引脚作为时钟脉冲输出</li><li>第二个是使能tamper（PC13）引脚作为入侵检测功能</li></ol><p>下面是两个RTC的中断：</p><ul><li><strong>RTC全局中断RTC_IRQHandler()</strong></li><li>*<em>闹钟中断函数RTCAlarm_IRQHandler()</em></li></ul><p><img src="https://img-blog.csdnimg.cn/2020042514381771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>此处设置时间为2020&#x2F;04&#x2F;25 13:30:00</strong></p><ul><li>Data Format: 日期格式</li></ul><p><strong>Binary data format 十六进制<br>BCD data format BCD码进制</strong></p><p>使用自动配置，初始化时间必须使用BCD data format，原因是库函数存在bug，如果使用Binary data format，月份配置会出错，比如说11月，配置时会赋值为RTC_MONTH_NOVEMBER，而此宏定义值为0x11，也就是说其十进制值为17</p><ul><li><strong>Hours： 小时</strong></li><li><strong>Minutes： 分钟</strong></li><li><strong>Seconds： 秒</strong></li><li><strong>Week Day： 星期</strong></li><li><strong>Month 月份</strong></li><li><strong>Date： 日期</strong></li><li>*<em>Year： 年份</em></li></ul><p><strong>3 使能串口</strong><br><img src="https://img-blog.csdnimg.cn/20200425143944495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br><strong>使能一下串口，因为发送日期到上位机</strong></p><p><strong>4时钟源设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144337169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>我的是 外部晶振为8MHz</p><ul><li>1选择外部时钟HSE 8MHz</li><li>2PLL锁相环倍频9倍</li><li>3系统时钟来源选择为PLL</li><li>4设置APB1分频器为 &#x2F;2</li><li>5 使能CSS监视时钟</li><li>*<em>6 设置RTC时钟为LSE</em></li></ul><p>32的时钟树框图 如果不懂的话请看<a href="https://blog.csdn.net/as480133937/article/details/98845509">《【STM32】系统时钟RCC详解(超详细，超全面)》</a></p><p><strong>5项目文件设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li>1 设置项目名称</li><li>2 设置存储路径</li><li>3 选择所用IDE<br><img src="https://img-blog.csdnimg.cn/2020042514462236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></li></ul><p><strong>6创建工程文件</strong></p><p><strong>然后点击GENERATE CODE 创建工程</strong></p><p><strong>配置下载工具</strong><br>新建的工程所有配置都是默认的 我们需要自行选择下载模式，勾选上下载后复位运行</p><p><img src="https://img-blog.csdnimg.cn/202004251446415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC-HAL库函数"><a href="#RTC-HAL库函数" class="headerlink" title=";  RTC_HAL库函数"></a><a name="rtc_hal_243">;</a>  RTC_HAL库函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm_IT</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"></span><br><span class="line">__weak <span class="keyword">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)</span></span><br><span class="line"></span><br><span class="line">uint32_t <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister</span></span><br></pre></td></tr></table></figure><p>我们可以看到前面的四个函数，分别是</p><ul><li><strong>设置系统时间：HAL_RTC_SetTime();</strong></li><li><strong>读取系统时间: HAL_RTC_GetTime();</strong></li><li><strong>设置系统日期: HAL_RTC_SetDate();</strong></li><li>*<em>读取系统日期: HAL_RTC_GetDate();</em></li></ul><p>因为系统的时间和日期开始的时候已经设置过了，所以我们这里只用两个读取函数</p><p><strong>读取系统时间函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的时间</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2</li><li><strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体，</li><li>Format： <strong>获取时间的格式</strong><br>*<em>RTC_FORMAT_BIN 使用16进制<br>RTC_FORMAT_BCD 使用BCD进制</em></li></ul><p><strong>读取系统日期函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的日期</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2</li><li><strong>RTC_DateTypeDef</strong> *sTime： 获取RTC日期的结构体，</li><li>Format： <strong>获取日期的格式</strong><br>*<em>RTC_FORMAT_BIN 使用16进制<br>RTC_FORMAT_BCD 使用BCD进制</em></li></ul><p>在stm32f1xx_hal_rtc.h头文件中，可以找到 <code>RTC_TimeTypeDef</code>， <code>RTC_DateTypeDef</code>这两个结构体的成员变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;</span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;</span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br></pre></td></tr></table></figure><p><strong>程序代码：</strong></p><p>main.c</p><p><strong>在main.c中重写fputc函数，使得能够使用printf函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *f)</span>&#123;</span><br><span class="line"> <span class="type">uint8_t</span> temp[<span class="number">1</span>]=&#123;ch&#125;;</span><br><span class="line"> HAL_UART_Transmit(&amp;huart1,temp,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义两个结构体来获取日期和时间：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTC_DateTypeDef GetData;</span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef GetTime;</span><br></pre></td></tr></table></figure><p>在while循环中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">   HAL_RTC_GetDate(&amp;hrtc, &amp;GetData, RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%02d/%02d/%02d\r\n&quot;</span>,<span class="number">2000</span> + GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d\r\n&quot;</span>,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><strong>程序中使用HAL_RTC_GetTime（）,HAL_RTC_GetDate()读取时间和日期，并保存到结构体变量中，然后通过串口输出读取的时间和日期。</strong></p><p><strong>例程测试正常：</strong><br><img src="https://img-blog.csdnimg.cn/20200425153330941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC掉电重置"><a href="#RTC掉电重置" class="headerlink" title="RTC掉电重置"></a>RTC掉电重置</h4><p>但是呢，在hal库中生成的代码， <strong>每次断电就RTC时间会重置</strong>，每次上电都会重新初始化时间</p><p>因为HAL库设置了一个BKP寄存器保存一个标志。每次单片机启动时都读取这个标志并判断是不是预先设定的值：如度果不是就初始化RTC并设置时间，再设置标志为预期值；如果是预期值就跳过初始化和时间设置，继续执行后面的程序</p><p><strong>所以这里我们只需要每次上电执行RTC初始化之前，将标志设置为预期值即可</strong></p><p><strong>在rtc.c中的RTC_Init修改为以下内容即可</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">MX_RTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef time;</span><br><span class="line">RTC_DateTypeDef datebuff;</span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__HAL_RCC_BKP_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= <span class="number">0x5051</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  sTime.Hours = <span class="number">0x14</span>;</span><br><span class="line">  sTime.Minutes = <span class="number">0x30</span>;</span><br><span class="line">  sTime.Seconds = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  DateToUpdate.WeekDay = RTC_WEEKDAY_SATURDAY;</span><br><span class="line">  DateToUpdate.Month = RTC_MONTH_APRIL;</span><br><span class="line">  DateToUpdate.Date = <span class="number">0x25</span>;</span><br><span class="line">  DateToUpdate.Year = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC);</span><br><span class="line">datebuff = DateToUpdate;</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, <span class="number">0x5051</span>);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR2, (<span class="type">uint16_t</span>)datebuff.Year);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR3, (<span class="type">uint16_t</span>)datebuff.Month);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR4, (<span class="type">uint16_t</span>)datebuff.Date);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR5, (<span class="type">uint16_t</span>)datebuff.WeekDay);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">datebuff.Year    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR2);</span><br><span class="line">datebuff.Month   = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR3);</span><br><span class="line">datebuff.Date    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR4);</span><br><span class="line">datebuff.WeekDay = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR5);</span><br><span class="line">DateToUpdate = datebuff;</span><br><span class="line"><span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BIN) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425165901167.gif"><br><img src="https://img-blog.csdnimg.cn/20200425165904365.gif"></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32HAL库，RC522（RFID）模块读写驱动，无线IC卡读写</title>
      <link href="/2024/03/stm32-%E5%9F%BA%E4%BA%8ESTM32HAL%E5%BA%93%EF%BC%8CRC522%EF%BC%88RFID%EF%BC%89%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99%E9%A9%B1%E5%8A%A8%EF%BC%8C%E6%97%A0%E7%BA%BFIC%E5%8D%A1%E8%AF%BB%E5%86%99/"/>
      <url>/2024/03/stm32-%E5%9F%BA%E4%BA%8ESTM32HAL%E5%BA%93%EF%BC%8CRC522%EF%BC%88RFID%EF%BC%89%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99%E9%A9%B1%E5%8A%A8%EF%BC%8C%E6%97%A0%E7%BA%BFIC%E5%8D%A1%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、模块简短介绍"><a href="#一、模块简短介绍" class="headerlink" title="一、模块简短介绍"></a>一、模块简短介绍</h2><p>有关RC522模块的背景知识以及工作原理，本次实验暂时不做分享，这里贴上两位写得很好的博主，大家可自行查看。</p><p><a href="https://blog.csdn.net/m0_51220742/article/details/123683745" title="(5条消息) RC522(RFID)读写驱动_桃成蹊2.0的博客-CSDN博客">(5条消息) RC522(RFID)读写驱动_桃成蹊2.0的博客-CSDN博客<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8">https://blog.csdn.net/m0_51220742&#x2F;article&#x2F;details&#x2F;123683745 ;</a> <a href="https://blog.csdn.net/weixin_45771489/article/details/124079134" title="(5条消息) STM32--RFID无线射频技术（RC522刷卡模块）_rc522射频模块详细资料_y黎好好的博客-CSDN博客">(5条消息) STM32–RFID无线射频技术（RC522刷卡模块）_rc522射频模块详细资料_y黎好好的博客-CSDN博客<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8">https://blog.csdn.net/weixin_45771489&#x2F;article&#x2F;details&#x2F;124079134 ;</a></p><p><img src="https://img-blog.csdnimg.cn/b829df1211c843b49139edf393f1aa42.jpeg"></p><p>该模块价格普遍实惠，所以我买了一个自己玩玩。经过一段时间的摸爬滚打目前能够正常读写，后续会继续完善该模块的使用，并加入到其他嵌入式设计中。</p><h2 id="二、开发资料的使用及经验分享"><a href="#二、开发资料的使用及经验分享" class="headerlink" title="二、开发资料的使用及经验分享"></a>二、开发资料的使用及经验分享</h2><p>该模块的API函数淘宝有很多资源，数据手册也有，不过是英文版的。建议大家有时间还是要过一数据手册的重要部分，比如寄存器和指令集，通信协议等，可以使用知云文献查看，我习惯用它来看论文，适合翻译长段大段。也可以用WPS的翻译，小部分翻译，看个人使用习惯。要是有能力直接撸原文那就更好，节约时间。</p><p><img src="https://img-blog.csdnimg.cn/2e92c08f81ca46af8c0d2361b9d2e130.png"></p><p>找过很多资料，提供的API无非就是一套没有章法，毫无可读性的杂乱代码，十分影响学习效果。这里建议大家不要去死磕，可以看本次实验的代码逻辑和上文提到的两位博主，每一个底层函数都有注释，在一些底层函数的逻辑上可以结合这些API函数进行反推或者校验，可以帮助读者理解实现原理。</p><p>一开始是通过数据手册，硬着头皮啃无良店铺给的代码，没有注释，没有逻辑，没有章法。虽然没报错，但是能不能用完全不知道，就是这一步就花了好几天时间，所以建议大家不要像我一样埋头苦读，可以先看每一个函数的中文注释，整理出一个框架。</p><h2 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h2><p>代码总体逻辑没有变化，参考了两位博主的思路，我用官方的API函数进行修改。两位博主一位使用的软件实现SPI协议，一位使用板载SPI。两种方法我都试过，但是软件SPI协议总是通信失败，不知道是我协议写的不对还是通信速度和模块不匹配，暂时还未解决。</p><h3 id="软件模拟SPI"><a href="#软件模拟SPI" class="headerlink" title="软件模拟SPI"></a><strong>软件模拟SPI</strong></h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SOFT_SPI_RC522_SendByte</span></span><br><span class="line"><span class="comment"> * 描述  ：向RC522发送1 Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：write_dat，要发送的数据</span></span><br><span class="line"><span class="comment"> * 返回  : RC522返回的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOFT_SPI_RC522_SendByte</span>(<span class="params">uint8_t write_dat</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i</span><br></pre></td></tr></table></figure><p>有大佬如果发现问题，还请给我留言，也不知道是什么原因导致通信失败。</p><h3 id="板载SPI通信"><a href="#板载SPI通信" class="headerlink" title="板载SPI通信"></a><strong>板载SPI通信</strong></h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SPI_WriteNBytes</span></span><br><span class="line"><span class="comment"> * 描述  ：向RC522发送n Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：SPIx : 要发送数据的SPI</span></span><br><span class="line"><span class="comment"> * 输入  ：p_TxData : 要发送的数据</span></span><br><span class="line"><span class="comment"> * 输入  ：sendDataNum : 要发送的数据量(Byte)</span></span><br><span class="line"><span class="comment"> * 返回  : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SPI_WriteNBytes</span>(<span class="params">SPI_TypeDef* SPIx, uint8_t *p_TxData,uint32_t sendDataNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sendDataNum--)&#123;</span><br><span class="line"><span class="keyword">while</span>((SPIx-&gt;SR&amp;SPI_FLAG_TXE)==<span class="number">0</span>)<span class="comment">//等待发送区空</span></span><br><span class="line">&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR=*p_TxData++;<span class="comment">//发送一个byte</span></span><br><span class="line">retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((SPIx-&gt;SR&amp;SPI_FLAG_RXNE)==<span class="number">0</span>)<span class="comment">//等待接收完一个byte</span></span><br><span class="line">&#123;</span><br><span class="line">SPIx-&gt;SR = SPIx-&gt;SR;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SPI_ReadNBytes</span></span><br><span class="line"><span class="comment"> * 描述  ：读取RC522 n Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：SPIx : 要读取数据的SPI</span></span><br><span class="line"><span class="comment"> * 输入  ：p_RxData : 要读取的数据</span></span><br><span class="line"><span class="comment"> * 输入  ：readDataNum : 要读取的数据量(Byte)</span></span><br><span class="line"><span class="comment"> * 返回  : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SPI_ReadNBytes</span>(<span class="params">SPI_TypeDef* SPIx, uint8_t *p_RxData,uint32_t readDataNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(readDataNum--)&#123;</span><br><span class="line">SPIx-&gt;DR = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_TXE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_RXNE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p_RxData++ = SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本实验使用读取寄存器状态来完成SPI通信，未使用HAL_SPI_TransmitReceive库函数。</p><h3 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h3><p>主函数比较简略，调用一个操作函数，用按键触发的方式启动该函数实现读写。main.c 中，加入以下代码：</p><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   RC522_Init();</span><br><span class="line">uint8_t key;</span><br><span class="line"></span><br><span class="line">   uint8_t Write_Card_Data[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//要写入的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = key_scan();<span class="comment">//按键扫描函数，自己定义修改</span></span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RC522_Start(<span class="number">5</span>,readID,Write_Card_Data);<span class="comment">//readID  读命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">RC522_Start(<span class="number">5</span>,writeID,Write_Card_Data);<span class="comment">//writeID  写命令</span></span><br><span class="line">&#125;</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">LED0=!LED0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RC522部分"><a href="#RC522部分" class="headerlink" title="RC522部分"></a>RC522部分</h4><p><strong>RC522.c</strong></p><p>其中RC522_Start是自定义函数，只要操作流程正确，可自行编写想要的操作方式，本实验只完成简单的单块读写操作。蓝卡和白卡的卡号根据自己的修改，可以通过手机NFC功能查看卡号，同时也能查看扇区数据，APP可以使用上文提到的博主推荐的NFC Writer。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;RC522.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;stdio.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;spi.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;oled.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;string.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M1卡分为16个扇区，每个扇区由四个块（块0、块1、块2、块3）组成</span></span><br><span class="line"><span class="comment">// 将16个扇区的64个块按绝对地址编号为：0~63,每块16个字节</span></span><br><span class="line"><span class="comment">// 第0个扇区的块0（即绝对地址0块），用于存放厂商代码，已经固化不可更改</span></span><br><span class="line"><span class="comment">// 每个扇区的块0、块1、块2为数据块，可用于存放数据</span></span><br><span class="line"><span class="comment">// 每个扇区的块3为控制块（绝对地址为:块3、块7、块11.....）包括密码A，存取控制、密码B等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RC522_SPI_GPIO_Init();<span class="comment">//初始化RC522的复位引脚和片选引脚</span></span><br><span class="line"></span><br><span class="line">SPI1_Init();<span class="comment">//初始化SPI</span></span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">50</span>);</span><br><span class="line">PcdReset();<span class="comment">//复位RC522读卡器</span></span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line">PcdAntennaOff();<span class="comment">//关闭天线发射</span></span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line">    PcdAntennaOn();<span class="comment">//开启天线发射</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;RFID-MFRC522 初始化完成\nPress KEY0 Or KEY1 To Start...\r\n&quot;</span>);  <span class="comment">//初始化完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t IC_UID[<span class="number">4</span>]; <span class="comment">//UID卡片序列号,4字节</span></span><br><span class="line">uint8_t IC_Type[<span class="number">2</span>];<span class="comment">//卡类型代码，2字节,0x0400，Mifare_One(S50)</span></span><br><span class="line">uint8_t card_1[<span class="number">4</span>]=&#123;<span class="number">0xC3</span>,<span class="number">0xB2</span>,<span class="number">0x37</span>,<span class="number">0xC5</span>&#125;;<span class="comment">//蓝卡1卡号</span></span><br><span class="line">uint8_t card_2[<span class="number">4</span>]=&#123;<span class="number">0xA3</span>,<span class="number">0x09</span>,<span class="number">0x3C</span>,<span class="number">0xFB</span>&#125;;<span class="comment">//白卡2卡号</span></span><br><span class="line">uint8_t ID_num=<span class="number">0</span>;<span class="comment">//当前操作的序号</span></span><br><span class="line">uint8_t Card_KEY[<span class="number">6</span>]=&#123;<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>&#125;;<span class="comment">//验证密码</span></span><br><span class="line">uint8_t Card_Data[<span class="number">16</span>];<span class="comment">//读取出的块数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：RC522_Start</span></span><br><span class="line"><span class="comment"> * 输入  block：要操作的块地址</span></span><br><span class="line"><span class="comment"> * 输入  option：读操作或写操作</span></span><br><span class="line"><span class="comment"> *              readID  1//读</span></span><br><span class="line"><span class="comment"> *writeID 2//写</span></span><br><span class="line"><span class="comment"> * 输入  block：要操作的块地址</span></span><br><span class="line"><span class="comment"> * 描述  ：RC522操作主函数，可完成对卡的读写操作</span></span><br><span class="line"><span class="comment"> *  * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = 1，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Start</span>(<span class="params">uint8_t block,uint8_t option,uint8_t *Write_Card_Data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PcdRequest(PICC_REQALL,IC_Type) == MI_OK)<span class="comment">//寻卡</span></span><br><span class="line">&#123;</span><br><span class="line">uint16_t cardType = (IC_Type[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | IC_Type[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">switch</span> (cardType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4400</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare UltraLight\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0400</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare One(S50)\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0200</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare One(S70)\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0800</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare Pro(X)\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4403</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare DESFire\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nUnknown Card\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(PcdAnticoll(IC_UID)==MI_OK)<span class="comment">//防冲撞</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((IC_UID[<span class="number">0</span>]==card_1[<span class="number">0</span>])&amp;&amp;(IC_UID[<span class="number">1</span>]==card_1[<span class="number">1</span>])&amp;&amp;(IC_UID[<span class="number">2</span>]==card_1[<span class="number">2</span>])&amp;&amp;(IC_UID[<span class="number">3</span>]==card_1[<span class="number">3</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                ID_num=<span class="number">1</span>;</span><br><span class="line">                printf(<span class="string">&quot;The User is: %d, Blue card&quot;</span>,ID_num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((IC_UID[<span class="number">0</span>]==card_2[<span class="number">0</span>])&amp;&amp;(IC_UID[<span class="number">1</span>]==card_2[<span class="number">1</span>])&amp;&amp;(IC_UID[<span class="number">2</span>]==card_2[<span class="number">2</span>])&amp;&amp;(IC_UID[<span class="number">3</span>]==card_2[<span class="number">3</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                ID_num=<span class="number">2</span>;</span><br><span class="line">                printf(<span class="string">&quot;The User is: %d, White card&quot;</span>,ID_num);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(<span class="string">&quot;\r\ncard_ID: %02X:%02X:%02X:%02X\r\n&quot;</span>,IC_UID[<span class="number">0</span>],IC_UID[<span class="number">1</span>],IC_UID[<span class="number">2</span>],IC_UID[<span class="number">3</span>]); <span class="comment">//打印卡的UID号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PcdSelect(IC_UID)==MI_OK)<span class="comment">//选卡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(PcdAuthState(PICC_AUTHENT1A,block,Card_KEY,IC_UID)==MI_OK)<span class="comment">//验证A密钥,对应块</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//memset(Card_Data,1,16);</span></span><br><span class="line"><span class="keyword">if</span>(option==readID)<span class="comment">//读操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(PcdRead(block,Card_Data)==MI_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">&quot;\n读取结果: \n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;block %d date:\r\n&quot;</span>,block);</span><br><span class="line">categories:</span><br><span class="line">    - stm32</span><br><span class="line">    - stm32hal库开发</span><br><span class="line">tags:</span><br><span class="line">    - stm32</span><br><span class="line">    - 外设</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;iSR&amp;SPI_FLAG_TXE)==<span class="number">0</span>)<span class="comment">//等待发送区空</span></span><br><span class="line">&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR=*p_TxData++;<span class="comment">//发送一个byte</span></span><br><span class="line">retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((SPIx-&gt;SR&amp;SPI_FLAG_RXNE)==<span class="number">0</span>)<span class="comment">//等待接收完一个byte</span></span><br><span class="line">&#123;</span><br><span class="line">SPIx-&gt;SR = SPIx-&gt;SR;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SPI_ReadNBytes</span></span><br><span class="line"><span class="comment"> * 描述  ：读取RC522 n Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：SPIx : 要读取数据的SPI</span></span><br><span class="line"><span class="comment"> * 输入  ：p_RxData : 要读取的数据</span></span><br><span class="line"><span class="comment"> * 输入  ：readDataNum : 要读取的数据量(Byte)</span></span><br><span class="line"><span class="comment"> * 返回  : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SPI_ReadNBytes</span>(<span class="params">SPI_TypeDef* SPIx, uint8_t *p_RxData,uint32_t readDataNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(readDataNum--)&#123;</span><br><span class="line">SPIx-&gt;DR = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_TXE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_RXNE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p_RxData++ = SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdComMF522</span></span><br><span class="line"><span class="comment"> * 描述  ：通过RC522和ISO14443卡通讯</span></span><br><span class="line"><span class="comment"> * 输入  ：ucCommand，RC522命令字</span></span><br><span class="line"><span class="comment"> *         pInData，通过RC522发送到卡片的数据</span></span><br><span class="line"><span class="comment"> *         ucInLenByte，发送数据的字节长度</span></span><br><span class="line"><span class="comment"> *         pOutData，接收到的卡片返回数据</span></span><br><span class="line"><span class="comment"> *         pOutLenBit，返回数据的位长度</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> * 调用  ：内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdComMF522</span>(<span class="params">uint8_t Command,uint8_t *pInData,uint8_t InLenByte,uint8_t *pOutData,uint32_t *pOutLenBit</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status = MI_ERR;</span><br><span class="line">    uint8_t irqEn = <span class="number">0x00</span>;</span><br><span class="line">    uint8_t waitFor = <span class="number">0x00</span>;</span><br><span class="line">    uint8_t lastBits;</span><br><span class="line">    uint8_t n;</span><br><span class="line">    uint32_t i;</span><br><span class="line">    <span class="keyword">switch</span> (Command)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PCD_AUTHENT:   <span class="comment">//Mifare认证</span></span><br><span class="line">        irqEn = <span class="number">0x12</span>;   <span class="comment">//允许错误中断请求ErrIEn  允许空闲中断IdleIEn</span></span><br><span class="line">        waitFor = <span class="number">0x10</span>; <span class="comment">//认证寻卡等待时候 查询空闲中断标志位</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PCD_TRANSCEIVE:<span class="comment">//接收发送 发送接收</span></span><br><span class="line">        irqEn = <span class="number">0x77</span>;   <span class="comment">//允许TxIEn RxIEn IdleIEn LoAlertIEn ErrIEn TimerIEn</span></span><br><span class="line">        waitFor = <span class="number">0x30</span>; <span class="comment">//寻卡等待时候 查询接收中断标志位与 空闲中断标志位</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteRawRC(ComIEnReg, irqEn | <span class="number">0x80</span>); <span class="comment">//IRqInv置位管脚IRQ与Status1Reg的IRq位的值相反</span></span><br><span class="line">    ClearBitMask(ComIrqReg, <span class="number">0x80</span>);       <span class="comment">//Set1该位清零时，CommIRqReg的屏蔽位清零</span></span><br><span class="line">    WriteRawRC(CommandReg, PCD_IDLE);    <span class="comment">//写空闲命令</span></span><br><span class="line">    SetBitMask(FIFOLevelReg, <span class="number">0x80</span>);      <span class="comment">//置位FlushBuffer清除内部FIFO的读和写指针以及ErrReg的BufferOvfl标志位被清除</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; InLenByte; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteRawRC(FIFODataReg, pInData[i]);<span class="comment">//写数据进FIFOdata</span></span><br><span class="line">    &#125;</span><br><span class="line">    WriteRawRC(CommandReg, Command);<span class="comment">//写命令</span></span><br><span class="line">    <span class="keyword">if</span> (Command == PCD_TRANSCEIVE)</span><br><span class="line">    &#123;</span><br><span class="line">        SetBitMask(BitFramingReg, <span class="number">0x80</span>);<span class="comment">//StartSend置位启动数据发送 该位与收发命令使用时才有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">800</span>;<span class="comment">//根据时钟频率调整，操作M1卡最大等待时间25ms</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = ReadRawRC(ComIrqReg);<span class="comment">//查询事件中断</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i != <span class="number">0</span>) &amp;&amp; !(n &amp; <span class="number">0x01</span>) &amp;&amp; !(n &amp; waitFor));<span class="comment">//退出条件i=0,定时器中断，与写空闲命令</span></span><br><span class="line">    ClearBitMask(BitFramingReg, <span class="number">0x80</span>);<span class="comment">//清理允许StartSend位</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(ReadRawRC(ErrorReg) &amp; <span class="number">0x1B</span>))<span class="comment">//读错误标志寄存器BufferOfI CollErr ParityErr ProtocolErr</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_OK;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; irqEn &amp; <span class="number">0x01</span>)<span class="comment">//是否发生定时器中断</span></span><br><span class="line">            &#123;</span><br><span class="line">                status = MI_NOTAGERR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Command == PCD_TRANSCEIVE)</span><br><span class="line">            &#123;</span><br><span class="line">                n = ReadRawRC(FIFOLevelReg);<span class="comment">//读FIFO中保存的字节数</span></span><br><span class="line">                lastBits = ReadRawRC(ControlReg) &amp; <span class="number">0x07</span>;<span class="comment">//最后接收到得字节的有效位数</span></span><br><span class="line">                <span class="keyword">if</span> (lastBits)</span><br><span class="line">                &#123;</span><br><span class="line">                    *pOutLenBit = (n - <span class="number">1</span>) * <span class="number">8</span> + lastBits;<span class="comment">//N个字节数减去1（最后一个字节）+最后一位的位数 读取到的数据总位数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *pOutLenBit = n * <span class="number">8</span>;<span class="comment">//最后接收到的字节整个字节有效</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; MAXRLEN)</span><br><span class="line">                &#123;</span><br><span class="line">                    n = MAXRLEN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    pOutData[i] = ReadRawRC(FIFODataReg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SetBitMask(ControlReg, <span class="number">0x80</span>); <span class="comment">// stop timer now</span></span><br><span class="line">    WriteRawRC(CommandReg, PCD_IDLE);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdRequest</span></span><br><span class="line"><span class="comment"> * 描述  ：寻卡</span></span><br><span class="line"><span class="comment"> * 输入  ：ucReq_code，寻卡方式</span></span><br><span class="line"><span class="comment"> *                     = 0x52，寻感应区内所有符合14443A标准的卡</span></span><br><span class="line"><span class="comment"> *                     = 0x26，寻未进入休眠状态的卡</span></span><br><span class="line"><span class="comment"> *         pTagType，卡片类型代码</span></span><br><span class="line"><span class="comment"> *                   = 0x4400，Mifare_UltraLight</span></span><br><span class="line"><span class="comment"> *                   = 0x0400，Mifare_One(S50)</span></span><br><span class="line"><span class="comment"> *                   = 0x0200，Mifare_One(S70)</span></span><br><span class="line"><span class="comment"> *                   = 0x0800，Mifare_Pro(X))</span></span><br><span class="line"><span class="comment"> *                   = 0x4403，Mifare_DESFire</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRequest</span>(<span class="params">uint8_t req_code, uint8_t *pTagType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line"></span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);  <span class="comment">//清除RC522寄存位,清理指示MIFARECyptol单元接通以及所有卡的数据通信被加密的情况</span></span><br><span class="line">    WriteRawRC(BitFramingReg, <span class="number">0x07</span>); <span class="comment">//写RC522寄存器，发送的最后一个字节的七位</span></span><br><span class="line">    SetBitMask(TxControlReg, <span class="number">0x03</span>);  写RC522寄存位，TX1,TX2管脚的输出信号传递经发送调制的<span class="number">13.56</span>的能量载波信号</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = req_code;<span class="comment">//存入寻卡方式</span></span><br><span class="line"></span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">1</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status == MI_OK) &amp;&amp; (unLen == <span class="number">0x10</span>))<span class="comment">//寻卡成功返回卡类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        *pTagType = ucComMF522Buf[<span class="number">0</span>];</span><br><span class="line">        *(pTagType + <span class="number">1</span>) = ucComMF522Buf[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAnticoll</span></span><br><span class="line"><span class="comment"> * 描述  ：防冲撞</span></span><br><span class="line"><span class="comment"> * 输入  ：pSnr，卡片序列号，4字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAnticoll</span>(<span class="params">uint8_t *pSnr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint8_t i, snr_check = <span class="number">0</span>;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);<span class="comment">//清MFCryptol On位,只有成功执行MFAuthent命令后，该位才能置位</span></span><br><span class="line">    WriteRawRC(BitFramingReg, <span class="number">0x00</span>);<span class="comment">//清理寄存器,停止收发</span></span><br><span class="line">    ClearBitMask(CollReg, <span class="number">0x80</span>);<span class="comment">//清ValuesAfterColl所有接收的位在冲突后被清除</span></span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_ANTICOLL1;<span class="comment">//卡片防冲突命令</span></span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">2</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(pSnr + i) = ucComMF522Buf[i];</span><br><span class="line">            snr_check ^= ucComMF522Buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (snr_check != ucComMF522Buf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SetBitMask(CollReg, <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdSelect</span></span><br><span class="line"><span class="comment"> * 描述  ：选定卡片</span></span><br><span class="line"><span class="comment"> * 输入  ：pSnr，卡片序列号，4字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdSelect</span>(<span class="params">uint8_t *pSnr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint8_t i;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_ANTICOLL1;<span class="comment">//防冲撞</span></span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = <span class="number">0x70</span>;</span><br><span class="line">    ucComMF522Buf[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[i + <span class="number">2</span>] = *(pSnr + i);</span><br><span class="line">        ucComMF522Buf[<span class="number">6</span>] ^= *(pSnr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">7</span>, &amp;ucComMF522Buf[<span class="number">7</span>]);</span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">9</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status == MI_OK) &amp;&amp; (unLen == <span class="number">0x18</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAuthState</span></span><br><span class="line"><span class="comment"> * 描述  ：验证卡片密码</span></span><br><span class="line"><span class="comment"> * 输入  ：ucAuth_mode，密码验证模式</span></span><br><span class="line"><span class="comment"> *                     = 0x60，验证A密钥</span></span><br><span class="line"><span class="comment"> *                     = 0x61，验证B密钥</span></span><br><span class="line"><span class="comment"> *         uint8_t ucAddr，块地址</span></span><br><span class="line"><span class="comment"> *         pKey，密码</span></span><br><span class="line"><span class="comment"> *         pSnr，卡片序列号，4字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAuthState</span>(<span class="params">uint8_t auth_mode, uint8_t addr, uint8_t *pKey, uint8_t *pSnr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = auth_mode;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[i + <span class="number">2</span>] = *(pKey + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[i + <span class="number">8</span>] = *(pSnr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    status = PcdComMF522(PCD_AUTHENT, ucComMF522Buf, <span class="number">12</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (!(ReadRawRC(Status2Reg) &amp; <span class="number">0x08</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdRead</span></span><br><span class="line"><span class="comment"> * 描述  ：读取M1卡一块数据</span></span><br><span class="line"><span class="comment"> * 输入  ：uint8_t ucAddr，块地址</span></span><br><span class="line"><span class="comment"> *         pData，读出的数据，16字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> * 调用  ：外部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRead</span>(<span class="params">uint8_t addr, uint8_t *pData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_READ;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status == MI_OK) &amp;&amp; (unLen == <span class="number">0x90</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(pData + i) = ucComMF522Buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdWrite</span></span><br><span class="line"><span class="comment"> * 描述  ：写数据到M1卡一块</span></span><br><span class="line"><span class="comment"> * 输入  ：uint8_t ucAddr，块地址</span></span><br><span class="line"><span class="comment"> *         pData，写入的数据，16字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> * 调用  ：外部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdWrite</span>(<span class="params">uint8_t addr, uint8_t *pData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_WRITE;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ucComMF522Buf[i] = *(pData + i);</span><br><span class="line">        &#125;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">16</span>, &amp;ucComMF522Buf[<span class="number">16</span>]);</span><br><span class="line"></span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">18</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">        <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdValue</span></span><br><span class="line"><span class="comment"> * 描述  ：扣款和充值</span></span><br><span class="line"><span class="comment"> * 输入  ：dd_mode[IN]：命令字</span></span><br><span class="line"><span class="comment"> *              0xC0 = 扣款</span></span><br><span class="line"><span class="comment"> *              0xC1 = 充值</span></span><br><span class="line"><span class="comment"> *         addr[IN]：钱包地址</span></span><br><span class="line"><span class="comment"> *         pValue[IN]：4字节增(减)值，低位在前</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdValue</span>(<span class="params">uint8_t dd_mode, uint8_t addr, uint8_t *pValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = dd_mode;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ucComMF522Buf[i] = *(pValue + i);</span><br><span class="line">        &#125;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">4</span>, &amp;ucComMF522Buf[<span class="number">4</span>]);</span><br><span class="line">        unLen = <span class="number">0</span>;</span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">6</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">        <span class="keyword">if</span> (status != MI_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[<span class="number">0</span>] = PICC_TRANSFER;</span><br><span class="line">        ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdBakValue</span></span><br><span class="line"><span class="comment"> * 描述  ：备份钱包</span></span><br><span class="line"><span class="comment"> * 输入  ：sourceaddr[IN]：源地址</span></span><br><span class="line"><span class="comment"> *         goaladdr[IN]：目标地址</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdBakValue</span>(<span class="params">uint8_t sourceaddr, uint8_t goaladdr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_RESTORE;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = sourceaddr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ucComMF522Buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ucComMF522Buf[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        ucComMF522Buf[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">4</span>, &amp;ucComMF522Buf[<span class="number">4</span>]);</span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">6</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">        <span class="keyword">if</span> (status != MI_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_TRANSFER;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = goaladdr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdHalt</span></span><br><span class="line"><span class="comment"> * 描述  ：命令卡片进入休眠状态</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdHalt</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_HALT;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MI_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：CalulateCRC</span></span><br><span class="line"><span class="comment"> * 描述  ：用RC522计算CRC16</span></span><br><span class="line"><span class="comment"> * 输入  ：pIndata，计算CRC16的数组</span></span><br><span class="line"><span class="comment"> *         ucLen，计算CRC16的数组字节长度</span></span><br><span class="line"><span class="comment"> *         pOutData，存放计算结果存放的首地址</span></span><br><span class="line"><span class="comment"> * 返回  : 无</span></span><br><span class="line"><span class="comment"> * 调用  ：内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalulateCRC</span>(<span class="params">uint8_t *pIndata, uint8_t len, uint8_t *pOutData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i, n;</span><br><span class="line">    ClearBitMask(DivIrqReg, <span class="number">0x04</span>);</span><br><span class="line">    WriteRawRC(CommandReg, PCD_IDLE);</span><br><span class="line">    SetBitMask(FIFOLevelReg, <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteRawRC(FIFODataReg, *(pIndata + i));</span><br><span class="line">    &#125;</span><br><span class="line">    WriteRawRC(CommandReg, PCD_CALCCRC);</span><br><span class="line">    i = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = ReadRawRC(DivIrqReg);</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i != <span class="number">0</span>) &amp;&amp; !(n &amp; <span class="number">0x04</span>));</span><br><span class="line">    pOutData[<span class="number">0</span>] = ReadRawRC(CRCResultRegL);</span><br><span class="line">    pOutData[<span class="number">1</span>] = ReadRawRC(CRCResultRegM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdRese</span></span><br><span class="line"><span class="comment"> * 描述  ：复位RC522</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdReset</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RC522_Reset_Disable();</span><br><span class="line">    delay_ms(<span class="number">10</span>);</span><br><span class="line">    RC522_Reset_Enable();</span><br><span class="line">    delay_ms(<span class="number">60</span>);</span><br><span class="line">    RC522_Reset_Disable();</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">    WriteRawRC(CommandReg, PCD_RESETPHASE);<span class="comment">//复位指令</span></span><br><span class="line">    delay_ms(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    WriteRawRC(ModeReg, <span class="number">0x3D</span>);<span class="comment">//定义发送和接收常用模式,和Mifare卡通讯，CRC初始值0x6363</span></span><br><span class="line">    WriteRawRC(TReloadRegL, <span class="number">30</span>);<span class="comment">//16位定时器低位</span></span><br><span class="line">    WriteRawRC(TReloadRegH, <span class="number">0</span>);<span class="comment">//16位定时器高位</span></span><br><span class="line">    WriteRawRC(TModeReg, <span class="number">0x8D</span>);<span class="comment">//定义内部定时器的设置</span></span><br><span class="line">    WriteRawRC(TPrescalerReg, <span class="number">0x3E</span>);<span class="comment">//设置定时器分频系数</span></span><br><span class="line">    WriteRawRC(TxAutoReg, <span class="number">0x40</span>);<span class="comment">//调制发送信号为100%ASK</span></span><br><span class="line"></span><br><span class="line">    ClearBitMask(TestPinEnReg, <span class="number">0x80</span>);</span><br><span class="line">    WriteRawRC(TxAutoReg, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MI_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：ReadRawRC</span></span><br><span class="line"><span class="comment"> * 描述  ：读RC522寄存器</span></span><br><span class="line"><span class="comment"> * 输入  ：ucAddress，寄存器地址</span></span><br><span class="line"><span class="comment"> * 返回  : 寄存器的当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">uint8_t <span class="title">ReadRawRC</span>(<span class="params">uint8_t Address</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t ucAddr;</span><br><span class="line">    uint8_t ucResult = <span class="number">0</span>;</span><br><span class="line">    ucAddr = ((Address &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7E</span>) | <span class="number">0x80</span>;<span class="comment">//最高位置1，读操作;最低为默认0</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    RC522_CS_Enable();</span><br><span class="line">    SPI_WriteNBytes(SPI1_SPI, &amp;ucAddr, <span class="number">1</span>);  <span class="comment">//向总线写多个数据</span></span><br><span class="line">    SPI_ReadNBytes(SPI1_SPI, &amp;ucResult, <span class="number">1</span>); <span class="comment">//向总线读多个数据</span></span><br><span class="line">    RC522_CS_Disable();</span><br><span class="line">    <span class="keyword">return</span> ucResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：WriteRawRC</span></span><br><span class="line"><span class="comment"> * 描述  ：写RC522寄存器</span></span><br><span class="line"><span class="comment"> * 输入  ：ucAddress，寄存器地址</span></span><br><span class="line"><span class="comment"> *         ucValue，写入寄存器的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawRC</span>(<span class="params">uint8_t Address, uint8_t <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t ucAddr;</span><br><span class="line">    uint8_t write_buffer[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ucAddr = ((Address &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7E</span>);<span class="comment">//最高位置0，写操作;最低为默认0</span></span><br><span class="line">    write_buffer[<span class="number">0</span>] = ucAddr;</span><br><span class="line">    write_buffer[<span class="number">1</span>] = <span class="keyword">value</span>;</span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    RC522_CS_Enable();</span><br><span class="line">    SPI_WriteNBytes(SPI1_SPI, write_buffer, <span class="number">2</span>);</span><br><span class="line">    RC522_CS_Disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SetBitMask</span></span><br><span class="line"><span class="comment"> * 描述  ：对RC522寄存器置位，可对多个位同时操作</span></span><br><span class="line"><span class="comment"> * 输入  ：ucReg，寄存器地址</span></span><br><span class="line"><span class="comment"> *         ucMask，置位值,例0x13，0001 0011</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetBitMask</span>(<span class="params">uint8_t reg, uint8_t mask</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    temp = ReadRawRC(reg);        <span class="comment">//读寄存器</span></span><br><span class="line">    WriteRawRC(reg, temp | mask); <span class="comment">//将目标位置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：ClearBitMask</span></span><br><span class="line"><span class="comment"> * 描述  ：对RC522寄存器清位</span></span><br><span class="line"><span class="comment"> * 输入  ：ucReg，寄存器地址</span></span><br><span class="line"><span class="comment"> *         ucMask，清位值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBitMask</span>(<span class="params">uint8_t reg, uint8_t mask</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    temp = ReadRawRC(reg);</span><br><span class="line">    WriteRawRC(reg, temp &amp; ~mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAntennaOn</span></span><br><span class="line"><span class="comment"> * 描述  ：开启天线</span></span><br><span class="line"><span class="comment"> * TxControlReg寄存器位0置1，引脚TX1上的输出信号将传输由传输数据调制的13.56 MHz能量载波。</span></span><br><span class="line"><span class="comment"> * TxControlReg寄存器位1置1，引脚TX2上的输出信号将发送由传输数据调制的13.56 MHz能量载波。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOn</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i;</span><br><span class="line">    i = ReadRawRC(TxControlReg);</span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; <span class="number">0x03</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        SetBitMask(TxControlReg, <span class="number">0x03</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAntennaOff</span></span><br><span class="line"><span class="comment"> * 描述  ：关闭天线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOff</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ClearBitMask(TxControlReg, <span class="number">0x03</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：RC522_PcdConfig_Type</span></span><br><span class="line"><span class="comment"> * 描述  ：设置RC522的工作方式</span></span><br><span class="line"><span class="comment"> * 工作方式ISO14443_A</span></span><br><span class="line"><span class="comment"> * 复位中已经设置过，该函数暂时未调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Config</span>(<span class="params">uint8_t Card_Type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);</span><br><span class="line">    WriteRawRC(ModeReg, <span class="number">0x3D</span>);</span><br><span class="line">    WriteRawRC(RxSelReg, <span class="number">0x86</span>);</span><br><span class="line">    WriteRawRC(RFCfgReg, <span class="number">0x7F</span>);</span><br><span class="line">    WriteRawRC(TReloadRegL, <span class="number">30</span>);</span><br><span class="line">    WriteRawRC(TReloadRegH, <span class="number">0</span>);</span><br><span class="line">    WriteRawRC(TModeReg, <span class="number">0x8D</span>);</span><br><span class="line">    WriteRawRC(TPrescalerReg, <span class="number">0x3E</span>);</span><br><span class="line">    delay_ms(<span class="number">5</span>);</span><br><span class="line">    PcdAntennaOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RC522.h</p><p>头文件内容与API大致相同，定义了指令集和寄存器。</p><p>这里的sys.h是正点原子的F1系列头文件。</p><p>加入了引脚定义和自定义函数。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __RC522_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RC522_H</span></span><br><span class="line"><span class="meta">#include &quot;sys.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************引脚定义****************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RC522SPI引脚,RST和CS可随意更改</span></span><br><span class="line"><span class="comment">RST-PC5</span></span><br><span class="line"><span class="comment">CS-PA4</span></span><br><span class="line"><span class="comment">SCK-PA5</span></span><br><span class="line"><span class="comment">MISO-PA6</span></span><br><span class="line"><span class="comment">MOSI-PA7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Reset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_RST_Pin      GPIO_PIN_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_RST_GPIO_Port     GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_Reset_CLK_ENABLE() \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CS片选，模块SDA引脚，SPI通信时用作NSS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_CS_PIN      GPIO_PIN_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_CS_PORT     GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_CS_CLK_ENABLE() \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************RC522 函数宏定义**********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_Reset_Disable() HAL_GPIO_WritePin(RC522_RST_GPIO_Port, RC522_RST_Pin, GPIO_PIN_SET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_Reset_Enable() HAL_GPIO_WritePin(RC522_RST_GPIO_Port, RC522_RST_Pin, GPIO_PIN_RESET);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_CS_Enable() HAL_GPIO_WritePin(RC522_GPIO_CS_PORT, RC522_GPIO_CS_PIN, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_CS_Disable() HAL_GPIO_WritePin(RC522_GPIO_CS_PORT, RC522_GPIO_CS_PIN, GPIO_PIN_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> readID  1//读</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writeID 2//写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************自定义函数****************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Start</span>(<span class="params">uint8_t block,uint8_t option,uint8_t *Write_Card_Data</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_SPI_GPIO_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************RC522指令集****************************/</span></span><br><span class="line"><span class="comment">//MF522命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_IDLE              0x00               //取消当前命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_AUTHENT           0x0E               //验证密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RECEIVE           0x08               //接收数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSMIT          0x04               //发送数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSCEIVE        0x0C               //发送并接收数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RESETPHASE        0x0F               //复位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_CALCCRC           0x03               //CRC计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mifare_One卡片命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQIDL           0x26               //寻天线区内未进入休眠状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQALL           0x52               //寻天线区内全部卡</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL1        0x93               //防冲撞</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL2        0x95               //防冲撞</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1A        0x60               //验证A密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1B        0x61               //验证B密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_READ             0x30               //读块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_WRITE            0xA0               //写块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_DECREMENT        0xC0               //扣款</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_INCREMENT        0xC1               //充值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_RESTORE          0xC2               //调块数据到缓冲区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_TRANSFER         0xB0               //保存缓冲区中数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_HALT             0x50               //休眠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MF522 FIFO长度定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FIFO_LENGTH       64                 //FIFO size=64byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MF522寄存器定义</span></span><br><span class="line"><span class="comment">// PAGE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU00                 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CommandReg            0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ComIEnReg             0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DivlEnReg             0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ComIrqReg             0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DivIrqReg             0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ErrorReg              0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Status1Reg            0x07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Status2Reg            0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FIFODataReg           0x09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FIFOLevelReg          0x0A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     WaterLevelReg         0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ControlReg            0x0C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     BitFramingReg         0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CollReg               0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU0F                 0x0F</span></span><br><span class="line"><span class="comment">// PAGE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU10                 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModeReg               0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxModeReg             0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxModeReg             0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxControlReg          0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxAutoReg             0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxSelReg              0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxSelReg              0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxThresholdReg        0x18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DemodReg              0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1A                 0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1B                 0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     MifareReg             0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1D                 0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1E                 0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SerialSpeedReg        0x1F</span></span><br><span class="line"><span class="comment">// PAGE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU20                 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CRCResultRegM         0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CRCResultRegL         0x22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU23                 0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModWidthReg           0x24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU25                 0x25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFCfgReg              0x26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GsNReg                0x27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CWGsCfgReg            0x28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModGsCfgReg           0x29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TModeReg              0x2A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TPrescalerReg         0x2B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TReloadRegH           0x2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TReloadRegL           0x2D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TCounterValueRegH     0x2E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TCounterValueRegL     0x2F</span></span><br><span class="line"><span class="comment">// PAGE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU30                 0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestSel1Reg           0x31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestSel2Reg           0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestPinEnReg          0x33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestPinValueReg       0x34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestBusReg            0x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     AutoTestReg           0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     VersionReg            0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     AnalogTestReg         0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestDAC1Reg           0x39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestDAC2Reg           0x3A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestADCReg            0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3C                 0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3D                 0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3E                 0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3F  0x3F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和MF522通讯时返回的错误代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_OK                          0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_NOTAGERR                    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_ERR                         2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲数组大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXRLEN                       18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************内部调用函数**************************************/</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRequest</span>(<span class="params">uint8_t req_code,uint8_t *pTagType</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAnticoll</span>(<span class="params">uint8_t *pSnr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdSelect</span>(<span class="params">uint8_t *pSnr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAuthState</span>(<span class="params">uint8_t auth_mode,uint8_t addr,uint8_t *pKey,uint8_t *pSnr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRead</span>(<span class="params">uint8_t addr,uint8_t *pData</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdWrite</span>(<span class="params">uint8_t addr,uint8_t *pData</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdValue</span>(<span class="params">uint8_t dd_mode,uint8_t addr,uint8_t *pValue</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdBakValue</span>(<span class="params">uint8_t sourceaddr, uint8_t goaladdr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdHalt</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalulateCRC</span>(<span class="params">uint8_t *pIndata,uint8_t len,uint8_t *pOutData</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdReset</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function">uint8_t <span class="title">ReadRawRC</span>(<span class="params">uint8_t Address</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawRC</span>(<span class="params">uint8_t Address, uint8_t <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetBitMask</span>(<span class="params">uint8_t reg,uint8_t mask</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBitMask</span>(<span class="params">uint8_t reg,uint8_t mask</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdComMF522</span>(<span class="params">uint8_t Command,uint8_t *pInData,uint8_t InLenByte,uint8_t *pOutData,unsigned <span class="built_in">int</span> *pOutLenBit</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOn</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOff</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Config</span>(<span class="params">uint8_t Card_Type</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SPI定义"><a href="#SPI定义" class="headerlink" title="SPI定义"></a>SPI定义</h4><p>spi的初始化默认即可，注意以下两项的设置，才能保持和模块的正常通信：</p><p><strong>CLKPolarity</strong>&#x3D;SPI_POLARITY_LOW; &#x2F;&#x2F;串行同步时钟的空闲状态为低电平</p><p><strong>CLKPhase</strong>&#x3D;SPI_PHASE_1EDGE; &#x2F;&#x2F;串行同步时钟的第1个跳变沿（上升或下降）数据被采样</p><p>片选引脚改为软件管理，这样方便更改引脚，</p><p><strong>NSS</strong>&#x3D;SPI_NSS_SOFT; &#x2F;&#x2F;NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理</p><p>SPI.c</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;spi.h&quot;</span></span><br><span class="line"></span><br><span class="line">SPI_HandleTypeDef SPI1_Handler;  <span class="comment">//SPI句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是SPI模块的初始化代码，配置成主机模式</span></span><br><span class="line"><span class="comment">//SPI口初始化</span></span><br><span class="line"><span class="comment">//这里针是对SPI1的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SPI1_Handler.Instance=SPI1_SPI;                         <span class="comment">//SPI1</span></span><br><span class="line">    SPI1_Handler.Init.Mode=SPI_MODE_MASTER;             <span class="comment">//设置SPI工作模式，设置为主模式</span></span><br><span class="line">    SPI1_Handler.Init.Direction=SPI_DIRECTION_2LINES;   <span class="comment">//设置SPI单向或者双向的数据模式:SPI设置为双线模式</span></span><br><span class="line">    SPI1_Handler.Init.DataSize=SPI_DATASIZE_8BIT;       <span class="comment">//设置SPI的数据大小:SPI发送接收8位帧结构</span></span><br><span class="line">    SPI1_Handler.Init.CLKPolarity=SPI_POLARITY_LOW;    <span class="comment">//串行同步时钟的空闲状态为低电平</span></span><br><span class="line">    SPI1_Handler.Init.CLKPhase=SPI_PHASE_1EDGE;         <span class="comment">//串行同步时钟的第1个跳变沿（上升或下降）数据被采样</span></span><br><span class="line">    SPI1_Handler.Init.NSS=SPI_NSS_SOFT;                 <span class="comment">//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制</span></span><br><span class="line">    SPI1_Handler.Init.BaudRatePrescaler=SPI_BAUDRATEPRESCALER_256;<span class="comment">//定义波特率预分频的值:波特率预分频值为256</span></span><br><span class="line">    SPI1_Handler.Init.FirstBit=SPI_FIRSTBIT_MSB;        <span class="comment">//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始</span></span><br><span class="line">    SPI1_Handler.Init.TIMode=SPI_TIMODE_DISABLE;        <span class="comment">//关闭TI模式</span></span><br><span class="line">    SPI1_Handler.Init.CRCCalculation=SPI_CRCCALCULATION_DISABLE;<span class="comment">//关闭硬件CRC校验</span></span><br><span class="line">    SPI1_Handler.Init.CRCPolynomial=<span class="number">7</span>;                  <span class="comment">//CRC值计算的多项式,默认值为7</span></span><br><span class="line">    HAL_SPI_Init(&amp;SPI1_Handler);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    __HAL_SPI_ENABLE(&amp;SPI1_Handler);                    <span class="comment">//使能SPI1</span></span><br><span class="line"></span><br><span class="line">    SPI1_ReadWriteByte(<span class="number">0Xff</span>);                           <span class="comment">//启动传输,产生8个时钟脉冲, 达到清空DR的作用, 非必需</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI底层驱动，时钟使能，引脚配置</span></span><br><span class="line"><span class="comment">//此函数会被HAL_SPI_Init()调用</span></span><br><span class="line"><span class="comment">//hspi:SPI句柄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_SPI_MspInit</span>(<span class="params">SPI_HandleTypeDef *hspi</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Initure;</span><br><span class="line"></span><br><span class="line">    SPI1_SPI_CLK_ENABLE();</span><br><span class="line">    SPI1_SCK_GPIO_CLK_ENABLE();</span><br><span class="line">    SPI1_MISO_GPIO_CLK_ENABLE();</span><br><span class="line">    SPI1_MOSI_GPIO_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    GPIO_Initure.Pin=SPI1_SCK_GPIO_PIN;</span><br><span class="line">    GPIO_Initure.Mode=GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_Initure.Pull=GPIO_PULLDOWN;</span><br><span class="line">    GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    HAL_GPIO_Init(SPI1_SCK_GPIO_PORT,&amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">    GPIO_Initure.Pin=SPI1_MISO_GPIO_PIN;</span><br><span class="line">    HAL_GPIO_Init(SPI1_MISO_GPIO_PORT,&amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">    GPIO_Initure.Pin=SPI1_MOSI_GPIO_PIN;</span><br><span class="line">    HAL_GPIO_Init(SPI1_MOSI_GPIO_PORT,&amp;GPIO_Initure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPI.h</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __SPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SPI_H</span></span><br><span class="line"><span class="meta">#include &quot;sys.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SPI_HandleTypeDef SPI1_Handler;  <span class="comment">//SPI句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI1 引脚 定义 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SCK_GPIO_PORT              GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SCK_GPIO_PIN               GPIO_PIN_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SCK_GPIO_CLK_ENABLE()      do&#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MISO_GPIO_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MISO_GPIO_PIN              GPIO_PIN_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MISO_GPIO_CLK_ENABLE()     do&#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MOSI_GPIO_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MOSI_GPIO_PIN              GPIO_PIN_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MOSI_GPIO_CLK_ENABLE()     do&#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI1相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SPI                        SPI1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SPI_CLK_ENABLE()           do&#123; __HAL_RCC_SPI1_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p><img src="https://img-blog.csdnimg.cn/53941b94abc34bf5a897740cede1942a.png"></p><p>本实验在于经验分享和学习记录，有不正确的地方请读者指正。</p><h2 id="五、更新源码："><a href="#五、更新源码：" class="headerlink" title="五、更新源码："></a>五、更新源码：</h2><p>源码已上传至gitee：</p><p><a href="https://gitee.com/lrf1125962926/stm32/tree/RC522_SPI/" title="stm32: 一些stm32模块使用经验记录 - Gitee.com">stm32: 一些stm32模块使用经验记录 - Gitee.com <img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8">https://gitee.com/lrf1125962926/stm32/tree/RC522_SPI&#x2F;;</a></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STM32HAL库，RC522（RFID）模块读写驱动，无线IC卡读写</title>
      <link href="/2024/03/stm32-stm32-%E5%9F%BA%E4%BA%8ESTM32HAL%E5%BA%93%EF%BC%8CRC522%EF%BC%88RFID%EF%BC%89%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99%E9%A9%B1%E5%8A%A8%EF%BC%8C%E6%97%A0%E7%BA%BFIC%E5%8D%A1%E8%AF%BB%E5%86%99/"/>
      <url>/2024/03/stm32-stm32-%E5%9F%BA%E4%BA%8ESTM32HAL%E5%BA%93%EF%BC%8CRC522%EF%BC%88RFID%EF%BC%89%E6%A8%A1%E5%9D%97%E8%AF%BB%E5%86%99%E9%A9%B1%E5%8A%A8%EF%BC%8C%E6%97%A0%E7%BA%BFIC%E5%8D%A1%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、模块简短介绍"><a href="#一、模块简短介绍" class="headerlink" title="一、模块简短介绍"></a>一、模块简短介绍</h2><p>有关RC522模块的背景知识以及工作原理，本次实验暂时不做分享，这里贴上两位写得很好的博主，大家可自行查看。</p><p><a href="https://blog.csdn.net/m0_51220742/article/details/123683745" title="(5条消息) RC522(RFID)读写驱动_桃成蹊2.0的博客-CSDN博客">(5条消息) RC522(RFID)读写驱动_桃成蹊2.0的博客-CSDN博客<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8">https://blog.csdn.net/m0_51220742&#x2F;article&#x2F;details&#x2F;123683745 ;</a> <a href="https://blog.csdn.net/weixin_45771489/article/details/124079134" title="(5条消息) STM32--RFID无线射频技术（RC522刷卡模块）_rc522射频模块详细资料_y黎好好的博客-CSDN博客">(5条消息) STM32–RFID无线射频技术（RC522刷卡模块）_rc522射频模块详细资料_y黎好好的博客-CSDN博客<img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8">https://blog.csdn.net/weixin_45771489&#x2F;article&#x2F;details&#x2F;124079134 ;</a></p><p><img src="https://img-blog.csdnimg.cn/b829df1211c843b49139edf393f1aa42.jpeg"></p><p>该模块价格普遍实惠，所以我买了一个自己玩玩。经过一段时间的摸爬滚打目前能够正常读写，后续会继续完善该模块的使用，并加入到其他嵌入式设计中。</p><h2 id="二、开发资料的使用及经验分享"><a href="#二、开发资料的使用及经验分享" class="headerlink" title="二、开发资料的使用及经验分享"></a>二、开发资料的使用及经验分享</h2><p>该模块的API函数淘宝有很多资源，数据手册也有，不过是英文版的。建议大家有时间还是要过一数据手册的重要部分，比如寄存器和指令集，通信协议等，可以使用知云文献查看，我习惯用它来看论文，适合翻译长段大段。也可以用WPS的翻译，小部分翻译，看个人使用习惯。要是有能力直接撸原文那就更好，节约时间。</p><p><img src="https://img-blog.csdnimg.cn/2e92c08f81ca46af8c0d2361b9d2e130.png"></p><p>找过很多资料，提供的API无非就是一套没有章法，毫无可读性的杂乱代码，十分影响学习效果。这里建议大家不要去死磕，可以看本次实验的代码逻辑和上文提到的两位博主，每一个底层函数都有注释，在一些底层函数的逻辑上可以结合这些API函数进行反推或者校验，可以帮助读者理解实现原理。</p><p>一开始是通过数据手册，硬着头皮啃无良店铺给的代码，没有注释，没有逻辑，没有章法。虽然没报错，但是能不能用完全不知道，就是这一步就花了好几天时间，所以建议大家不要像我一样埋头苦读，可以先看每一个函数的中文注释，整理出一个框架。</p><h2 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h2><p>代码总体逻辑没有变化，参考了两位博主的思路，我用官方的API函数进行修改。两位博主一位使用的软件实现SPI协议，一位使用板载SPI。两种方法我都试过，但是软件SPI协议总是通信失败，不知道是我协议写的不对还是通信速度和模块不匹配，暂时还未解决。</p><h3 id="软件模拟SPI"><a href="#软件模拟SPI" class="headerlink" title="软件模拟SPI"></a><strong>软件模拟SPI</strong></h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SOFT_SPI_RC522_SendByte</span></span><br><span class="line"><span class="comment"> * 描述  ：向RC522发送1 Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：write_dat，要发送的数据</span></span><br><span class="line"><span class="comment"> * 返回  : RC522返回的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SOFT_SPI_RC522_SendByte</span>(<span class="params">uint8_t write_dat</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i</span><br></pre></td></tr></table></figure><p>有大佬如果发现问题，还请给我留言，也不知道是什么原因导致通信失败。</p><h3 id="板载SPI通信"><a href="#板载SPI通信" class="headerlink" title="板载SPI通信"></a><strong>板载SPI通信</strong></h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SPI_WriteNBytes</span></span><br><span class="line"><span class="comment"> * 描述  ：向RC522发送n Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：SPIx : 要发送数据的SPI</span></span><br><span class="line"><span class="comment"> * 输入  ：p_TxData : 要发送的数据</span></span><br><span class="line"><span class="comment"> * 输入  ：sendDataNum : 要发送的数据量(Byte)</span></span><br><span class="line"><span class="comment"> * 返回  : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SPI_WriteNBytes</span>(<span class="params">SPI_TypeDef* SPIx, uint8_t *p_TxData,uint32_t sendDataNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sendDataNum--)&#123;</span><br><span class="line"><span class="keyword">while</span>((SPIx-&gt;SR&amp;SPI_FLAG_TXE)==<span class="number">0</span>)<span class="comment">//等待发送区空</span></span><br><span class="line">&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR=*p_TxData++;<span class="comment">//发送一个byte</span></span><br><span class="line">retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((SPIx-&gt;SR&amp;SPI_FLAG_RXNE)==<span class="number">0</span>)<span class="comment">//等待接收完一个byte</span></span><br><span class="line">&#123;</span><br><span class="line">SPIx-&gt;SR = SPIx-&gt;SR;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SPI_ReadNBytes</span></span><br><span class="line"><span class="comment"> * 描述  ：读取RC522 n Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：SPIx : 要读取数据的SPI</span></span><br><span class="line"><span class="comment"> * 输入  ：p_RxData : 要读取的数据</span></span><br><span class="line"><span class="comment"> * 输入  ：readDataNum : 要读取的数据量(Byte)</span></span><br><span class="line"><span class="comment"> * 返回  : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SPI_ReadNBytes</span>(<span class="params">SPI_TypeDef* SPIx, uint8_t *p_RxData,uint32_t readDataNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(readDataNum--)&#123;</span><br><span class="line">SPIx-&gt;DR = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_TXE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_RXNE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p_RxData++ = SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本实验使用读取寄存器状态来完成SPI通信，未使用HAL_SPI_TransmitReceive库函数。</p><h3 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h3><p>主函数比较简略，调用一个操作函数，用按键触发的方式启动该函数实现读写。main.c 中，加入以下代码：</p><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   RC522_Init();</span><br><span class="line">uint8_t key;</span><br><span class="line"></span><br><span class="line">   uint8_t Write_Card_Data[<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//要写入的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = key_scan();<span class="comment">//按键扫描函数，自己定义修改</span></span><br><span class="line"><span class="keyword">if</span>(key==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RC522_Start(<span class="number">5</span>,readID,Write_Card_Data);<span class="comment">//readID  读命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">RC522_Start(<span class="number">5</span>,writeID,Write_Card_Data);<span class="comment">//writeID  写命令</span></span><br><span class="line">&#125;</span><br><span class="line">delay_ms(<span class="number">100</span>);</span><br><span class="line">LED0=!LED0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RC522部分"><a href="#RC522部分" class="headerlink" title="RC522部分"></a>RC522部分</h4><p><strong>RC522.c</strong></p><p>其中RC522_Start是自定义函数，只要操作流程正确，可自行编写想要的操作方式，本实验只完成简单的单块读写操作。蓝卡和白卡的卡号根据自己的修改，可以通过手机NFC功能查看卡号，同时也能查看扇区数据，APP可以使用上文提到的博主推荐的NFC Writer。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;RC522.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;stdio.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;delay.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;spi.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;oled.h&quot;</span></span><br><span class="line"><span class="meta">#include &quot;string.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M1卡分为16个扇区，每个扇区由四个块（块0、块1、块2、块3）组成</span></span><br><span class="line"><span class="comment">// 将16个扇区的64个块按绝对地址编号为：0~63,每块16个字节</span></span><br><span class="line"><span class="comment">// 第0个扇区的块0（即绝对地址0块），用于存放厂商代码，已经固化不可更改</span></span><br><span class="line"><span class="comment">// 每个扇区的块0、块1、块2为数据块，可用于存放数据</span></span><br><span class="line"><span class="comment">// 每个扇区的块3为控制块（绝对地址为:块3、块7、块11.....）包括密码A，存取控制、密码B等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RC522_SPI_GPIO_Init();<span class="comment">//初始化RC522的复位引脚和片选引脚</span></span><br><span class="line"></span><br><span class="line">SPI1_Init();<span class="comment">//初始化SPI</span></span><br><span class="line"></span><br><span class="line">    delay_ms(<span class="number">50</span>);</span><br><span class="line">PcdReset();<span class="comment">//复位RC522读卡器</span></span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line">PcdAntennaOff();<span class="comment">//关闭天线发射</span></span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line">    PcdAntennaOn();<span class="comment">//开启天线发射</span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;RFID-MFRC522 初始化完成\nPress KEY0 Or KEY1 To Start...\r\n&quot;</span>);  <span class="comment">//初始化完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t IC_UID[<span class="number">4</span>]; <span class="comment">//UID卡片序列号,4字节</span></span><br><span class="line">uint8_t IC_Type[<span class="number">2</span>];<span class="comment">//卡类型代码，2字节,0x0400，Mifare_One(S50)</span></span><br><span class="line">uint8_t card_1[<span class="number">4</span>]=&#123;<span class="number">0xC3</span>,<span class="number">0xB2</span>,<span class="number">0x37</span>,<span class="number">0xC5</span>&#125;;<span class="comment">//蓝卡1卡号</span></span><br><span class="line">uint8_t card_2[<span class="number">4</span>]=&#123;<span class="number">0xA3</span>,<span class="number">0x09</span>,<span class="number">0x3C</span>,<span class="number">0xFB</span>&#125;;<span class="comment">//白卡2卡号</span></span><br><span class="line">uint8_t ID_num=<span class="number">0</span>;<span class="comment">//当前操作的序号</span></span><br><span class="line">uint8_t Card_KEY[<span class="number">6</span>]=&#123;<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>&#125;;<span class="comment">//验证密码</span></span><br><span class="line">uint8_t Card_Data[<span class="number">16</span>];<span class="comment">//读取出的块数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：RC522_Start</span></span><br><span class="line"><span class="comment"> * 输入  block：要操作的块地址</span></span><br><span class="line"><span class="comment"> * 输入  option：读操作或写操作</span></span><br><span class="line"><span class="comment"> *              readID  1//读</span></span><br><span class="line"><span class="comment"> *writeID 2//写</span></span><br><span class="line"><span class="comment"> * 输入  block：要操作的块地址</span></span><br><span class="line"><span class="comment"> * 描述  ：RC522操作主函数，可完成对卡的读写操作</span></span><br><span class="line"><span class="comment"> *  * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = 1，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Start</span>(<span class="params">uint8_t block,uint8_t option,uint8_t *Write_Card_Data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PcdRequest(PICC_REQALL,IC_Type) == MI_OK)<span class="comment">//寻卡</span></span><br><span class="line">&#123;</span><br><span class="line">uint16_t cardType = (IC_Type[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | IC_Type[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">switch</span> (cardType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4400</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare UltraLight\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0400</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare One(S50)\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0200</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare One(S70)\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0800</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare Pro(X)\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x4403</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nMifare DESFire\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                printf(<span class="string">&quot;\r\nUnknown Card\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(PcdAnticoll(IC_UID)==MI_OK)<span class="comment">//防冲撞</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((IC_UID[<span class="number">0</span>]==card_1[<span class="number">0</span>])&amp;&amp;(IC_UID[<span class="number">1</span>]==card_1[<span class="number">1</span>])&amp;&amp;(IC_UID[<span class="number">2</span>]==card_1[<span class="number">2</span>])&amp;&amp;(IC_UID[<span class="number">3</span>]==card_1[<span class="number">3</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                ID_num=<span class="number">1</span>;</span><br><span class="line">                printf(<span class="string">&quot;The User is: %d, Blue card&quot;</span>,ID_num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((IC_UID[<span class="number">0</span>]==card_2[<span class="number">0</span>])&amp;&amp;(IC_UID[<span class="number">1</span>]==card_2[<span class="number">1</span>])&amp;&amp;(IC_UID[<span class="number">2</span>]==card_2[<span class="number">2</span>])&amp;&amp;(IC_UID[<span class="number">3</span>]==card_2[<span class="number">3</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                ID_num=<span class="number">2</span>;</span><br><span class="line">                printf(<span class="string">&quot;The User is: %d, White card&quot;</span>,ID_num);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(<span class="string">&quot;\r\ncard_ID: %02X:%02X:%02X:%02X\r\n&quot;</span>,IC_UID[<span class="number">0</span>],IC_UID[<span class="number">1</span>],IC_UID[<span class="number">2</span>],IC_UID[<span class="number">3</span>]); <span class="comment">//打印卡的UID号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PcdSelect(IC_UID)==MI_OK)<span class="comment">//选卡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(PcdAuthState(PICC_AUTHENT1A,block,Card_KEY,IC_UID)==MI_OK)<span class="comment">//验证A密钥,对应块</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//memset(Card_Data,1,16);</span></span><br><span class="line"><span class="keyword">if</span>(option==readID)<span class="comment">//读操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(PcdRead(block,Card_Data)==MI_OK)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">&quot;\n读取结果: \n&quot;</span>);</span><br><span class="line">printf(<span class="string">&quot;block %d date:\r\n&quot;</span>,block);</span><br><span class="line">categories:</span><br><span class="line">    - stm32</span><br><span class="line">    - stm32hal库开发</span><br><span class="line">tags:</span><br><span class="line">    - stm32</span><br><span class="line">    - 外设</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;iSR&amp;SPI_FLAG_TXE)==<span class="number">0</span>)<span class="comment">//等待发送区空</span></span><br><span class="line">&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR=*p_TxData++;<span class="comment">//发送一个byte</span></span><br><span class="line">retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((SPIx-&gt;SR&amp;SPI_FLAG_RXNE)==<span class="number">0</span>)<span class="comment">//等待接收完一个byte</span></span><br><span class="line">&#123;</span><br><span class="line">SPIx-&gt;SR = SPIx-&gt;SR;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SPI_ReadNBytes</span></span><br><span class="line"><span class="comment"> * 描述  ：读取RC522 n Byte 数据</span></span><br><span class="line"><span class="comment"> * 输入  ：SPIx : 要读取数据的SPI</span></span><br><span class="line"><span class="comment"> * 输入  ：p_RxData : 要读取的数据</span></span><br><span class="line"><span class="comment"> * 输入  ：readDataNum : 要读取的数据量(Byte)</span></span><br><span class="line"><span class="comment"> * 返回  : 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">SPI_ReadNBytes</span>(<span class="params">SPI_TypeDef* SPIx, uint8_t *p_RxData,uint32_t readDataNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> retry=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(readDataNum--)&#123;</span><br><span class="line">SPIx-&gt;DR = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_TXE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">retry = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SPIx-&gt;SR&amp;SPI_FLAG_RXNE))&#123;</span><br><span class="line">retry++;</span><br><span class="line"><span class="keyword">if</span>(retry&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*p_RxData++ = SPIx-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdComMF522</span></span><br><span class="line"><span class="comment"> * 描述  ：通过RC522和ISO14443卡通讯</span></span><br><span class="line"><span class="comment"> * 输入  ：ucCommand，RC522命令字</span></span><br><span class="line"><span class="comment"> *         pInData，通过RC522发送到卡片的数据</span></span><br><span class="line"><span class="comment"> *         ucInLenByte，发送数据的字节长度</span></span><br><span class="line"><span class="comment"> *         pOutData，接收到的卡片返回数据</span></span><br><span class="line"><span class="comment"> *         pOutLenBit，返回数据的位长度</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> * 调用  ：内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdComMF522</span>(<span class="params">uint8_t Command,uint8_t *pInData,uint8_t InLenByte,uint8_t *pOutData,uint32_t *pOutLenBit</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status = MI_ERR;</span><br><span class="line">    uint8_t irqEn = <span class="number">0x00</span>;</span><br><span class="line">    uint8_t waitFor = <span class="number">0x00</span>;</span><br><span class="line">    uint8_t lastBits;</span><br><span class="line">    uint8_t n;</span><br><span class="line">    uint32_t i;</span><br><span class="line">    <span class="keyword">switch</span> (Command)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PCD_AUTHENT:   <span class="comment">//Mifare认证</span></span><br><span class="line">        irqEn = <span class="number">0x12</span>;   <span class="comment">//允许错误中断请求ErrIEn  允许空闲中断IdleIEn</span></span><br><span class="line">        waitFor = <span class="number">0x10</span>; <span class="comment">//认证寻卡等待时候 查询空闲中断标志位</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PCD_TRANSCEIVE:<span class="comment">//接收发送 发送接收</span></span><br><span class="line">        irqEn = <span class="number">0x77</span>;   <span class="comment">//允许TxIEn RxIEn IdleIEn LoAlertIEn ErrIEn TimerIEn</span></span><br><span class="line">        waitFor = <span class="number">0x30</span>; <span class="comment">//寻卡等待时候 查询接收中断标志位与 空闲中断标志位</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteRawRC(ComIEnReg, irqEn | <span class="number">0x80</span>); <span class="comment">//IRqInv置位管脚IRQ与Status1Reg的IRq位的值相反</span></span><br><span class="line">    ClearBitMask(ComIrqReg, <span class="number">0x80</span>);       <span class="comment">//Set1该位清零时，CommIRqReg的屏蔽位清零</span></span><br><span class="line">    WriteRawRC(CommandReg, PCD_IDLE);    <span class="comment">//写空闲命令</span></span><br><span class="line">    SetBitMask(FIFOLevelReg, <span class="number">0x80</span>);      <span class="comment">//置位FlushBuffer清除内部FIFO的读和写指针以及ErrReg的BufferOvfl标志位被清除</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; InLenByte; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteRawRC(FIFODataReg, pInData[i]);<span class="comment">//写数据进FIFOdata</span></span><br><span class="line">    &#125;</span><br><span class="line">    WriteRawRC(CommandReg, Command);<span class="comment">//写命令</span></span><br><span class="line">    <span class="keyword">if</span> (Command == PCD_TRANSCEIVE)</span><br><span class="line">    &#123;</span><br><span class="line">        SetBitMask(BitFramingReg, <span class="number">0x80</span>);<span class="comment">//StartSend置位启动数据发送 该位与收发命令使用时才有效</span></span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">800</span>;<span class="comment">//根据时钟频率调整，操作M1卡最大等待时间25ms</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = ReadRawRC(ComIrqReg);<span class="comment">//查询事件中断</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i != <span class="number">0</span>) &amp;&amp; !(n &amp; <span class="number">0x01</span>) &amp;&amp; !(n &amp; waitFor));<span class="comment">//退出条件i=0,定时器中断，与写空闲命令</span></span><br><span class="line">    ClearBitMask(BitFramingReg, <span class="number">0x80</span>);<span class="comment">//清理允许StartSend位</span></span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(ReadRawRC(ErrorReg) &amp; <span class="number">0x1B</span>))<span class="comment">//读错误标志寄存器BufferOfI CollErr ParityErr ProtocolErr</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_OK;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; irqEn &amp; <span class="number">0x01</span>)<span class="comment">//是否发生定时器中断</span></span><br><span class="line">            &#123;</span><br><span class="line">                status = MI_NOTAGERR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Command == PCD_TRANSCEIVE)</span><br><span class="line">            &#123;</span><br><span class="line">                n = ReadRawRC(FIFOLevelReg);<span class="comment">//读FIFO中保存的字节数</span></span><br><span class="line">                lastBits = ReadRawRC(ControlReg) &amp; <span class="number">0x07</span>;<span class="comment">//最后接收到得字节的有效位数</span></span><br><span class="line">                <span class="keyword">if</span> (lastBits)</span><br><span class="line">                &#123;</span><br><span class="line">                    *pOutLenBit = (n - <span class="number">1</span>) * <span class="number">8</span> + lastBits;<span class="comment">//N个字节数减去1（最后一个字节）+最后一位的位数 读取到的数据总位数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    *pOutLenBit = n * <span class="number">8</span>;<span class="comment">//最后接收到的字节整个字节有效</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    n = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n &gt; MAXRLEN)</span><br><span class="line">                &#123;</span><br><span class="line">                    n = MAXRLEN;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    pOutData[i] = ReadRawRC(FIFODataReg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SetBitMask(ControlReg, <span class="number">0x80</span>); <span class="comment">// stop timer now</span></span><br><span class="line">    WriteRawRC(CommandReg, PCD_IDLE);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdRequest</span></span><br><span class="line"><span class="comment"> * 描述  ：寻卡</span></span><br><span class="line"><span class="comment"> * 输入  ：ucReq_code，寻卡方式</span></span><br><span class="line"><span class="comment"> *                     = 0x52，寻感应区内所有符合14443A标准的卡</span></span><br><span class="line"><span class="comment"> *                     = 0x26，寻未进入休眠状态的卡</span></span><br><span class="line"><span class="comment"> *         pTagType，卡片类型代码</span></span><br><span class="line"><span class="comment"> *                   = 0x4400，Mifare_UltraLight</span></span><br><span class="line"><span class="comment"> *                   = 0x0400，Mifare_One(S50)</span></span><br><span class="line"><span class="comment"> *                   = 0x0200，Mifare_One(S70)</span></span><br><span class="line"><span class="comment"> *                   = 0x0800，Mifare_Pro(X))</span></span><br><span class="line"><span class="comment"> *                   = 0x4403，Mifare_DESFire</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRequest</span>(<span class="params">uint8_t req_code, uint8_t *pTagType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line"></span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);  <span class="comment">//清除RC522寄存位,清理指示MIFARECyptol单元接通以及所有卡的数据通信被加密的情况</span></span><br><span class="line">    WriteRawRC(BitFramingReg, <span class="number">0x07</span>); <span class="comment">//写RC522寄存器，发送的最后一个字节的七位</span></span><br><span class="line">    SetBitMask(TxControlReg, <span class="number">0x03</span>);  写RC522寄存位，TX1,TX2管脚的输出信号传递经发送调制的<span class="number">13.56</span>的能量载波信号</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = req_code;<span class="comment">//存入寻卡方式</span></span><br><span class="line"></span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">1</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status == MI_OK) &amp;&amp; (unLen == <span class="number">0x10</span>))<span class="comment">//寻卡成功返回卡类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        *pTagType = ucComMF522Buf[<span class="number">0</span>];</span><br><span class="line">        *(pTagType + <span class="number">1</span>) = ucComMF522Buf[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAnticoll</span></span><br><span class="line"><span class="comment"> * 描述  ：防冲撞</span></span><br><span class="line"><span class="comment"> * 输入  ：pSnr，卡片序列号，4字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAnticoll</span>(<span class="params">uint8_t *pSnr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint8_t i, snr_check = <span class="number">0</span>;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);<span class="comment">//清MFCryptol On位,只有成功执行MFAuthent命令后，该位才能置位</span></span><br><span class="line">    WriteRawRC(BitFramingReg, <span class="number">0x00</span>);<span class="comment">//清理寄存器,停止收发</span></span><br><span class="line">    ClearBitMask(CollReg, <span class="number">0x80</span>);<span class="comment">//清ValuesAfterColl所有接收的位在冲突后被清除</span></span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_ANTICOLL1;<span class="comment">//卡片防冲突命令</span></span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">2</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(pSnr + i) = ucComMF522Buf[i];</span><br><span class="line">            snr_check ^= ucComMF522Buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (snr_check != ucComMF522Buf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SetBitMask(CollReg, <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdSelect</span></span><br><span class="line"><span class="comment"> * 描述  ：选定卡片</span></span><br><span class="line"><span class="comment"> * 输入  ：pSnr，卡片序列号，4字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdSelect</span>(<span class="params">uint8_t *pSnr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint8_t i;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_ANTICOLL1;<span class="comment">//防冲撞</span></span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = <span class="number">0x70</span>;</span><br><span class="line">    ucComMF522Buf[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[i + <span class="number">2</span>] = *(pSnr + i);</span><br><span class="line">        ucComMF522Buf[<span class="number">6</span>] ^= *(pSnr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">7</span>, &amp;ucComMF522Buf[<span class="number">7</span>]);</span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">9</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status == MI_OK) &amp;&amp; (unLen == <span class="number">0x18</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAuthState</span></span><br><span class="line"><span class="comment"> * 描述  ：验证卡片密码</span></span><br><span class="line"><span class="comment"> * 输入  ：ucAuth_mode，密码验证模式</span></span><br><span class="line"><span class="comment"> *                     = 0x60，验证A密钥</span></span><br><span class="line"><span class="comment"> *                     = 0x61，验证B密钥</span></span><br><span class="line"><span class="comment"> *         uint8_t ucAddr，块地址</span></span><br><span class="line"><span class="comment"> *         pKey，密码</span></span><br><span class="line"><span class="comment"> *         pSnr，卡片序列号，4字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAuthState</span>(<span class="params">uint8_t auth_mode, uint8_t addr, uint8_t *pKey, uint8_t *pSnr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = auth_mode;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[i + <span class="number">2</span>] = *(pKey + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[i + <span class="number">8</span>] = *(pSnr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    status = PcdComMF522(PCD_AUTHENT, ucComMF522Buf, <span class="number">12</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (!(ReadRawRC(Status2Reg) &amp; <span class="number">0x08</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdRead</span></span><br><span class="line"><span class="comment"> * 描述  ：读取M1卡一块数据</span></span><br><span class="line"><span class="comment"> * 输入  ：uint8_t ucAddr，块地址</span></span><br><span class="line"><span class="comment"> *         pData，读出的数据，16字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> * 调用  ：外部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRead</span>(<span class="params">uint8_t addr, uint8_t *pData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_READ;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status == MI_OK) &amp;&amp; (unLen == <span class="number">0x90</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(pData + i) = ucComMF522Buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdWrite</span></span><br><span class="line"><span class="comment"> * 描述  ：写数据到M1卡一块</span></span><br><span class="line"><span class="comment"> * 输入  ：uint8_t ucAddr，块地址</span></span><br><span class="line"><span class="comment"> *         pData，写入的数据，16字节</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> * 调用  ：外部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdWrite</span>(<span class="params">uint8_t addr, uint8_t *pData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_WRITE;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ucComMF522Buf[i] = *(pData + i);</span><br><span class="line">        &#125;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">16</span>, &amp;ucComMF522Buf[<span class="number">16</span>]);</span><br><span class="line"></span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">18</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">        <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdValue</span></span><br><span class="line"><span class="comment"> * 描述  ：扣款和充值</span></span><br><span class="line"><span class="comment"> * 输入  ：dd_mode[IN]：命令字</span></span><br><span class="line"><span class="comment"> *              0xC0 = 扣款</span></span><br><span class="line"><span class="comment"> *              0xC1 = 充值</span></span><br><span class="line"><span class="comment"> *         addr[IN]：钱包地址</span></span><br><span class="line"><span class="comment"> *         pValue[IN]：4字节增(减)值，低位在前</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdValue</span>(<span class="params">uint8_t dd_mode, uint8_t addr, uint8_t *pValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t i, ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = dd_mode;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ucComMF522Buf[i] = *(pValue + i);</span><br><span class="line">        &#125;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">4</span>, &amp;ucComMF522Buf[<span class="number">4</span>]);</span><br><span class="line">        unLen = <span class="number">0</span>;</span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">6</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">        <span class="keyword">if</span> (status != MI_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[<span class="number">0</span>] = PICC_TRANSFER;</span><br><span class="line">        ucComMF522Buf[<span class="number">1</span>] = addr;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdBakValue</span></span><br><span class="line"><span class="comment"> * 描述  ：备份钱包</span></span><br><span class="line"><span class="comment"> * 输入  ：sourceaddr[IN]：源地址</span></span><br><span class="line"><span class="comment"> *         goaladdr[IN]：目标地址</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdBakValue</span>(<span class="params">uint8_t sourceaddr, uint8_t goaladdr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span> status;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_RESTORE;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = sourceaddr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ucComMF522Buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ucComMF522Buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ucComMF522Buf[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        ucComMF522Buf[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        CalulateCRC(ucComMF522Buf, <span class="number">4</span>, &amp;ucComMF522Buf[<span class="number">4</span>]);</span><br><span class="line">        status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">6</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">        <span class="keyword">if</span> (status != MI_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            status = MI_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != MI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_TRANSFER;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = goaladdr;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line">    status = PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line">    <span class="keyword">if</span> ((status != MI_OK) || (unLen != <span class="number">4</span>) || ((ucComMF522Buf[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) != <span class="number">0x0A</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        status = MI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdHalt</span></span><br><span class="line"><span class="comment"> * 描述  ：命令卡片进入休眠状态</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdHalt</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint32_t unLen;</span><br><span class="line">    uint8_t ucComMF522Buf[MAXRLEN];</span><br><span class="line"></span><br><span class="line">    ucComMF522Buf[<span class="number">0</span>] = PICC_HALT;</span><br><span class="line">    ucComMF522Buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    CalulateCRC(ucComMF522Buf, <span class="number">2</span>, &amp;ucComMF522Buf[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    PcdComMF522(PCD_TRANSCEIVE, ucComMF522Buf, <span class="number">4</span>, ucComMF522Buf, &amp;unLen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MI_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：CalulateCRC</span></span><br><span class="line"><span class="comment"> * 描述  ：用RC522计算CRC16</span></span><br><span class="line"><span class="comment"> * 输入  ：pIndata，计算CRC16的数组</span></span><br><span class="line"><span class="comment"> *         ucLen，计算CRC16的数组字节长度</span></span><br><span class="line"><span class="comment"> *         pOutData，存放计算结果存放的首地址</span></span><br><span class="line"><span class="comment"> * 返回  : 无</span></span><br><span class="line"><span class="comment"> * 调用  ：内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalulateCRC</span>(<span class="params">uint8_t *pIndata, uint8_t len, uint8_t *pOutData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i, n;</span><br><span class="line">    ClearBitMask(DivIrqReg, <span class="number">0x04</span>);</span><br><span class="line">    WriteRawRC(CommandReg, PCD_IDLE);</span><br><span class="line">    SetBitMask(FIFOLevelReg, <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteRawRC(FIFODataReg, *(pIndata + i));</span><br><span class="line">    &#125;</span><br><span class="line">    WriteRawRC(CommandReg, PCD_CALCCRC);</span><br><span class="line">    i = <span class="number">0xFF</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = ReadRawRC(DivIrqReg);</span><br><span class="line">        i--;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i != <span class="number">0</span>) &amp;&amp; !(n &amp; <span class="number">0x04</span>));</span><br><span class="line">    pOutData[<span class="number">0</span>] = ReadRawRC(CRCResultRegL);</span><br><span class="line">    pOutData[<span class="number">1</span>] = ReadRawRC(CRCResultRegM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdRese</span></span><br><span class="line"><span class="comment"> * 描述  ：复位RC522</span></span><br><span class="line"><span class="comment"> * 返回  : 状态值</span></span><br><span class="line"><span class="comment"> *         = MI_OK，成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdReset</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RC522_Reset_Disable();</span><br><span class="line">    delay_ms(<span class="number">10</span>);</span><br><span class="line">    RC522_Reset_Enable();</span><br><span class="line">    delay_ms(<span class="number">60</span>);</span><br><span class="line">    RC522_Reset_Disable();</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">    WriteRawRC(CommandReg, PCD_RESETPHASE);<span class="comment">//复位指令</span></span><br><span class="line">    delay_ms(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    WriteRawRC(ModeReg, <span class="number">0x3D</span>);<span class="comment">//定义发送和接收常用模式,和Mifare卡通讯，CRC初始值0x6363</span></span><br><span class="line">    WriteRawRC(TReloadRegL, <span class="number">30</span>);<span class="comment">//16位定时器低位</span></span><br><span class="line">    WriteRawRC(TReloadRegH, <span class="number">0</span>);<span class="comment">//16位定时器高位</span></span><br><span class="line">    WriteRawRC(TModeReg, <span class="number">0x8D</span>);<span class="comment">//定义内部定时器的设置</span></span><br><span class="line">    WriteRawRC(TPrescalerReg, <span class="number">0x3E</span>);<span class="comment">//设置定时器分频系数</span></span><br><span class="line">    WriteRawRC(TxAutoReg, <span class="number">0x40</span>);<span class="comment">//调制发送信号为100%ASK</span></span><br><span class="line"></span><br><span class="line">    ClearBitMask(TestPinEnReg, <span class="number">0x80</span>);</span><br><span class="line">    WriteRawRC(TxAutoReg, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MI_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：ReadRawRC</span></span><br><span class="line"><span class="comment"> * 描述  ：读RC522寄存器</span></span><br><span class="line"><span class="comment"> * 输入  ：ucAddress，寄存器地址</span></span><br><span class="line"><span class="comment"> * 返回  : 寄存器的当前值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">uint8_t <span class="title">ReadRawRC</span>(<span class="params">uint8_t Address</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t ucAddr;</span><br><span class="line">    uint8_t ucResult = <span class="number">0</span>;</span><br><span class="line">    ucAddr = ((Address &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7E</span>) | <span class="number">0x80</span>;<span class="comment">//最高位置1，读操作;最低为默认0</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    RC522_CS_Enable();</span><br><span class="line">    SPI_WriteNBytes(SPI1_SPI, &amp;ucAddr, <span class="number">1</span>);  <span class="comment">//向总线写多个数据</span></span><br><span class="line">    SPI_ReadNBytes(SPI1_SPI, &amp;ucResult, <span class="number">1</span>); <span class="comment">//向总线读多个数据</span></span><br><span class="line">    RC522_CS_Disable();</span><br><span class="line">    <span class="keyword">return</span> ucResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：WriteRawRC</span></span><br><span class="line"><span class="comment"> * 描述  ：写RC522寄存器</span></span><br><span class="line"><span class="comment"> * 输入  ：ucAddress，寄存器地址</span></span><br><span class="line"><span class="comment"> *         ucValue，写入寄存器的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawRC</span>(<span class="params">uint8_t Address, uint8_t <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t ucAddr;</span><br><span class="line">    uint8_t write_buffer[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ucAddr = ((Address &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x7E</span>);<span class="comment">//最高位置0，写操作;最低为默认0</span></span><br><span class="line">    write_buffer[<span class="number">0</span>] = ucAddr;</span><br><span class="line">    write_buffer[<span class="number">1</span>] = <span class="keyword">value</span>;</span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    RC522_CS_Enable();</span><br><span class="line">    SPI_WriteNBytes(SPI1_SPI, write_buffer, <span class="number">2</span>);</span><br><span class="line">    RC522_CS_Disable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：SetBitMask</span></span><br><span class="line"><span class="comment"> * 描述  ：对RC522寄存器置位，可对多个位同时操作</span></span><br><span class="line"><span class="comment"> * 输入  ：ucReg，寄存器地址</span></span><br><span class="line"><span class="comment"> *         ucMask，置位值,例0x13，0001 0011</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetBitMask</span>(<span class="params">uint8_t reg, uint8_t mask</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    temp = ReadRawRC(reg);        <span class="comment">//读寄存器</span></span><br><span class="line">    WriteRawRC(reg, temp | mask); <span class="comment">//将目标位置1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：ClearBitMask</span></span><br><span class="line"><span class="comment"> * 描述  ：对RC522寄存器清位</span></span><br><span class="line"><span class="comment"> * 输入  ：ucReg，寄存器地址</span></span><br><span class="line"><span class="comment"> *         ucMask，清位值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBitMask</span>(<span class="params">uint8_t reg, uint8_t mask</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t temp = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    temp = ReadRawRC(reg);</span><br><span class="line">    WriteRawRC(reg, temp &amp; ~mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAntennaOn</span></span><br><span class="line"><span class="comment"> * 描述  ：开启天线</span></span><br><span class="line"><span class="comment"> * TxControlReg寄存器位0置1，引脚TX1上的输出信号将传输由传输数据调制的13.56 MHz能量载波。</span></span><br><span class="line"><span class="comment"> * TxControlReg寄存器位1置1，引脚TX2上的输出信号将发送由传输数据调制的13.56 MHz能量载波。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOn</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint8_t i;</span><br><span class="line">    i = ReadRawRC(TxControlReg);</span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; <span class="number">0x03</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        SetBitMask(TxControlReg, <span class="number">0x03</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：PcdAntennaOff</span></span><br><span class="line"><span class="comment"> * 描述  ：关闭天线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOff</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ClearBitMask(TxControlReg, <span class="number">0x03</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：RC522_PcdConfig_Type</span></span><br><span class="line"><span class="comment"> * 描述  ：设置RC522的工作方式</span></span><br><span class="line"><span class="comment"> * 工作方式ISO14443_A</span></span><br><span class="line"><span class="comment"> * 复位中已经设置过，该函数暂时未调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Config</span>(<span class="params">uint8_t Card_Type</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ClearBitMask(Status2Reg, <span class="number">0x08</span>);</span><br><span class="line">    WriteRawRC(ModeReg, <span class="number">0x3D</span>);</span><br><span class="line">    WriteRawRC(RxSelReg, <span class="number">0x86</span>);</span><br><span class="line">    WriteRawRC(RFCfgReg, <span class="number">0x7F</span>);</span><br><span class="line">    WriteRawRC(TReloadRegL, <span class="number">30</span>);</span><br><span class="line">    WriteRawRC(TReloadRegH, <span class="number">0</span>);</span><br><span class="line">    WriteRawRC(TModeReg, <span class="number">0x8D</span>);</span><br><span class="line">    WriteRawRC(TPrescalerReg, <span class="number">0x3E</span>);</span><br><span class="line">    delay_ms(<span class="number">5</span>);</span><br><span class="line">    PcdAntennaOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RC522.h</p><p>头文件内容与API大致相同，定义了指令集和寄存器。</p><p>这里的sys.h是正点原子的F1系列头文件。</p><p>加入了引脚定义和自定义函数。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __RC522_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RC522_H</span></span><br><span class="line"><span class="meta">#include &quot;sys.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************引脚定义****************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RC522SPI引脚,RST和CS可随意更改</span></span><br><span class="line"><span class="comment">RST-PC5</span></span><br><span class="line"><span class="comment">CS-PA4</span></span><br><span class="line"><span class="comment">SCK-PA5</span></span><br><span class="line"><span class="comment">MISO-PA6</span></span><br><span class="line"><span class="comment">MOSI-PA7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Reset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_RST_Pin      GPIO_PIN_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_RST_GPIO_Port     GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_Reset_CLK_ENABLE() \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CS片选，模块SDA引脚，SPI通信时用作NSS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_CS_PIN      GPIO_PIN_4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_CS_PORT     GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_GPIO_CS_CLK_ENABLE() \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************RC522 函数宏定义**********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_Reset_Disable() HAL_GPIO_WritePin(RC522_RST_GPIO_Port, RC522_RST_Pin, GPIO_PIN_SET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_Reset_Enable() HAL_GPIO_WritePin(RC522_RST_GPIO_Port, RC522_RST_Pin, GPIO_PIN_RESET);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_CS_Enable() HAL_GPIO_WritePin(RC522_GPIO_CS_PORT, RC522_GPIO_CS_PIN, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RC522_CS_Disable() HAL_GPIO_WritePin(RC522_GPIO_CS_PORT, RC522_GPIO_CS_PIN, GPIO_PIN_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> readID  1//读</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writeID 2//写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************自定义函数****************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Start</span>(<span class="params">uint8_t block,uint8_t option,uint8_t *Write_Card_Data</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_SPI_GPIO_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************RC522指令集****************************/</span></span><br><span class="line"><span class="comment">//MF522命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_IDLE              0x00               //取消当前命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_AUTHENT           0x0E               //验证密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RECEIVE           0x08               //接收数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSMIT          0x04               //发送数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSCEIVE        0x0C               //发送并接收数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RESETPHASE        0x0F               //复位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_CALCCRC           0x03               //CRC计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mifare_One卡片命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQIDL           0x26               //寻天线区内未进入休眠状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQALL           0x52               //寻天线区内全部卡</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL1        0x93               //防冲撞</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL2        0x95               //防冲撞</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1A        0x60               //验证A密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1B        0x61               //验证B密钥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_READ             0x30               //读块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_WRITE            0xA0               //写块</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_DECREMENT        0xC0               //扣款</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_INCREMENT        0xC1               //充值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_RESTORE          0xC2               //调块数据到缓冲区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_TRANSFER         0xB0               //保存缓冲区中数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_HALT             0x50               //休眠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MF522 FIFO长度定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_FIFO_LENGTH       64                 //FIFO size=64byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MF522寄存器定义</span></span><br><span class="line"><span class="comment">// PAGE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU00                 0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CommandReg            0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ComIEnReg             0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DivlEnReg             0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ComIrqReg             0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DivIrqReg             0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ErrorReg              0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Status1Reg            0x07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     Status2Reg            0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FIFODataReg           0x09</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     FIFOLevelReg          0x0A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     WaterLevelReg         0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ControlReg            0x0C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     BitFramingReg         0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CollReg               0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU0F                 0x0F</span></span><br><span class="line"><span class="comment">// PAGE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU10                 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModeReg               0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxModeReg             0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxModeReg             0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxControlReg          0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxAutoReg             0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TxSelReg              0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxSelReg              0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RxThresholdReg        0x18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DemodReg              0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1A                 0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1B                 0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     MifareReg             0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1D                 0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU1E                 0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SerialSpeedReg        0x1F</span></span><br><span class="line"><span class="comment">// PAGE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU20                 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CRCResultRegM         0x21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CRCResultRegL         0x22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU23                 0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModWidthReg           0x24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU25                 0x25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFCfgReg              0x26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     GsNReg                0x27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     CWGsCfgReg            0x28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     ModGsCfgReg           0x29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TModeReg              0x2A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TPrescalerReg         0x2B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TReloadRegH           0x2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TReloadRegL           0x2D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TCounterValueRegH     0x2E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TCounterValueRegL     0x2F</span></span><br><span class="line"><span class="comment">// PAGE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU30                 0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestSel1Reg           0x31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestSel2Reg           0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestPinEnReg          0x33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestPinValueReg       0x34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestBusReg            0x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     AutoTestReg           0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     VersionReg            0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     AnalogTestReg         0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestDAC1Reg           0x39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestDAC2Reg           0x3A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     TestADCReg            0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3C                 0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3D                 0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3E                 0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     RFU3F  0x3F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和MF522通讯时返回的错误代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_OK                          0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_NOTAGERR                    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MI_ERR                         2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲数组大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXRLEN                       18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************内部调用函数**************************************/</span></span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRequest</span>(<span class="params">uint8_t req_code,uint8_t *pTagType</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAnticoll</span>(<span class="params">uint8_t *pSnr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdSelect</span>(<span class="params">uint8_t *pSnr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdAuthState</span>(<span class="params">uint8_t auth_mode,uint8_t addr,uint8_t *pKey,uint8_t *pSnr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdRead</span>(<span class="params">uint8_t addr,uint8_t *pData</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdWrite</span>(<span class="params">uint8_t addr,uint8_t *pData</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdValue</span>(<span class="params">uint8_t dd_mode,uint8_t addr,uint8_t *pValue</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdBakValue</span>(<span class="params">uint8_t sourceaddr, uint8_t goaladdr</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdHalt</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalulateCRC</span>(<span class="params">uint8_t *pIndata,uint8_t len,uint8_t *pOutData</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdReset</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function">uint8_t <span class="title">ReadRawRC</span>(<span class="params">uint8_t Address</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteRawRC</span>(<span class="params">uint8_t Address, uint8_t <span class="keyword">value</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetBitMask</span>(<span class="params">uint8_t reg,uint8_t mask</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBitMask</span>(<span class="params">uint8_t reg,uint8_t mask</span>)</span>;</span><br><span class="line"><span class="function"><span class="built_in">char</span> <span class="title">PcdComMF522</span>(<span class="params">uint8_t Command,uint8_t *pInData,uint8_t InLenByte,uint8_t *pOutData,unsigned <span class="built_in">int</span> *pOutLenBit</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOn</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PcdAntennaOff</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RC522_Config</span>(<span class="params">uint8_t Card_Type</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="SPI定义"><a href="#SPI定义" class="headerlink" title="SPI定义"></a>SPI定义</h4><p>spi的初始化默认即可，注意以下两项的设置，才能保持和模块的正常通信：</p><p><strong>CLKPolarity</strong>&#x3D;SPI_POLARITY_LOW; &#x2F;&#x2F;串行同步时钟的空闲状态为低电平</p><p><strong>CLKPhase</strong>&#x3D;SPI_PHASE_1EDGE; &#x2F;&#x2F;串行同步时钟的第1个跳变沿（上升或下降）数据被采样</p><p>片选引脚改为软件管理，这样方便更改引脚，</p><p><strong>NSS</strong>&#x3D;SPI_NSS_SOFT; &#x2F;&#x2F;NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理</p><p>SPI.c</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;spi.h&quot;</span></span><br><span class="line"></span><br><span class="line">SPI_HandleTypeDef SPI1_Handler;  <span class="comment">//SPI句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是SPI模块的初始化代码，配置成主机模式</span></span><br><span class="line"><span class="comment">//SPI口初始化</span></span><br><span class="line"><span class="comment">//这里针是对SPI1的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SPI1_Handler.Instance=SPI1_SPI;                         <span class="comment">//SPI1</span></span><br><span class="line">    SPI1_Handler.Init.Mode=SPI_MODE_MASTER;             <span class="comment">//设置SPI工作模式，设置为主模式</span></span><br><span class="line">    SPI1_Handler.Init.Direction=SPI_DIRECTION_2LINES;   <span class="comment">//设置SPI单向或者双向的数据模式:SPI设置为双线模式</span></span><br><span class="line">    SPI1_Handler.Init.DataSize=SPI_DATASIZE_8BIT;       <span class="comment">//设置SPI的数据大小:SPI发送接收8位帧结构</span></span><br><span class="line">    SPI1_Handler.Init.CLKPolarity=SPI_POLARITY_LOW;    <span class="comment">//串行同步时钟的空闲状态为低电平</span></span><br><span class="line">    SPI1_Handler.Init.CLKPhase=SPI_PHASE_1EDGE;         <span class="comment">//串行同步时钟的第1个跳变沿（上升或下降）数据被采样</span></span><br><span class="line">    SPI1_Handler.Init.NSS=SPI_NSS_SOFT;                 <span class="comment">//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制</span></span><br><span class="line">    SPI1_Handler.Init.BaudRatePrescaler=SPI_BAUDRATEPRESCALER_256;<span class="comment">//定义波特率预分频的值:波特率预分频值为256</span></span><br><span class="line">    SPI1_Handler.Init.FirstBit=SPI_FIRSTBIT_MSB;        <span class="comment">//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始</span></span><br><span class="line">    SPI1_Handler.Init.TIMode=SPI_TIMODE_DISABLE;        <span class="comment">//关闭TI模式</span></span><br><span class="line">    SPI1_Handler.Init.CRCCalculation=SPI_CRCCALCULATION_DISABLE;<span class="comment">//关闭硬件CRC校验</span></span><br><span class="line">    SPI1_Handler.Init.CRCPolynomial=<span class="number">7</span>;                  <span class="comment">//CRC值计算的多项式,默认值为7</span></span><br><span class="line">    HAL_SPI_Init(&amp;SPI1_Handler);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    __HAL_SPI_ENABLE(&amp;SPI1_Handler);                    <span class="comment">//使能SPI1</span></span><br><span class="line"></span><br><span class="line">    SPI1_ReadWriteByte(<span class="number">0Xff</span>);                           <span class="comment">//启动传输,产生8个时钟脉冲, 达到清空DR的作用, 非必需</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI底层驱动，时钟使能，引脚配置</span></span><br><span class="line"><span class="comment">//此函数会被HAL_SPI_Init()调用</span></span><br><span class="line"><span class="comment">//hspi:SPI句柄</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_SPI_MspInit</span>(<span class="params">SPI_HandleTypeDef *hspi</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_Initure;</span><br><span class="line"></span><br><span class="line">    SPI1_SPI_CLK_ENABLE();</span><br><span class="line">    SPI1_SCK_GPIO_CLK_ENABLE();</span><br><span class="line">    SPI1_MISO_GPIO_CLK_ENABLE();</span><br><span class="line">    SPI1_MOSI_GPIO_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    GPIO_Initure.Pin=SPI1_SCK_GPIO_PIN;</span><br><span class="line">    GPIO_Initure.Mode=GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_Initure.Pull=GPIO_PULLDOWN;</span><br><span class="line">    GPIO_Initure.Speed=GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">    HAL_GPIO_Init(SPI1_SCK_GPIO_PORT,&amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">    GPIO_Initure.Pin=SPI1_MISO_GPIO_PIN;</span><br><span class="line">    HAL_GPIO_Init(SPI1_MISO_GPIO_PORT,&amp;GPIO_Initure);</span><br><span class="line"></span><br><span class="line">    GPIO_Initure.Pin=SPI1_MOSI_GPIO_PIN;</span><br><span class="line">    HAL_GPIO_Init(SPI1_MOSI_GPIO_PORT,&amp;GPIO_Initure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPI.h</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __SPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SPI_H</span></span><br><span class="line"><span class="meta">#include &quot;sys.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SPI_HandleTypeDef SPI1_Handler;  <span class="comment">//SPI句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI1 引脚 定义 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SCK_GPIO_PORT              GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SCK_GPIO_PIN               GPIO_PIN_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SCK_GPIO_CLK_ENABLE()      do&#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MISO_GPIO_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MISO_GPIO_PIN              GPIO_PIN_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MISO_GPIO_CLK_ENABLE()     do&#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MOSI_GPIO_PORT             GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MOSI_GPIO_PIN              GPIO_PIN_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_MOSI_GPIO_CLK_ENABLE()     do&#123; __HAL_RCC_GPIOA_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI1相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SPI                        SPI1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI1_SPI_CLK_ENABLE()           do&#123; __HAL_RCC_SPI1_CLK_ENABLE(); &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_Init</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p><img src="https://img-blog.csdnimg.cn/53941b94abc34bf5a897740cede1942a.png"></p><p>本实验在于经验分享和学习记录，有不正确的地方请读者指正。</p><h2 id="五、更新源码："><a href="#五、更新源码：" class="headerlink" title="五、更新源码："></a>五、更新源码：</h2><p>源码已上传至gitee：</p><p><a href="https://gitee.com/lrf1125962926/stm32/tree/RC522_SPI/" title="stm32: 一些stm32模块使用经验记录 - Gitee.com">stm32: 一些stm32模块使用经验记录 - Gitee.com <img src="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8">https://gitee.com/lrf1125962926/stm32/tree/RC522_SPI&#x2F;;</a></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.Systick滴答定时器初始化（HAL库）&amp;无OS延时函数</title>
      <link href="/2024/03/stm32-5-Systick%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88HAL%E5%BA%93%EF%BC%89-%E6%97%A0OS%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/"/>
      <url>/2024/03/stm32-5-Systick%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88HAL%E5%BA%93%EF%BC%89-%E6%97%A0OS%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#1systick-1">1.Systick滴答定时器简介</a></li><li><a href="#2systick-3">2.Systick主要寄存器</a></li><li><a href="#3systick-9">3.Systick中断优先级</a></li><li><a href="#4systick-13">4.Systick初始化流程</a></li><li><a href="#5os-108">5.无OS延时函数</a></li></ul><h2 id="1-Systick滴答定时器简介"><a href="#1-Systick滴答定时器简介" class="headerlink" title="1.Systick滴答定时器简介"></a>1.Systick滴答定时器简介</h2><p>SysTick是属于CM4内核中的外设，其寄存器的定义和部分库函数都在core_cm4.h中实现。Systick是一个24bit的向下递减的计数器，一般设置其时钟等于SYSCLK的180M（另一个选择是HCLK&#x2F;8）。当重装载数值寄存器的值递减到0的时候，系统定时器就产生一次中断，以此循环往复。基于CM4内核的MCU都有这个系统定时器，使得软件在CM4 单片机中可以很容易的移植。因此它一般用于RTOS，用于产生时基，维持操作系统的心跳。Systick用于RTOS的总结我打算以后写UCOS博客的时候总结，这篇博客主要介绍无OS时，Systick初始化过程和延时函数使用方法。</p><h2 id="2-Systick主要寄存器"><a href="#2-Systick主要寄存器" class="headerlink" title="2.Systick主要寄存器"></a>2.Systick主要寄存器</h2><p><img src="https://img-blog.csdnimg.cn/20200404233234532.png"><br><strong>控制寄存器：</strong> CLKSOURCE用于选择时钟源，一般会选择处理器时钟；ENABLE位用于使能Systick；TICKINT位置1会开启Systick中断。<br><img src="https://img-blog.csdnimg.cn/20200404233348124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg5ODgwNA==,size_1,color_FFFFFF,t_1"><br><strong>重装载值寄存器：</strong><br><img src="https://img-blog.csdnimg.cn/20200404234149713.png"></p><h2 id="3-Systick中断优先级"><a href="#3-Systick中断优先级" class="headerlink" title=";  3.Systick中断优先级"></a><a name="3systick_9">;</a>  3.Systick中断优先级</h2><p>SysTick属于内核外设，和普通外设的中断优先级不同，没有抢占优先级和响应优先级的说法。在F429 中，内核外设的中断优先级由内核SCB的外设的寄存器SHPRx（x&#x3D;1.2.3）配置。SPRH1-SPRH3是32位的寄存器，只能通过字节访问，每 8个字段控制着一个内核外设的中断优先级的配置。在F429 中只有位 7:3 这高四位有效，所以内核外设的中断优先级可编程为：0~15，数值越小优先级越高。<br><img src="https://img-blog.csdnimg.cn/20200405093144981.png"><br><img src="https://img-blog.csdnimg.cn/20200405093414919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg5ODgwNA==,size_1,color_FFFFFF,t_1"></p><h2 id="4-Systick初始化流程"><a href="#4-Systick初始化流程" class="headerlink" title="4.Systick初始化流程"></a>4.Systick初始化流程</h2><ol><li>HAL_Init()是主函数main中执行的第一个函数，会设置中断优先级，将时钟源选为16M的HSI。我们可以注意到它还调用了HAL_InitTick()函数，它的输入参数是中断优先级，函数作用是初始化Systick并配置1ms中断一次。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INSTRUCTION_CACHE_ENABLE != 0)</span></span><br><span class="line">   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (DATA_CACHE_ENABLE != 0)</span></span><br><span class="line">   __HAL_FLASH_DATA_CACHE_ENABLE();&lt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.Systick滴答定时器初始化（HAL库）&amp;无OS延时函数</title>
      <link href="/2024/03/stm32-stm32-5-Systick%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88HAL%E5%BA%93%EF%BC%89-%E6%97%A0OS%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/"/>
      <url>/2024/03/stm32-stm32-5-Systick%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88HAL%E5%BA%93%EF%BC%89-%E6%97%A0OS%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#1systick-1">1.Systick滴答定时器简介</a></li><li><a href="#2systick-3">2.Systick主要寄存器</a></li><li><a href="#3systick-9">3.Systick中断优先级</a></li><li><a href="#4systick-13">4.Systick初始化流程</a></li><li><a href="#5os-108">5.无OS延时函数</a></li></ul><h2 id="1-Systick滴答定时器简介"><a href="#1-Systick滴答定时器简介" class="headerlink" title="1.Systick滴答定时器简介"></a>1.Systick滴答定时器简介</h2><p>SysTick是属于CM4内核中的外设，其寄存器的定义和部分库函数都在core_cm4.h中实现。Systick是一个24bit的向下递减的计数器，一般设置其时钟等于SYSCLK的180M（另一个选择是HCLK&#x2F;8）。当重装载数值寄存器的值递减到0的时候，系统定时器就产生一次中断，以此循环往复。基于CM4内核的MCU都有这个系统定时器，使得软件在CM4 单片机中可以很容易的移植。因此它一般用于RTOS，用于产生时基，维持操作系统的心跳。Systick用于RTOS的总结我打算以后写UCOS博客的时候总结，这篇博客主要介绍无OS时，Systick初始化过程和延时函数使用方法。</p><h2 id="2-Systick主要寄存器"><a href="#2-Systick主要寄存器" class="headerlink" title="2.Systick主要寄存器"></a>2.Systick主要寄存器</h2><p><img src="https://img-blog.csdnimg.cn/20200404233234532.png"><br><strong>控制寄存器：</strong> CLKSOURCE用于选择时钟源，一般会选择处理器时钟；ENABLE位用于使能Systick；TICKINT位置1会开启Systick中断。<br><img src="https://img-blog.csdnimg.cn/20200404233348124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg5ODgwNA==,size_1,color_FFFFFF,t_1"><br><strong>重装载值寄存器：</strong><br><img src="https://img-blog.csdnimg.cn/20200404234149713.png"></p><h2 id="3-Systick中断优先级"><a href="#3-Systick中断优先级" class="headerlink" title=";  3.Systick中断优先级"></a><a name="3systick_9">;</a>  3.Systick中断优先级</h2><p>SysTick属于内核外设，和普通外设的中断优先级不同，没有抢占优先级和响应优先级的说法。在F429 中，内核外设的中断优先级由内核SCB的外设的寄存器SHPRx（x&#x3D;1.2.3）配置。SPRH1-SPRH3是32位的寄存器，只能通过字节访问，每 8个字段控制着一个内核外设的中断优先级的配置。在F429 中只有位 7:3 这高四位有效，所以内核外设的中断优先级可编程为：0~15，数值越小优先级越高。<br><img src="https://img-blog.csdnimg.cn/20200405093144981.png"><br><img src="https://img-blog.csdnimg.cn/20200405093414919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg5ODgwNA==,size_1,color_FFFFFF,t_1"></p><h2 id="4-Systick初始化流程"><a href="#4-Systick初始化流程" class="headerlink" title="4.Systick初始化流程"></a>4.Systick初始化流程</h2><ol><li>HAL_Init()是主函数main中执行的第一个函数，会设置中断优先级，将时钟源选为16M的HSI。我们可以注意到它还调用了HAL_InitTick()函数，它的输入参数是中断优先级，函数作用是初始化Systick并配置1ms中断一次。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (INSTRUCTION_CACHE_ENABLE != 0)</span></span><br><span class="line">   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (DATA_CACHE_ENABLE != 0)</span></span><br><span class="line">   __HAL_FLASH_DATA_CACHE_ENABLE();&lt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32cam系列教程002：ESP32cam通过MQTT协议上传图片数据到阿里云IOT平台 - 巧遇人生 - 博客园</title>
      <link href="/2024/03/ESP32-ESP32cam%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B002%EF%BC%9AESP32cam%E9%80%9A%E8%BF%87MQTT%E5%8D%8F%E8%AE%AE%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91IOT%E5%B9%B3%E5%8F%B0-%E5%B7%A7%E9%81%87%E4%BA%BA%E7%94%9F-%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
      <url>/2024/03/ESP32-ESP32cam%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B002%EF%BC%9AESP32cam%E9%80%9A%E8%BF%87MQTT%E5%8D%8F%E8%AE%AE%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91IOT%E5%B9%B3%E5%8F%B0-%E5%B7%A7%E9%81%87%E4%BA%BA%E7%94%9F-%E5%8D%9A%E5%AE%A2%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<p>@</p><ul><li><a href="#1-esp32cam%E9%80%9A%E8%BF%87mqtt%E5%8D%8F%E8%AE%AE%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E5%B9%B3%E5%8F%B0">1. ESP32cam通过MQTT协议上传图片数据到阿里云平台</a><ul><li><a href="#11-%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE">1.1 阿里云物联网平台相关配置</a></li><li><a href="#12-esp32cam-%E9%80%9A%E8%BF%87-mqtt-%E5%8D%8F%E8%AE%AE%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91iot%E5%B9%B3%E5%8F%B0">1.2 esp32cam 通过 mqtt 协议上传图片到阿里云IOT平台</a></li></ul></li><li><a href="#2-%E4%BB%8E%E9%98%BF%E9%87%8C%E4%BA%91iot%E5%B9%B3%E5%8F%B0%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0">2. 从阿里云IOT平台获取图片数据并保存到本地</a><ul><li><a href="#21-%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE">2.1 阿里云物联网平台相关配置</a></li><li><a href="#22-%E5%B0%86%E9%98%BF%E9%87%8C%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87amqp%E5%AE%9E%E6%97%B6%E6%8B%89%E5%8F%96%E5%88%B0%E6%9C%AC%E5%9C%B0">2.2 将阿里云平台中的数据通过AMQP实时拉取到本地</a><ul><li><a href="#221-nodejs-%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE">2.2.1 Node.js 获取阿里云物联网平台图片数据</a></li><li><a href="#222-python-%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83">2.2.2 Python 获取阿里云物联网平台图片数据（仅供参考）</a></li></ul></li></ul></li></ul><h1 id="1-ESP32cam通过MQTT协议上传图片数据到阿里云平台"><a href="#1-ESP32cam通过MQTT协议上传图片数据到阿里云平台" class="headerlink" title="1. ESP32cam通过MQTT协议上传图片数据到阿里云平台"></a>1. ESP32cam通过MQTT协议上传图片数据到阿里云平台</h1><h2 id="1-1-阿里云物联网平台相关配置"><a href="#1-1-阿里云物联网平台相关配置" class="headerlink" title="1.1 阿里云物联网平台相关配置"></a>1.1 阿里云物联网平台相关配置</h2><ol><li>进入阿里云物联网平台创建公共实例<br>阿里云物联网平台网址：<a href="https://iot.console.aliyun.com/">https://iot.console.aliyun.com/</a></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/6c412b90a973e23d4fe84014f18203b7.png"></p><p>选择 华东2（上海）节点，开通公共实例。</p><ol><li>创建产品与设备</li></ol><ul><li>创建产品：<br><img src="https://img-blog.csdnimg.cn/img_convert/d12514d43501488585c89df33d1ffffc.png"></li><li>在产品中的功能定义中创建功能模块用来存储图片文本：<br><img src="https://img-blog.csdnimg.cn/img_convert/68123aa0e93845935f1ee43a9b6fa3b0.png"></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/0611112fedaff4c705362d581788f27d.png"></p><ul><li>创建设备：<br><img src="https://img-blog.csdnimg.cn/img_convert/4d36e491d54471368ace116dfddffa55.png"></li><li>在设备的物模型数据中就有 img 的模块：<br><img src="https://img-blog.csdnimg.cn/img_convert/778ae787e98b8a5c4b8d91e67f6423f6.png"></li></ul><p>自此，阿里云物联网平台的准备工作就已全部完成。</p><h2 id="1-2-esp32cam-通过-mqtt-协议上传图片到阿里云IOT平台"><a href="#1-2-esp32cam-通过-mqtt-协议上传图片到阿里云IOT平台" class="headerlink" title="1.2 esp32cam 通过 mqtt 协议上传图片到阿里云IOT平台"></a>1.2 esp32cam 通过 mqtt 协议上传图片到阿里云IOT平台</h2><blockquote><p>注：本人使用 Arduino IDE 开发 ESP32cam 程序，如何使用 Arduino IDE 开发 ESP32 程序请参考本人其他博客。<a href="https://blog.gitnote.cn/post/esp32cam_001/">博客：Arduino 配置 ESP32 开发环境</a></p></blockquote><p>在 Arduino IDE 中新建一个项目，需要有三个文件：</p><ul><li>send_img_aliyun.ino</li><li>aliyunmqtt.cpp</li><li>aliyunmqtt.h<br>其中 <code>send_img_aliyun.ino</code> 为上传图片数据到阿里云物联网平台的主程序， <code>aliyunmqtt.cpp</code> 与 <code>aliyunmqtt.h</code> 是连接阿里云物联网平台的校验程序。</li></ul><p>仅需修改 <code>send_img_aliyun.ino</code> 中 WIFI 账号与密码 和 阿里云物联网平台三元组（见下图）即可， <code>aliyunmqtt.cpp</code> 与 <code>aliyunmqtt.h</code> 文件无需修改任何内容。由于 ESP32cam 性能问题， <code>send_img_aliyun.ino</code> 中将一个图片分为多段进行传输，每段为 800，详见代码。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7e39e1cc37cca0312f027a75fcca6166.png"></p><p>这里直接给出代码：</p><blockquote><p><code>send_img_aliyun.ino</code> :</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send_img_aliyun.ino</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &quot;aliyun_mqtt.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aliyunmqtt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FS.h&quot;</span>                <span class="comment">// SD Card ESP32</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SD_MMC.h&quot;</span>            <span class="comment">// SD Card ESP32</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;soc/soc.h&quot;</span>           <span class="comment">// Disable brownour problems</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;soc/rtc_cntl_reg.h&quot;</span>  <span class="comment">// Disable brownour problems</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/rtc_io.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存存储相关配置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_SIZE 1</span></span><br><span class="line"><span class="type">int</span> pictureNumber = <span class="number">0</span>;</span><br><span class="line">String msg;</span><br><span class="line"><span class="type">int</span> buttonState = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> btnHold = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define SENSOR_PIN 10</span></span><br><span class="line"><span class="comment">//以下信息需要自己修改</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_SSID <span class="string">&quot;TP-LINK_1760&quot;</span>  <span class="comment">//替换自己的WIFI</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_PASSWD <span class="string">&quot;987654321&quot;</span>   <span class="comment">//替换自己的WIFI密码</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阿里云物联网 三元组</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRODUCT_KEY <span class="string">&quot;k0xxxxxIM&quot;</span>                         <span class="comment">//替换自己的PRODUCT_KEY</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;esp001_001&quot;</span>                       <span class="comment">//替换自己的DEVICE_NAME</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_SECRET <span class="string">&quot;589xxxxxxxxxxxxxxxxxxxe0f&quot;</span>  <span class="comment">//替换自己的DEVICE_SECRET \</span></span></span><br><span class="line"><span class="comment"><span class="meta"></span></span></span><br><span class="line"><span class="comment">//以下不需修改</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_BODY_FORMAT <span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;123\&quot;,\&quot;version\&quot;:\&quot;1.0\&quot;,\&quot;method\&quot;:\&quot;%s\&quot;,\&quot;params\&quot;:%s&#125;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_TOPIC_PROP_POST <span class="string">&quot;/sys/&quot;</span> PRODUCT_KEY <span class="string">&quot;/&quot;</span> DEVICE_NAME <span class="string">&quot;/thing/event/property/post&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_TOPIC_PROP_POSTRSP <span class="string">&quot;/sys/&quot;</span> PRODUCT_KEY <span class="string">&quot;/&quot;</span> DEVICE_NAME <span class="string">&quot;/thing/event/property/post_reply&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_TOPIC_PROP_SET <span class="string">&quot;/sys/&quot;</span> PRODUCT_KEY <span class="string">&quot;/&quot;</span> DEVICE_NAME <span class="string">&quot;/thing/service/property/set&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_METHOD_PROP_POST <span class="string">&quot;thing.event.property.post&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_TOPIC_DEV_INFO <span class="string">&quot;/ota/device/inform/&quot;</span> PRODUCT_KEY <span class="string">&quot;/&quot;</span> DEVICE_NAME <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALINK_VERSION_FROMA <span class="string">&quot;&#123;\&quot;id\&quot;: 123,\&quot;params\&quot;: &#123;\&quot;version\&quot;: \&quot;%s\&quot;&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> lastMs = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 测试 初始温度</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">WiFiClient espClient;</span><br><span class="line"><span class="function">PubSubClient <span class="title">mqttClient</span><span class="params">(espClient)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAMERA_MODEL_AI_THINKER类型摄像头的引脚定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWDN_GPIO_NUM 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESET_GPIO_NUM -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XCLK_GPIO_NUM 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIOD_GPIO_NUM 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIOC_GPIO_NUM 27</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y9_GPIO_NUM 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y8_GPIO_NUM 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y7_GPIO_NUM 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y6_GPIO_NUM 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y5_GPIO_NUM 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y4_GPIO_NUM 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y3_GPIO_NUM 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Y2_GPIO_NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VSYNC_GPIO_NUM 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HREF_GPIO_NUM 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCLK_GPIO_NUM 22</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">camera_config_t</span> camera_config = &#123;</span><br><span class="line">  .pin_pwdn = PWDN_GPIO_NUM,</span><br><span class="line">  .pin_reset = RESET_GPIO_NUM,</span><br><span class="line">  .pin_xclk = XCLK_GPIO_NUM,</span><br><span class="line">  .pin_sscb_sda = SIOD_GPIO_NUM,</span><br><span class="line">  .pin_sscb_scl = SIOC_GPIO_NUM,</span><br><span class="line"></span><br><span class="line">  .pin_d7 = Y9_GPIO_NUM,</span><br><span class="line">  .pin_d6 = Y8_GPIO_NUM,</span><br><span class="line">  .pin_d5 = Y7_GPIO_NUM,</span><br><span class="line">  .pin_d4 = Y6_GPIO_NUM,</span><br><span class="line">  .pin_d3 = Y5_GPIO_NUM,</span><br><span class="line">  .pin_d2 = Y4_GPIO_NUM,</span><br><span class="line">  .pin_d1 = Y3_GPIO_NUM,</span><br><span class="line">  .pin_d0 = Y2_GPIO_NUM,</span><br><span class="line">  .pin_vsync = VSYNC_GPIO_NUM,</span><br><span class="line">  .pin_href = HREF_GPIO_NUM,</span><br><span class="line">  .pin_pclk = PCLK_GPIO_NUM,</span><br><span class="line"></span><br><span class="line">  .xclk_freq_hz = <span class="number">20000000</span>,</span><br><span class="line">  .ledc_timer = LEDC_TIMER_0,</span><br><span class="line">  .ledc_channel = LEDC_CHANNEL_0,</span><br><span class="line"></span><br><span class="line">  .pixel_format = PIXFORMAT_JPEG,</span><br><span class="line">  <span class="comment">// .frame_size = FRAMESIZE_VGA,</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_UXGA (1600 x 1200)</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_QVGA (320 x 240)</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_CIF (352 x 288)</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_VGA (640 x 480)</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_SVGA (800 x 600)</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_XGA (1024 x 768)</span></span><br><span class="line">  <span class="comment">// FRAMESIZE_SXGA (1280 x 1024)</span></span><br><span class="line">  .frame_size = FRAMESIZE_QVGA,</span><br><span class="line">  .jpeg_quality = <span class="number">10</span>,</span><br><span class="line">  <span class="comment">// 图像质量（jpeg_quality) 可以是 0 到 63 之间的数字。数字越小意味着质量越高</span></span><br><span class="line">  .fb_count = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_wifi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ssid, <span class="type">const</span> <span class="type">char</span> *password)</span> </span>&#123;</span><br><span class="line">  WiFi.<span class="built_in">mode</span>(WIFI_STA);</span><br><span class="line">  WiFi.<span class="built_in">begin</span>(ssid, password);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.<span class="built_in">status</span>() != WL_CONNECTED) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;WiFi does not connect, try again ...&quot;</span>);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Wifi is connected.&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(WiFi.<span class="built_in">localIP</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mqtt_callback</span><span class="params">(<span class="type">char</span> *topic, byte *payload, <span class="type">unsigned</span> <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;Message arrived [&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">print</span>(topic);</span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;] &quot;</span>);</span><br><span class="line">  payload[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  Serial.<span class="built_in">println</span>((<span class="type">char</span> *)payload);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(topic, ALINK_TOPIC_PROP_SET)) &#123;</span><br><span class="line">    StaticJsonBuffer jsonBuffer;</span><br><span class="line">    JsonObject &amp;root = jsonBuffer.<span class="built_in">parseObject</span>(payload);</span><br><span class="line">    <span class="keyword">if</span> (!root.<span class="built_in">success</span>()) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;parseObject() failed&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mqtt_check_connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!mqttClient.<span class="built_in">connected</span>())  <span class="comment">//</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">connect_aliyun_mqtt</span>(mqttClient, PRODUCT_KEY, DEVICE_NAME, DEVICE_SECRET)) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;MQTT connect succeed!&quot;</span>);</span><br><span class="line">      <span class="comment">//client.subscribe(ALINK_TOPIC_PROP_POSTRSP);</span></span><br><span class="line">      mqttClient.<span class="built_in">subscribe</span>(ALINK_TOPIC_PROP_SET);</span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;subscribe done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mqtt_interval_post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  static int i=0;</span></span><br><span class="line">  <span class="type">char</span> param[<span class="number">512</span>];</span><br><span class="line">  <span class="type">char</span> jsonBuf[<span class="number">1024</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(jsonBuf, <span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;1189401707\&quot;,\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;method\&quot;:\&quot;%s\&quot;,\&quot;params\&quot;:&#123;\&quot;img\&quot;:\&quot;END\&quot;&#125;&#125;&quot;</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(jsonBuf);</span><br><span class="line">  mqttClient.<span class="built_in">publish</span>(ALINK_TOPIC_PROP_POST, jsonBuf);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;发送结束符&quot;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 摄像头、SD卡与 SPIFFS 初始化</span></span><br><span class="line"><span class="function"><span class="type">esp_err_t</span> <span class="title">camera_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//initialize the camera</span></span><br><span class="line">  <span class="type">esp_err_t</span> err = <span class="built_in">esp_camera_init</span>(&amp;camera_config);</span><br><span class="line">  <span class="keyword">if</span> (err != ESP_OK) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Camera Init Failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">sensor_t</span> *s = <span class="built_in">esp_camera_sensor_get</span>();</span><br><span class="line">  <span class="comment">//initial sensors are flipped vertically and colors are a bit saturated</span></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;id.PID == OV2640_PID) &#123;</span><br><span class="line">    <span class="comment">//        s-&gt;set_vflip(s, 1);//flip it back</span></span><br><span class="line">    <span class="comment">//        s-&gt;set_brightness(s, 1);//up the blightness just a bit</span></span><br><span class="line">    <span class="comment">//        s-&gt;set_contrast(s, 1);</span></span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Camera Init OK!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sd_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//SD card init</span></span><br><span class="line">  <span class="keyword">if</span> (!SD_MMC.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Card Mount Failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint8_t</span> cardType = SD_MMC.<span class="built_in">cardType</span>();</span><br><span class="line">  <span class="keyword">if</span> (cardType == CARD_NONE) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;No SD_MMC card attached&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPIFFS_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化SPIFFS</span></span><br><span class="line">  <span class="keyword">if</span> (!SPIFFS.<span class="built_in">begin</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;An Error has occurred while mounting SPIFFS&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;SPIFFS mounted successfully&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Turn-off the &#x27;brownout detector&#x27;</span></span><br><span class="line">  <span class="built_in">WRITE_PERI_REG</span>(RTC_CNTL_BROWN_OUT_REG, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 摄像头、SD卡与 SPIFFS 初始化 end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;程序 Start&quot;</span>);</span><br><span class="line">  <span class="built_in">init_wifi</span>(WIFI_SSID, WIFI_PASSWD);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">camera_init</span>();</span><br><span class="line">  <span class="built_in">sd_init</span>();</span><br><span class="line">  <span class="built_in">SPIFFS_init</span>();</span><br><span class="line"></span><br><span class="line">  mqttClient.<span class="built_in">setCallback</span>(mqtt_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the loop function runs over and over again forever</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 程序开始拍照并保存</span></span><br><span class="line">  Serial.<span class="built_in">print</span>(<span class="string">&quot;进行拍照\n&quot;</span>);</span><br><span class="line">  <span class="type">camera_fb_t</span> *fb = <span class="built_in">esp_camera_fb_get</span>();</span><br><span class="line">  <span class="keyword">if</span> (!fb) &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;Camera capture failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    EEPROM.<span class="built_in">begin</span>(EEPROM_SIZE);</span><br><span class="line">    pictureNumber = EEPROM.<span class="built_in">read</span>(<span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Path where new picture will be saved in SD Card</span></span><br><span class="line">    String path = <span class="string">&quot;/picture&quot;</span> + <span class="built_in">String</span>(pictureNumber) + <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fs::FS &amp;fs = SD_MMC;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;文件名字: %s\n&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">    File file = fs.<span class="built_in">open</span>(path.<span class="built_in">c_str</span>(), FILE_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;Failed to open file in writing mode&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      file.<span class="built_in">write</span>(fb-&gt;buf, fb-&gt;len);  <span class="comment">// payload (image), payload length</span></span><br><span class="line">      Serial.<span class="built_in">println</span>(fb-&gt;len);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;抓拍成功并保存\n&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">printf</span>(<span class="string">&quot;保存路径: %s\n\n&quot;</span>, path.<span class="built_in">c_str</span>());</span><br><span class="line">      EEPROM.<span class="built_in">write</span>(<span class="number">0</span>, pictureNumber);</span><br><span class="line">      EEPROM.<span class="built_in">commit</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String a1 = <span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;1189401707\&quot;,\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;method\&quot;:\&quot;123\&quot;,\&quot;params\&quot;:&#123;\&quot;img\&quot;:\&quot;&quot;</span>;</span><br><span class="line">    String a2;</span><br><span class="line">    String a3 = <span class="string">&quot;\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">4104</span>];</span><br><span class="line">    <span class="comment">// 将图片分为不超过 800 通过 MQTT 发送出去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fb-&gt;len; i++) &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(data, <span class="string">&quot;%02X&quot;</span>, *(fb-&gt;buf + i));</span><br><span class="line">      a2 += data;</span><br><span class="line">      <span class="keyword">if</span> (a2.<span class="built_in">length</span>() == <span class="number">800</span>) &#123;</span><br><span class="line">        String a4 = a1 + a2;</span><br><span class="line">        String a = a4 + a3;</span><br><span class="line">        <span class="type">char</span> jsonBuf[a.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">          jsonBuf[i] = a[i];</span><br><span class="line">        jsonBuf[a.<span class="built_in">length</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        Serial.<span class="built_in">println</span>(jsonBuf);</span><br><span class="line">        mqttClient.<span class="built_in">publish</span>(ALINK_TOPIC_PROP_POST, jsonBuf);</span><br><span class="line">        a2 = <span class="string">&quot;&quot;</span>, a = <span class="string">&quot;&quot;</span>, a4 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// ms</span></span><br><span class="line">        <span class="built_in">delay</span>(<span class="number">200</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a2.<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String a4 = a1 + a2;</span><br><span class="line">      String a = a4 + a3;</span><br><span class="line">      <span class="type">char</span> jsonBuf[a.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">        jsonBuf[i] = a[i];</span><br><span class="line">      jsonBuf[a.<span class="built_in">length</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      Serial.<span class="built_in">println</span>(jsonBuf);</span><br><span class="line">      mqttClient.<span class="built_in">publish</span>(ALINK_TOPIC_PROP_POST, jsonBuf);</span><br><span class="line">      a2 = <span class="string">&quot;&quot;</span>, a = <span class="string">&quot;&quot;</span>, a4 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 将图片分为不超过 800 通过 MQTT 发送出去  end</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">char</span> endBuf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(endBuf, <span class="string">&quot;&#123;\&quot;id\&quot;:\&quot;1189401707\&quot;,\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;method\&quot;:\&quot;123\&quot;,\&quot;params\&quot;:&#123;\&quot;img\&quot;:\&quot;END\&quot;&#125;&#125;&quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(endBuf);</span><br><span class="line">    mqttClient.<span class="built_in">publish</span>(ALINK_TOPIC_PROP_POST, endBuf);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;发送结束符&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;图片发送完成了......&quot;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 图片发送结束后发送 END</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">millis</span>() - lastMs &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">    lastMs = <span class="built_in">millis</span>();</span><br><span class="line">    <span class="built_in">mqtt_check_connect</span>();</span><br><span class="line">    <span class="comment">// Post  interval 间隔</span></span><br><span class="line">    <span class="comment">// mqtt_interval_post();</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mqttClient.<span class="built_in">loop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> WAIT_MS = <span class="number">2000</span>;</span><br><span class="line">  <span class="built_in">delay</span>(WAIT_MS);  <span class="comment">// ms</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="built_in">millis</span>() / WAIT_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>aliyunmqtt.h</code> :</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aliyunmqtt.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Aliyun_mqtt.h - Library for connect to Aliyun MQTT server with authentication by</span></span><br><span class="line"><span class="comment">  product key, device name and device secret.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  https://www.alibabacloud.com/help/product/30520.htm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALIYUN_MATT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALIYUN_MATT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Arduino.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Connect to Alibaba Cloud MQTT server. In connection process, it will try several times for</span></span><br><span class="line"><span class="comment"> * possible network failure. For authentication issue, it will return false at once.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param mqttClient: Caller provide a valid PubSubClient object (initialized with network client).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param productKey: Product Key, get from Alibaba Cloud Link Platform.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param deviceName: Device Name, get from Alibaba Cloud Link Platform.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * @param deviceSecret: Device Secret, get from Alibaba Cloud Link Platform.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param region: Optional region, use &quot;cn-shanghai&quot; as default. It can be &quot;us-west-1&quot;,</span></span><br><span class="line"><span class="comment"> *                &quot;ap-southeast-1&quot; etc. Refer to Alibaba Cloud Link Platform.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return true if connect succeed, otherwise false.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">bool</span> <span class="title">connect_aliyun_mqtt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PubSubClient &amp;mqttClient,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *productKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *deviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *deviceSecret,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *region = <span class="string">&quot;cn-shanghai&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Two new added APIs are designed for devices with limited resource like Arduino UNO.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Since it is hard to calculate HMAC256 on such devices, the calculation can be done externally.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These two APIs should be used together with external HMAC256 calculation tools, e.g.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * http://tool.oschina.net/encrypt?type=2</span></span><br><span class="line"><span class="comment"> * They can be used together to replace connectAliyunMQTT on resource-limited devices.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This API should be called in setup() phase to init all MQTT parameters. Since HMAC256</span></span><br><span class="line"><span class="comment"> * calculation is executed extenrally, a fixed timestamp string should be provided, such</span></span><br><span class="line"><span class="comment"> * as &quot;23668&quot; etc. The same timestamp string is also used to calculate HMAC256 result.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Other params are similar to them in connectAliyunMQTT.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">mqtt_prepare</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *productKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *deviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *deviceSecret,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *region = <span class="string">&quot;cn-shanghai&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use tools here to calculate HMAC256: http://tool.oschina.net/encrypt?type=2</span></span><br><span class="line"><span class="comment"> * The calculated result should be defined as constants and passed when call this function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">bool</span> <span class="title">connect_aliyun_mqtt_With_password</span><span class="params">(PubSubClient &amp;mqttClient, <span class="type">const</span> <span class="type">char</span> *password)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>aliyunmqtt.cpp</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aliyunmqtt.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Aliyun_mqtt.h - Library for connect to Aliyun MQTT server.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &quot;aliyun_mqtt.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aliyunmqtt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MQTT_PORT 1883</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHA256HMAC_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify tool: http://tool.oschina.net/encrypt?type=2</span></span><br><span class="line"><span class="function"><span class="type">static</span> String <span class="title">hmac256</span><span class="params">(<span class="type">const</span> String &amp;signcontent, <span class="type">const</span> String &amp;ds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  byte hashCode[SHA256HMAC_SIZE];</span><br><span class="line">  SHA256 sha256;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *key = ds.<span class="built_in">c_str</span>();</span><br><span class="line">  <span class="type">size_t</span> keySize = ds.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">  sha256.<span class="built_in">resetHMAC</span>(key, keySize);</span><br><span class="line">  sha256.<span class="built_in">update</span>((<span class="type">const</span> byte *)signcontent.<span class="built_in">c_str</span>(), signcontent.<span class="built_in">length</span>());</span><br><span class="line">  sha256.<span class="built_in">finalizeHMAC</span>(key, keySize, hashCode, <span class="built_in">sizeof</span>(hashCode));</span><br><span class="line"></span><br><span class="line">  String sign = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (byte i = <span class="number">0</span>; i &lt; SHA256HMAC_SIZE; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    sign += <span class="string">&quot;0123456789ABCDEF&quot;</span>[hashCode[i] &gt;&gt; <span class="number">4</span>];</span><br><span class="line">    sign += <span class="string">&quot;0123456789ABCDEF&quot;</span>[hashCode[i] &amp; <span class="number">0xf</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> String mqttBroker;</span><br><span class="line"><span class="type">static</span> String mqttClientID;</span><br><span class="line"><span class="type">static</span> String mqttUserName;</span><br><span class="line"><span class="type">static</span> String mqttPassword;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call this function once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mqtt_prepare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *timestamp,<span class="type">const</span> <span class="type">char</span> *productKey, <span class="type">const</span> <span class="type">char</span> *deviceName,<span class="type">const</span> <span class="type">char</span> *deviceSecret,<span class="type">const</span> <span class="type">char</span> *region)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mqttBroker = productKey;</span><br><span class="line">  mqttBroker += <span class="string">&quot;.iot-as-mqtt.&quot;</span>;</span><br><span class="line">  mqttBroker += <span class="built_in">String</span>(region);</span><br><span class="line">  mqttBroker += <span class="string">&quot;.aliyuncs.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Serial.println(mqttBroker);</span></span><br><span class="line"></span><br><span class="line">  mqttUserName = deviceName;</span><br><span class="line">  mqttUserName += <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">  mqttUserName += productKey;</span><br><span class="line">   <span class="comment">//Serial.println(mqttUserName);</span></span><br><span class="line"></span><br><span class="line">  mqttClientID = deviceName; <span class="comment">// device name used as client ID</span></span><br><span class="line">  mqttClientID += <span class="string">&quot;|securemode=3,signmethod=hmacsha256,timestamp=&quot;</span>;</span><br><span class="line">  mqttClientID += timestamp;</span><br><span class="line">  mqttClientID += <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">   <span class="comment">//Serial.println(mqttClientID);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect_aliyun_mqtt_With_password</span><span class="params">(PubSubClient &amp;mqttClient, <span class="type">const</span> <span class="type">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mqttClient.<span class="built_in">setServer</span>(mqttBroker.<span class="built_in">c_str</span>(), MQTT_PORT);</span><br><span class="line"></span><br><span class="line">  byte mqttConnectTryCnt = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">while</span> (!mqttClient.<span class="built_in">connected</span>() &amp;&amp; mqttConnectTryCnt &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//Serial.println(&quot;Connecting to MQTT Server ...&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (mqttClient.<span class="built_in">connect</span>(mqttClientID.<span class="built_in">c_str</span>(), mqttUserName.<span class="built_in">c_str</span>(), password))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Serial.println(&quot;MQTT Connected!&quot;);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      byte errCode = mqttClient.<span class="built_in">state</span>();</span><br><span class="line">      <span class="comment">//Serial.print(&quot;MQTT connect failed, error code:&quot;);</span></span><br><span class="line">      <span class="comment">//Serial.println(errCode);</span></span><br><span class="line">      <span class="keyword">if</span> (errCode == MQTT_CONNECT_BAD_PROTOCOL || errCode == MQTT_CONNECT_BAD_CLIENT_ID || errCode == MQTT_CONNECT_BAD_CREDENTIALS || errCode == MQTT_CONNECT_UNAUTHORIZED)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//Serial.println(&quot;No need to try again.&quot;);</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// No need to try again for these situation</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">delay</span>(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mqttConnectTryCnt -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect_aliyun_mqtt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PubSubClient &amp;mqttClient,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *productKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *deviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *deviceSecret,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *region)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String timestamp = <span class="built_in">String</span>(<span class="built_in">millis</span>());</span><br><span class="line">  <span class="built_in">mqtt_prepare</span>(timestamp.<span class="built_in">c_str</span>(), productKey, deviceName, deviceSecret, region);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate MQTT Password, use deviceName as clientID</span></span><br><span class="line">  String signcontent = <span class="string">&quot;clientId&quot;</span>;</span><br><span class="line">  signcontent += deviceName;</span><br><span class="line">  signcontent += <span class="string">&quot;deviceName&quot;</span>;</span><br><span class="line">  signcontent += deviceName;</span><br><span class="line">  signcontent += <span class="string">&quot;productKey&quot;</span>;</span><br><span class="line">  signcontent += productKey;</span><br><span class="line">  signcontent += <span class="string">&quot;timestamp&quot;</span>;</span><br><span class="line">  signcontent += timestamp;</span><br><span class="line"></span><br><span class="line">  String mqttPassword = <span class="built_in">hmac256</span>(signcontent, deviceSecret);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Serial.print(&quot;HMAC256 data: &quot;);</span></span><br><span class="line">   <span class="comment">//Serial.println(signcontent);</span></span><br><span class="line">   <span class="comment">//Serial.print(&quot;HMAC256 key: &quot;);</span></span><br><span class="line">  <span class="comment">// Serial.println(deviceSecret);</span></span><br><span class="line">  <span class="comment">// Serial.println(mqttPassword);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">connect_aliyun_mqtt_With_password</span>(mqttClient, mqttPassword.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序烧录运行结果如下图：</p><ol><li>本地 Arduino IDE 串口显示图：<br><img src="https://img-blog.csdnimg.cn/img_convert/7d29321b38f90d320016cac13767c44d.png"></li><li>物联网平台物模型已获取数据：<br><img src="https://img-blog.csdnimg.cn/img_convert/2d2b188ef1cffc95ece51b5e01b8f642.png"></li></ol><blockquote><p>注意：若Arduino IDE 串口显示正常，而物联网平台中没有获取到数据，请查看 阿里云物联网平台左侧&gt;监控运维&gt;日志服务，若日志中出现状态 460 错误，请调整本地 Arduino IDE 中引用的 <code>PubSubClient.h</code> 中的两个参数： <code>MQTT_MAX_PACKET_SIZE</code> 和 <code>MQTT_KEEPLIVE</code> ,分别调整为大于 <code>1024</code> 和大于 <code>65</code> ，然后重新烧录 ESP32cam 即可解决。</p></blockquote><p>自此，ESP32cam 获取图片数据存本地内存卡并通过 MQTT 协议上传阿里云物联网平台已全部完成。</p><h1 id="2-从阿里云IOT平台获取图片数据并保存到本地"><a href="#2-从阿里云IOT平台获取图片数据并保存到本地" class="headerlink" title="2. 从阿里云IOT平台获取图片数据并保存到本地"></a>2. 从阿里云IOT平台获取图片数据并保存到本地</h1><p>虽然图片数据已经上传到阿里云物联网平台中存储，但平台中存储的只是图片的数据，而非图片，需要将图片数据转换成图片并在其他地方展示出来。<br>于是需要进行下面操作。</p><h2 id="2-1-阿里云物联网平台相关配置"><a href="#2-1-阿里云物联网平台相关配置" class="headerlink" title="2.1 阿里云物联网平台相关配置"></a>2.1 阿里云物联网平台相关配置</h2><p>需要配置 消息转发&gt;服务端订阅：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e76be033dd790934f7e5aad790b5d84.png"></p><p>本操作就是将 ESP32cam 上传到阿里云物联网平台中的数据转发一份到处理端，处理端通过 AMQP 获取数据并解析进行下一步操作。</p><h2 id="2-2-将阿里云平台中的数据通过AMQP实时拉取到本地"><a href="#2-2-将阿里云平台中的数据通过AMQP实时拉取到本地" class="headerlink" title="2.2 将阿里云平台中的数据通过AMQP实时拉取到本地"></a>2.2 将阿里云平台中的数据通过AMQP实时拉取到本地</h2><p>将图片拉取到本地使用 Nodejs 和 Python 两种方式。</p><ol><li>Node.js 程序较为完整，可将图片数据获取到并转化为图片存到本地</li><li>Python 程序仅仅获取到数据并打印出来，仅供参考。</li></ol><h3 id="2-2-1-Node-js-获取阿里云物联网平台图片数据"><a href="#2-2-1-Node-js-获取阿里云物联网平台图片数据" class="headerlink" title="2.2.1 Node.js 获取阿里云物联网平台图片数据"></a>2.2.1 Node.js 获取阿里云物联网平台图片数据</h3><p>在本地运行 Nodejs 程序，通过 AMQP 实时获取 ESP32cam 上传到阿里云的图片数据组合成图片并保存到本地中。<br>其中部分参数配置参考：</p><ol><li><a href="https://help.aliyun.com/zh/iot/developer-reference/connect-an-amqp-client-to-iot-platform">阿里云AMQP客户端接入说明</a></li><li><a href="https://help.aliyun.com/zh/iot/developer-reference/connect-a-client-to-iot-platform-by-using-the-sdk-for-node-js">Nodejs客户端SDK接入实例</a></li><li><a href="https://help.aliyun.com/zh/iot/developer-reference/connect-a-client-to-iot-platform-by-using-the-sdk-for-python">python客户端SDK接入实例</a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="built_in">require</span>(<span class="string">&#x27;rhea&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请根据实际情况修改下面的参数</span></span><br><span class="line"><span class="comment">// host，在物联网平台首页，查看开发配置中查看</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">YourHost</span>=<span class="string">&quot;iot-06z00xxxxt6xc.amqp.iothub.aliyuncs.com&quot;</span></span><br><span class="line"><span class="comment">// 客户端ID，可自定义，长度不可超过64个字符</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">YourClientId</span>=<span class="string">&quot;esp32_001&quot;</span></span><br><span class="line"><span class="comment">// 账号的 AccessKey。将鼠标移至账号头像上，然后单击AccessKey管理，获取AccessKey ID和AccessKey Secret。</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">YourAccessKeyId</span>=<span class="string">&quot;LTAI5tXXXXXXXXXXxLEMGYL2&quot;</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">YourAccessKeySecret</span>=<span class="string">&quot;6vi2Txxxw9xxxrwig&quot;</span></span><br><span class="line"><span class="comment">// 在对应实例的消息转发 &gt; 服务端订阅 &gt; 消费组列表查看您的消费组ID。</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">YourConsumerGroupId</span>=<span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line"><span class="comment">// 物联网平台首页实例 ID</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">YourIotInstanceId</span>=<span class="string">&quot;iot-0600uxtxxsx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放完整的图片字符串</span></span><br><span class="line"><span class="keyword">var</span> imgStr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制图片转base64</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">to_base64</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> digits = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> base64_rep = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> bit_arr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> bit_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; str.<span class="property">length</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[n] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[n] = <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[n] = <span class="number">6</span>) &#123;</span><br><span class="line">            bit_num -= <span class="number">6</span>;</span><br><span class="line">            base64_rep += digits[bit_arr &gt;&gt;&gt; bit_num];</span><br><span class="line">            bit_arr &amp;= ~(-<span class="number">1</span> &lt;&lt; bit_num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bit_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bit_arr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; <span class="number">4</span> - padding; ++n) &#123;</span><br><span class="line">            base64_rep += <span class="string">&quot;=&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base64_rep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Connection。</span></span><br><span class="line"><span class="keyword">var</span> connection = container.<span class="title function_">connect</span>(&#123;</span><br><span class="line">    <span class="comment">//接入域名，请参见AMQP客户端接入说明文档。</span></span><br><span class="line">    <span class="string">&#x27;host&#x27;</span>: <span class="title class_">YourHost</span>,</span><br><span class="line">    <span class="string">&#x27;port&#x27;</span>: <span class="number">5671</span>,</span><br><span class="line">    <span class="string">&#x27;transport&#x27;</span>:<span class="string">&#x27;tls&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reconnect&#x27;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;idle_time_out&#x27;</span>:<span class="number">60000</span>,</span><br><span class="line">    <span class="comment">//userName组装方法，请参见AMQP客户端接入说明文档。</span></span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>:<span class="title class_">YourClientId</span>+<span class="string">&#x27;|authMode=aksign,signMethod=hmacsha1,timestamp=1573489088171,authId=&#x27;</span>+<span class="title class_">YourAccessKeyId</span>+<span class="string">&#x27;,iotInstanceId=&#x27;</span>+<span class="title class_">YourIotInstanceId</span>+<span class="string">&#x27;,consumerGroupId=&#x27;</span>+<span class="title class_">YourConsumerGroupId</span>+<span class="string">&#x27;|&#x27;</span>,</span><br><span class="line">    <span class="comment">//计算签名，password组装方法，请参见AMQP客户端接入说明文档。</span></span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="title function_">hmacSha1</span>(<span class="title class_">YourAccessKeySecret</span>, <span class="string">&#x27;authId=&#x27;</span>+<span class="title class_">YourAccessKeyId</span>+<span class="string">&#x27;×tamp=1573489088171&#x27;</span>),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Receiver Link</span></span><br><span class="line"><span class="keyword">var</span> receiver = connection.<span class="title function_">open_receiver</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收云端推送消息的回调函数。</span></span><br><span class="line">container.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> msg = context.<span class="property">message</span>;</span><br><span class="line">    <span class="keyword">var</span> messageId = msg.<span class="property">message_id</span>;</span><br><span class="line">    <span class="keyword">var</span> topic = msg.<span class="property">application_properties</span>.<span class="property">topic</span>;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(msg.<span class="property">body</span>.<span class="property">content</span>).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出内容。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将接收到的mqtt消息中内容转为json</span></span><br><span class="line">    <span class="keyword">var</span> imgBody = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(content).<span class="property">items</span>.<span class="property">img</span>.<span class="property">value</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------&#x27;</span>)</span><br><span class="line">    <span class="comment">// 如果图片没有传输完毕，则拼接图片</span></span><br><span class="line">    <span class="keyword">if</span> (imgBody != <span class="string">&#x27;END&#x27;</span>) &#123;</span><br><span class="line">        imgStr += imgBody</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果图片传输完毕，则将图片转为base64</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;imgStr:&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">to_base64</span>(imgStr))</span><br><span class="line">        <span class="comment">// 配置图片保存路径</span></span><br><span class="line">        <span class="keyword">var</span> path = <span class="string">&#x27;./img/&#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + <span class="string">&#x27;.jpg&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> dataBuffer = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="title function_">to_base64</span>(imgStr), <span class="string">&#x27;base64&#x27;</span>); <span class="comment">//把base64码转成buffer对象，</span></span><br><span class="line">        <span class="comment">//用fs将图片写入本地文件</span></span><br><span class="line">        fs.<span class="title function_">writeFile</span>(path, dataBuffer, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功！&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 图片转换完毕后，清空imgStr，准备接受下一张图片</span></span><br><span class="line">        imgStr = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送ACK，注意不要在回调函数有耗时逻辑。</span></span><br><span class="line">    context.<span class="property">delivery</span>.<span class="title function_">accept</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算password签名。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hmacSha1</span>(<span class="params">key, context</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Buffer</span>.<span class="title function_">from</span>(crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha1&#x27;</span>, key).<span class="title function_">update</span>(context).<span class="title function_">digest</span>())</span><br><span class="line">        .<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nodejs 本地运行图：<br><img src="https://img-blog.csdnimg.cn/img_convert/e7ddc2f1e9ea29fd820650785c658f6e.png"></p><h3 id="2-2-2-Python-获取阿里云物联网平台图片数据（仅供参考）"><a href="#2-2-2-Python-获取阿里云物联网平台图片数据（仅供参考）" class="headerlink" title="2.2.2 Python 获取阿里云物联网平台图片数据（仅供参考）"></a>2.2.2 Python 获取阿里云物联网平台图片数据（仅供参考）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> stomp</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> schedule</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 16进制转图片</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">imgStr=<span class="string">&quot;&quot;</span></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect_and_subscribe</span>(<span class="params">conn</span>):</span><br><span class="line">    accessKey = <span class="string">&quot;LTAxxxxxExxxL2&quot;</span></span><br><span class="line">    accessSecret = <span class="string">&quot;AsJWxxxxxxxxxxxxxR0xxxxxB&quot;</span></span><br><span class="line">    consumerGroupId = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="comment"># iotInstanceId：实例ID。</span></span><br><span class="line">    iotInstanceId = <span class="string">&quot;iot-06z0xxxxxx6xc&quot;</span></span><br><span class="line">    clientId = <span class="string">&quot;esp32_001&quot;</span></span><br><span class="line">    <span class="comment"># 签名方法：支持hmacmd5，hmacsha1和hmacsha256。</span></span><br><span class="line">    signMethod = <span class="string">&quot;hmacsha1&quot;</span></span><br><span class="line">    timestamp = current_time_millis()</span><br><span class="line">    <span class="comment"># userName组装方法，请参见AMQP客户端接入说明文档。</span></span><br><span class="line">    <span class="comment"># 若使用二进制传输，则userName需要添加encode=base64参数，服务端会将消息体base64编码后再推送。具体添加方法请参见下一章节&quot;二进制消息体说明&quot;。</span></span><br><span class="line">    username = clientId + <span class="string">&quot;|authMode=aksign&quot;</span> + <span class="string">&quot;,signMethod=&quot;</span> + signMethod \</span><br><span class="line">                    + <span class="string">&quot;,timestamp=&quot;</span> + timestamp + <span class="string">&quot;,authId=&quot;</span> + accessKey \</span><br><span class="line">                    + <span class="string">&quot;,iotInstanceId=&quot;</span> + iotInstanceId \</span><br><span class="line">                    + <span class="string">&quot;,consumerGroupId=&quot;</span> + consumerGroupId + <span class="string">&quot;|&quot;</span></span><br><span class="line">    signContent = <span class="string">&quot;authId=&quot;</span> + accessKey + <span class="string">&quot;×tamp=&quot;</span> + timestamp</span><br><span class="line">    <span class="comment"># 计算签名，password组装方法，请参见AMQP客户端接入说明文档。</span></span><br><span class="line">    password = do_sign(accessSecret.encode(<span class="string">&quot;utf-8&quot;</span>), signContent.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    conn.set_listener(<span class="string">&#x27;&#x27;</span>, MyListener(conn))</span><br><span class="line">    conn.connect(username, password, wait=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 清除历史连接检查任务，新建连接检查任务</span></span><br><span class="line">    schedule.clear(<span class="string">&#x27;conn-check&#x27;</span>)</span><br><span class="line">    schedule.every(<span class="number">1</span>).seconds.do(do_check,conn).tag(<span class="string">&#x27;conn-check&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyListener</span>(stomp.ConnectionListener):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, conn</span>):</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_error</span>(<span class="params">self, frame</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;received an error &quot;%s&quot;&#x27;</span> % frame.body)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">self, frame</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;received a message &quot;%s&quot;&#x27;</span> % frame.body)</span><br><span class="line">        <span class="comment"># print(&#x27;received a message :&#x27; + json.loads(frame.body).items)</span></span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_heartbeat_timeout</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;on_heartbeat_timeout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_connected</span>(<span class="params">self, headers</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;successfully connected&quot;</span>)</span><br><span class="line">        conn.subscribe(destination=<span class="string">&#x27;/topic/#&#x27;</span>, <span class="built_in">id</span>=<span class="number">1</span>, ack=<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;successfully subscribe&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_disconnected</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;disconnected&#x27;</span>)</span><br><span class="line">        connect_and_subscribe(self.conn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">current_time_millis</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_sign</span>(<span class="params">secret, sign_content</span>):</span><br><span class="line">    m = hmac.new(secret, sign_content, digestmod=hashlib.sha1)</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(m.digest()).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查连接，如果未连接则重新建连</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_check</span>(<span class="params">conn</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;check connection, is_connected: %s&#x27;</span>, conn.is_connected())</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> conn.is_connected()):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            connect_and_subscribe(conn)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;disconnected, &#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定时任务方法，检查连接状态</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connection_check_timer</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        schedule.run_pending()</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  接入域名，请参见AMQP客户端接入说明文档。这里直接填入域名，不需要带amqps://前缀</span></span><br><span class="line">conn = stomp.Connection([(<span class="string">&#x27;iot-06xxxxxc.amqp.iothub.aliyuncs.com&#x27;</span>, <span class="number">61614</span>)], heartbeats=(<span class="number">0</span>,<span class="number">300</span>))</span><br><span class="line">conn.set_ssl(for_hosts=[(<span class="string">&#x27;iot-06xxxxxc.amqp.iothub.aliyuncs.com&#x27;</span>, <span class="number">61614</span>)], ssl_version=ssl.PROTOCOL_TLS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    connect_and_subscribe(conn)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;connecting failed&#x27;</span>)</span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步线程运行定时任务，检查连接状态</span></span><br><span class="line">thread = threading.Thread(target=connection_check_timer)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>其中 Python 中的参数配置同 Nodejs。<br>参考：</p><ol><li><a href="https://help.aliyun.com/zh/iot/developer-reference/connect-an-amqp-client-to-iot-platform">阿里云AMQP客户端接入说明</a></li><li><a href="https://help.aliyun.com/zh/iot/developer-reference/connect-a-client-to-iot-platform-by-using-the-sdk-for-node-js">Nodejs客户端SDK接入实例</a></li><li><a href="https://help.aliyun.com/zh/iot/developer-reference/connect-a-client-to-iot-platform-by-using-the-sdk-for-python">python客户端SDK接入实例</a></li></ol><p>Python 获取图片数据运行图如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/aac729c92ca8b9aca59aa7d2f19a64a3.png"></p><p>至此，从阿里云IOT平台获取图片数据并保存到本地的程序已全部完成，程序目前较为简陋，仅供参考使用。</p><p>相关参考内容：</p><ol><li><a href="https://blog.csdn.net/isoface/article/details/125349106">CSDN:ESP32CAM的图片用MQTT也能传？</a></li><li><a href="https://blog.csdn.net/haote216/article/details/105762808">CSDN:ESP32CAM连接阿里云物联网平台</a></li><li><a href="https://blog.csdn.net/weixin_46323814/article/details/128116095">CSDN:ESP32-S2使用Arduino连接阿里云</a></li><li><a href="https://blog.csdn.net/qq_39592312/article/details/108931427">CSDN:连接阿里云失败MQTT connect failed</a></li><li><a href="https://blog.gitnote.cn/post/esp32cam_001/">Gitnote:ESP32cam系列教程001</a></li></ol><p>本文首发于本人博客：<a href="https://blog.gitnote.cn/post/esp32cam_mqtt_aliyun_iot">https://blog.gitnote.cn/post/esp32cam_mqtt_aliyun_iot</a></p><p>版权信息: CC BY-NC-SA 4.0 (自由转载-非商用-相同方式共享-保持署名)</p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的requests在网络请求中添加cookies参数</title>
      <link href="/2024/03/python-python-python%E7%9A%84requests%E5%9C%A8%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B7%BB%E5%8A%A0cookies%E5%8F%82%E6%95%B0/"/>
      <url>/2024/03/python-python-python%E7%9A%84requests%E5%9C%A8%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B7%BB%E5%8A%A0cookies%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>哎，好久没有学习爬虫了，现在想要重新拾起来。发现之前学习爬虫有些粗糙，竟然连requests中添加cookies都没有掌握，惭愧。废话不宜多，直接上内容。</p><p>我们平时使用requests获取网络内容很简单，几行代码搞定了，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res=requests.get(<span class="string">&quot;https://cloud.flyme.cn/browser/index.jsp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> res.content</span><br></pre></td></tr></table></figure><p>你没有看错，真的只有三行代码。但是简单归简单，问题还是不少的。</p><p>首先，这里的请求只是get方法，并且没有解决cookies的问题。</p><p>然后就是这里并没有解决乱码的问题。（乱码是python中的变态点）</p><p>其实，在requests的get方法中添加cookies的方法不难 可以这样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=requests.get(<span class="string">&quot;https://cloud.flyme.cn/browser/index.jsp&quot;</span>,cookies=cookies)</span><br></pre></td></tr></table></figure><p>我们所面临的问题是，如何构造这里的cookies。</p><p>这里的cookies是一个字典格式的数据。</p><p>平时我们浏览网页的时候，在审查元素中可以查看到所访问网页的cookies内容，大都是这样子的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sn_openNetBySms=%23810EBMA3TE53; sn_map=810EBMA3TE53; DSESSIONID=f1987887-3d1d-4a85-ad75-c6270e588290; JSESSIONID=; _uid=; _keyLogin=; _rmtk=; _uticket=ns_0393027c2f9f686e3499e8ebb8d1d622; _ckk=ns_397a592791064029bf1336eff1cf516e; ucuid=8a135520affa423584307f6e2c210f02; _domain=cloud.flyme.cn; _islogin=true; lang=zh_CN; JSESSIONID=1gmfzynp0ns6s1u6a92xkqgi6q</span><br></pre></td></tr></table></figure><p>天那，这是人看的吗？不是。这是经过加密处理后的数据。同样，我们可以将加密后的数据传递到get方法的cookies参数中，服务器会自动将加密后的数据进行解密，再检查数据的正确性。</p><p>至于，如何查看所访问网页的cookies内容，可以使用浏览器的审查功能，F12或者右击审查（Chrome）打开。在network中查看链接的Headers内容。另外，也可以使用软件抓包查看，如Fiddler web Debugger。</p><p>这里假设获取到了cookies的内容，我们可以保存到本地TXT文件中（直接把cookies的内容粘贴进去即可），例如test.txt文件。</p><p>然后，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">r&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)<span class="comment">#打开所保存的cookies内容文件</span></span><br><span class="line">cookies=&#123;&#125;<span class="comment">#初始化cookies字典变量</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.read().split(<span class="string">&#x27;;&#x27;</span>):   <span class="comment">#按照字符：进行划分读取</span></span><br><span class="line">    <span class="comment">#其设置为1就会把字符串拆分成2份</span></span><br><span class="line">    name,value=line.strip().split(<span class="string">&#x27;=&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    cookies[name]=value  <span class="comment">#为字典cookies添加内容</span></span><br></pre></td></tr></table></figure><p>这时候我们将cookies添加到get方法中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=requests.get(<span class="string">&quot;https://cloud.flyme.cn/browser/index.jsp&quot;</span>,cookies=cookies)</span><br></pre></td></tr></table></figure><p>这时候获取到的res.content中就是我们将cookies信息添加到get中后访问网页所获取的内容。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用python揭秘CSDN热门付费专栏惊人真相</title>
      <link href="/2024/03/python-python-%E4%BD%BF%E7%94%A8python%E6%8F%AD%E7%A7%98CSDN%E7%83%AD%E9%97%A8%E4%BB%98%E8%B4%B9%E4%B8%93%E6%A0%8F%E6%83%8A%E4%BA%BA%E7%9C%9F%E7%9B%B8/"/>
      <url>/2024/03/python-python-%E4%BD%BF%E7%94%A8python%E6%8F%AD%E7%A7%98CSDN%E7%83%AD%E9%97%A8%E4%BB%98%E8%B4%B9%E4%B8%93%E6%A0%8F%E6%83%8A%E4%BA%BA%E7%9C%9F%E7%9B%B8/</url>
      
        <content type="html"><![CDATA[<h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="#1csdn-3">1.csdn付费专栏词云</a></li><li><a href="#2-18">2.浏览器抓包分析</a></li><li><a href="#3api-40">3.API接口测试</a></li><li><a href="#4python-50">4.需要使用的python库</a></li><li><a href="#5-68">5.爬虫与数据分析设计</a></li><li><a href="#6--185">6. 完整代码</a></li><li><a href="#7-316">7.最终的成果</a></li><li><a href="#8-337">8.惊人真相在这里</a></li></ul><h2 id="1-csdn付费专栏词云"><a href="#1-csdn付费专栏词云" class="headerlink" title="1.csdn付费专栏词云"></a>1.csdn付费专栏词云</h2><blockquote><p>我们如何分析csdn热门付费专栏呢？</p></blockquote><p><img src="https://img-blog.csdnimg.cn/direct/4931ba9c431441f7a3c8eacf9dbdb573.jpeg"></p><p><strong>热门专栏是动态的，所以我们爬取的数据是一直变化的！</strong></p><p>通过我的分析得出如下结论，热门付费的领域：</p><ul><li>目标检测与计算机视觉：利用深度学习和图像处理技术，实现自动识别和定位目标物体的领域。</li><li>系统开发与嵌入式：涉及设计、开发和优化嵌入式系统，包括硬件和软件的集成。</li><li>数据科学与机器学习：通过分析和解释大量数据，利用机器学习算法构建模型，从中获取洞察和预测。</li><li>物联网与人工智能：将传感器、设备和网络连接起来，通过人工智能技术实现智能化的互联网应用。</li><li>MATLAB应用：使用MATLAB编程语言和工具进行科学计算、数据分析、图像处理和模型开发等应用。</li></ul><h2 id="2-浏览器抓包分析"><a href="#2-浏览器抓包分析" class="headerlink" title=";  2.浏览器抓包分析"></a><a name="2_18">;</a>  2.浏览器抓包分析</h2><ul><li>1.我们首先找到CSDN排行榜页面</li></ul><blockquote><p><a href="https://blog.csdn.net/rank/list/total">https://blog.csdn.net/rank/list/total</a><br>浏览器打开F12，点击网络</p></blockquote><p><img src="https://img-blog.csdnimg.cn/direct/762deb6bacfc42f58ec7ed91df021718.png"></p><ul><li>我们停靠放上改为上下结构，如我上图</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/d50f89818bb6412c9a0bf4868157ae0b.png"></p><ul><li>点击如下图</li></ul><blockquote><p>首先我们点击热门专栏，然后我们点击Fetch&#x2F;XHR,查看所有的网络请求<br>通过分析我们可以知道<br><img src="https://img-blog.csdnimg.cn/direct/33a3cddde73543c6b9a0109b7a5fa397.png"></p></blockquote><ul><li>分析结果如下</li></ul><blockquote><p><a href="https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&pageSize=20">https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&amp;pageSize=20</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/direct/380cffeb94c44bdb81a7424ac74a7f21.png"><br><img src="https://img-blog.csdnimg.cn/direct/f86acb209663470d961489f914df34e7.png"></p><h2 id="3-API接口测试"><a href="#3-API接口测试" class="headerlink" title=";  3.API接口测试"></a><a name="3api_40">;</a>  3.API接口测试</h2><p>我测试了</p><ul><li><a href="https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&pageSize=20">https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&amp;pageSize=20</a></li><li><a href="https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&pageSize=100">https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&amp;pageSize=100</a></li><li><a href="https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&pageSize=200">https://blog.csdn.net/phoenix/web/blog/pay-column-rank?page=0&amp;pageSize=200</a><br>通过测试发现，最多只能给到100个热门付费专栏数据</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/14ab57ec02f34bf0b6b741798da0fa03.png"></p><h2 id="4-需要使用的python库"><a href="#4-需要使用的python库" class="headerlink" title="4.需要使用的python库"></a>4.需要使用的python库</h2><ul><li>requests: 用于发送HTTP请求和处理响应的库。它可以用于与Web服务进行交互，例如获取网页内容或发送API请求。</li><li>pandas: 提供了用于数据操作和分析的数据结构和函数。它是一个功能强大的库，用于处理和分析结构化数据，例如表格数据。</li><li>wordcloud: 用于生成词云图的库。词云图是一种可视化形式，通过展示文本中出现频率较高的单词，以图形化的方式呈现文本数据。</li><li>matplotlib:<br>用于创建静态、动态和交互式的可视化图表的库。它提供了各种绘图选项，可以用于创建线图、散点图、条形图、饼图等各种类型的图表。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install pandas</span><br><span class="line">pip install wordcloud</span><br><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><h2 id="5-爬虫与数据分析设计"><a href="#5-爬虫与数据分析设计" class="headerlink" title="5.爬虫与数据分析设计"></a>5.爬虫与数据分析设计</h2><ul><li>首先我们需要做个爬虫，爬取API获取出的网络排行榜</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">API_RANK = &quot;https://blog.csdn.net/phoenix/web/blog/pay-column-rank&quot;</span><br><span class="line"></span><br><span class="line"># Http&amp;#x4EE3;&amp;#x7406;&amp;#x5934;</span><br><span class="line">HTTP_headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params = &#123;&#x27;page&#x27;: &#x27;0&#x27;,</span><br><span class="line">            &#x27;pageSize&#x27;: 100&#125;</span><br><span class="line">response = requests.get(API_RANK, params=params, headers=HTTP_headers)</span><br><span class="line">print(&quot;http:&quot;, response.url)</span><br><span class="line">print(&quot;Status Code:&quot;, response.status_code)</span><br><span class="line">print(&quot;Response Text:&quot;, response.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>我尝试把我们抓取到的数据写到excel中，我们来进行分析</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">API_RANK = &quot;https://blog.csdn.net/phoenix/web/blog/pay-column-rank&quot;</span><br><span class="line"></span><br><span class="line"># Http&amp;#x4EE3;&amp;#x7406;&amp;#x5934;</span><br><span class="line">HTTP_headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params = &#123;&#x27;page&#x27;: &#x27;0&#x27;,</span><br><span class="line">            &#x27;pageSize&#x27;: 100&#125;</span><br><span class="line">response = requests.get(API_RANK, params=params, headers=HTTP_headers)</span><br><span class="line">data = response.json()</span><br><span class="line">print(&quot;http:&quot;, response.url)</span><br><span class="line">print(&quot;Status Code:&quot;, response.status_code)</span><br><span class="line">print(&quot;Response Text:&quot;, response.text)</span><br><span class="line"></span><br><span class="line">def save_data_to_excel(data):</span><br><span class="line">    df = pd.DataFrame(data)</span><br><span class="line">    df.to_excel(&#x27;data.xlsx&#x27;, index=False)</span><br><span class="line">    print(&quot;&amp;#x6570;&amp;#x636E;&amp;#x5DF2;&amp;#x6210;&amp;#x529F;&amp;#x4FDD;&amp;#x5B58;&amp;#x5230; data.xlsx &amp;#x6587;&amp;#x4EF6;&quot;)</span><br><span class="line">save_data_to_excel(data[&#x27;data&#x27;][&quot;payColumnRankListItemList&quot;])</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/a1ff07ec14d748b085b16846b8f41c0f.png"></p><ul><li>我们要分析高频词汇<ul><li>1.不可以分析高频词汇的时候拆分（C++，C#，OD等字样）</li><li>2.根据高频词汇的出现数量来排名</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">def extract_top_keywords(,titles, fixed_words=None, min_count=2):</span><br><span class="line">        fixed_words = &#123;&quot;OD&quot;, &quot;C#&quot;, &quot;JAVA&quot;, &quot;C++&quot;, &quot;&amp;#x534E;&amp;#x4E3A;&quot;, &quot;Python&quot;&#125;</span><br><span class="line">        # &amp;#x521B;&amp;#x5EFA;&amp;#x81EA;&amp;#x5B9A;&amp;#x4E49;&amp;#x8BCD;&amp;#x6C47;&amp;#x8868;</span><br><span class="line">        custom_vocab = set(fixed_words) if fixed_words else set()</span><br><span class="line"></span><br><span class="line">        # &amp;#x5206;&amp;#x8BCD;&amp;#x548C;&amp;#x6E05;&amp;#x6D17;&amp;#x6807;&amp;#x9898;</span><br><span class="line">        words = []</span><br><span class="line">        for title in titles:</span><br><span class="line">            # &amp;#x4F7F;&amp;#x7528;&amp;#x6B63;&amp;#x5219;&amp;#x8868;&amp;#x8FBE;&amp;#x5F0F;&amp;#x63D0;&amp;#x53D6;&amp;#x5355;&amp;#x8BCD;&amp;#x548C;&amp;#x6570;&amp;#x5B57;</span><br><span class="line">            tokens = re.findall(r&#x27;\w+&#x27;, title)</span><br><span class="line">            # &amp;#x5C06;&amp;#x5355;&amp;#x8BCD;&amp;#x8F6C;&amp;#x6362;&amp;#x4E3A;&amp;#x5C0F;&amp;#x5199;</span><br><span class="line">            tokens = [token.lower() for token in tokens]</span><br><span class="line"></span><br><span class="line">            # &amp;#x5C06;&amp;#x56FA;&amp;#x5B9A;&amp;#x8BCD;&amp;#x6C47;&amp;#x4F5C;&amp;#x4E3A;&amp;#x6574;&amp;#x4F53;&amp;#x6DFB;&amp;#x52A0;&amp;#x5230;&amp;#x8BCD;&amp;#x6C47;&amp;#x8868;&amp;#x4E2D;</span><br><span class="line">            for word in fixed_words:</span><br><span class="line">                if word.lower() in title.lower():</span><br><span class="line">                    tokens.append(word.lower())</span><br><span class="line"></span><br><span class="line">            words.extend(tokens)</span><br><span class="line"></span><br><span class="line">        # &amp;#x7EDF;&amp;#x8BA1;&amp;#x8BCD;&amp;#x9891;</span><br><span class="line">        word_counts = Counter(words)</span><br><span class="line"></span><br><span class="line">        # &amp;#x6839;&amp;#x636E;&amp;#x8BCD;&amp;#x9891;&amp;#x6392;&amp;#x5E8F;</span><br><span class="line">        sorted_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line"></span><br><span class="line">        # &amp;#x83B7;&amp;#x53D6;&amp;#x9AD8;&amp;#x9891;&amp;#x5173;&amp;#x952E;&amp;#x5B57;&amp;#x548C;&amp;#x8BCD;&amp;#x6C47;</span><br><span class="line">        top_keywords = [word for word, count in sorted_words if count &gt;= min_count]</span><br><span class="line"></span><br><span class="line">        return top_keywords</span><br><span class="line"></span><br><span class="line">    def writePng(pic, title_list):</span><br><span class="line">        # &amp;#x5C06;&amp;#x6807;&amp;#x9898;&amp;#x5217;&amp;#x8868;&amp;#x8F6C;&amp;#x6362;&amp;#x4E3A;&amp;#x5B57;&amp;#x7B26;&amp;#x4E32;</span><br><span class="line">        text = &#x27; &#x27;.join(title_list)</span><br><span class="line"></span><br><span class="line">        # &amp;#x8BBE;&amp;#x7F6E;&amp;#x4E2D;&amp;#x6587;&amp;#x5B57;&amp;#x4F53;&amp;#x8DEF;&amp;#x5F84;</span><br><span class="line">        font_path = &#x27;C:\\Windows\\Fonts\\simsun.ttc&#x27;  # &amp;#x66FF;&amp;#x6362;&amp;#x4E3A;&amp;#x4F60;&amp;#x7684;&amp;#x4E2D;&amp;#x6587;&amp;#x5B57;&amp;#x4F53;&amp;#x8DEF;&amp;#x5F84;</span><br><span class="line"></span><br><span class="line">        # &amp;#x521B;&amp;#x5EFA;&amp;#x8BCD;&amp;#x4E91;&amp;#x5BF9;&amp;#x8C61;&amp;#x5E76;&amp;#x8BBE;&amp;#x7F6E;&amp;#x53C2;&amp;#x6570;</span><br><span class="line">        wc = WordCloud(font_path=font_path, background_color=&#x27;white&#x27;, width=800, height=600)</span><br><span class="line"></span><br><span class="line">        # &amp;#x751F;&amp;#x6210;&amp;#x8BCD;&amp;#x4E91;</span><br><span class="line">        wc.generate(text)</span><br><span class="line"></span><br><span class="line">        # &amp;#x663E;&amp;#x793A;&amp;#x8BCD;&amp;#x4E91;</span><br><span class="line">        plt.imshow(wc, interpolation=&#x27;bilinear&#x27;)</span><br><span class="line">        plt.axis(&#x27;off&#x27;)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">        # &amp;#x4FDD;&amp;#x5B58;&amp;#x8BCD;&amp;#x4E91;&amp;#x6587;&amp;#x4EF6;</span><br><span class="line">        wc.to_file(pic)</span><br></pre></td></tr></table></figure><h2 id="6-完整代码"><a href="#6-完整代码" class="headerlink" title="6. 完整代码"></a>6. 完整代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import pandas as pd</span><br><span class="line">import re</span><br><span class="line">from collections import Counter</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">API_RANK = &quot;https://blog.csdn.net/phoenix/web/blog/pay-column-rank&quot;</span><br><span class="line"></span><br><span class="line"># Http&amp;#x4EE3;&amp;#x7406;&amp;#x5934;</span><br><span class="line">HTTP_headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># http get &amp;#x5C01;&amp;#x88C5;</span><br><span class="line">class HttpRequest:</span><br><span class="line">    header = None</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def request(self, URL, PARAMS):</span><br><span class="line">        response = requests.get(URL, params=PARAMS, headers=HTTP_headers)</span><br><span class="line">        print(&quot;http:&quot;, response.url)</span><br><span class="line">        print(&quot;Status Code:&quot;, response.status_code)</span><br><span class="line">        print(&quot;Response Text:&quot;, response.text)</span><br><span class="line">        try:</span><br><span class="line">            data = response.json()</span><br><span class="line">            return data</span><br><span class="line">        except json.JSONDecodeError:</span><br><span class="line">            print(&quot;Error: The response is not in JSON format.&quot;)</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">class CSDNDataFetcher:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    def setHttpRequest(self, request):</span><br><span class="line">        self.csdnGeter = request</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # &amp;#x83B7;&amp;#x53D6;&amp;#x6392;&amp;#x884C;&amp;#x699C;</span><br><span class="line">    def getRank(self, size):</span><br><span class="line">        params = &#123;</span><br><span class="line">            &#x27;page&#x27;: &#x27;0&#x27;,</span><br><span class="line">            &#x27;pageSize&#x27;: size&#125;</span><br><span class="line">        data = self.csdnGeter.request(API_RANK, params)</span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">    # &amp;#x4FDD;&amp;#x5B58;&amp;#x5230;excel&amp;#x4E2D;</span><br><span class="line">    def save_data_to_excel(self, data):</span><br><span class="line">        df = pd.DataFrame(data)</span><br><span class="line">        df.to_excel(&#x27;data.xlsx&#x27;, index=False)</span><br><span class="line">        print(&quot;&amp;#x6570;&amp;#x636E;&amp;#x5DF2;&amp;#x6210;&amp;#x529F;&amp;#x4FDD;&amp;#x5B58;&amp;#x5230; data.xlsx &amp;#x6587;&amp;#x4EF6;&quot;)</span><br><span class="line"></span><br><span class="line">    def read_column_from_excel(self, file_path, sheet_name, column_name):</span><br><span class="line">        df = pd.read_excel(file_path, sheet_name=sheet_name)</span><br><span class="line">        column_data = df[column_name].tolist()</span><br><span class="line">        return column_data</span><br><span class="line"></span><br><span class="line">    def extract_top_keywords(self, titles, fixed_words=None, min_count=2):</span><br><span class="line">        fixed_words = &#123;&quot;OD&quot;, &quot;C#&quot;, &quot;JAVA&quot;, &quot;C++&quot;, &quot;&amp;#x534E;&amp;#x4E3A;&quot;, &quot;Python&quot;,&quot;Matlab&quot;,&quot;Qt&quot;&#125;</span><br><span class="line">        # &amp;#x521B;&amp;#x5EFA;&amp;#x81EA;&amp;#x5B9A;&amp;#x4E49;&amp;#x8BCD;&amp;#x6C47;&amp;#x8868;</span><br><span class="line">        custom_vocab = set(fixed_words) if fixed_words else set()</span><br><span class="line"></span><br><span class="line">        # &amp;#x5206;&amp;#x8BCD;&amp;#x548C;&amp;#x6E05;&amp;#x6D17;&amp;#x6807;&amp;#x9898;</span><br><span class="line">        words = []</span><br><span class="line">        for title in titles:</span><br><span class="line">            # &amp;#x4F7F;&amp;#x7528;&amp;#x6B63;&amp;#x5219;&amp;#x8868;&amp;#x8FBE;&amp;#x5F0F;&amp;#x63D0;&amp;#x53D6;&amp;#x5355;&amp;#x8BCD;&amp;#x548C;&amp;#x6570;&amp;#x5B57;</span><br><span class="line">            tokens = re.findall(r&#x27;\w+&#x27;, title)</span><br><span class="line">            # &amp;#x5C06;&amp;#x5355;&amp;#x8BCD;&amp;#x8F6C;&amp;#x6362;&amp;#x4E3A;&amp;#x5C0F;&amp;#x5199;</span><br><span class="line">            tokens = [token.lower() for token in tokens]</span><br><span class="line"></span><br><span class="line">            # &amp;#x5C06;&amp;#x56FA;&amp;#x5B9A;&amp;#x8BCD;&amp;#x6C47;&amp;#x4F5C;&amp;#x4E3A;&amp;#x6574;&amp;#x4F53;&amp;#x6DFB;&amp;#x52A0;&amp;#x5230;&amp;#x8BCD;&amp;#x6C47;&amp;#x8868;&amp;#x4E2D;</span><br><span class="line">            for word in fixed_words:</span><br><span class="line">                if word.lower() in title.lower():</span><br><span class="line">                    tokens.append(word.lower())</span><br><span class="line"></span><br><span class="line">            words.extend(tokens)</span><br><span class="line"></span><br><span class="line">        # &amp;#x7EDF;&amp;#x8BA1;&amp;#x8BCD;&amp;#x9891;</span><br><span class="line">        word_counts = Counter(words)</span><br><span class="line"></span><br><span class="line">        # &amp;#x6839;&amp;#x636E;&amp;#x8BCD;&amp;#x9891;&amp;#x6392;&amp;#x5E8F;</span><br><span class="line">        sorted_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line"></span><br><span class="line">        # &amp;#x83B7;&amp;#x53D6;&amp;#x9AD8;&amp;#x9891;&amp;#x5173;&amp;#x952E;&amp;#x5B57;&amp;#x548C;&amp;#x8BCD;&amp;#x6C47;</span><br><span class="line">        top_keywords = [word for word, count in sorted_words if count &gt;= min_count]</span><br><span class="line"></span><br><span class="line">        return top_keywords</span><br><span class="line"></span><br><span class="line">    def writePng(self, pic, title_list):</span><br><span class="line">        # &amp;#x5C06;&amp;#x6807;&amp;#x9898;&amp;#x5217;&amp;#x8868;&amp;#x8F6C;&amp;#x6362;&amp;#x4E3A;&amp;#x5B57;&amp;#x7B26;&amp;#x4E32;</span><br><span class="line">        text = &#x27; &#x27;.join(title_list)</span><br><span class="line"></span><br><span class="line">        # &amp;#x8BBE;&amp;#x7F6E;&amp;#x4E2D;&amp;#x6587;&amp;#x5B57;&amp;#x4F53;&amp;#x8DEF;&amp;#x5F84;</span><br><span class="line">        font_path = &#x27;C:\\Windows\\Fonts\\simsun.ttc&#x27;  # &amp;#x66FF;&amp;#x6362;&amp;#x4E3A;&amp;#x4F60;&amp;#x7684;&amp;#x4E2D;&amp;#x6587;&amp;#x5B57;&amp;#x4F53;&amp;#x8DEF;&amp;#x5F84;</span><br><span class="line"></span><br><span class="line">        # &amp;#x521B;&amp;#x5EFA;&amp;#x8BCD;&amp;#x4E91;&amp;#x5BF9;&amp;#x8C61;&amp;#x5E76;&amp;#x8BBE;&amp;#x7F6E;&amp;#x53C2;&amp;#x6570;</span><br><span class="line">        wc = WordCloud(font_path=font_path, background_color=&#x27;white&#x27;, width=800, height=600)</span><br><span class="line"></span><br><span class="line">        # &amp;#x751F;&amp;#x6210;&amp;#x8BCD;&amp;#x4E91;</span><br><span class="line">        wc.generate(text)</span><br><span class="line"></span><br><span class="line">        # &amp;#x663E;&amp;#x793A;&amp;#x8BCD;&amp;#x4E91;</span><br><span class="line">        plt.imshow(wc, interpolation=&#x27;bilinear&#x27;)</span><br><span class="line">        plt.axis(&#x27;off&#x27;)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">        # &amp;#x4FDD;&amp;#x5B58;&amp;#x8BCD;&amp;#x4E91;&amp;#x6587;&amp;#x4EF6;</span><br><span class="line">        wc.to_file(pic)</span><br><span class="line"></span><br><span class="line">#&amp;#x521B;&amp;#x5EFA;</span><br><span class="line">r = HttpRequest()</span><br><span class="line">obj = CSDNDataFetcher()</span><br><span class="line">obj.setHttpRequest(r)</span><br><span class="line"></span><br><span class="line">data = obj.getRank(100)</span><br><span class="line">obj.save_data_to_excel(data[&#x27;data&#x27;][&quot;payColumnRankListItemList&quot;])</span><br><span class="line"></span><br><span class="line">text = obj.read_column_from_excel(&quot;data.xlsx&quot;, &quot;Sheet1&quot;, &quot;columnName&quot;)</span><br><span class="line">tiles = obj.extract_top_keywords(text)</span><br><span class="line">obj.writePng(&quot;test.jpg&quot;, tiles)</span><br></pre></td></tr></table></figure><h2 id="7-最终的成果"><a href="#7-最终的成果" class="headerlink" title="7.最终的成果"></a>7.最终的成果</h2><blockquote><p>你们真的好卷!!!</p></blockquote><p>为了资本卷!!!</p><p>为了技术卷!!!</p><p>年底分多少钱!!!</p><p>今年加多少班!!!</p><p>绩效怎么样!!!</p><p>沉淀沉淀吧，有些事我都不知道怎么说。</p><p><img src="https://img-blog.csdnimg.cn/direct/4931ba9c431441f7a3c8eacf9dbdb573.jpeg">)</p><ul><li>目标检测与计算机视觉：YOLOv8、YOLOv5、YOLOv8-seg是目标检测算法的不同版本，芒果改进YOLO进阶指南和YOLOv8改进实战专栏提供了关于目标检测算法的改进和实践经验。此外，深度学习、点云处理、计算机视觉等也是与目标检测相关的热门领域。</li><li>系统开发与嵌入式：华为OD机试专栏、Android开发、Autosar、FPGA、单片机、ARM开发等专栏涉及了系统开发、嵌入式开发、底层编程等方面的内容，适合对系统开发和嵌入式技术感兴趣的人。</li><li>数据科学与机器学习：包括Python、R语言、XGBoost、BP神经网络、时间序列分析（ARIMA和GARCH）等专栏，涵盖了数据科学、机器学习、深度学习等领域的内容，适合对数据分析和机器学习算法感兴趣的人。</li><li>物联网与人工智能：智能家居与物联网项目实战、物联网AIOT、ESP8266&#x2F;ESP32等专栏关注物联网应用和物联网设备的开发，同时涉及到与人工智能相关的技术。</li><li>MATLAB应用：MATLAB专栏提供了各类MATLAB代码和工具的使用，适合对MATLAB编程和应用感兴趣的人。</li></ul><h2 id="8-惊人真相在这里"><a href="#8-惊人真相在这里" class="headerlink" title=";  8.惊人真相在这里"></a><a name="8_337">;</a>  8.惊人真相在这里</h2><p><strong>😳😳😳😳😳😳</strong><br>你们好卷，再见！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python的requests在网络请求中添加cookies参数</title>
      <link href="/2024/03/python-python%E7%9A%84requests%E5%9C%A8%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B7%BB%E5%8A%A0cookies%E5%8F%82%E6%95%B0/"/>
      <url>/2024/03/python-python%E7%9A%84requests%E5%9C%A8%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%B7%BB%E5%8A%A0cookies%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>哎，好久没有学习爬虫了，现在想要重新拾起来。发现之前学习爬虫有些粗糙，竟然连requests中添加cookies都没有掌握，惭愧。废话不宜多，直接上内容。</p><p>我们平时使用requests获取网络内容很简单，几行代码搞定了，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res=requests.get(<span class="string">&quot;https://cloud.flyme.cn/browser/index.jsp&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> res.content</span><br></pre></td></tr></table></figure><p>你没有看错，真的只有三行代码。但是简单归简单，问题还是不少的。</p><p>首先，这里的请求只是get方法，并且没有解决cookies的问题。</p><p>然后就是这里并没有解决乱码的问题。（乱码是python中的变态点）</p><p>其实，在requests的get方法中添加cookies的方法不难 可以这样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=requests.get(<span class="string">&quot;https://cloud.flyme.cn/browser/index.jsp&quot;</span>,cookies=cookies)</span><br></pre></td></tr></table></figure><p>我们所面临的问题是，如何构造这里的cookies。</p><p>这里的cookies是一个字典格式的数据。</p><p>平时我们浏览网页的时候，在审查元素中可以查看到所访问网页的cookies内容，大都是这样子的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sn_openNetBySms=%23810EBMA3TE53; sn_map=810EBMA3TE53; DSESSIONID=f1987887-3d1d-4a85-ad75-c6270e588290; JSESSIONID=; _uid=; _keyLogin=; _rmtk=; _uticket=ns_0393027c2f9f686e3499e8ebb8d1d622; _ckk=ns_397a592791064029bf1336eff1cf516e; ucuid=8a135520affa423584307f6e2c210f02; _domain=cloud.flyme.cn; _islogin=true; lang=zh_CN; JSESSIONID=1gmfzynp0ns6s1u6a92xkqgi6q</span><br></pre></td></tr></table></figure><p>天那，这是人看的吗？不是。这是经过加密处理后的数据。同样，我们可以将加密后的数据传递到get方法的cookies参数中，服务器会自动将加密后的数据进行解密，再检查数据的正确性。</p><p>至于，如何查看所访问网页的cookies内容，可以使用浏览器的审查功能，F12或者右击审查（Chrome）打开。在network中查看链接的Headers内容。另外，也可以使用软件抓包查看，如Fiddler web Debugger。</p><p>这里假设获取到了cookies的内容，我们可以保存到本地TXT文件中（直接把cookies的内容粘贴进去即可），例如test.txt文件。</p><p>然后，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">r&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)<span class="comment">#打开所保存的cookies内容文件</span></span><br><span class="line">cookies=&#123;&#125;<span class="comment">#初始化cookies字典变量</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.read().split(<span class="string">&#x27;;&#x27;</span>):   <span class="comment">#按照字符：进行划分读取</span></span><br><span class="line">    <span class="comment">#其设置为1就会把字符串拆分成2份</span></span><br><span class="line">    name,value=line.strip().split(<span class="string">&#x27;=&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    cookies[name]=value  <span class="comment">#为字典cookies添加内容</span></span><br></pre></td></tr></table></figure><p>这时候我们将cookies添加到get方法中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res=requests.get(<span class="string">&quot;https://cloud.flyme.cn/browser/index.jsp&quot;</span>,cookies=cookies)</span><br></pre></td></tr></table></figure><p>这时候获取到的res.content中就是我们将cookies信息添加到get中后访问网页所获取的内容。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> requests </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32】HAL库_STM32CubeMX教程十三---RTC时钟</title>
      <link href="/2024/03/stm32-%E3%80%90STM32%E3%80%91HAL%E5%BA%93-STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-RTC%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/stm32-%E3%80%90STM32%E3%80%91HAL%E5%BA%93-STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89-RTC%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>前言：</p><p>本系列教程将 对应外设原理，HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用</p><p>所用工具：</p><p>1、芯片： STM32F407ZET6&#x2F; STM32F103ZET6</p><p>2、STM32CubeMx软件</p><p>3、IDE： MDK-Keil软件</p><p>4、STM32F1xx&#x2F;STM32F4xxHAL库</p><p>知识概括：</p><p>通过本篇博客您将学到：</p><p>RTC时钟原理</p><p>STM32CubeMX创建RTC例程</p><p>HAL库定时器RTC函数库</p><p><strong>PS: 这里的RTC讲解，我们只将原理，不讲寄存器，如果要看RTC的寄存器，请看这篇文章</strong> <a href="https://blog.csdn.net/as480133937/article/details/105026033">【STM32】RTC实时时钟，步骤超细详解，一文看懂RTC</a></p><h3 id="什么是RTC"><a href="#什么是RTC" class="headerlink" title="什么是RTC"></a>什么是RTC</h3><p>**RTC (Real Time Clock)**：实时时钟</p><p><strong>RTC是个独立的定时器</strong>。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。</p><p><img src="https://img-blog.csdnimg.cn/20200423215123488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200423215123488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。</strong></p><p>RTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。</p><p>两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。</p><p>上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。</p><p>无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。</p><h4 id="RCT特征："><a href="#RCT特征：" class="headerlink" title="RCT特征："></a><strong>RCT特征：</strong></h4><p>● <strong>可编程的预分频系数：分频系数高为220。</strong> ● <strong>32位的可编程计数器，可用于较长时间段的测量。</strong> ● <strong>2个分离的时钟：用于APB1接口的PCLK1和RTC时钟(RTC时钟的频率必须小于PCLK1时钟 频率的四分之一以上)。</strong> ● 可以选择以下<strong>三种RTC的时钟源</strong>：      ● HSE时钟除以128；      ● LSE振荡器时钟；      ● LSI振荡器时钟</p><p>● <strong>2个独立的复位类型：</strong>      ● APB1接口由系统复位；      ● RTC核心(预分频器、闹钟、计数器和分频器)只能由后备域复位</p><p>● <strong>3个专门的可屏蔽中断：</strong>      ● 1.<strong>闹钟中断</strong>，用来产生一个软件可编程的闹钟中断。</p><p>     ● 2.<strong>秒中断</strong>，用来产生一个可编程的周期性中断信号(长可达1秒)。</p><p>     ● 3.<strong>溢出中断</strong>，指示内部可编程计数器溢出并回转为0的状态。</p><p><strong>RTC时钟源：</strong> 三种不同的时钟源可被用来驱动系统时钟(SYSCLK)：</p><p>● <strong>HSI振荡器时钟</strong> ● <strong>HSE振荡器时钟</strong> ● <strong>PLL时钟</strong></p><p>这些设备有以下2种二级时钟源：</p><p>● 40kHz低速内部RC，可以用于驱动独立看门狗和通过程序选择驱动RTC。 RTC用于从停机&#x2F;待机模式下自动唤醒系统。 ● 32.768kHz低速外部晶体也可用来通过程序选择驱动RTC(RTCCLK)。</p><h4 id="RTC原理框图"><a href="#RTC原理框图" class="headerlink" title="RTC原理框图"></a>RTC原理框图</h4><p><img src="https://img-blog.csdnimg.cn/20200322144525734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200322144525734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br> RTC时钟的框图还是比较简单的，这里我们把他分成 <strong><code>两个部分</code></strong>:</p><p><strong>APB1 接口</strong>：用来和 APB1 总线相连。 此单元还包含一组 16 位寄存器，可通过 APB1 总线对其进行读写操作。APB1 接口由 APB1 总 线时钟驱动，用来与 APB1 总线连接。</p><p>通过APB1接口可以访问RTC的相关寄存器（预分频值，计数器值，闹钟值）。</p><p><strong>RTC 核心接口</strong>：由一组可编程计数器组成，分成 <strong><code>两个主要模块</code></strong> 。<br><img src="https://img-blog.csdnimg.cn/20200322223612113.png" alt="https://img-blog.csdnimg.cn/20200322223612113.png"><br>g) <strong>第一个模块是 RTC 的 预分频模块</strong>，它可编程产生 1 秒的 RTC 时间基准 TR_CLK。RTC 的预分频模块包含了一个 20 位的可编程分频器(RTC 预分频器)。如果在 RTC_CR 寄存器中设置了相应的允许位，则在每个 TR_CLK 周期中 RTC 产生一个中断(秒中断)。<br><img src="https://img-blog.csdnimg.cn/2020032222362770.png" alt="https://img-blog.csdnimg.cn/2020032222362770.png"><br> <strong>第二个模块是一个 32 位的可编程计数器 （RTC_CNT）</strong>，可被初始化为当前的系统时间，一个 32 位的时钟计数器，按秒钟计算，可以记 录 4294967296 秒，约合 136 年左右，作为一般应用，这已经是足够了的。</p><h4 id="RTC具体流程："><a href="#RTC具体流程：" class="headerlink" title="RTC具体流程："></a><strong>RTC具体流程：</strong></h4><p><strong>RTCCLK经过RTC_DIV预分频，RTC_PRL设置预分频系数，然后得到TR_CLK时钟信号，我们一般设置其周期为1s，RTC_CNT计数器计数，假如1970设置为时间起点为0s，通过当前时间的秒数计算得到当前的时间。RTC_ALR是设置闹钟时间，RTC_CNT计数到RTC_ALR就会产生计数中断，</strong></p><ul><li><strong>RTC_Second</strong>为秒中断，用于刷新时间，+ <strong>RTC_Overflow</strong>是溢出中断。+ <strong>RTC Alarm</strong> 控制开关机</li></ul><h4 id="RTC时钟选择"><a href="#RTC时钟选择" class="headerlink" title="RTC时钟选择"></a>RTC时钟选择</h4><p><strong>使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响,因此没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE,频率为实时时钟模块中常用的32.768KHz,因为32768 &#x3D; 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</strong></p><h4 id="RTC复位过程"><a href="#RTC复位过程" class="headerlink" title="RTC复位过程"></a>RTC复位过程</h4><p>除了RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器外，所有的系统寄存器都由系统复位或电源复位进行异步复位。 RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器仅能通过备份域复位信号复位。</p><p><strong>系统复位后,禁止访问后备寄存器和RCT,防止对后卫区域(BKP)的意外写操作</strong></p><h4 id="RTC中断"><a href="#RTC中断" class="headerlink" title="RTC中断"></a>RTC中断</h4><p><strong>秒中断：</strong> 这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的“秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p><p><strong>闹钟中断：</strong> 闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p><h3 id="CubeMX配置RTC"><a href="#CubeMX配置RTC" class="headerlink" title="CubeMX配置RTC"></a>CubeMX配置RTC</h3><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p><strong>1设置RCC</strong><br><img src="https://img-blog.csdnimg.cn/20200425101549368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425101549368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li><strong>设置高速外部时钟HSE 选择外部时钟源</strong>+ <strong>使能外部晶振LSE</strong></li></ul><p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE</strong></p><p>2.<strong>配置RTC</strong><br><img src="https://img-blog.csdnimg.cn/20200425110730403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425110730403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li><strong>Activate Clock Source 激活时钟源</strong>+ <strong>Activate calendar激活日历</strong></li></ul><p><strong>这两个都要点，作用也很明显，先是使能时钟源，再使能RTC日历</strong></p><ul><li><strong>RTC_OUT： Not RTC_OUT</strong>+ <strong>Tamper：</strong> <strong>×</strong></li></ul><p>第一个是是否使能 <strong>tamper（PC13）引脚上输出校正的秒脉冲时钟，</strong></p><p>第二个： <strong>RTC入侵检测校验功能</strong></p><p><strong>RTC校验功能，使能侵入检测功能。RTC时钟经64分频输出到侵入检测引脚TAMPER上 当 TAMPER引脚上的信号从 0变成1或者从 1变成 0(取决于备份控制寄存器BKP_CR的 TPAL位)，会产生一个侵入检测事件。侵入检测事件将所有数据备份寄存器内容清除。</strong></p><ul><li>也就是第一个是使能tamper（PC13）引脚作为时钟脉冲输出+ 第二个是使能tamper（PC13）引脚作为入侵检测功能</li></ul><p>下面是两个RTC的中断：</p><ul><li><strong>RTC全局中断RTC_IRQHandler()</strong>+ <strong>闹钟中断函数RTCAlarm_IRQHandler()</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/2020042514381771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/2020042514381771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>此处设置时间为2020&#x2F;04&#x2F;25 13:30:00</strong></p><ul><li>Data Format: 日期格式</li></ul><p><strong>Binary data format 十六进制 BCD data format BCD码进制</strong></p><p>使用自动配置，初始化时间必须使用BCD data format，原因是库函数存在bug，如果使用Binary data format，月份配置会出错，比如说11月，配置时会赋值为RTC_MONTH_NOVEMBER，而此宏定义值为0x11，也就是说其十进制值为17</p><ul><li><strong>Hours： 小时</strong> +  <strong>Minutes： 分钟</strong> +  <strong>Seconds： 秒</strong> +  <strong>Week Day： 星期</strong> +  <strong>Month 月份</strong> +  <strong>Date： 日期</strong> +  <strong>Year： 年份</strong></li></ul><p><strong>3 使能串口</strong><br><img src="https://img-blog.csdnimg.cn/20200425143944495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425143944495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br> <strong>使能一下串口，因为发送日期到上位机</strong></p><p><strong>4时钟源设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144337169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425144337169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>我的是 外部晶振为8MHz</p><ul><li>1选择外部时钟HSE 8MHz+ 2PLL锁相环倍频9倍+ 3系统时钟来源选择为PLL+ 4设置APB1分频器为 &#x2F;2+ 5 使能CSS监视时钟+ <strong>6 设置RTC时钟为LSE</strong></li></ul><p>32的时钟树框图 如果不懂的话请看<a href="https://blog.csdn.net/as480133937/article/details/98845509">《【STM32】系统时钟RCC详解(超详细，超全面)》</a></p><p><strong>5项目文件设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425144600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li>1 设置项目名称+ 2 设置存储路径+ 3 选择所用IDE<br><img src="https://img-blog.csdnimg.cn/2020042514462236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/2020042514462236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></li></ul><p><strong>6创建工程文件</strong></p><p><strong>然后点击GENERATE CODE 创建工程</strong></p><p><strong>配置下载工具</strong> 新建的工程所有配置都是默认的 我们需要自行选择下载模式，勾选上下载后复位运行</p><p><img src="https://img-blog.csdnimg.cn/202004251446415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/202004251446415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC-HAL库函数"><a href="#RTC-HAL库函数" class="headerlink" title="RTC_HAL库函数"></a>RTC_HAL库函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置系统时间*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span> </span><br><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*设置系统日期*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*启动报警功能*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*设置报警中断*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm_IT</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*报警时间回调函数*/</span></span><br><span class="line">__weak <span class="keyword">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"><span class="comment">/*写入后备储存器*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)</span></span><br><span class="line"><span class="comment">/*读取后备储存器*/</span></span><br><span class="line">uint32_t <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister  </span></span><br></pre></td></tr></table></figure><p>我们可以看到前面的四个函数，分别是</p><ul><li><strong>设置系统时间：HAL_RTC_SetTime();</strong>+ <strong>读取系统时间: HAL_RTC_GetTime();</strong>+ <strong>设置系统日期: HAL_RTC_SetDate();</strong>+ <strong>读取系统日期: HAL_RTC_GetDate();</strong></li></ul><p>因为系统的时间和日期开始的时候已经设置过了，所以我们这里只用两个读取函数</p><p> <strong>读取系统时间函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的时间</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2 +  <strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体， +  Format： <strong>获取时间的格式</strong> <strong>RTC_FORMAT_BIN 使用16进制 RTC_FORMAT_BCD 使用BCD进制</strong></li></ul><p> <strong>读取系统日期函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的日期</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2 +  <strong>RTC_DateTypeDef</strong> *sTime： 获取RTC日期的结构体， +  Format： <strong>获取日期的格式</strong> <strong>RTC_FORMAT_BIN 使用16进制 RTC_FORMAT_BCD 使用BCD进制</strong></li></ul><p>在stm32f1xx_hal_rtc.h头文件中，可以找到<code>RTC_TimeTypeDef</code>，<code>RTC_DateTypeDef</code>这两个结构体的成员变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @brief  RTC Time structure definition</span><br><span class="line">  */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t Hours;            /*!&lt; Specifies the RTC Time Hour.</span><br><span class="line">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 */</span><br><span class="line"></span><br><span class="line">  uint8_t Minutes;          /*!&lt; Specifies the RTC Time Minutes.</span><br><span class="line">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span><br><span class="line"></span><br><span class="line">  uint8_t Seconds;          /*!&lt; Specifies the RTC Time Seconds.</span><br><span class="line">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @brief  RTC Date structure definition</span><br><span class="line">  */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t WeekDay;  /*!&lt; Specifies the RTC Date WeekDay (not necessary for HAL_RTC_SetDate).</span><br><span class="line">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span><br><span class="line"></span><br><span class="line">  uint8_t Month;    /*!&lt; Specifies the RTC Date Month (in BCD format).</span><br><span class="line">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span><br><span class="line"></span><br><span class="line">  uint8_t Date;     /*!&lt; Specifies the RTC Date.</span><br><span class="line">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span><br><span class="line"></span><br><span class="line">  uint8_t Year;     /*!&lt; Specifies the RTC Date Year.</span><br><span class="line">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br></pre></td></tr></table></figure><p><strong>程序代码：</strong></p><p>main.c</p><p><strong>在main.c中重写fputc函数，使得能够使用printf函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fputc(int ch,FILE *f)&#123;</span><br><span class="line"> uint8_t temp[1]=&#123;ch&#125;;</span><br><span class="line"> HAL_UART_Transmit(&amp;huart1,temp,1,2);</span><br><span class="line"> return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义两个结构体来获取日期和时间：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTC_DateTypeDef GetData;  //获取日期结构体</span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef GetTime;   //获取时间结构体</span><br></pre></td></tr></table></figure><p>在while循环中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Get the RTC current Time */</span><br><span class="line">HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line">   /* Get the RTC current Date */</span><br><span class="line">   HAL_RTC_GetDate(&amp;hrtc, &amp;GetData, RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">   /* Display date Format : yy/mm/dd */</span><br><span class="line">   printf(&quot;%02d/%02d/%02d\r\n&quot;,2000 + GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line">   /* Display time Format : hh:mm:ss */</span><br><span class="line">   printf(&quot;%02d:%02d:%02d\r\n&quot;,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">   printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">   HAL_Delay(1000);</span><br></pre></td></tr></table></figure><p><strong>程序中使用HAL_RTC_GetTime（）,HAL_RTC_GetDate()读取时间和日期，并保存到结构体变量中，然后通过串口输出读取的时间和日期。</strong></p><p><strong>例程测试正常：</strong><br><img src="https://img-blog.csdnimg.cn/20200425153330941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425153330941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC掉电重置"><a href="#RTC掉电重置" class="headerlink" title="RTC掉电重置"></a>RTC掉电重置</h4><p>但是呢，在hal库中生成的代码，<strong>每次断电就RTC时间会重置</strong>，每次上电都会重新初始化时间</p><p>因为HAL库设置了一个BKP寄存器保存一个标志。每次单片机启动时都读取这个标志并判断是不是预先设定的值：如度果不是就初始化RTC并设置时间，再设置标志为预期值；如果是预期值就跳过初始化和时间设置，继续执行后面的程序</p><p><strong>所以这里我们只需要每次上电执行RTC初始化之前，将标志设置为预期值即可</strong></p><p><strong>在rtc.c中的RTC_Init修改为以下内容即可</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> void MX_RTC_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN RTC_Init 0 */</span><br><span class="line">RTC_TimeTypeDef time;   //时间结构体参数</span><br><span class="line">RTC_DateTypeDef datebuff;   //日期结构体参数</span><br><span class="line">  /* USER CODE END RTC_Init 0 */</span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;0&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN RTC_Init 1 */</span><br><span class="line">__HAL_RCC_BKP_CLK_ENABLE();       //开启后备区域时钟</span><br><span class="line">__HAL_RCC_PWR_CLK_ENABLE();  //开启电源时钟</span><br><span class="line">  /* USER CODE END RTC_Init 1 */</span><br><span class="line">  /**Initialize RTC Only </span><br><span class="line">  */</span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  if (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN Check_RTC_BKUP */</span><br><span class="line">if(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= 0x5051)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END Check_RTC_BKUP */</span><br><span class="line"></span><br><span class="line">  /**Initialize RTC and set the Time and Date </span><br><span class="line">  */</span><br><span class="line">  sTime.Hours = 0x14;</span><br><span class="line">  sTime.Minutes = 0x30;</span><br><span class="line">  sTime.Seconds = 0x0;</span><br><span class="line"></span><br><span class="line">  if (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  DateToUpdate.WeekDay = RTC_WEEKDAY_SATURDAY;</span><br><span class="line">  DateToUpdate.Month = RTC_MONTH_APRIL;</span><br><span class="line">  DateToUpdate.Date = 0x25;</span><br><span class="line">  DateToUpdate.Year = 0x20;</span><br><span class="line"></span><br><span class="line">  if (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE BEGIN RTC_Init 2 */</span><br><span class="line"></span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); //开启RTC时钟秒中断</span><br><span class="line">datebuff = DateToUpdate;  //把日期数据拷贝到自己定义的data中</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, 0x5051);//向指定的后备区域寄存器写入数据</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR2, (uint16_t)datebuff.Year);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR3, (uint16_t)datebuff.Month);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR4, (uint16_t)datebuff.Date);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR5, (uint16_t)datebuff.WeekDay);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">datebuff.Year    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR2);</span><br><span class="line">datebuff.Month   = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR3);</span><br><span class="line">datebuff.Date    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR4);</span><br><span class="line">datebuff.WeekDay = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR5);</span><br><span class="line">DateToUpdate = datebuff;</span><br><span class="line">if (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BIN) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); //开启RTC时钟秒中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425165901167.gif" alt="https://img-blog.csdnimg.cn/20200425165901167.gif"></p><p><img src="https://img-blog.csdnimg.cn/20200425165904365.gif" alt="https://img-blog.csdnimg.cn/20200425165904365.gif"></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32 hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32_HAL库驱动DHT11读取温湿度程序</title>
      <link href="/2024/03/stm32-STM32-HAL%E5%BA%93%E9%A9%B1%E5%8A%A8DHT11%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/03/stm32-STM32-HAL%E5%BA%93%E9%A9%B1%E5%8A%A8DHT11%E8%AF%BB%E5%8F%96%E6%B8%A9%E6%B9%BF%E5%BA%A6%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="STM32使用HAL库驱动DHT11读取温湿度程序"><a href="#STM32使用HAL库驱动DHT11读取温湿度程序" class="headerlink" title="STM32使用HAL库驱动DHT11读取温湿度程序"></a>STM32使用HAL库驱动DHT11读取温湿度程序</h2><p><strong>驱动DHT11、DHT22、DS18BB20等温湿度模块时序是比较简单的，关键在于控制好时序的<code>延时时间</code>，HAL库的延时函数HAL_Delay是毫秒级别延时函数，所关键点就是实现微秒级别的延时函数。</strong></p><p><strong>微秒级别延时函数实现见我的另一篇博客：<a href="https://blog.csdn.net/qq153471503/article/details/102930097">https://blog.csdn.net/qq153471503/article/details/102930097</a></strong></p><p><strong>扫描以下二维码，关注公众号<code>雍正不秃头</code>获取更多STM32资源及干货！</strong><br><img src="https://img-blog.csdnimg.cn/20210126155428872.png" alt="https://img-blog.csdnimg.cn/20210126155428872.png"></p><h3 id="sys-h"><a href="#sys-h" class="headerlink" title="sys.h"></a>sys.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _SYS_H_</span><br><span class="line">#define _SYS_H_</span><br><span class="line"></span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line"></span><br><span class="line">#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span><br><span class="line">#define MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))</span><br><span class="line">#define BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))</span><br><span class="line"></span><br><span class="line">#define GPIOA_ODR_Addr    (GPIOA_BASE+12) //0x4001080C </span><br><span class="line">#define GPIOB_ODR_Addr    (GPIOB_BASE+12) //0x40010C0C </span><br><span class="line">#define GPIOC_ODR_Addr    (GPIOC_BASE+12) //0x4001100C </span><br><span class="line">#define GPIOD_ODR_Addr    (GPIOD_BASE+12) //0x4001140C </span><br><span class="line">#define GPIOE_ODR_Addr    (GPIOE_BASE+12) //0x4001180C </span><br><span class="line">#define GPIOF_ODR_Addr    (GPIOF_BASE+12) //0x40011A0C    </span><br><span class="line">#define GPIOG_ODR_Addr    (GPIOG_BASE+12) //0x40011E0C    </span><br><span class="line"></span><br><span class="line">#define GPIOA_IDR_Addr    (GPIOA_BASE+8) //0x40010808 </span><br><span class="line">#define GPIOB_IDR_Addr    (GPIOB_BASE+8) //0x40010C08 </span><br><span class="line">#define GPIOC_IDR_Addr    (GPIOC_BASE+8) //0x40011008 </span><br><span class="line">#define GPIOD_IDR_Addr    (GPIOD_BASE+8) //0x40011408 </span><br><span class="line">#define GPIOE_IDR_Addr    (GPIOE_BASE+8) //0x40011808 </span><br><span class="line">#define GPIOF_IDR_Addr    (GPIOF_BASE+8) //0x40011A08 </span><br><span class="line">#define GPIOG_IDR_Addr    (GPIOG_BASE+8) //0x40011E08 </span><br><span class="line"></span><br><span class="line">#define PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  //</span><br><span class="line">#define PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  //</span><br><span class="line"></span><br><span class="line">#define PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  //</span><br><span class="line">#define PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  //</span><br><span class="line"></span><br><span class="line">#define PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)  //</span><br><span class="line">#define PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  //</span><br><span class="line"></span><br><span class="line">#define PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)  //</span><br><span class="line">#define PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)  //</span><br><span class="line"></span><br><span class="line">#define PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  //</span><br><span class="line">#define PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  //</span><br><span class="line"></span><br><span class="line">#define PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  //</span><br><span class="line">#define PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  //</span><br><span class="line"></span><br><span class="line">#define PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  //</span><br><span class="line">#define PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)  //</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dht11-h"><a href="#dht11-h" class="headerlink" title="dht11.h"></a>dht11.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DHT11_H</span><br><span class="line">#define __DHT11_H</span><br><span class="line"></span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;sys.h&quot;</span><br><span class="line"></span><br><span class="line">typedef uint8_t u8;</span><br><span class="line">typedef uint16_t u16;</span><br><span class="line">typedef uint32_t u32;</span><br><span class="line"></span><br><span class="line">//IO方向设置</span><br><span class="line">#define DHT11_IO_IN()  &#123;IODHT22_GPIO_Port-&gt;CRH &amp;= 0xFFFFF0FF;IODHT22_GPIO_Port-&gt;CRH |= 8 &lt;&lt; 8;&#125;// PC10 IN  MODE</span><br><span class="line">#define DHT11_IO_OUT() &#123;IODHT22_GPIO_Port-&gt;CRH &amp;= 0xFFFFF0FF;IODHT22_GPIO_Port-&gt;CRH |= 3 &lt;&lt; 8;&#125;// PC10 OUT MODE</span><br><span class="line"></span><br><span class="line">IO操作函数</span><br><span class="line">#defineDHT11_DQ_OUT PCout(10) //数据端口PC10</span><br><span class="line">#defineDHT11_DQ_IN  PCin(10)  //数据端口PC10</span><br><span class="line"></span><br><span class="line">u8 DHT11_Init(void);//初始化DHT11</span><br><span class="line">u8 DHT11_Read_Data(u8 *temp, u8 *humi); //读取温湿度</span><br><span class="line">u8 DHT11_Read_Byte(void);//读出一个字节</span><br><span class="line">u8 DHT11_Read_Bit(void);//读出一个位</span><br><span class="line">u8 DHT11_Check(void);//检测是否存在DHT11</span><br><span class="line">void DHT11_Rst(void);//复位DHT11</span><br><span class="line">u8 DHT11_Read_Data_Float(float *temp,float *humi);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="dht11-c"><a href="#dht11-c" class="headerlink" title="dht11.c"></a>dht11.c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;dht11.h&quot;</span><br><span class="line"></span><br><span class="line">//复位DHT11</span><br><span class="line">void DHT11_Rst(void)</span><br><span class="line">&#123;</span><br><span class="line">    DHT11_IO_OUT(); //SET OUTPUT</span><br><span class="line">    DHT11_DQ_OUT=0; //拉低DQ</span><br><span class="line">    delay_ms(20);    //拉低至少18ms,(DHT22 500us)</span><br><span class="line">    DHT11_DQ_OUT=1; //DQ=1</span><br><span class="line">    delay_us(30);     //主机拉高20~40us</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待DHT11的回应</span><br><span class="line">//返回1:未检测到DHT11的存在</span><br><span class="line">//返回0:存在</span><br><span class="line">u8 DHT11_Check(void)</span><br><span class="line">&#123;</span><br><span class="line">    u8 retry=0;</span><br><span class="line">    DHT11_IO_IN();//SET INPUT</span><br><span class="line">    while (DHT11_DQ_IN&amp;&amp;retry&lt;100)//DHT11会拉低40~80us</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(1);</span><br><span class="line">    &#125;;</span><br><span class="line">    if(retry&gt;=100)return 1;</span><br><span class="line">    else retry=0;</span><br><span class="line">    while (!DHT11_DQ_IN&amp;&amp;retry&lt;100)//DHT11拉低后会再次拉高40~80us</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(1);</span><br><span class="line">    &#125;;</span><br><span class="line">    if(retry&gt;=100)return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从DHT11读取一个位</span><br><span class="line">//返回值：1/0</span><br><span class="line">u8 DHT11_Read_Bit(void)</span><br><span class="line">&#123;</span><br><span class="line">    u8 retry=0;</span><br><span class="line">    while(DHT11_DQ_IN&amp;&amp;retry&lt;100)//等待变为低电平</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(1);</span><br><span class="line">    &#125;</span><br><span class="line">    retry=0;</span><br><span class="line">    while(!DHT11_DQ_IN&amp;&amp;retry&lt;100)//等待变高电平</span><br><span class="line">    &#123;</span><br><span class="line">        retry++;</span><br><span class="line">        delay_us(1);</span><br><span class="line">    &#125;</span><br><span class="line">    delay_us(40);//等待40us</span><br><span class="line">    if(DHT11_DQ_IN)return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从DHT11读取一个字节</span><br><span class="line">//返回值：读到的数据</span><br><span class="line">u8 DHT11_Read_Byte(void)</span><br><span class="line">&#123;</span><br><span class="line">    u8 i,dat;</span><br><span class="line">    dat=0;</span><br><span class="line">    for (i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dat&lt;&lt;=1;</span><br><span class="line">        dat|=DHT11_Read_Bit();</span><br><span class="line">    &#125;</span><br><span class="line">    return dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从DHT11读取一次数据</span><br><span class="line">//temp:温度值(范围:0~50°)</span><br><span class="line">//humi:湿度值(范围:20%~90%)</span><br><span class="line">//返回值：0,正常;1,读取失败</span><br><span class="line">u8 DHT11_Read_Data(u8 *temp,u8 *humi)</span><br><span class="line">&#123;</span><br><span class="line">    u8 buf[5];</span><br><span class="line">    u8 i;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    if(DHT11_Check()==0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=0; i&lt;5; i++) //读取40位数据</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]=DHT11_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4])</span><br><span class="line">        &#123;</span><br><span class="line">            *humi=buf[0];</span><br><span class="line">            *temp=buf[2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 DHT11_Read_Data_Float(float *temp,float *humi)</span><br><span class="line">&#123;</span><br><span class="line">    u8 buf[5];</span><br><span class="line">    u8 i;</span><br><span class="line">    DHT11_Rst();</span><br><span class="line">    if(DHT11_Check()==0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=0; i&lt;5; i++) //读取40位数据</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]=DHT11_Read_Byte();</span><br><span class="line">        &#125;</span><br><span class="line">        if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4])</span><br><span class="line">        &#123;</span><br><span class="line">*humi=((buf[0] &lt;&lt; 8) + buf[1]) / 10.0;</span><br><span class="line">*temp=((buf[2] &lt;&lt; 8) + buf[3]) / 10.0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else return 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化DHT11的IO口 DQ 同时检测DHT11的存在</span><br><span class="line">//返回1:不存在</span><br><span class="line">//返回0:存在</span><br><span class="line">u8 DHT11_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">    u8 ret = 1;</span><br><span class="line">    DHT11_Rst();  //复位DHT11</span><br><span class="line">    ret = DHT11_Check();</span><br><span class="line">    printf(&quot;dht11 init %s. \r\n&quot;, ret == 0 ? &quot;ok&quot; : &quot;failed&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32 hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX_|_HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</title>
      <link href="/2024/03/stm32-STM32CubeMX-HAL%E5%BA%93%E7%9A%84ADC%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E8%BD%AE%E8%AE%AD%E3%80%81DMA%E3%80%81DMA-TIM-%E3%80%81%E8%AF%BB%E5%8F%96%E5%86%85%E9%83%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B8%A9%E5%BA%A6/"/>
      <url>/2024/03/stm32-STM32CubeMX-HAL%E5%BA%93%E7%9A%84ADC%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E8%BD%AE%E8%AE%AD%E3%80%81DMA%E3%80%81DMA-TIM-%E3%80%81%E8%AF%BB%E5%8F%96%E5%86%85%E9%83%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="STM32CubeMX-HAL库的ADC多通道数据采集（轮训、DMA、DMA-TIM-、读取内部传感器温度"><a href="#STM32CubeMX-HAL库的ADC多通道数据采集（轮训、DMA、DMA-TIM-、读取内部传感器温度" class="headerlink" title="STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度"></a>STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</h2><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><p><a href="#STM32CubeMX__HALADCDMADMATIM_0">STM32CubeMX | HAL库的ADC多通道数据采集（轮训、DMA、DMA+TIM)、读取内部传感器温度</a>+ </p></li><li></li><li><p><a href="#1ADC_11">1、ADC简介</a>+ </p></li><li><p><a href="#11__13">1.1 采样定理</a>+ <a href="#12__15">1.2 模式介绍</a>+ <a href="#13__24">1.3 采样时间和采样频率的计算</a></p></li><li><p><a href="#2_56">2、轮训方式的多通道采集</a>+ </p></li><li><p><a href="#21__57">2.1 方式一：间断模式+扫描模式</a>+ <a href="#22__72">2.2 方式二：完全轮训</a></p></li><li><p><a href="#3DMA_108">3、DMA实现多通道采集</a>+ <a href="#4TIMDMA_136">4、TIM+DMA实现多通道采集</a>+ <a href="#5ADC_179">5、补充：内部温度传感器ADC通道</a></p></li></ul><p><em>注：本片文章以STM32F103系列为例，其他系列可能稍有不同。</em></p><h4 id="1、ADC简介"><a href="#1、ADC简介" class="headerlink" title="1、ADC简介"></a>1、ADC简介</h4><h5 id="1-1-采样定理"><a href="#1-1-采样定理" class="headerlink" title="1.1 采样定理"></a>1.1 采样定理</h5><h5 id="1-2-模式介绍"><a href="#1-2-模式介绍" class="headerlink" title="1.2 模式介绍"></a>1.2 模式介绍</h5><ul><li><strong>扫描模式：</strong> 使用STM32CUBEMX配置了多通道后，这一项默认开启且无法设置成关闭。这个模式就是自动扫描你开启的所有通道进行转换，直至转换完。例如你开启了CH0、CH1、CH2、CH3这四个通道，启动转换后ADC会自动将这4个通道全部转换完，但是这种连续性是可以被打断的，所以就引出了间断模式。 +  <strong>连续模式：</strong> 在CUBE中选中ENABLE就是连续模式，DISABLE就是单次模式。开启连续模式后，ADC的转换不由其他控制。例如将ADC设置为了定时器的TGRO触发采样，如果开启连续模式，ADC将忽略定时器的触发采样。（连续转换模式开启后其实就是满频率的采样）。 +  <strong>间断模式：</strong> 可以将多个通道进行<strong>分组采集</strong>，例如你开启了CH0~3这4个通道，假如你设置了间断次数为4，就相当于将4个通道分成了4组，每组1个通道，那么要想采集完这4个通道就需要手动触发4次ADC采集；如果设置了间断次数为2，那么采集完4个通道就需要手动触发2次ADC采集。</li></ul><h5 id="1-3-采样时间和采样频率的计算"><a href="#1-3-采样时间和采样频率的计算" class="headerlink" title="1.3 采样时间和采样频率的计算"></a>1.3 采样时间和采样频率的计算</h5><p><strong>ADC采样两点间隔的时间一定要大于ADC的采样时间！</strong> 采样时间怎么算，下面就细说一下。</p><p>STM32F103一般将时钟配置主频为72M、APB2为72M。ADC挂在APB2时钟总线上，且ADC的时钟不能超过14M。所以一般将ADC的分频设置为6，ADC的时钟主频就为72&#x2F;6&#x3D;12MHz。那么一个周期就是：1&#x2F;12MHz&#x3D;0.0833us。</p><p>以下截图为STM32F1参考手册（手册编号RM0008，可在ST官网直接搜索下载）：</p><p><img src="https://img-blog.csdnimg.cn/84ca12cd9d40459eb3e03c54889e9df3.png" alt="https://img-blog.csdnimg.cn/84ca12cd9d40459eb3e03c54889e9df3.png"></p><p>上图的意思是：ADC对输入电压采样若干个ADC_CLK周期，这些周期可通过ADC_SMPR1和ADC_SMPR2寄存器中的SMP[2:0]位进行修改。每个通道都可以用不同的采样时间进行采样。</p><p><strong>ADC转换时间 &#x3D; 采样时间 + 12.5个周期</strong></p><p>示例： $~~~~~~~~$当ADC时钟主频为14MHz并且采样时间为1.5个周期时：采样时间 &#x3D; 1.5 + 12.5 &#x3D; 14个周期；一个周期的时间为1&#x2F;14MHz，一共14个周期，<strong>1 &#x2F; 14MHz * 14个周期 &#x3D; 1us</strong>，那么此时ADC的采样频率就是1&#x2F;1us&#x3D;1000KHz&#x3D;1MHz，这也是理论上ADC的最大采样频率。</p><p>STM32F1系列的时钟主频一般设置为了12M，采样时间的设置所对应采样频率如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/de1135452e21490a94b671995f48824f.png" alt="https://img-blog.csdnimg.cn/de1135452e21490a94b671995f48824f.png"></p><p>知道了最短时间后，当ADC时钟主频为12M并且采样时间为1.5个周期时，ADC采样两点的时间必须大于1.17us。</p><p>而STM32F031系列的ADC时钟主频为14MHz，采样时间的设置所对应采样频率如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/4616052a159b4c6da44230ee81f9a4a0.png" alt="https://img-blog.csdnimg.cn/4616052a159b4c6da44230ee81f9a4a0.png"></p><p>当ADC时钟主频为14M并且采样时间为1.5个周期时，ADC采样两点的时间必须大于1us。</p><h4 id="2、轮训方式的多通道采集"><a href="#2、轮训方式的多通道采集" class="headerlink" title="2、轮训方式的多通道采集"></a>2、轮训方式的多通道采集</h4><h5 id="2-1-方式一：间断模式-扫描模式"><a href="#2-1-方式一：间断模式-扫描模式" class="headerlink" title="2.1 方式一：间断模式+扫描模式"></a>2.1 方式一：间断模式+扫描模式</h5><p>我开启了通道0、1、2以及内部温度读取通道一共四个通道：</p><p><img src="https://img-blog.csdnimg.cn/20200820144708671.png#pic_center" alt="https://img-blog.csdnimg.cn/20200820144708671.png#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/20200820144717271.png#pic_center" alt="https://img-blog.csdnimg.cn/20200820144717271.png#pic_center"><br> 如果想使用轮训方式并且不使用DMA的多通道采集，那么就要配置为 <strong>【单次模式+间断模式】</strong>，并且将Number Of Discontinuous Conversions为1，也就是每个通道分成了一个组，配置如下图：<br><img src="https://img-blog.csdnimg.cn/20200820145205371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center" alt="https://img-blog.csdnimg.cn/20200820145205371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center"></p><p>由于我这里设置间断数为1，也就是将4个通道分成了4组，那么我每次采集的时候都需要手动去触发ADC采集，也就是调用一次HAL_ADC_Start函数，完整代码如下：</p><p><img src="https://img-blog.csdnimg.cn/2020082014582133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center" alt="https://img-blog.csdnimg.cn/2020082014582133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center"><br> 我将通道0分别接到3.3V和GND上，4通道采集运行效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200820150008132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center" alt="https://img-blog.csdnimg.cn/20200820150008132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center"></p><h5 id="2-2-方式二：完全轮训"><a href="#2-2-方式二：完全轮训" class="headerlink" title="2.2 方式二：完全轮训"></a>2.2 方式二：完全轮训</h5><p>完全使用轮训的方式不能使用<strong>扫描模式</strong>（理论上来说多通道需要使用扫描模式，而不是完全轮训），但是使用STM32CUBEMX配置多通道扫描模式不无法被关闭的，所以我们先用STM32CUBEMX配置成一个通道：<br><img src="https://img-blog.csdnimg.cn/0b4c62f299d54bcf89ba61ea0aee0eca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeS16aGVuZw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="https://img-blog.csdnimg.cn/0b4c62f299d54bcf89ba61ea0aee0eca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeS16aGVuZw==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>然后读取ADC采集数值的函数是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uint16_t ADC_Read(uint32_t Channel)</span><br><span class="line">&#123;</span><br><span class="line">ADC_ChannelConfTypeDef sConfig = &#123;0&#125;;</span><br><span class="line">sConfig.Channel = Channel;                                         /* 通道 */</span><br><span class="line">sConfig.Rank = ADC_REGULAR_RANK_1;                              </span><br><span class="line">sConfig.SamplingTime = ADC_SAMPLETIME_55CYCLES_5;                  /* 采样时间 */</span><br><span class="line">if (HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig) != HAL_OK)             </span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, HAL_MAX_DELAY);</span><br><span class="line">return (uint16_t)HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">uint16_t ADC_Value[5];</span><br><span class="line"></span><br><span class="line">ADC_Value[0] = ADC_Read(ADC_CHANNEL_1);  // 采集并读取通道1</span><br><span class="line">ADC_Value[1] = ADC_Read(ADC_CHANNEL_4);</span><br><span class="line">ADC_Value[2] = ADC_Read(ADC_CHANNEL_5);</span><br><span class="line">ADC_Value[3] = ADC_Read(ADC_CHANNEL_6);</span><br><span class="line">ADC_Value[4] = ADC_Read(ADC_CHANNEL_7);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="3、DMA实现多通道采集"><a href="#3、DMA实现多通道采集" class="headerlink" title="3、DMA实现多通道采集"></a>3、DMA实现多通道采集</h4><p>通过DMA实现多通道数据采集，<strong>要将连续模式和间断模式关闭！</strong></p><p>如果连续模式开启，那么通过DMA传输到的数组中，每个通道所采集到的值对应数组中的一个位置就是不固定的。</p><p>例如你开启了IN0~IN3这四个通道，并通过DMA将这四个通道的数据放到ADC_Value这个大小为4的u16类型数组，</p><p>你在第一次采集的时候IN0通道的数值通过DMA被放在ADC_Value[0]，</p><p>第二次采集的时候IN0采集到的数值就可能被放到了ADC_Value[1]，</p><p>这样的话就极不方便我们对每个通道的数据进行分析和提取。</p><p>配置如下，将连续转换模式和间断转换模式关闭，并开启ADC的DMA通道，将DMA的模式配置为周期模式：</p><p><img src="https://img-blog.csdnimg.cn/20200820152200735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center" alt="https://img-blog.csdnimg.cn/20200820152200735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/ddd590ed84b44942863728c7b84ff639.png" alt="https://img-blog.csdnimg.cn/ddd590ed84b44942863728c7b84ff639.png"></p><p>代码如下：</p><p><img src="https://img-blog.csdnimg.cn/c457e847f73847ceb3a35f112f66667e.png" alt="https://img-blog.csdnimg.cn/c457e847f73847ceb3a35f112f66667e.png"><br> 4个通道采集运行效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20200820152427227.png#pic_center" alt="https://img-blog.csdnimg.cn/20200820152427227.png#pic_center"></p><h4 id="4、TIM-DMA实现多通道采集"><a href="#4、TIM-DMA实现多通道采集" class="headerlink" title="4、TIM+DMA实现多通道采集"></a>4、TIM+DMA实现多通道采集</h4><p>在不使用DMA的情况下，定时器控制ADC进行数据采集只能是单通道！如果开启了多通道，读取到的ADC采集值只会是最后一个通道的值！</p><p>所以，要想使用定时器控制ADC采集<strong>多通道</strong>，必须使用DMA！</p><p>CubeMX配置如下，使能ADC的DMA：</p><p><img src="https://img-blog.csdnimg.cn/42aa3e7658df4d89ac32b7f2a1ebc643.png" alt="https://img-blog.csdnimg.cn/42aa3e7658df4d89ac32b7f2a1ebc643.png"></p><p>ADC的触发方式设置为定时器3的触发事件：</p><p><img src="https://img-blog.csdnimg.cn/c4ff90b3330b44fda0a609316e2370db.png" alt="https://img-blog.csdnimg.cn/c4ff90b3330b44fda0a609316e2370db.png"></p><p>采样时间设置为了55.5个周期，对应采样频率为176.47KHz，所以定时器3的频率设置要低于176.47KHz。</p><p>设置定时器3分频系数为72，重载值为10，得到<code>72MHz / 72分频 / 10 = 100KHz</code>的定时器3：</p><p><img src="https://img-blog.csdnimg.cn/a50e71979339457e90f451449ec69d86.png" alt="https://img-blog.csdnimg.cn/a50e71979339457e90f451449ec69d86.png"></p><p>代码如下：</p><p><img src="https://img-blog.csdnimg.cn/c418cbe4d5b340a2ae94438927728da5.png" alt="https://img-blog.csdnimg.cn/c418cbe4d5b340a2ae94438927728da5.png"></p><p>运行结果如下：</p><p><img src="https://img-blog.csdnimg.cn/534899ff62e24bcb9909ffaff4b29065.png" alt="https://img-blog.csdnimg.cn/534899ff62e24bcb9909ffaff4b29065.png"></p><p>当然也可以选择进行一组数据，例如将32个点为一组数据进行采集，设置如下：</p><p><img src="https://img-blog.csdnimg.cn/a08aa8f0ae7c4cd8bfd70d40a980b3e1.png" alt="https://img-blog.csdnimg.cn/a08aa8f0ae7c4cd8bfd70d40a980b3e1.png"></p><p>运行结果如下：</p><p><img src="https://img-blog.csdnimg.cn/eb3feca6e37140eeb65f794634e86da3.png" alt="https://img-blog.csdnimg.cn/eb3feca6e37140eeb65f794634e86da3.png"></p><h4 id="5、补充：内部温度传感器ADC通道"><a href="#5、补充：内部温度传感器ADC通道" class="headerlink" title="5、补充：内部温度传感器ADC通道"></a>5、补充：内部温度传感器ADC通道</h4><p><img src="https://img-blog.csdnimg.cn/87fe51b0eb7b447798ade02be31b4329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/87fe51b0eb7b447798ade02be31b4329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70"><br> 上面图片是截取在STM32F103RC的datasheet中的，中文意思就是：温度传感器必须产生随温度线性变化的电压。转换范围在2v &lt; VDDA &lt; 3.6 V之间。温度传感器内部连接ADC1_IN16输入通道，用于将传感器输出电压转换为数字值。</p><p>内部温度计算公式：</p><p>【Temperature &#x3D; {(V25 - VSENSE) &#x2F; Avg_Slope} + 25】</p><p>字段说明：</p><ul><li><strong>V25：</strong> 最小1.34V，最大1.52V，典型值1.43V+ <strong>Avg_Slope：</strong> 最小4.0，最大4.6，典型值4.3mv&#x2F;℃+ <strong>VSENSE：</strong> ADC采集到的电压<br><img src="https://img-blog.csdnimg.cn/da0745b68e874c41b42573887a74e20e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/da0745b68e874c41b42573887a74e20e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTUzNDcxNTAz,size_16,color_FFFFFF,t_70"></li></ul><p>ADC值转电压值计算公式：【电压 &#x3D; ADC采集到的值 * 3.3 &#x2F; 4096】</p><p>看上图我采集到的值为1703，先转换为电压值：1703*3.3&#x2F;4096≈1.37</p><p><strong>（1.43 - 1.37）&#x2F; 0.0043 + 25 ≈ 38.95℃</strong></p><p>ends…</p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32 hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module</title>
      <link href="/2024/03/daily/"/>
      <url>/2024/03/daily/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/C%E8%AF%AD%E8%A8%80-1-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/03/C%E8%AF%AD%E8%A8%80-1-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言基本概念"><a href="#C语言基本概念" class="headerlink" title="C语言基本概念"></a>C语言基本概念</h1><h2 id="1-标识符"><a href="#1-标识符" class="headerlink" title="1.标识符"></a>1.标识符</h2><p>&emsp;&emsp;标识符是我们在编程时使用的名字，比如指定某个东西、人，都要用到它，他或她的名字。在电脑语言中，对于变量，常量，函数，语句块也有名字，统统称为标识符。需要注意的是标识符只能由三种字符组成，<font color="red">字母、数字和下划线</font>且第一个字符必须是字母或下划线。</p><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h2><p>&emsp;&emsp;C语言的关键字共有32个，根据关键字的作用，可分其为数据类型关键字、控制语句关键字、存储类型关键字和其它关键字四类。</p><h3 id="1、数据类型关键字（12个）："><a href="#1、数据类型关键字（12个）：" class="headerlink" title="1、数据类型关键字（12个）："></a>1、数据类型关键字（12个）：</h3><pre><code>(1) char ：声明字符型变量或函数(2) double ：声明双精度变量或函数(3) enum ：声明枚举类型(4) float：声明浮点型变量或函数(5) int： 声明整型变量或函数(6) long ：声明长整型变量或函数(7) short ：声明短整型变量或函数(8) signed：声明有符号类型变量或函数(9) struct：声明结构体变量或函数(10) union：声明联合数据类型(11) unsigned：声明无符号类型变量或函数(12) void ：声明函数无返回值或无参数，声明无类型指针（基本上就这三个作用）</code></pre><p><font color="red">&emsp;&emsp;需要注意的是，C语言没有字符串类型。</font></p><h3 id="2、控制语句关键字（12个）："><a href="#2、控制语句关键字（12个）：" class="headerlink" title="2、控制语句关键字（12个）："></a>2、控制语句关键字（12个）：</h3><p>A、循环语句 ：</p><pre><code>(1) for：一种循环语句(可意会不可言传） (2) do ：循环语句的循环体 (3) while ：循环语句的循环条件 (4) break：跳出当前循环 (5) continue：结束当前循环，开始下一轮循环</code></pre><p>B、条件语句：</p><pre><code>(1)if: 条件语句 (2)else ：条件语句否定分支（与 if 连用） (3)goto：无条件跳转语句</code></pre><p>C、开关语句： </p><pre><code>(1)switch :用于开关语句 (2)case：开关语句分支 (3)default：开关语句中的“其他”分支</code></pre><p>D、程序返回语句：</p><pre><code>return ：子程序返回语句（可以带参数，也看不带参数）</code></pre><h3 id="3、预定义标识符"><a href="#3、预定义标识符" class="headerlink" title="3、预定义标识符"></a>3、预定义标识符</h3><pre><code>(1)auto ：声明自动变量 一般不使用，使用数据类型关键词声明变量，默认即为auto(2)extern：声明变量是在其他文件正声明（也可以看做是引用变量）(3)register：声明积存器变量(4)static ：声明静态变量</code></pre><h3 id="4、-其它关键字（4个）："><a href="#4、-其它关键字（4个）：" class="headerlink" title="4、 其它关键字（4个）："></a>4、 其它关键字（4个）：</h3><pre><code>(1)const ：声明只读变量(2)sizeof：计算数据类型长度(3)typedef：用以给数据类型取别名（当然还有其他作用(4)volatile：说明变量在程序执行中可被隐含地改变。使用此关键字声明变量可以避免变量因为被优化而导致程序出错。</code></pre><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><pre><code>    对不变的值，C语言中用常量概念来表示，可变的值，C语言中使用变量的概念来表示。对C语言编译器来说，常量的一般形式为：1.数字：1, 2, 3, 4...2.字符：&#39;a&#39;, &#39;b&#39;, &#39;c&#39;...3.字符串: &quot;hello&quot;, &quot;world&quot;...4 const修饰的常变量5 #define定义的标识符常量6 枚举常量    前三类可以统称为字面常量。除此之外，C编译器在编译的时候会将除了保留关键字所有的字符串认为是变量。如果变量没有定义却使用了就会报错。</code></pre><h3 id="1-定义一个变量"><a href="#1-定义一个变量" class="headerlink" title="1.定义一个变量"></a>1.定义一个变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">150</span>;#定义一个整形变量</span><br><span class="line"><span class="type">float</span> weight = <span class="number">45.5f</span>;<span class="comment">//这里后面必须加上f,否则编译器会认为是双精度</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;w&#x27;</span>;#定义一个字符型变量</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此外，上文曾经说过变量的命名只能由字母（包括大写和小写）、数字和下划线_组成，且不能以数字开头，长度不能超过63个字符，变量中区分大小写，变量名不能使用关键字。</p><h3 id="2-将变量值打印出来"><a href="#2-将变量值打印出来" class="headerlink" title="2.将变量值打印出来"></a>2.将变量值打印出来</h3><p>&emsp;&emsp;打印变量一般使用printf()函数,举例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of a is %d\r\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of b is %d\r\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你还没有系统的学习过C语言或其他编程语言，那么现在你可能对上面的代码一头雾水，但请不要退缩，在下面我们会详细的解释上述代码。他并没有你想象的那么晦涩难懂。</p><h3 id="3-变量的分类"><a href="#3-变量的分类" class="headerlink" title="3.变量的分类"></a>3.变量的分类</h3><p>&emsp;&emsp;变量分为局部变量与全局变量，当重名的时候，局部变量优先使用（就近原则），但是还请尽量避免出现全局变量与局部变量重名的情况，因为这可能会干扰到我们思考程序逻辑。</p><h3 id="4-变量的作用域和生命周期"><a href="#4-变量的作用域和生命周期" class="headerlink" title="4. 变量的作用域和生命周期"></a>4. 变量的作用域和生命周期</h3><p>&emsp;&emsp;作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效&#x2F;可用的而限定这个名字的可用性的代码范围就是这个名字的作用域。</p><pre><code>1.局部变量的作用域是变量所在的局部范围2.全局变量的作用域是整个工程</code></pre><p>&emsp;&emsp;变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段</p><pre><code>1.局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束2.全局变量的生命周期是：整个程序的生命周期</code></pre><h3 id="5-常量"><a href="#5-常量" class="headerlink" title="5.常量"></a>5.常量</h3><p>&emsp;&emsp;C语言的常量分为以下几种</p><pre><code>• 字面常量• const修饰的常变量• #define定义的标识符常量• 枚举常量</code></pre><h2 id="4-字符串、转义字符与注释"><a href="#4-字符串、转义字符与注释" class="headerlink" title="4. 字符串、转义字符与注释"></a>4. 字符串、转义字符与注释</h2><h3 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h3><p>&emsp;&emsp;由双引号引起来的一串字符成为字符串字面值，或者简称字符串。字符串的结束标志是一个’\0’的转义字符，在计算字符串的长度的时候\0是结束标志，不算作字符串的内容。</p><h3 id="4-2-转义字符："><a href="#4-2-转义字符：" class="headerlink" title="4.2 转义字符："></a>4.2 转义字符：</h3><p>常用的转义字符：</p><table><thead><tr><th>转义字符</th><th>释义</th></tr></thead><tbody><tr><td><code>?</code></td><td>在书写连续多个问号是使用，防止被解析成三字母符</td></tr><tr><td><code>&#39;</code></td><td>用于表示字符常量的单引号</td></tr><tr><td><code>&quot;</code></td><td>用于表示字符串内部的双引号</td></tr><tr><td><code>|</code></td><td>用于表示一个反斜杠，防止解析成一个转义序列符</td></tr><tr><td><code>\a</code></td><td>警告字符，蜂鸣</td></tr><tr><td><code>\b</code></td><td>退格符</td></tr><tr><td><code>\f</code></td><td>进纸符</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\t</code></td><td>水平制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\ddd</code></td><td>ddd表示1-3个8进制的数字</td></tr><tr><td><code>\xdd</code></td><td>dd表示1-2个8进制的数字</td></tr></tbody></table><h3 id="4-3-注释"><a href="#4-3-注释" class="headerlink" title="4.3 注释"></a>4.3 注释</h3><p>注释有两种风格：</p><p>&emsp;&emsp;1.C语言风格的注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我不会被编译器看到</span></span><br><span class="line"><span class="comment">我也不会被编译器看到</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种注释风格有一个缺陷：不能嵌套注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我不会被编译器看到</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我不会被编译器看到</span></span><br><span class="line"><span class="comment">我也不会被编译器看到</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">我会被编译器看到，而且下方横杠也会被编译器看到</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2.C++风格的注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我不会被编译器看到</span></span><br><span class="line">我会被编译器看到</span><br><span class="line"><span class="comment">//我不会被编译器看到</span></span><br><span class="line"><span class="comment">//我不会被编译器看到</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32】HAL库_STM32CubeMX教程十三---RTC时钟</title>
      <link href="/2024/03/%E3%80%90STM32%E3%80%91HAL%E5%BA%93_STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89---RTC%E6%97%B6%E9%92%9F/"/>
      <url>/2024/03/%E3%80%90STM32%E3%80%91HAL%E5%BA%93_STM32CubeMX%E6%95%99%E7%A8%8B%E5%8D%81%E4%B8%89---RTC%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>前言：</p><p>本系列教程将 对应外设原理，HAL库与STM32CubeMX结合在一起讲解，使您可以更快速的学会各个模块的使用</p><p>所用工具：</p><p>1、芯片： STM32F407ZET6&#x2F; STM32F103ZET6</p><p>2、STM32CubeMx软件</p><p>3、IDE： MDK-Keil软件</p><p>4、STM32F1xx&#x2F;STM32F4xxHAL库</p><p>知识概括：</p><p>通过本篇博客您将学到：</p><p>RTC时钟原理</p><p>STM32CubeMX创建RTC例程</p><p>HAL库定时器RTC函数库</p><p><strong>PS: 这里的RTC讲解，我们只将原理，不讲寄存器，如果要看RTC的寄存器，请看这篇文章</strong> <a href="https://blog.csdn.net/as480133937/article/details/105026033">【STM32】RTC实时时钟，步骤超细详解，一文看懂RTC</a></p><h3 id="什么是RTC"><a href="#什么是RTC" class="headerlink" title="什么是RTC"></a>什么是RTC</h3><p>**RTC (Real Time Clock)**：实时时钟</p><p><strong>RTC是个独立的定时器</strong>。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。</p><p><img src="https://img-blog.csdnimg.cn/20200423215123488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200423215123488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。</strong></p><p>RTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。</p><p>两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。</p><p>上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。</p><p>无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。</p><h4 id="RCT特征："><a href="#RCT特征：" class="headerlink" title="RCT特征："></a><strong>RCT特征：</strong></h4><p>● <strong>可编程的预分频系数：分频系数高为220。</strong> ● <strong>32位的可编程计数器，可用于较长时间段的测量。</strong> ● <strong>2个分离的时钟：用于APB1接口的PCLK1和RTC时钟(RTC时钟的频率必须小于PCLK1时钟 频率的四分之一以上)。</strong> ● 可以选择以下<strong>三种RTC的时钟源</strong>：      ● HSE时钟除以128；      ● LSE振荡器时钟；      ● LSI振荡器时钟</p><p>● <strong>2个独立的复位类型：</strong>      ● APB1接口由系统复位；      ● RTC核心(预分频器、闹钟、计数器和分频器)只能由后备域复位</p><p>● <strong>3个专门的可屏蔽中断：</strong>      ● 1.<strong>闹钟中断</strong>，用来产生一个软件可编程的闹钟中断。</p><p>     ● 2.<strong>秒中断</strong>，用来产生一个可编程的周期性中断信号(长可达1秒)。</p><p>     ● 3.<strong>溢出中断</strong>，指示内部可编程计数器溢出并回转为0的状态。</p><p><strong>RTC时钟源：</strong> 三种不同的时钟源可被用来驱动系统时钟(SYSCLK)：</p><p>● <strong>HSI振荡器时钟</strong> ● <strong>HSE振荡器时钟</strong> ● <strong>PLL时钟</strong></p><p>这些设备有以下2种二级时钟源：</p><p>● 40kHz低速内部RC，可以用于驱动独立看门狗和通过程序选择驱动RTC。 RTC用于从停机&#x2F;待机模式下自动唤醒系统。 ● 32.768kHz低速外部晶体也可用来通过程序选择驱动RTC(RTCCLK)。</p><h4 id="RTC原理框图"><a href="#RTC原理框图" class="headerlink" title="RTC原理框图"></a>RTC原理框图</h4><p><img src="https://img-blog.csdnimg.cn/20200322144525734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200322144525734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br> RTC时钟的框图还是比较简单的，这里我们把他分成 <strong><code>两个部分</code></strong>:</p><p><strong>APB1 接口</strong>：用来和 APB1 总线相连。 此单元还包含一组 16 位寄存器，可通过 APB1 总线对其进行读写操作。APB1 接口由 APB1 总 线时钟驱动，用来与 APB1 总线连接。</p><p>通过APB1接口可以访问RTC的相关寄存器（预分频值，计数器值，闹钟值）。</p><p><strong>RTC 核心接口</strong>：由一组可编程计数器组成，分成 <strong><code>两个主要模块</code></strong> 。<br><img src="https://img-blog.csdnimg.cn/20200322223612113.png" alt="https://img-blog.csdnimg.cn/20200322223612113.png"><br>g) <strong>第一个模块是 RTC 的 预分频模块</strong>，它可编程产生 1 秒的 RTC 时间基准 TR_CLK。RTC 的预分频模块包含了一个 20 位的可编程分频器(RTC 预分频器)。如果在 RTC_CR 寄存器中设置了相应的允许位，则在每个 TR_CLK 周期中 RTC 产生一个中断(秒中断)。<br><img src="https://img-blog.csdnimg.cn/2020032222362770.png" alt="https://img-blog.csdnimg.cn/2020032222362770.png"><br> <strong>第二个模块是一个 32 位的可编程计数器 （RTC_CNT）</strong>，可被初始化为当前的系统时间，一个 32 位的时钟计数器，按秒钟计算，可以记 录 4294967296 秒，约合 136 年左右，作为一般应用，这已经是足够了的。</p><h4 id="RTC具体流程："><a href="#RTC具体流程：" class="headerlink" title="RTC具体流程："></a><strong>RTC具体流程：</strong></h4><p><strong>RTCCLK经过RTC_DIV预分频，RTC_PRL设置预分频系数，然后得到TR_CLK时钟信号，我们一般设置其周期为1s，RTC_CNT计数器计数，假如1970设置为时间起点为0s，通过当前时间的秒数计算得到当前的时间。RTC_ALR是设置闹钟时间，RTC_CNT计数到RTC_ALR就会产生计数中断，</strong></p><ul><li><strong>RTC_Second</strong>为秒中断，用于刷新时间，+ <strong>RTC_Overflow</strong>是溢出中断。+ <strong>RTC Alarm</strong> 控制开关机</li></ul><h4 id="RTC时钟选择"><a href="#RTC时钟选择" class="headerlink" title="RTC时钟选择"></a>RTC时钟选择</h4><p><strong>使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响,因此没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE,频率为实时时钟模块中常用的32.768KHz,因为32768 &#x3D; 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</strong></p><h4 id="RTC复位过程"><a href="#RTC复位过程" class="headerlink" title="RTC复位过程"></a>RTC复位过程</h4><p>除了RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器外，所有的系统寄存器都由系统复位或电源复位进行异步复位。 RTC_PRL、RTC_ALR、RTC_CNT和RTC_DIV寄存器仅能通过备份域复位信号复位。</p><p><strong>系统复位后,禁止访问后备寄存器和RCT,防止对后卫区域(BKP)的意外写操作</strong></p><h4 id="RTC中断"><a href="#RTC中断" class="headerlink" title="RTC中断"></a>RTC中断</h4><p><strong>秒中断：</strong> 这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的“秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p><p><strong>闹钟中断：</strong> 闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p><h3 id="CubeMX配置RTC"><a href="#CubeMX配置RTC" class="headerlink" title="CubeMX配置RTC"></a>CubeMX配置RTC</h3><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p><strong>1设置RCC</strong><br><img src="https://img-blog.csdnimg.cn/20200425101549368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425101549368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li><strong>设置高速外部时钟HSE 选择外部时钟源</strong>+ <strong>使能外部晶振LSE</strong></li></ul><p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE</strong></p><p>2.<strong>配置RTC</strong><br><img src="https://img-blog.csdnimg.cn/20200425110730403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425110730403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li><strong>Activate Clock Source 激活时钟源</strong>+ <strong>Activate calendar激活日历</strong></li></ul><p><strong>这两个都要点，作用也很明显，先是使能时钟源，再使能RTC日历</strong></p><ul><li><strong>RTC_OUT： Not RTC_OUT</strong>+ <strong>Tamper：</strong> <strong>×</strong></li></ul><p>第一个是是否使能 <strong>tamper（PC13）引脚上输出校正的秒脉冲时钟，</strong></p><p>第二个： <strong>RTC入侵检测校验功能</strong></p><p><strong>RTC校验功能，使能侵入检测功能。RTC时钟经64分频输出到侵入检测引脚TAMPER上 当 TAMPER引脚上的信号从 0变成1或者从 1变成 0(取决于备份控制寄存器BKP_CR的 TPAL位)，会产生一个侵入检测事件。侵入检测事件将所有数据备份寄存器内容清除。</strong></p><ul><li>也就是第一个是使能tamper（PC13）引脚作为时钟脉冲输出+ 第二个是使能tamper（PC13）引脚作为入侵检测功能</li></ul><p>下面是两个RTC的中断：</p><ul><li><strong>RTC全局中断RTC_IRQHandler()</strong>+ <strong>闹钟中断函数RTCAlarm_IRQHandler()</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/2020042514381771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/2020042514381771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p><strong>此处设置时间为2020&#x2F;04&#x2F;25 13:30:00</strong></p><ul><li>Data Format: 日期格式</li></ul><p><strong>Binary data format 十六进制 BCD data format BCD码进制</strong></p><p>使用自动配置，初始化时间必须使用BCD data format，原因是库函数存在bug，如果使用Binary data format，月份配置会出错，比如说11月，配置时会赋值为RTC_MONTH_NOVEMBER，而此宏定义值为0x11，也就是说其十进制值为17</p><ul><li><strong>Hours： 小时</strong> +  <strong>Minutes： 分钟</strong> +  <strong>Seconds： 秒</strong> +  <strong>Week Day： 星期</strong> +  <strong>Month 月份</strong> +  <strong>Date： 日期</strong> +  <strong>Year： 年份</strong></li></ul><p><strong>3 使能串口</strong><br><img src="https://img-blog.csdnimg.cn/20200425143944495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425143944495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"><br> <strong>使能一下串口，因为发送日期到上位机</strong></p><p><strong>4时钟源设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144337169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425144337169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><p>我的是 外部晶振为8MHz</p><ul><li>1选择外部时钟HSE 8MHz+ 2PLL锁相环倍频9倍+ 3系统时钟来源选择为PLL+ 4设置APB1分频器为 &#x2F;2+ 5 使能CSS监视时钟+ <strong>6 设置RTC时钟为LSE</strong></li></ul><p>32的时钟树框图 如果不懂的话请看<a href="https://blog.csdn.net/as480133937/article/details/98845509">《【STM32】系统时钟RCC详解(超详细，超全面)》</a></p><p><strong>5项目文件设置</strong><br><img src="https://img-blog.csdnimg.cn/20200425144600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425144600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><ul><li>1 设置项目名称+ 2 设置存储路径+ 3 选择所用IDE<br><img src="https://img-blog.csdnimg.cn/2020042514462236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/2020042514462236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></li></ul><p><strong>6创建工程文件</strong></p><p><strong>然后点击GENERATE CODE 创建工程</strong></p><p><strong>配置下载工具</strong> 新建的工程所有配置都是默认的 我们需要自行选择下载模式，勾选上下载后复位运行</p><p><img src="https://img-blog.csdnimg.cn/202004251446415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/202004251446415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC-HAL库函数"><a href="#RTC-HAL库函数" class="headerlink" title="RTC_HAL库函数"></a>RTC_HAL库函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置系统时间*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span> </span><br><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*设置系统日期*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*启动报警功能*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*设置报警中断*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_SetAlarm_IT</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</span></span><br><span class="line"><span class="comment">/*报警时间回调函数*/</span></span><br><span class="line">__weak <span class="keyword">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"><span class="comment">/*写入后备储存器*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)</span></span><br><span class="line"><span class="comment">/*读取后备储存器*/</span></span><br><span class="line">uint32_t <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister  </span></span><br></pre></td></tr></table></figure><p>我们可以看到前面的四个函数，分别是</p><ul><li><strong>设置系统时间：HAL_RTC_SetTime();</strong>+ <strong>读取系统时间: HAL_RTC_GetTime();</strong>+ <strong>设置系统日期: HAL_RTC_SetDate();</strong>+ <strong>读取系统日期: HAL_RTC_GetDate();</strong></li></ul><p>因为系统的时间和日期开始的时候已经设置过了，所以我们这里只用两个读取函数</p><p> <strong>读取系统时间函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetTime</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的时间</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2 +  <strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体， +  Format： <strong>获取时间的格式</strong> <strong>RTC_FORMAT_BIN 使用16进制 RTC_FORMAT_BCD 使用BCD进制</strong></li></ul><p> <strong>读取系统日期函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_RTC_GetDate</span><span class="params">(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</span></span><br></pre></td></tr></table></figure><p>功能： 获取RTC时钟的日期</p><p>参数：</p><ul><li>*hrtc RTC结构体参数 例：&amp;hi2c2 +  <strong>RTC_DateTypeDef</strong> *sTime： 获取RTC日期的结构体， +  Format： <strong>获取日期的格式</strong> <strong>RTC_FORMAT_BIN 使用16进制 RTC_FORMAT_BCD 使用BCD进制</strong></li></ul><p>在stm32f1xx_hal_rtc.h头文件中，可以找到<code>RTC_TimeTypeDef</code>，<code>RTC_DateTypeDef</code>这两个结构体的成员变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @brief  RTC Time structure definition</span><br><span class="line">  */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t Hours;            /*!&lt; Specifies the RTC Time Hour.</span><br><span class="line">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 */</span><br><span class="line"></span><br><span class="line">  uint8_t Minutes;          /*!&lt; Specifies the RTC Time Minutes.</span><br><span class="line">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span><br><span class="line"></span><br><span class="line">  uint8_t Seconds;          /*!&lt; Specifies the RTC Time Seconds.</span><br><span class="line">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @brief  RTC Date structure definition</span><br><span class="line">  */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  uint8_t WeekDay;  /*!&lt; Specifies the RTC Date WeekDay (not necessary for HAL_RTC_SetDate).</span><br><span class="line">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span><br><span class="line"></span><br><span class="line">  uint8_t Month;    /*!&lt; Specifies the RTC Date Month (in BCD format).</span><br><span class="line">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span><br><span class="line"></span><br><span class="line">  uint8_t Date;     /*!&lt; Specifies the RTC Date.</span><br><span class="line">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span><br><span class="line"></span><br><span class="line">  uint8_t Year;     /*!&lt; Specifies the RTC Date Year.</span><br><span class="line">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br></pre></td></tr></table></figure><p><strong>程序代码：</strong></p><p>main.c</p><p><strong>在main.c中重写fputc函数，使得能够使用printf函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fputc(int ch,FILE *f)&#123;</span><br><span class="line"> uint8_t temp[1]=&#123;ch&#125;;</span><br><span class="line"> HAL_UART_Transmit(&amp;huart1,temp,1,2);</span><br><span class="line"> return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义两个结构体来获取日期和时间：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTC_DateTypeDef GetData;  //获取日期结构体</span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef GetTime;   //获取时间结构体</span><br></pre></td></tr></table></figure><p>在while循环中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Get the RTC current Time */</span><br><span class="line">HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line">   /* Get the RTC current Date */</span><br><span class="line">   HAL_RTC_GetDate(&amp;hrtc, &amp;GetData, RTC_FORMAT_BIN);</span><br><span class="line"></span><br><span class="line">   /* Display date Format : yy/mm/dd */</span><br><span class="line">   printf(&quot;%02d/%02d/%02d\r\n&quot;,2000 + GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line">   /* Display time Format : hh:mm:ss */</span><br><span class="line">   printf(&quot;%02d:%02d:%02d\r\n&quot;,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">   printf(&quot;\r\n&quot;);</span><br><span class="line"></span><br><span class="line">   HAL_Delay(1000);</span><br></pre></td></tr></table></figure><p><strong>程序中使用HAL_RTC_GetTime（）,HAL_RTC_GetDate()读取时间和日期，并保存到结构体变量中，然后通过串口输出读取的时间和日期。</strong></p><p><strong>例程测试正常：</strong><br><img src="https://img-blog.csdnimg.cn/20200425153330941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="https://img-blog.csdnimg.cn/20200425153330941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70"></p><h4 id="RTC掉电重置"><a href="#RTC掉电重置" class="headerlink" title="RTC掉电重置"></a>RTC掉电重置</h4><p>但是呢，在hal库中生成的代码，<strong>每次断电就RTC时间会重置</strong>，每次上电都会重新初始化时间</p><p>因为HAL库设置了一个BKP寄存器保存一个标志。每次单片机启动时都读取这个标志并判断是不是预先设定的值：如度果不是就初始化RTC并设置时间，再设置标志为预期值；如果是预期值就跳过初始化和时间设置，继续执行后面的程序</p><p><strong>所以这里我们只需要每次上电执行RTC初始化之前，将标志设置为预期值即可</strong></p><p><strong>在rtc.c中的RTC_Init修改为以下内容即可</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> void MX_RTC_Init(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN RTC_Init 0 */</span><br><span class="line">RTC_TimeTypeDef time;   //时间结构体参数</span><br><span class="line">RTC_DateTypeDef datebuff;   //日期结构体参数</span><br><span class="line">  /* USER CODE END RTC_Init 0 */</span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;0&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN RTC_Init 1 */</span><br><span class="line">__HAL_RCC_BKP_CLK_ENABLE();       //开启后备区域时钟</span><br><span class="line">__HAL_RCC_PWR_CLK_ENABLE();  //开启电源时钟</span><br><span class="line">  /* USER CODE END RTC_Init 1 */</span><br><span class="line">  /**Initialize RTC Only </span><br><span class="line">  */</span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  if (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN Check_RTC_BKUP */</span><br><span class="line">if(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= 0x5051)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  /* USER CODE END Check_RTC_BKUP */</span><br><span class="line"></span><br><span class="line">  /**Initialize RTC and set the Time and Date </span><br><span class="line">  */</span><br><span class="line">  sTime.Hours = 0x14;</span><br><span class="line">  sTime.Minutes = 0x30;</span><br><span class="line">  sTime.Seconds = 0x0;</span><br><span class="line"></span><br><span class="line">  if (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  DateToUpdate.WeekDay = RTC_WEEKDAY_SATURDAY;</span><br><span class="line">  DateToUpdate.Month = RTC_MONTH_APRIL;</span><br><span class="line">  DateToUpdate.Date = 0x25;</span><br><span class="line">  DateToUpdate.Year = 0x20;</span><br><span class="line"></span><br><span class="line">  if (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE BEGIN RTC_Init 2 */</span><br><span class="line"></span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); //开启RTC时钟秒中断</span><br><span class="line">datebuff = DateToUpdate;  //把日期数据拷贝到自己定义的data中</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, 0x5051);//向指定的后备区域寄存器写入数据</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR2, (uint16_t)datebuff.Year);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR3, (uint16_t)datebuff.Month);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR4, (uint16_t)datebuff.Date);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR5, (uint16_t)datebuff.WeekDay);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">datebuff.Year    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR2);</span><br><span class="line">datebuff.Month   = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR3);</span><br><span class="line">datebuff.Date    = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR4);</span><br><span class="line">datebuff.WeekDay = HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR5);</span><br><span class="line">DateToUpdate = datebuff;</span><br><span class="line">if (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BIN) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">Error_Handler();</span><br><span class="line">&#125;</span><br><span class="line">__HAL_RTC_SECOND_ENABLE_IT(&amp;hrtc,RTC_IT_SEC); //开启RTC时钟秒中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425165901167.gif" alt="https://img-blog.csdnimg.cn/20200425165901167.gif"></p><p><img src="https://img-blog.csdnimg.cn/20200425165904365.gif" alt="https://img-blog.csdnimg.cn/20200425165904365.gif"></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32 hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 HAL GPIO详细篇</title>
      <link href="/2024/03/stm32-STM32HAL%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94GPIO/"/>
      <url>/2024/03/stm32-STM32HAL%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94GPIO/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><p>GPIO全名为General Purpose Input Output，即通用输入输出。有时候简称为“IO口”。通用，说明它是常见的。输入输出，就是说既能当输入口使用，又能当输出口使用。端口，就是元器件上的一个引脚。</p><p>输入模式和输出模式是GPIO的基本特性，当然GPIO还有其它模式可选。</p><p><img src="https://img-blog.csdnimg.cn/4b4a4a4a754c42a686395c54851dac7f.png" alt="./figures/4b4a4a4a754c42a686395c54851dac7f.png"></p><h3 id="IO耐压问题"><a href="#IO耐压问题" class="headerlink" title="IO耐压问题"></a>IO耐压问题</h3><p>STM32是一款3.3V电压的芯片，IO输出是3.3V,但IO大部分都是可以容忍5V电压输入。一般在芯片手册的“引脚定义”章节可以查看到有FT标识表示该IO可以容忍5V电压输入。</p><p><img src="https://img-blog.csdnimg.cn/417fa39b882b42de99526837d5af45b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP56W655qE5a6d5a6d,size_20,color_FFFFFF,t_70,g_se,x_16" alt="./figures/417fa39b882b42de99526837d5af45b2.png"></p><h2 id="二、在HAL库中的GPIO的模式"><a href="#二、在HAL库中的GPIO的模式" class="headerlink" title="二、在HAL库中的GPIO的模式"></a>二、在HAL库中的GPIO的模式</h2><h2 id="１、输入模式GPIO＿Input"><a href="#１、输入模式GPIO＿Input" class="headerlink" title="１、输入模式GPIO＿Input"></a>１、输入模式GPIO＿Input</h2><h4 id="上拉或下拉输入（GPIO-Pull-up／Pull-down）："><a href="#上拉或下拉输入（GPIO-Pull-up／Pull-down）：" class="headerlink" title="上拉或下拉输入（GPIO　Pull-up／Pull-down）："></a>上拉或下拉输入（GPIO　Pull-up／Pull-down）：</h4><p>        ｜浮空输入（No　pull－up　and　no　pull－down）：引脚电平是真实的外部连接器件电压，电平有不确定性</p><p>        ｜上拉输入（Pull－up）：默认通过电阻上拉到VCC,不接外部器件时可以读出高电平</p><p>        ｜下拉输入（Pull-down）：默认通过电阻下拉到GND,不接外部器件时可以读出低电平</p><h3 id="２、输出模式GPIO-Out"><a href="#２、输出模式GPIO-Out" class="headerlink" title="２、输出模式GPIO_Out"></a>２、输出模式GPIO_Out</h3><h4 id="默认输出电平（GPIO-output-level）："><a href="#默认输出电平（GPIO-output-level）：" class="headerlink" title="默认输出电平（GPIO　output　level）："></a>默认输出电平（GPIO　output　level）：</h4><p>        ｜低电平（Low）：默认输出低电平</p><p>        ｜高电平（High）：默认输出高电平</p><h4 id="输出类型（GPIO-Mode）："><a href="#输出类型（GPIO-Mode）：" class="headerlink" title="输出类型（GPIO　Mode）："></a>输出类型（GPIO　Mode）：</h4><p>        ｜推挽输出（Output　Push　Pull）：一种使用一对选择性地从相连负载灌电流或者拉电流的器件的电路。</p><p>        ｜开漏输出（Output　Open　Drain）：高电平时没有驱动能力，需要借助外部上拉电阻完成对外驱动。</p><h4 id="上拉或下拉输出（GPIO-Pull-up／Pull-down）："><a href="#上拉或下拉输出（GPIO-Pull-up／Pull-down）：" class="headerlink" title="上拉或下拉输出（GPIO　Pull-up／Pull-down）："></a>上拉或下拉输出（GPIO　Pull-up／Pull-down）：</h4><p>        ｜浮空输出（No　pull－up　and　no　pull－down）：引脚电平是真实的外部连接器件电压，电平有不确定性</p><p>        ｜上拉输出（Pull－up）：默认通过电阻上拉到VCC,不接外部器件时可以输出高电平</p><p>        ｜下拉输出（Pull-down）：默认通过电阻下拉到GND,不接外部器件时可以输出低电平 </p><h4 id="输出频率（Maximum-output-speed）："><a href="#输出频率（Maximum-output-speed）：" class="headerlink" title="输出频率（Maximum　output　speed）："></a>输出频率（Maximum　output　speed）：</h4><p>        ｜低频率输出（LOW）</p><p>        ｜中频率输出（Medium）</p><p>        ｜高频率输出（High）</p><p>        ｜极高频率输出（Very　High）</p><h2 id="三、在CubeMX中修改引脚名称"><a href="#三、在CubeMX中修改引脚名称" class="headerlink" title="三、在CubeMX中修改引脚名称"></a>三、在CubeMX中修改引脚名称</h2><p>        1.在左侧找到System Core-&gt;GPIO；</p><p>        2.找到应对的GPIO，例如PH10；</p><p>        3.在下方的配置单中User Label 填写命名，填好后会在芯片缩略图中更新</p><p>        4.点击 GENERATE CODE 生成代码</p><h2 id="四、常用引脚输入函数"><a href="#四、常用引脚输入函数" class="headerlink" title="四、常用引脚输入函数"></a>四、常用引脚输入函数</h2><p>        函数名：HAL_GPIO_ReadPin(参数1,参数2)</p><p>        函数作用：读取对应的引脚电平</p><p>        返回值：若读取到高电平，则返回GPIO_PIN_SET；反之，读取到低电平，则返回GPIO_PIN_RESET      </p><p>        参数1：GPIOx      对应GPIO总线，其中x可以是A…I，例如PH10，则输入GPIOH</p><p>        参数2：GPIO_Pin   对应引脚数，可以是1…15，例如PH10，则输入GPIO_PIN_10</p><h2 id="五、常用引脚输出函数"><a href="#五、常用引脚输出函数" class="headerlink" title="五、常用引脚输出函数"></a>五、常用引脚输出函数</h2><p>        函数名：HAL_GPIO_WritePin(参数1,参数2,参数3)</p><p>        函数作用：使对应的引脚输出高电平或者低电平</p><p>        返回值：viod</p><p>        参数1：GPIOx      对应GPIO总线，其中x可以是A…I，例如PH10，则输入GPIOH</p><p>        参数2：GPIO_Pin   对应引脚数，可以是1…15，例如PH10，则输入GPIO_PIN_10</p><p>        参数3：PinState    GPIO_PIN_RESET，输出低电平；GPIO_PIN_SET，输出高电平</p><p>（若修改对应引脚的名字，例如PH10修改为LED，则输入 HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,参数3)）</p><h2 id="六、其他常用函数"><a href="#六、其他常用函数" class="headerlink" title="六、其他常用函数"></a>六、其他常用函数</h2><p>        函数名：HAL_GPIO_ToglePin(参数1,参数2)</p><p>        函数作用：翻转对应引脚的电平</p><p>        返回值：viod</p><p>        参数1：GPIOx      对应GPIO总线，其中x可以是A…I，例如PH10，则输入GPIOH</p><p>        参数2：GPIO_Pin   对应引脚数，可以是1…15，例如PH10，则输入GPIO_PIN_10</p><p>        </p><p>        函数名：HAL_Delay(参数1)</p><p>        函数作用：延时</p><p>        返回值：void</p><p>        参数1：常数，单位ms</p><p>参考文章：<a href="https://www.cnblogs.com/dongxiaodong/p/14128088.html">STM32 GPIO详细篇（基于HAL库）</a></p>]]></content>
      
      
      <categories>
          
          <category> stm32 </category>
          
          <category> stm32 hal库开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用教程</title>
      <link href="/2024/03/usageOfHexo/"/>
      <url>/2024/03/usageOfHexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo使用教程"><a href="#hexo使用教程" class="headerlink" title="hexo使用教程"></a>hexo使用教程</h1><h2 id="1-发布文章"><a href="#1-发布文章" class="headerlink" title="1. 发布文章"></a>1. 发布文章</h2><p>1.新建文章<br>&emsp;&emsp;使用如下命令来新建文章：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] \&lt;title\&gt; </span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;其中layout是文章的布局，默认为post，可以先不写。title 是文章的标题，也是文件的名字，存储在source&#x2F;_posts下。在编写文章的shi’hshih ，有时候会遇见无法缩进的问题，可以使用如下字符进行缩进：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不换行空格: \&amp;nbsp;或\&amp;#160;</span><br><span class="line">半角空格: \&amp;ensp;或\&amp;#8194;</span><br><span class="line">全角空格: \&amp;emsp;或\&amp;#8195;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;写好文章后，输入如下命令进行发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2024/03/linux-common-cmd/"/>
      <url>/2024/03/linux-common-cmd/</url>
      
        <content type="html"><![CDATA[<h1 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h1><h2 id="1-tmux"><a href="#1-tmux" class="headerlink" title="1. tmux"></a>1. tmux</h2><p>1.暂时退出窗口</p><blockquote><p>ctrl + b , d</p></blockquote><p>2.查看tmux历史log</p><blockquote><p>ctrl + b , [<br>此命令会进入到复制模式，可以查看tmux当前窗口的历史log，使用q键可以退出此模式</p></blockquote><p>3.查看当前开了哪些tmux窗口</p><blockquote><p>tmux list-windows</p></blockquote><p>4.重命名当前窗口的名字：</p><blockquote><p>Ctrl + b, ,<br>确保当前处于要重命名的窗口中。按下快捷键 Ctrl + b, , (逗号键)。这会使当前窗口的名称进入编辑状态。</p></blockquote><p>5.切换到别的窗口：</p><blockquote><p>tmux switch-client -t 2:0<br>其中2为作业号，0为窗口号<br>tmux attach-session -t 10<br>此处10为作业号</p></blockquote><h2 id="2-ip命令"><a href="#2-ip命令" class="headerlink" title="2. ip命令"></a>2. ip命令</h2><h2 id="2-1-网络接口管理"><a href="#2-1-网络接口管理" class="headerlink" title="2.1 网络接口管理"></a>2.1 网络接口管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show <span class="comment">#显示所有网络接口信息</span></span><br><span class="line">ip <span class="built_in">link</span> show dev eth0 <span class="comment">#显示指定网络接口信息</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 up <span class="comment"># 启用指定网络接口</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 down <span class="comment"># 禁用指定网络接口</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 address 00:11:22:33:44:55 <span class="comment">#设置指定网络接口的mac地址</span></span><br><span class="line">ip addr add 192.168.1.2/24 dev eth0 <span class="comment">#配置ip地址</span></span><br><span class="line">ip addr del 192.168.1.2/24 dev eth0 <span class="comment">#删除ip地址</span></span><br></pre></td></tr></table></figure><h2 id="2-2-路由管理"><a href="#2-2-路由管理" class="headerlink" title="2.2 路由管理"></a>2.2 路由管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route show <span class="comment">#显示路由表</span></span><br><span class="line">ip route add 192.168.2.0/24 via 192.168.1.1 dev eth0 <span class="comment">#添加静态路由</span></span><br><span class="line">ip route del 192.168.2.0/24 <span class="comment">#删除路由</span></span><br></pre></td></tr></table></figure><h2 id="2-3-arp管理"><a href="#2-3-arp管理" class="headerlink" title="2.3 arp管理"></a>2.3 arp管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip neigh show<span class="comment">#显示arp缓存</span></span><br><span class="line">ip neigh add 192.168.1.1 lladdr 00:11:22:33:44:55 dev eth0 <span class="comment">#添加静态arp</span></span><br><span class="line">ip neigh del 192.168.1.1 dev eth0<span class="comment">#删除arp条目</span></span><br></pre></td></tr></table></figure><h2 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1 <span class="comment">#启用ip转发</span></span><br><span class="line">ip neigh show <span class="comment">#显示邻居缓存</span></span><br><span class="line">ip -s <span class="built_in">link</span> i希纳是统计信息</span><br></pre></td></tr></table></figure><h2 id="3-brctl"><a href="#3-brctl" class="headerlink" title="3. brctl"></a>3. brctl</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brctl show <span class="comment"># 显示网络桥接信息</span></span><br><span class="line">brctl addbr mybridge <span class="comment"># 创建一个新的网络桥接</span></span><br><span class="line">brctl addif mybridge eth0 <span class="comment"># 将网络接口添加到桥接</span></span><br><span class="line">brctl delif mybridge eth0 <span class="comment"># 从桥接中移除网络接口</span></span><br><span class="line">brctl delbr mybridge<span class="comment"># 删除网络桥接</span></span><br></pre></td></tr></table></figure><h2 id="4-du"><a href="#4-du" class="headerlink" title="4. du"></a>4. du</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh <span class="comment">#查看当前目录的使用情况</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1<span class="comment">#逐级显示子目录的磁盘使用情况</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1 * <span class="comment">#显示每个文件和目录的磁盘使用情况</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1 | <span class="built_in">sort</span> -h <span class="comment">#按大小排序显示文件和目录</span></span><br></pre></td></tr></table></figure><h2 id="5-sort排序命令"><a href="#5-sort排序命令" class="headerlink" title="5. sort排序命令"></a>5. sort排序命令</h2><p>5.1 经典用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> filename <span class="comment">#对文件的每一行信息按照字典顺序排序，并输出到当前目录</span></span><br><span class="line"><span class="built_in">sort</span> -n filename <span class="comment">#对文件的每一行信息按照数字顺序排序，并输出到当前目录</span></span><br><span class="line"><span class="built_in">sort</span> -r filename <span class="comment">#对文件的每一行信息按照字典倒序排序，并输出到当前目录</span></span><br><span class="line"><span class="built_in">sort</span> -u filename <span class="comment">#对文件的每一行信息按照字典顺序并且去重排序，并输出到当前目录</span></span><br><span class="line"><span class="built_in">sort</span> -k&lt;列数&gt; filename <span class="comment">#按列排序</span></span><br><span class="line"><span class="built_in">sort</span> -n -k&lt;列数&gt; filename <span class="comment">#按数字字段排序</span></span><br><span class="line"><span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k2 filename <span class="comment">#自定义分隔符使用 -t 选项指定字段分隔符，例如 :，然后使用 -k 选项按照指定列排序</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;b\na\nc&quot;</span> | <span class="built_in">sort</span> <span class="comment">#从标准输入读取数据并排序</span></span><br></pre></td></tr></table></figure><h2 id="6-i2ctools"><a href="#6-i2ctools" class="headerlink" title="6. i2ctools"></a>6. i2ctools</h2><p>6.1 i2cset命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cset -f -y 0x1 0x48 0x03 0x0020 w</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中,-y 指定了i2c控制器为i2c1，0x48为i2c设备的地址，0x03为寄存器偏移量，他表示了寄存器地址，0x0020为要写入的数据。w表示以字（16 位）为单位读写，还可以选择其他读写单位：b，以字节（8 位）为单位读取；c， 以字符（ASCII）为单位读取。</p><p>6.2 i2cget命令</p><p>&emsp;&emsp;use example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cget -y 1 0x48 0x03 w <span class="comment">#以字为单位，读取i2c地址为0x48，寄存器0x03的数据</span></span><br></pre></td></tr></table></figure><h2 id="7-dd"><a href="#7-dd" class="headerlink" title="7.dd"></a>7.dd</h2><p>&emsp;&emsp;命令基本形式：</p><pre><code>    dd if=input_file of=output_file bs=block_size options</code></pre><p>examples:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/mmcblk0gp0 bs=512 count=1024 seek=3072</span><br><span class="line"><span class="comment"># 指定块大小为512，复制块数为1024，跳过输出文件的前3072块。（也就是从输出文件的第3072*512处开始，将输入文件的数据复制进去）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/mmcblk0gp0 bs=512 count=1024 skip=3072</span><br><span class="line"><span class="comment"># 指定块大小为512，复制块数为1024，跳过输入文件的前3072块。（也就是从输入文件的第3072*512处开始，将往后的512*1024块数据复制进输出文件。（从输出文件的0x00地址开始））</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;dd命令还有一些其他的可选命令选项，具体为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• bs=1024：设置块大小为1024字节，即1KB。这是<span class="built_in">dd</span>每次读取和写入的数据块大小。</span><br><span class="line">• count：指定要复制的块数或数据块的数量。</span><br><span class="line">• skip 在复制之前跳过输入文件的块数或字节数。用于设置输入文件的起始位置，即在输入文件中跳过一定数量的块</span><br><span class="line">• seek：在写入之前跳过输出文件的块数或字节数。用于设置输出文件的起始位置，即在输出文件中跳过一定数量的块</span><br><span class="line">• iflag：设置输入选项，例如iflag=direct表示直接访问输入文件而不进行缓存。</span><br><span class="line">• oflag：设置输出选项，例如oflag=direct表示直接写入输出文件而不进行缓存。</span><br><span class="line">• status=progress：显示复制进度信息</span><br></pre></td></tr></table></figure><h2 id="8-stty命令"><a href="#8-stty命令" class="headerlink" title="8.stty命令"></a>8.stty命令</h2><p>&emsp;&emsp;stty命令可以修改终端驱动程序里的设置，可以用来显示和修改终端命令。下面是它的常见用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stty</span> size;<span class="comment">#显示终端的大小，也就是行数和列数，加上-a可以显示的更加详细。</span></span><br><span class="line"><span class="comment">#此外，有的时候在终端误按ctrl+s导致终端僵死，此时按下ctrl+q便可以使终端回复；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> -F /dev/tty0 115200; <span class="comment">#设置串口波特率为115200</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> -a -F /dev/tty2; <span class="comment">#检查当前串口2的设置</span></span><br></pre></td></tr></table></figure><h2 id="9-使用命令行进行简单的串口通信"><a href="#9-使用命令行进行简单的串口通信" class="headerlink" title="9.使用命令行进行简单的串口通信"></a>9.使用命令行进行简单的串口通信</h2><ol><li>首先使用stty设置串口波特率<blockquote><p>stty -F &#x2F;dev&#x2F;ttyAMA1 115200</p></blockquote></li><li>使用echo向串口发送信息<blockquote><p>echo “Hello world” &gt; &#x2F;dev&#x2F;ttyAMA1 </p></blockquote></li><li>使用cat打印当前串口返回的信息<blockquote><p>cat &#x2F;dev&#x2F;ttyAMA1</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HTTPS</title>
      <link href="/2022/11/hexo-Hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0-Coding-Pages-%E5%92%8C-GitHub-Pages-%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99-HTTPS/"/>
      <url>/2022/11/hexo-Hexo-%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E5%88%B0-Coding-Pages-%E5%92%8C-GitHub-Pages-%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%85%A8%E7%AB%99-HTTPS/</url>
      
        <content type="html"><![CDATA[<p><strong>2022-01-25 更新：博客新地址：<a href="https://www.itbob.cn/">https://www.itbob.cn/</a> ，文章距上次编辑时间较远，部分内容可能已经过时！</strong></p><p>我的博客地址：<a href="https://www.itrhx.com/">https://www.itrhx.com/</a></p><p>部署到 Coding Pages 的好处：国内访问速度更快，可以提交百度收录（GitHub 禁止了百度的爬取）</p><p>部署到 Coding Pages 的坏处：就今年来说，Coding 不太稳定，随时有宕机的可能，群里的朋友已经经历过几次了，不过相信以后会越来越稳定的</p><p>部署过程中常见的问题：无法实现全站 HTTPS，Coding 申请 SSL 证书失败，浏览器可能会提示不是安全链接</p><p>本文前提：你已经将 Hexo 成功部署到了 GitHub Pages，如果还没有，请参考：<a href="https://blog.csdn.net/qq_36759224/article/details/82121420">《使用Github Pages和Hexo搭建自己的独立博客【超级详细的小白教程】》</a></p><p>本文将全面讲述如何成功双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HPPTS，同时解决一些常见的问题！</p><h2 id="Coding-已更新，新版页面在创建项目的时候选择-【DevOps-项目】，其他步骤一样，然后进去项目里面，在左侧依次选择【持续部署】、【静态网站】，就可以开启-pages-服务了！"><a href="#Coding-已更新，新版页面在创建项目的时候选择-【DevOps-项目】，其他步骤一样，然后进去项目里面，在左侧依次选择【持续部署】、【静态网站】，就可以开启-pages-服务了！" class="headerlink" title="Coding 已更新，新版页面在创建项目的时候选择 【DevOps 项目】，其他步骤一样，然后进去项目里面，在左侧依次选择【持续部署】、【静态网站】，就可以开启 pages 服务了！"></a>Coding 已更新，新版页面在创建项目的时候选择 【DevOps 项目】，其他步骤一样，然后进去项目里面，在左侧依次选择【持续部署】、【静态网站】，就可以开启 pages 服务了！</h2><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>进入 <a href="https://coding.net/">Coding 官网</a>，点击个人版登陆，没有账号就注册一个并登录，由于 Coding 已经被腾讯收购了，所以登录就会来到腾讯云开发者平台，点击创建项目<br><img src="https://img-blog.csdnimg.cn/20190916103158338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"><br>项目名称建议和你的用户名一致，这样做的好处是：到时候可以直接通过 <code>user_name.coding.me</code> 访问你的博客，如果项目名与用户名不一致，则需要通过 <code>user_name.coding.me/project_name</code> 才能访问，项目描述可以随便写<br><img src="https://img-blog.csdnimg.cn/20190916103926753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"></p><h2 id="2-配置公钥"><a href="#2-配置公钥" class="headerlink" title=";  2.配置公钥"></a><a name="font_colorff00002font_30">;</a>  2.配置公钥</h2><p>配置 SSH 公钥方法与 GitHub Pages 的方式差不多，点击你的头像，依次选择【个人设置】-【SSH公钥】-【新增公钥】<img src="https://img-blog.csdnimg.cn/20190916105353837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"></p><p>前面部署到 GitHub Pages 的时候就已经有了一对公钥，我们直接将该公钥粘贴进去就行，公钥名称可以随便写，选中永久有效选项</p><p>PS：公钥储存位置一般在 C:\Users\用户名.ssh 目录下的 id_rsa.pub 文件里，用记事本打开复制其内容即可</p><p><img src="https://img-blog.csdnimg.cn/20190916110214603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"><br>添加公钥后，我们可以右键 <code>Get Bash</code>，输入以下命令来检查是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure><p>若出现以下提示，则证明配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Coding 提示: Hello XXX, You<span class="string">&#x27;ve connected to Coding.net via SSH. This is a personal key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">XXX，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</span></span><br></pre></td></tr></table></figure><h2 id="3-配置-config-yml"><a href="#3-配置-config-yml" class="headerlink" title="3.配置 _config.yml"></a>3.配置 _config.yml</h2><p>进入你的项目，在右下角有选择连接方式，选择 SSH 方式（HTTPS 方式也可以，但是这种方式有时候可能连接不上，SSH 连接不容易出问题），一键复制，然后打开你本地博客根目录的 <code>_config.yml</code> 文件，找到 <code>deploy</code> 关键字，添加 coding 地址： <code>coding: git@git.dev.tencent.com:user_name/user_name.git </code>，也就是刚刚复制的 SSH 地址。</p><p><strong>【2020.04.06 更新】coding 地址格式现在有所改变，类似于 <code>git@e.coding.net:TRHX/TRHX.git</code> ，记住去仓库复制你自己的即可。</strong><br><img src="https://img-blog.csdnimg.cn/20190916111108720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20190916120353840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"></p><p>添加完成后先执行命令 <code>hexo clean</code> 清理一下缓存，然后执行命令 <code>hexo g -d</code> 将博客双线部署到 Coding Pages 和 GitHub Pages，如下图所示表示部署成功：<br><img src="https://img-blog.csdnimg.cn/20190916144513473.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"></p><h2 id="4-开启-Coding-Pages"><a href="#4-开启-Coding-Pages" class="headerlink" title=";  4.开启 Coding Pages"></a><a name="font_colorff00004_coding_pagesfont_63">;</a>  4.开启 Coding Pages</h2><p>进入你的项目，在代码栏下选择 Pages 服务，一键开启 Coding Pages，等待几秒后刷新网页即可看到已经开启的 Coding Pages，到目前为止，你就可以通过 xxxx.coding.me（比如我的是 trhx.coding.me）访问你的 Coding Pages 页面了</p><p><strong>【2020.04.06 更新】coding 分配的域名现在有所改变，类似于 <code>https://p51l67.coding-pages.com</code></strong></p><p><img src="https://img-blog.csdnimg.cn/20190916110721794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20190916124340990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"></p><h2 id="5-绑定域名并开启-HPPTS"><a href="#5-绑定域名并开启-HPPTS" class="headerlink" title="5.绑定域名并开启 HPPTS"></a>5.绑定域名并开启 HPPTS</h2><p>首先在你的域名 DNS 设置中添加一条 <code>CNAME</code> 记录指向 <code>xxxx.coding.me</code>，解析路线选择 <code>&amp;#x9ED8;&amp;#x8BA4;</code>，将 GitHub 的解析路线改为 <code>&amp;#x5883;&amp;#x5916;</code>，这样境外访问就会走 GitHub，境内就会走 Coding，也有人说阿里云是智能解析，自动分配路线，如果解析路线都是默认，境外访问同样会智能选择走 GitHub，境内走 Coding，我没有验证过，有兴趣的可以自己试试，我的解析如下图所示：</p><p><strong>【2020.04.06 更新】coding 分配的域名现在有所改变，类似于 <code>https://p51l67.coding-pages.com</code> ，请注意解析当中记录值的填写。</strong></p><p><img src="https://img-blog.csdnimg.cn/20190916132146484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"><br>然后点击静态 Pages 应用右上角的设置，进入设置页面，这里要注意，如果你之前已经部署到了 GitHub Pages 并开启了 HTTPS，那么直接在设置页面绑定你自己的域名，SSL&#x2F;TLS 安全证书就会显示申请错误，如下图所示，没有申请到 SSL 证书，当你访问你的网站时，浏览器就会提示不是安全连接<br><img src="https://img-blog.csdnimg.cn/20190916125313300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"><br>申请错误原因是：在验证域名所有权时会定位到 Github Pages 的主机上导致 SSL 证书申请失败</p><p>正确的做法是：先去域名 DNS 把 GitHub 的解析暂停掉，然后再重新申请 SSL 证书，大约十秒左右就能申请成功，然后开启强制 HTTPS 访问</p><p>这里也建议同时绑定有 www 前缀和没有 www 前缀的，如果要绑定没有 www 前缀的，首先要去域名 DNS 添加一个 <code>A</code> 记录，主机记录为 <code>@</code>，记录值为你博客 IP 地址，IP 地址可以在 cmd 命令行 ping 一下得到，然后在 Coding Pages 中设置其中一个为【首选】，另一个设置【跳转至首选】，这样不管用户是否输入 www 前缀都会跳到有 www 前缀的了</p><p>在博客资源引用的时候也要注意所有资源的 URL 必须是以 https:&#x2F;&#x2F; 开头，不然浏览器依旧会提示不安全！<br><img src="https://img-blog.csdnimg.cn/20191207135619989.png"><img src="https://img-blog.csdnimg.cn/20191126004255465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pdHJoeC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70"><br>至此，我们的 Hexo 博客就成功双线部署到 Coding Pages 和 GitHub Pages 了，并且也实现了全站 HPPTS，最后来一张 GitHub Pages 和 Coding Pages 在国内的速度对比图，可以明显看到速度的提升<br><img src="https://img-blog.csdnimg.cn/20190916134128463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzU5MjI0,size_16,color_FFFFFF,t_70"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
